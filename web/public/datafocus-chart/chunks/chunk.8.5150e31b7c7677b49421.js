(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[8],{

/***/ "../src-v5/assets/js/charts.plugin/animationTimeSequenceFrame.js":
/*!***********************************************************************!*\
  !*** ../src-v5/assets/js/charts.plugin/animationTimeSequenceFrame.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {let exports = {};\nfunction convertObjToStyleStr(obj) {\n  if (typeof obj !== 'object' && Array.isArray(obj)) {\n    return '';\n  }\n  const camel2Kebab = str => str.replaceAll(/([A-Z])/g, '-$1').toLowerCase();\n  return Object.entries(obj).filter(([key, val]) => key && val).map(([key, val]) => `${camel2Kebab(key)}:${val}`).join(';');\n}\n\n/***\n * 统一数据处理，传入的参数\n * @param option\n *          {\n *               chartAxis  //轴配置\n *               columns    //行列数据\n *               headers    //表头统计数据\n *               isPieceWishScaleFlag   //  是否需要分段比例尺\n *          }\n */\n/***\n * 统一数据处理后，输出的变量\n columns; //原始行列数据\n positionDatas;  //处理后的数据，以x轴为主索引\n sLegendFlag;  //是否存在图例\n isTimeLegendFlag; //是否配置了时间轴的列\n legendType;   //图例的类型\n legends;      //图例数组\n xAxisIdx,yAxisIdx,sAxisIdx,legendIdx,timeIdx;  //各配置轴的idx\n lntIdx,latIdx;  //地理数据列的idx\n allAttributeId=[]; //所有属性列的idx列表\n timeLabels;     //时间轴数组\n initXLabels;    //x轴数组\n isTimeXAxis   // X轴充当时间轴\n timeType   //独立时间轴模型\n timeLabelMap  //时间内容与时间顺序的映射\n initXLabelsList  //存在多个x轴，x轴数组\n isMeasureXAxisFlag  //x轴中是否有数值列\n xpMap  // x轴内容与x轴顺序的映射\n legendMap  //图例内容与图例顺序的映射\n isPieceWishScaleFlag  //是否使用分段比例尺标志\n getNormalizeScale  //提供一个获取规整比例尺的方法\n getSplitScaleParameter  //分段比例尺的参数\n neoXScaleBand  //分段比例尺各段实际值\n neoXScaleList  //分段比例尺各段规范值\n */\n//时序数据\nlet timeData = {};\ntimeData.translateData = function (option) {\n  let chartAxis = option.chartAxis;\n  let columns = option.columns;\n  let headers = option.headers;\n  let isPieceWishScaleFlag = option.isPieceWishScaleFlag; //是否使用分段比例尺标志\n  let isNeglectDataFlag = option.isNeglectDataFlag; //不进行数据转换标志，不再生成positionDatas，节约开销\n  //统计轴信息\n  let isLegendFlag = false; //  tong - 是否需要图例 单独图例列 或 多Y轴\n  let isTimeLegendFlag = false; //遍历独立轴的数据形式 tong - ??\n  let legendType = 'yAxis'; // or 'legend'\n  let timeType = false; //  tong - 是否有时间列配置 curTime\n  let isTimeXAxis = false; //  tong - 第一个X轴属性列是否是时间列\n  /**允许时间列作为图例*/\n  if (chartAxis.curLegend) {\n    isLegendFlag = true;\n    legendType = 'legend';\n  }\n  /**用length*/else if (chartAxis.curYAxis && chartAxis.curYAxis[1]) {\n    isLegendFlag = true;\n    legendType = \"yAxis\";\n  }\n\n  // debugger;\n  if (chartAxis.curTime) {\n    // 选中了时间列\n    timeType = true;\n    // debugger;\n    // X 轴也为时间列\n    if (chartAxis.curXAxis[0].columnClassify === \"date\") {\n      isTimeLegendFlag = false;\n    } else {\n      isTimeLegendFlag = true;\n    }\n  } else {\n    if (chartAxis.curXAxis[0].columnClassify === \"date\") {\n      isTimeXAxis = true;\n    }\n  }\n  let legends; //  tong - 图例所有的值\n  let xAxisIdx,\n    //  tong -  第一个x轴属性列的idx\n    yAxisIdx,\n    //  tong -  第一个y轴属性列的idx\n    sAxisIdx,\n    //  tong -  size轴数值列的idx\n    legendIdx; //  tong -  legend轴属性列的idx\n  let lntIdx,\n    //  tong    -   当前数据中的经度idx\n    latIdx; //  tong    -   当前数据中的维度idx\n  let allAttributeId = [];\n  /**globe常量*/\n  headers.forEach(function (h) {\n    if (h.columnType === 'attribute' && h.geo_type === _DataFocusMethod._LONGITUDE) {\n      lntIdx = h.idx;\n    }\n    if (h.columnType === 'attribute' && h.geo_type === _DataFocusMethod._LATITUDE) {\n      latIdx = h.idx;\n    }\n    if (h.columnType === 'attribute' && h.columnClassify !== 'date') {\n      allAttributeId.push(h.idx);\n    }\n  });\n\n  //规整数据\n  xAxisIdx = chartAxis.curXAxis[0].idx; //  tong - 第一个X轴属性列的idx\n  let xAxisIdxs = []; //  tong - 所有X轴idx的数组\n  for (let i = 0; i < 5; i++) {\n    if (chartAxis.curXAxis[i]) {\n      xAxisIdxs.push(chartAxis.curXAxis[i].idx);\n    } else {\n      break;\n    }\n  }\n  sAxisIdx = chartAxis.curSize && chartAxis.curSize.idx; //  tong    -   size轴配置的idx\n  if (isLegendFlag) {\n    if (legendType === 'legend') {\n      // 有单独图例属性列时，legendIdx有值 ； legends中存放所有图例列的distincts值\n      legendIdx = chartAxis.curLegend.idx;\n      legends = chartAxis.curLegend.distincts;\n      if (chartAxis.curLegend.columnClassify === \"date\") {\n        // legends=legends.map(function (lds) {\n        //     return lds.split(\" \")[0];\n        // });\n      }\n      yAxisIdx = chartAxis.curYAxis && chartAxis.curYAxis[0] && chartAxis.curYAxis[0].idx; //  有图例的情况，只允许一个Y轴\n    } else {\n      // 多个Y轴的图例模式，legends中存放各个列的信息\n      legends = [];\n      //遍历对象\n      if (chartAxis.curYAxis) {\n        let tempIndex = 0;\n        while (true) {\n          if (!chartAxis.curYAxis[tempIndex]) break;\n          let yAxis = chartAxis.curYAxis[tempIndex];\n          legends.push({\n            name: yAxis.col_name,\n            idx: yAxis.idx,\n            direction: yAxis.direction\n          });\n          tempIndex++;\n        }\n      }\n    }\n  } else {\n    yAxisIdx = chartAxis.curYAxis && chartAxis.curYAxis[0] && chartAxis.curYAxis[0].idx; //  tong    -   第一个Y轴的idx\n  }\n\n  //处理为时序数据\n  /**\n   1.以X轴为时序索引\n   2.保持每个时间投影上所有点的数据\n   */\n  let timeLabels;\n  let timeLabelMap = {};\n  let timeIdx;\n  if (timeType) {\n    timeIdx = chartAxis.curTime.idx;\n    timeLabels = chartAxis.curTime.distincts;\n    timeLabels = timeLabels.sort(function (a, b) {\n      if (a > b) return 1;else if (a < b) return -1;else return 0;\n    });\n    timeLabels.forEach(function (tl, index) {\n      if (!tl && tl !== 0) return;\n      timeLabelMap[tl] = index;\n    });\n  }\n  let initXLabels = chartAxis.curXAxis[0].distincts; //  tong - 第一个X轴属性列的distincts\n  let initXLabelsList = []; //  tong    -   所有X轴属性列的distincts [ 二维数组 ]\n\n  for (let i = 0; i < xAxisIdxs.length; i++) {\n    initXLabelsList.push(chartAxis.curXAxis[i].distincts);\n  }\n\n  // 2-3 个 X 轴 聚合\n  function aggregateXAxes(xAxisIdxs) {\n    const xAxesTrieTree = {};\n    for (let i = 0; i < columns.length; i++) {\n      const curRow = columns[i];\n      let curParentRoot = xAxesTrieTree;\n      xAxisIdxs.forEach(xIndex => {\n        const curXValue = curRow[xIndex];\n        if (!curParentRoot[curXValue]) curParentRoot[curXValue] = {};\n        curParentRoot = curParentRoot[curXValue];\n      });\n    }\n    return xAxesTrieTree;\n  }\n  let xAxesTrieTree;\n  // X 轴大于1小于3时，分类聚合展示。以 “省-市-区” 的包含关系进行聚合\n  // if (xAxisIdxs.length > 1 && xAxisIdxs.length <=3){\n  //     xAxesTrieTree = aggregateXAxes(xAxisIdxs);\n  // }\n\n  if (chartAxis.curXAxis[0].columnClassify === \"date\") {\n    // initXLabels=initXLabels.map(function (lds) {\n    //     return lds.split(\" \")[0];\n    // });\n  }\n  let isMeasureXAxisFlag = false; //  tong -  当前X轴是否是数值列的标志\n  if (chartAxis.curXAxis[0].columnClassify === \"number\" && chartAxis.curXAxis[0].columnType === \"measure\") {\n    isMeasureXAxisFlag = true;\n  }\n  let positionDatas = [];\n  let xpMap = {}; //  tong -  第一个X轴对应的值与在distincts的序号\n  let legendMap = {};\n  if (isMeasureXAxisFlag) {\n    initXLabels = []; //  tong - X轴是单个属性列的情况下，存所有独立的数值\n    let tempSet = {};\n    let tempXAxisIdx = chartAxis.curXAxis[0].idx;\n    columns.forEach(function (c) {\n      if (!tempSet[c[tempXAxisIdx]]) {\n        tempSet[c[tempXAxisIdx]] = true;\n        initXLabels.push(c[tempXAxisIdx] + \"\");\n      }\n    });\n  }\n  initXLabels.forEach(function (xl, index) {\n    xpMap[xl] = index;\n  });\n  //分段新方案start\n  //研究分段比例尺\n  //找到最近的整刻度\n  let getNormalizeScale = function (val) {\n    let valText = val + \"\";\n    let integerVal, fractionVal;\n    integerVal = valText.split(\".\")[0];\n    fractionVal = valText.split(\".\")[1];\n    let tempScale = 0;\n    if (parseInt(integerVal) > 0) {\n      let digitLen = integerVal.length - 1;\n      for (let bound = 9; bound >= 0; bound--) {\n        if (val > bound * Math.pow(10, digitLen)) {\n          let baseScale = bound * Math.pow(10, digitLen);\n          //先赋值为下一阶scale\n          tempScale = (bound + 1) * Math.pow(10, digitLen);\n          if (digitLen >= 3) {\n            //再细分为十份定位\n            for (let i = 1; i <= 9; i++) {\n              if (baseScale + i * Math.pow(10, digitLen - 1) > val) {\n                tempScale = baseScale + i * Math.pow(10, digitLen - 1);\n                break;\n              }\n            }\n          }\n          break;\n        }\n      }\n    } else {\n      let digitLen = 1;\n      for (let i = 0; i < fractionVal.length; i++) {\n        if (fractionVal.charAt(i) === \"0\") {\n          digitLen++;\n        } else {\n          break;\n        }\n      }\n      for (let bound = 9; bound >= 0; bound--) {\n        if (val > bound * Math.pow(10, -1 * digitLen)) {\n          tempScale = (bound + 1) * Math.pow(10, -1 * digitLen);\n          break;\n        }\n      }\n    }\n    return tempScale;\n  };\n  let tempMax = -Infinity,\n    tempMin = Infinity;\n  let xScaleLabel; //  tong    -   X轴是单独数值列时，所有的数值\n  if (isMeasureXAxisFlag && isPieceWishScaleFlag) {\n    xScaleLabel = initXLabels.filter(function (d) {\n      if (_DataFocusMethod.isNumber(d)) {\n        if (parseFloat(d) > tempMax) tempMax = parseFloat(d);\n        if (parseFloat(d) < tempMin) tempMin = parseFloat(d);\n        return true;\n      } else {\n        return false;\n      }\n    });\n    xScaleLabel = xScaleLabel.sort(function (a, b) {\n      return parseFloat(a) - parseFloat(b);\n    });\n  }\n  let neoXScaleBand = [];\n  /**\n   * 计算数值数组的分段比例尺\n   * @param ansScaleArray     -   需要计算刻度的数值数组\n   * @param theMax            -   最大值\n   * @param equalRate         -   剩余的需要平分的空间[ 0 - 1] ,\n   *          例： equalRate = 0.1 表明将区间的10%留出来平分，剩下的90%按节点比重获取比例\n   * **/\n  let getSplitScaleParameter = function (ansScaleArray, theMax, equalRate) {\n    let ansScaleBand = [];\n    /**\n     *  按分散密度计算数值列的scale\n     * @param xScaleLocateStart     -   刻度数组起点\n     * @param xScaleLocateEnd       -   计算刻度数组的终点\n     * @param proportion        -   分配的比例\n     * @param distinctStart     -   计算区间的起点\n     * @param distinctEnd       -   计算区间的终点\n     * @param splitAmount       -   分割数量\n     * @param deep              -\n     * **/\n    let splitByDispersedDensity = function (xScaleLocateStart, xScaleLocateEnd, proportion, distinctStart, distinctEnd, splitAmount, deep) {\n      let perWidth = (distinctEnd - distinctStart) / splitAmount;\n      let tpSum;\n      let curXScaleLocateStart = xScaleLocateStart;\n      let tpObjects = [];\n      let xScaleAmount = xScaleLocateEnd - xScaleLocateStart + 1;\n      if (xScaleAmount <= 0) {\n        //如果不包含数据，则均分\n        tpSum = distinctStart;\n        for (let i = 0; i < splitAmount; i++) {\n          let subEndDistinct;\n          if (i === splitAmount - 1) subEndDistinct = distinctEnd;else subEndDistinct = tpSum + perWidth;\n          tpObjects[i] = {\n            density: 0,\n            distinctStart: tpSum,\n            distinctEnd: subEndDistinct,\n            xScaleLocateStart: 0,\n            xScaleLocateEnd: -1,\n            proportion: proportion / splitAmount\n          };\n          tpSum += perWidth;\n        }\n      } else {\n        //计算每个区间的空间占比\n        tpSum = distinctStart;\n        for (let i = 0; i < splitAmount; i++) {\n          let subEndDistinct;\n          if (i === splitAmount - 1) subEndDistinct = distinctEnd;else subEndDistinct = tpSum + perWidth;\n          tpObjects[i] = {\n            density: 0,\n            distinctStart: tpSum,\n            distinctEnd: subEndDistinct\n          };\n\n          // 将数值数组数量分配到各个数值区间中的density\n          let isBreak = false;\n          for (let j = curXScaleLocateStart; j <= xScaleLocateEnd; j++) {\n            if (parseFloat(ansScaleArray[j]) <= subEndDistinct) {\n              tpObjects[i].density++;\n            } else {\n              tpObjects[i].xScaleLocateStart = curXScaleLocateStart;\n              tpObjects[i].xScaleLocateEnd = j - 1;\n              curXScaleLocateStart = j;\n              isBreak = true;\n              break;\n            }\n          }\n          if (!isBreak) {\n            tpObjects[i].xScaleLocateStart = curXScaleLocateStart;\n            tpObjects[i].xScaleLocateEnd = xScaleLocateEnd;\n          }\n          tpSum += perWidth;\n        }\n        //拿出p%的空间均分，剩下的按比例分配\n        for (let i = 0; i < splitAmount; i++) {\n          /**\n           * tpObjects[i].proportion 计算的是 tpObjects[i] 这个区间在整个区间中所占的比重\n           * 平分区间的比例  (proportion*equalRate/splitAmount)\n           * 比重区间获取的比例  (proportion*(1.0-equalRate)*tpObjects[i].density/xScaleAmount)\n           * */\n          tpObjects[i].proportion = proportion * equalRate / splitAmount + proportion * (1.0 - equalRate) * tpObjects[i].density / xScaleAmount;\n        }\n      }\n      if (deep >= 3) {\n        for (let i = 0; i < splitAmount; i++) {\n          ansScaleBand.push({\n            distinctStart: tpObjects[i].distinctStart,\n            distinctEnd: tpObjects[i].distinctEnd,\n            proportion: tpObjects[i].proportion\n          });\n        }\n      } else {\n        for (let i = 0; i < splitAmount; i++) {\n          splitByDispersedDensity(tpObjects[i].xScaleLocateStart, tpObjects[i].xScaleLocateEnd, tpObjects[i].proportion, tpObjects[i].distinctStart, tpObjects[i].distinctEnd, deep < 2 ? 3 : 2, deep + 1);\n        }\n      }\n    };\n    splitByDispersedDensity(0, ansScaleArray.length - 1, 1.0, 0, getNormalizeScale(theMax), 3, 0);\n    return ansScaleBand;\n  };\n\n  // 如果X轴是数值列时，并且设置需要分段比例尺，则计算X轴的分段比例尺\n  if (isMeasureXAxisFlag && isPieceWishScaleFlag) {\n    neoXScaleBand = getSplitScaleParameter(xScaleLabel, tempMax, 0.1);\n  }\n  //规整刻度尺列表\n  let neoXScaleList = [];\n  for (let i = 0; i < neoXScaleBand.length; i++) {\n    if (i === 0) {\n      neoXScaleList.push(neoXScaleBand[i].distinctStart.toFixed(5));\n      neoXScaleList.push(neoXScaleBand[i].distinctEnd.toFixed(5));\n    } else {\n      neoXScaleList.push(neoXScaleBand[i].distinctEnd.toFixed(5));\n    }\n  }\n  if (isLegendFlag) {\n    if (legendType === \"legend\") {\n      legends.forEach(function (ld, index) {\n        legendMap[ld] = index;\n      });\n    }\n  }\n  if (!isNeglectDataFlag) columns.forEach(function (c) {\n    let index;\n    if (isTimeXAxis) {\n      //index=xpMap[c[xAxisIdx].split(\" \")[0]];\n      index = xpMap[c[xAxisIdx]];\n    } else {\n      index = xpMap[c[xAxisIdx]];\n    }\n    if (!positionDatas[index]) {\n      positionDatas[index] = {};\n      positionDatas[index].name = c[xAxisIdx];\n      positionDatas[index].points = [];\n      if (timeType) positionDatas[index].timePoints = [];\n    }\n    if (isLegendFlag) {\n      if (legendType === \"legend\") {\n        let legendIndex = legendMap[c[legendIdx]];\n        let tempObject = {\n          legendIdx: legendIndex,\n          //  tong  legend值在legendList字符串列表中的索引\n          legendName: c[legendIdx],\n          rowData: c,\n          value: c[yAxisIdx],\n          x: c[xAxisIdx],\n          xPosition: index\n        };\n\n        // tong 没有时间列时，将所有数据记录在points下各个图例next数组中\n        //冲突处理，链表\n        if (positionDatas[index].points[legendIndex]) {\n          if (!positionDatas[index].points[legendIndex].next) positionDatas[index].points[legendIndex].next = [];\n          positionDatas[index].points[legendIndex].next.push(tempObject);\n        } else {\n          positionDatas[index].points[legendIndex] = tempObject;\n        }\n\n        // tong 有时间列时，将所有数据记录在timePoints下各个图例下各个时间点的next数组中\n        if (timeType) {\n          if (!c[timeIdx]) return;\n          if (!positionDatas[index].timePoints[legendIndex]) {\n            positionDatas[index].timePoints[legendIndex] = [];\n          }\n          //冲突处理，链表\n          // if(positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx].split(\" \")[0]]]){\n          //     if(!positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx].split(\" \")[0]]].next)positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx].split(\" \")[0]]].next=[];\n          //     positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx].split(\" \")[0]]].next.push(tempObject);\n          // }else{\n          //     positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx].split(\" \")[0]]]=tempObject;\n          // }\n          if (positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx]]]) {\n            if (!positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx]]].next) positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx]]].next = [];\n            positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx]]].next.push(tempObject);\n          } else {\n            positionDatas[index].timePoints[legendIndex][timeLabelMap[c[timeIdx]]] = tempObject;\n          }\n        }\n      } else {\n        // 多Y轴模式下\n        legends.forEach(function (yAxis, legendIdx) {\n          let tempObject = {\n            legendIdx: legendIdx,\n            legendName: yAxis.name,\n            rowData: c,\n            value: c[yAxis.idx],\n            x: c[xAxisIdx],\n            xPosition: index,\n            isRight: yAxis.direction === \"right\"\n          };\n          //冲突处理，链表\n          if (positionDatas[index].points[legendIdx]) {\n            if (!positionDatas[index].points[legendIdx].next) positionDatas[index].points[legendIdx].next = [];\n            positionDatas[index].points[legendIdx].next.push(tempObject);\n          } else {\n            positionDatas[index].points[legendIdx] = tempObject;\n          }\n          if (timeType) {\n            if (!c[timeIdx]) return;\n            if (!positionDatas[index].timePoints[legendIdx]) {\n              positionDatas[index].timePoints[legendIdx] = [];\n            }\n            //冲突处理，链表\n            // if(positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx].split(\" \")[0]]]){\n            //     if(!positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx].split(\" \")[0]]].next)positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx].split(\" \")[0]]].next=[];\n            //     positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx].split(\" \")[0]]].next.push(tempObject);\n            // }else{\n            //     positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx].split(\" \")[0]]]=tempObject;\n            // }\n            if (positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx]]]) {\n              if (!positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx]]].next) positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx]]].next = [];\n              positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx]]].next.push(tempObject);\n            } else {\n              positionDatas[index].timePoints[legendIdx][timeLabelMap[c[timeIdx]]] = tempObject;\n            }\n          }\n        });\n      }\n    } else {\n      let tempObject = {\n        legendIdx: 0,\n        legendName: chartAxis.curYAxis ? chartAxis.curYAxis[0] ? chartAxis.curYAxis[0].col_name : null : null,\n        rowData: c,\n        value: c[yAxisIdx],\n        x: c[xAxisIdx],\n        xPosition: index\n      };\n      //冲突处理，链表\n      if (!timeType && positionDatas[index].points[0]) {\n        if (!positionDatas[index].points[0].next) positionDatas[index].points[0].next = [];\n        positionDatas[index].points[0].next.push(tempObject);\n      } else {\n        positionDatas[index].points[0] = tempObject;\n      }\n      if (timeType) {\n        if (!c[timeIdx]) return;\n        if (!positionDatas[index].timePoints[0]) {\n          positionDatas[index].timePoints[0] = [];\n        }\n        // if(positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx].split(\" \")[0]]]){\n        //     if(!positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx].split(\" \")[0]]].next)positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx].split(\" \")[0]]].next=[];\n        //     positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx].split(\" \")[0]]].next.push(tempObject);\n        // }else{\n        //     positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx].split(\" \")[0]]]=tempObject;\n        // }\n        if (positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx]]]) {\n          if (!positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx]]].next) positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx]]].next = [];\n          positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx]]].next.push(tempObject);\n        } else {\n          positionDatas[index].timePoints[0][timeLabelMap[c[timeIdx]]] = tempObject;\n        }\n      }\n    }\n  });\n  return {\n    columns: columns,\n    positionDatas: positionDatas,\n    isLegendFlag: isLegendFlag,\n    isTimeLegendFlag: isTimeLegendFlag,\n    isTimeXAxis: isTimeXAxis,\n    legendType: legendType,\n    timeType: timeType,\n    legends: legends,\n    xAxisId: xAxisIdx,\n    xAxisIdxs: xAxisIdxs,\n    xAxesTrieTree: xAxesTrieTree,\n    yAxisId: yAxisIdx,\n    sAxisId: sAxisIdx,\n    legendIdx: legendIdx,\n    lntIdx: lntIdx,\n    latIdx: latIdx,\n    allAttributeId: allAttributeId,\n    timeLabels: timeLabels,\n    timeLabelMap: timeLabelMap,\n    timeIdx: timeIdx,\n    initXLabels: initXLabels,\n    initXLabelsList: initXLabelsList,\n    isMeasureXAxisFlag: isMeasureXAxisFlag,\n    xpMap: xpMap,\n    legendMap: legendMap,\n    isPieceWishScaleFlag: isPieceWishScaleFlag,\n    getNormalizeScale: getNormalizeScale,\n    getSplitScaleParameter: getSplitScaleParameter,\n    neoXScaleBand: neoXScaleBand,\n    neoXScaleList: neoXScaleList\n  };\n};\n\n//坐标轴系统\nlet timeAxisSystem = {};\n/***\n * @param option\n *          {\n *              hideAxisLabelFlag  隐层轴标签标志\n *              d3  传入d3实例\n *          }\n */\ntimeAxisSystem.sampleAxisSystem = function (option) {\n  let hideAxisLabelFlag = option.hideAxisLabelFlag; //隐藏轴标签标志\n  let d3 = option.d3;\n  let sas = {};\n  sas.alignZeroLine = false; //左右Y轴零点对齐标志\n  sas.mainYAxisBaseOffset = 100; //左Y轴默认占宽\n  /***\n   * 计算0-target的值域的比例尺参数 0-1部分的 ； 1-Infinity部分\n   * @param target  正的最大值\n   * @param intervalCount  推荐间隔数\n   * @returns {{scale: number, count: number}}  //最终确定的 间隔大小 和 间隔数\n   */\n  sas.getOnePositiveScaleParameter = function (target, intervalCount) {\n    // 2 5 10\n    let testScale = target / (intervalCount * 1.0) + \"\";\n    let testScaleStr = testScale.split(\".\");\n    let moreThanOnePart = testScaleStr[0];\n    let lessThanOnePart = testScaleStr[1];\n    let tempScale;\n    if (parseInt(moreThanOnePart) > 0) {\n      let digitLen = moreThanOnePart.length - 1;\n      if (testScale > 5 * Math.pow(10, digitLen)) {\n        tempScale = 10 * Math.pow(10, digitLen);\n      } else if (testScale > 2 * Math.pow(10, digitLen)) {\n        tempScale = 5 * Math.pow(10, digitLen);\n      } else {\n        tempScale = 2 * Math.pow(10, digitLen);\n      }\n    } else {\n      let digitLen = 1;\n      for (let i = 0; i < lessThanOnePart.length; i++) {\n        if (lessThanOnePart.charAt(i) === \"0\") {\n          digitLen++;\n        } else {\n          break;\n        }\n      }\n      if (testScale > 5 * Math.pow(10, -1 * digitLen)) {\n        tempScale = 10 * Math.pow(10, -1 * digitLen);\n      } else if (testScale > 2 * Math.pow(10, -1 * digitLen)) {\n        tempScale = 5 * Math.pow(10, -1 * digitLen);\n      } else {\n        tempScale = 2 * Math.pow(10, -1 * digitLen);\n      }\n    }\n    let finalScaleCount = intervalCount;\n    for (let i = intervalCount - 1; i >= 1; i--) {\n      if (tempScale * i > target) {\n        finalScaleCount = i;\n      } else {\n        break;\n      }\n    }\n    return {\n      scale: tempScale,\n      count: finalScaleCount\n    };\n  };\n  /***\n   * 设置左Y轴\n   * @param tMin  左Y轴的最小值\n   * @param tMax  左Y轴的最大值\n   * @param tempHeader  左Y轴的header\n   */\n  sas.setLeftYAxis = function (tMin, tMax, tempHeader) {\n    let self = this;\n    self.leftYAxisMin = tMin;\n    self.leftYAxisMax = tMax;\n    self.leftYAxisPositiveScale = null;\n    self.leftYAxisNegativeScale = null;\n\n    // 如果最小值大于0，则直接将最大值分5个间隔\n    if (tMin >= 0) {\n      self.leftYAxisPositiveScaleParameter = self.getOnePositiveScaleParameter(tMax, 5);\n    } else {\n      // 如果最大值也小于0 ， 则只需要将负值部分分5个间隔\n      if (tMax <= 0) {\n        let tempParameter = self.getOnePositiveScaleParameter(Math.abs(tMin), 5);\n        self.leftYAxisNegativeScaleParameter = {\n          scale: tempParameter.scale,\n          count: tempParameter.count\n        };\n      }\n      // 如果分处正负两个区间， 正数区间大于负数区间的情况下\n      else if (Math.abs(tMin) <= Math.abs(tMax)) {\n        //单方向最多五个区间\n        for (let i = 5; i >= 1; i--) {\n          let tempParameter = self.getOnePositiveScaleParameter(tMax, i);\n          let negativeCount = Math.ceil(Math.abs(tMin) / tempParameter.scale);\n          if (negativeCount + tempParameter.count <= 6) {\n            self.leftYAxisPositiveScaleParameter = tempParameter;\n            self.leftYAxisNegativeScaleParameter = {\n              scale: tempParameter.scale,\n              count: negativeCount\n            };\n            break;\n          }\n        }\n      }\n      // 如果分处正负两个区间， 负数区间大于正数区间的情况下\n      else if (Math.abs(tMin) > Math.abs(tMax)) {\n        for (let i = 5; i >= 1; i--) {\n          let tempParameter = self.getOnePositiveScaleParameter(Math.abs(tMin), i);\n          let positiveCount = Math.ceil(Math.abs(tMax) / tempParameter.scale);\n          if (positiveCount + tempParameter.count <= 6) {\n            self.leftYAxisNegativeScaleParameter = {\n              scale: tempParameter.scale,\n              count: tempParameter.count\n            };\n            self.leftYAxisPositiveScaleParameter = {\n              scale: tempParameter.scale,\n              count: positiveCount\n            };\n            break;\n          }\n        }\n      }\n    }\n    if (self.leftYAxisPositiveScaleParameter) self.leftYAxisPositiveScaleParameter.header = tempHeader;\n    if (self.leftYAxisNegativeScaleParameter) self.leftYAxisNegativeScaleParameter.header = tempHeader;\n  };\n  /***\n   * 设置右Y轴\n   * @param tMin  右Y轴的最小值\n   * @param tMax  右Y轴的最大值\n   * @param tempHeader  右Y轴的header\n   */\n  sas.setRightYAxis = function (tMin, tMax, tempHeader) {\n    let self = this;\n    self.rightYAxisMin = tMin;\n    self.rightYAxisMax = tMax;\n    self.rightYAxisPositiveScale = null;\n    self.rightYAxisNegativeScale = null;\n    if (tMin >= 0) {\n      self.rightYAxisPositiveScaleParameter = self.getOnePositiveScaleParameter(tMax, 5);\n    } else {\n      if (tMax < 0) {\n        let tempParameter = self.getOnePositiveScaleParameter(Math.abs(tMin), 5);\n        self.rightYAxisNegativeScaleParameter = {\n          scale: tempParameter.scale,\n          count: tempParameter.count\n        };\n      } else if (Math.abs(tMin) <= Math.abs(tMax)) {\n        for (let i = 5; i >= 1; i--) {\n          let tempParameter = self.getOnePositiveScaleParameter(tMax, i);\n          let negativeCount = Math.ceil(Math.abs(tMin) / tempParameter.scale);\n          if (negativeCount + tempParameter.count <= 6) {\n            self.rightYAxisPositiveScaleParameter = tempParameter;\n            self.rightYAxisNegativeScaleParameter = {\n              scale: tempParameter.scale,\n              count: negativeCount\n            };\n            break;\n          }\n        }\n      } else if (Math.abs(tMin) > Math.abs(tMax)) {\n        for (let i = 5; i >= 1; i--) {\n          let tempParameter = self.getOnePositiveScaleParameter(Math.abs(tMin), i);\n          let positiveCount = Math.ceil(Math.abs(tMax) / tempParameter.scale);\n          if (positiveCount + tempParameter.count <= 6) {\n            self.rightYAxisNegativeScaleParameter = {\n              scale: tempParameter.scale,\n              count: tempParameter.count\n            };\n            self.rightYAxisPositiveScaleParameter = {\n              scale: tempParameter.scale,\n              count: positiveCount\n            };\n            break;\n          }\n        }\n      }\n    }\n    if (self.rightYAxisPositiveScaleParameter) self.rightYAxisPositiveScaleParameter.header = tempHeader;\n    if (self.rightYAxisNegativeScaleParameter) self.rightYAxisNegativeScaleParameter.header = tempHeader;\n  };\n\n  /**\n   * 设置数值列X轴，内部方法\n   * 给当前的sampleAxisSystem中输出以下对象：\n   * -    self.measureXAxisMin\n   * -    self.measureXAxisMax\n   * -    self.measureXAxisPositiveScaleParameter\n   * -    self.measureXAxisNegativeScaleParameter\n   *\n   * 清空以下对象\n   *  -   self.measureXAxisPositiveScale = null\n   *  -   self.measureXAxisNegativeScale = null\n   * */\n  sas.setMeasureXAxis = function (tMin, tMax) {\n    let self = this;\n    self.measureXAxisMin = tMin;\n    self.measureXAxisMax = tMax;\n    self.measureXAxisPositiveScale = null;\n    self.measureXAxisNegativeScale = null;\n    if (tMin >= 0) {\n      self.measureXAxisPositiveScaleParameter = self.getOnePositiveScaleParameter(tMax, 5);\n    } else {\n      if (tMax < 0) {\n        let tempParameter = self.getOnePositiveScaleParameter(Math.abs(tMin), 5);\n        self.measureXAxisNegativeScaleParameter = {\n          scale: tempParameter.scale,\n          count: tempParameter.count\n        };\n      } else if (Math.abs(tMin) < Math.abs(tMax)) {\n        //单方向最多五个区间\n        for (let i = 5; i >= 1; i--) {\n          let tempParameter = self.getOnePositiveScaleParameter(tMax, i);\n          let negativeCount = Math.ceil(Math.abs(tMin) / tempParameter.scale);\n          if (negativeCount + tempParameter.count <= 6) {\n            self.measureXAxisPositiveScaleParameter = tempParameter;\n            self.measureXAxisNegativeScaleParameter = {\n              scale: tempParameter.scale,\n              count: negativeCount\n            };\n            break;\n          }\n        }\n      } else if (Math.abs(tMin) > Math.abs(tMax)) {\n        for (let i = 5; i >= 1; i--) {\n          let tempParameter = self.getOnePositiveScaleParameter(Math.abs(tMin), i);\n          let positiveCount = Math.ceil(Math.abs(tMax) / tempParameter.scale);\n          if (positiveCount + tempParameter.count <= 6) {\n            self.measureXAxisNegativeScaleParameter = {\n              scale: tempParameter.scale,\n              count: tempParameter.count\n            };\n            self.measureXAxisPositiveScaleParameter = {\n              scale: tempParameter.scale,\n              count: positiveCount\n            };\n            break;\n          }\n        }\n      }\n    }\n  };\n  /**\n   * 同步左右Y轴的刻度数，并生成比例尺\n   * 给当前的sampleAxisSystem中输出以下对象：\n   *  - self.leftYAxisPositiveScaleRange\n   *  - self.leftYAxisNegativeScaleRange\n   *  - self.leftYAxisPositiveScale\n   *  - self.leftYAxisNegativeScale\n   *\n   *  - self.rightYAxisPositiveScaleRange\n   *  - self.rightYAxisNegativeScaleRange\n   *  - self.rightYAxisPositiveScale\n   *  - self.rightYAxisNegativeScale\n   * */\n  sas.synchronizationLeftAndRightAxisInDrawArea = function (totalHeight) {\n    let self = this;\n    if (self.alignZeroLine) {\n      //同步会补全刻度\n      if (self.leftYAxisPositiveScaleParameter || self.rightYAxisPositiveScaleParameter) {\n        if (!self.leftYAxisPositiveScaleParameter) {\n          self.leftYAxisPositiveScaleParameter = {\n            scale: self.leftYAxisNegativeScaleParameter.scale || 1,\n            count: 0\n          };\n        }\n        if (!self.rightYAxisPositiveScaleParameter) {\n          self.rightYAxisPositiveScaleParameter = {\n            scale: self.rightYAxisNegativeScaleParameter.scale || 1,\n            count: 0\n          };\n        }\n        self.leftYAxisPositiveScaleParameter.count = Math.max(self.leftYAxisPositiveScaleParameter.count, self.rightYAxisPositiveScaleParameter.count);\n        self.rightYAxisPositiveScaleParameter.count = Math.max(self.leftYAxisPositiveScaleParameter.count, self.rightYAxisPositiveScaleParameter.count);\n      }\n      if (self.leftYAxisNegativeScaleParameter || self.rightYAxisNegativeScaleParameter) {\n        if (!self.leftYAxisNegativeScaleParameter) {\n          self.leftYAxisNegativeScaleParameter = {\n            scale: self.leftYAxisPositiveScaleParameter.scale || 1,\n            count: 0\n          };\n        }\n        if (!self.rightYAxisNegativeScaleParameter) {\n          self.rightYAxisNegativeScaleParameter = {\n            scale: self.rightYAxisPositiveScaleParameter.scale || 1,\n            count: 0\n          };\n        }\n        self.leftYAxisNegativeScaleParameter.count = Math.max(self.leftYAxisNegativeScaleParameter.count, self.rightYAxisNegativeScaleParameter.count);\n        self.rightYAxisNegativeScaleParameter.count = Math.max(self.leftYAxisNegativeScaleParameter.count, self.rightYAxisNegativeScaleParameter.count);\n      }\n    }\n    //生成刻度尺\n    if (self.leftYAxisPositiveScaleParameter && self.leftYAxisNegativeScaleParameter) {\n      let totalCount = self.leftYAxisPositiveScaleParameter.count + self.leftYAxisNegativeScaleParameter.count;\n      let positivePartHeight = totalHeight * self.leftYAxisPositiveScaleParameter.count / (totalCount * 1.0);\n      let negativePartHeight = totalHeight * self.leftYAxisNegativeScaleParameter.count / (totalCount * 1.0);\n      self.leftYAxisPositiveScaleRange = [0, self.leftYAxisPositiveScaleParameter.count * self.leftYAxisPositiveScaleParameter.scale];\n      self.leftYAxisNegativeScaleRange = [0, -1 * self.leftYAxisNegativeScaleParameter.count * self.leftYAxisNegativeScaleParameter.scale];\n      self.leftYAxisPositiveScale = d3.scale.linear().domain([0, self.leftYAxisPositiveScaleParameter.count * self.leftYAxisPositiveScaleParameter.scale]).range([0, positivePartHeight]);\n      self.leftYAxisNegativeScale = d3.scale.linear().domain([0, -1 * self.leftYAxisNegativeScaleParameter.count * self.leftYAxisNegativeScaleParameter.scale]).range([positivePartHeight, positivePartHeight + negativePartHeight]);\n    } else if (self.leftYAxisPositiveScaleParameter) {\n      let positivePartHeight = totalHeight;\n      self.leftYAxisPositiveScaleRange = [0, self.leftYAxisPositiveScaleParameter.count * self.leftYAxisPositiveScaleParameter.scale];\n      self.leftYAxisPositiveScale = d3.scale.linear().domain([0, self.leftYAxisPositiveScaleParameter.count * self.leftYAxisPositiveScaleParameter.scale]).range([0, positivePartHeight]);\n    } else if (self.leftYAxisNegativeScaleParameter) {\n      let negativePartHeight = totalHeight;\n      self.leftYAxisNegativeScaleRange = [0, -1 * self.leftYAxisNegativeScaleParameter.count * self.leftYAxisNegativeScaleParameter.scale];\n      self.leftYAxisNegativeScale = d3.scale.linear().domain([0, -1 * self.leftYAxisNegativeScaleParameter.count * self.leftYAxisNegativeScaleParameter.scale]).range([0, negativePartHeight]);\n    }\n    if (self.rightYAxisPositiveScaleParameter && self.rightYAxisNegativeScaleParameter) {\n      let totalCount = self.rightYAxisPositiveScaleParameter.count + self.rightYAxisNegativeScaleParameter.count;\n      let positivePartHeight = totalHeight * self.rightYAxisPositiveScaleParameter.count / (totalCount * 1.0);\n      let negativePartHeight = totalHeight * self.rightYAxisNegativeScaleParameter.count / (totalCount * 1.0);\n      self.rightYAxisPositiveScaleRange = [0, self.rightYAxisPositiveScaleParameter.count * self.rightYAxisPositiveScaleParameter.scale];\n      self.rightYAxisNegativeScaleRange = [0, -1 * self.rightYAxisNegativeScaleParameter.count * self.rightYAxisNegativeScaleParameter.scale];\n      self.rightYAxisPositiveScale = d3.scale.linear().domain([0, self.rightYAxisPositiveScaleParameter.count * self.rightYAxisPositiveScaleParameter.scale]).range([0, positivePartHeight]);\n      self.rightYAxisNegativeScale = d3.scale.linear().domain([0, -1 * self.rightYAxisNegativeScaleParameter.count * self.rightYAxisNegativeScaleParameter.scale]).range([positivePartHeight, positivePartHeight + negativePartHeight]);\n    } else if (self.rightYAxisPositiveScaleParameter) {\n      let positivePartHeight = totalHeight;\n      self.rightYAxisPositiveScaleRange = [0, self.rightYAxisPositiveScaleParameter.count * self.rightYAxisPositiveScaleParameter.scale];\n      self.rightYAxisPositiveScale = d3.scale.linear().domain([0, self.rightYAxisPositiveScaleParameter.count * self.rightYAxisPositiveScaleParameter.scale]).range([0, positivePartHeight]);\n    } else if (self.rightYAxisNegativeScaleParameter) {\n      let negativePartHeight = totalHeight;\n      self.rightYAxisNegativeScaleRange = [0, -1 * self.rightYAxisNegativeScaleParameter.count * self.rightYAxisNegativeScaleParameter.scale];\n      self.rightYAxisNegativeScale = d3.scale.linear().domain([0, -1 * self.rightYAxisNegativeScaleParameter.count * self.rightYAxisNegativeScaleParameter.scale]).range([0, negativePartHeight]);\n    }\n  };\n  /**\n   * 生成Y轴标签\n   * 给当前的sampleAxisSystem中输出以下对象：\n   *\n   * - self.leftYPositiveAxisLabels\n   * - self.leftYPositiveAxisLabelTexts\n   * - self.leftYNegativeAxisLabels\n   * - self.leftYNegativeAxisLabelTexts\n   * - self.leftYNegativeAxisLabelTextsAbs\n   * - self.leftYAxisLabelLength\n   *\n   * - self.rightYPositiveAxisLabels\n   * - self.rightYPositiveAxisLabelTexts\n   * - self.rightYNegativeAxisLabels\n   * - self.rightYNegativeAxisLabelTexts\n   * - self.rightYAxisLabelLength\n   * */\n  sas.generateYAxisLabels = function () {\n    let self = this;\n    let leftYAxisLabelLength = 0;\n    let rightYAxisLabelLength = 0;\n    if (self.leftYAxisPositiveScaleParameter) {\n      let unitText;\n      let unitValue;\n      let unitFlag = false;\n      self.leftYPositiveAxisLabels = [0];\n      self.leftYPositiveAxisLabelTexts = [0];\n      for (let i = 1; i <= self.leftYAxisPositiveScaleParameter.count; i++) {\n        let curValue = i * self.leftYAxisPositiveScaleParameter.scale;\n        let tempOriginalValue = curValue;\n        curValue = curValue.toFixed(10);\n        if (i === 1 && Math.abs(parseFloat(curValue)) % 1000000 === 0) {\n          unitFlag = true;\n          unitText = \"M\";\n          unitValue = 1000000;\n        } else if (i === 1 && Math.abs(parseFloat(curValue)) % 1000 === 0) {\n          unitFlag = true;\n          unitText = \"K\";\n          unitValue = 1000;\n        }\n        let realValue = parseFloat(curValue) + \"\";\n        curValue = _DataFocusMethod.formatData(curValue, self.leftYAxisPositiveScaleParameter.header);\n        if (tempOriginalValue + \"\" === curValue + \"\") {\n          if (unitFlag) {\n            curValue = parseFloat(curValue) / unitValue + unitText;\n          } else {\n            curValue = parseFloat(curValue) + \"\";\n          }\n        }\n        self.leftYPositiveAxisLabels.push(realValue);\n        self.leftYPositiveAxisLabelTexts.push(curValue);\n        let labelLength = curValue.length;\n        if (labelLength > leftYAxisLabelLength) {\n          leftYAxisLabelLength = labelLength;\n        }\n      }\n    }\n    if (self.leftYAxisNegativeScaleParameter) {\n      let unitText;\n      let unitValue;\n      let unitFlag = false;\n      self.leftYNegativeAxisLabels = [0];\n      self.leftYNegativeAxisLabelTexts = [0];\n      self.leftYNegativeAxisLabelTextsAbs = [0];\n      for (let i = 1; i <= self.leftYAxisNegativeScaleParameter.count; i++) {\n        let curValue = i * self.leftYAxisNegativeScaleParameter.scale;\n        let tempOriginalValue = curValue;\n        curValue = curValue.toFixed(10);\n        if (i === 1 && Math.abs(parseFloat(curValue)) % 1000000 === 0) {\n          unitFlag = true;\n          unitText = \"M\";\n          unitValue = 1000000;\n        } else if (i === 1 && Math.abs(parseFloat(curValue)) % 1000 === 0) {\n          unitFlag = true;\n          unitText = \"K\";\n          unitValue = 1000;\n        }\n        let realValue = -1 * parseFloat(curValue) + \"\";\n        curValue = _DataFocusMethod.formatData(curValue, self.leftYAxisNegativeScaleParameter.header);\n        if (tempOriginalValue + \"\" === curValue + \"\") {\n          if (unitFlag) {\n            curValue = parseFloat(curValue) / unitValue + unitText;\n          } else {\n            curValue = parseFloat(curValue) + \"\";\n          }\n        }\n        self.leftYNegativeAxisLabels.push(realValue);\n        self.leftYNegativeAxisLabelTexts.push(\"-\" + curValue);\n        self.leftYNegativeAxisLabelTextsAbs.push(curValue);\n        let labelLength = curValue.length;\n        if (labelLength > leftYAxisLabelLength) {\n          leftYAxisLabelLength = labelLength;\n        }\n      }\n    }\n    if (self.rightYAxisPositiveScaleParameter) {\n      let unitText;\n      let unitValue;\n      let unitFlag = false;\n      self.rightYPositiveAxisLabels = [0];\n      self.rightYPositiveAxisLabelTexts = [0];\n      for (let i = 1; i <= self.rightYAxisPositiveScaleParameter.count; i++) {\n        let curValue = i * self.rightYAxisPositiveScaleParameter.scale;\n        let tempOriginalValue = curValue;\n        curValue = curValue.toFixed(10);\n        if (i === 1 && Math.abs(parseFloat(curValue)) % 1000000 === 0) {\n          unitFlag = true;\n          unitText = \"M\";\n          unitValue = 1000000;\n        } else if (i === 1 && Math.abs(parseFloat(curValue)) % 1000 === 0) {\n          unitFlag = true;\n          unitText = \"K\";\n          unitValue = 1000;\n        }\n        let realValue = parseFloat(curValue) + \"\";\n        curValue = _DataFocusMethod.formatData(curValue, self.rightYAxisPositiveScaleParameter.header);\n        if (tempOriginalValue + \"\" === curValue + \"\") {\n          if (unitFlag) {\n            curValue = parseFloat(curValue) / unitValue + unitText;\n          } else {\n            curValue = parseFloat(curValue) + \"\";\n          }\n        }\n        self.rightYPositiveAxisLabels.push(realValue);\n        self.rightYPositiveAxisLabelTexts.push(curValue);\n        let labelLength = curValue.length;\n        if (labelLength > rightYAxisLabelLength) {\n          rightYAxisLabelLength = labelLength;\n        }\n      }\n    }\n    if (self.rightYAxisNegativeScaleParameter) {\n      let unitText;\n      let unitValue;\n      let unitFlag = false;\n      self.rightYNegativeAxisLabels = [0];\n      self.rightYNegativeAxisLabelTexts = [0];\n      for (let i = 1; i <= self.rightYAxisNegativeScaleParameter.count; i++) {\n        let curValue = i * self.rightYAxisNegativeScaleParameter.scale;\n        let tempOriginalValue = curValue;\n        curValue = curValue.toFixed(10);\n        if (i === 1 && Math.abs(parseFloat(curValue)) % 1000000 === 0) {\n          unitFlag = true;\n          unitText = \"M\";\n          unitValue = 1000000;\n        } else if (i === 1 && Math.abs(parseFloat(curValue)) % 1000 === 0) {\n          unitFlag = true;\n          unitText = \"K\";\n          unitValue = 1000;\n        }\n        let realValue = -1 * parseFloat(curValue) + \"\";\n        curValue = _DataFocusMethod.formatData(curValue, self.rightYAxisNegativeScaleParameter.header);\n        if (tempOriginalValue + \"\" === curValue + \"\") {\n          if (unitFlag) {\n            curValue = parseFloat(curValue) / unitValue + unitText;\n          } else {\n            curValue = parseFloat(curValue) + \"\";\n          }\n        }\n        self.rightYNegativeAxisLabels.push(realValue);\n        self.rightYNegativeAxisLabelTexts.push(\"-\" + curValue);\n        let labelLength = curValue.length;\n        if (labelLength > rightYAxisLabelLength) {\n          rightYAxisLabelLength = labelLength;\n        }\n      }\n    }\n    if (leftYAxisLabelLength) self.leftYAxisLabelLength = leftYAxisLabelLength;\n    if (rightYAxisLabelLength) self.rightYAxisLabelLength = rightYAxisLabelLength;\n  };\n  /**\n   * 设置X轴，并生成比例尺\n   * 给当前的sampleAxisSystem中输出以下对象：\n   *\n   * -    self.leftYAxisOffset\n   * -    self.rightYAxisOffset\n   * -    self.realDrawWidth\n   * -    self.xAxisScale\n   *\n   * 如果X轴是数值列的情况下，给当前的sampleAxisSystem中输出以下对象：\n   *\n   * -    self.measureXAxisPositiveScaleRange\n   * -    self.measureXAxisNegativeScaleRange\n   * -    self.measureXAxisPositiveScale\n   * -    self.measureXAxisNegativeScale\n   * -    self.measureXPositiveAxisLabels\n   * -    self.measureXPositiveAxisLabelTexts\n   * -    self.measureXNegativeAxisLabels\n   * -    self.measureXNegativeAxisLabelTexts\n   * -    self.measureXNegativeAxisLabelTextsAbs\n   * */\n  sas.setXAxis = function (xLabels, totalWidth, option) {\n    let self = this;\n    let labelFontSize = 0;\n    let xAxisMeasureFlag = false;\n    let xAxisMax = 0,\n      xAxisMin = 1000;\n    if (option) {\n      if (option.labelFontSize) {\n        labelFontSize = option.labelFontSize;\n      }\n      if (option.isXAxisMeasure) {\n        xAxisMeasureFlag = true;\n        xAxisMin = option.xAxisMin;\n        xAxisMax = option.xAxisMax;\n      }\n    }\n    let offsetWidth = 0;\n    //X轴的宽度，要减去左右Y轴的空间\n    if (self.leftYAxisLabelLength || self.rightYAxisLabelLength) {\n      if (!self.rightYAxisLabelLength) {\n        // 如果没有右侧Y轴，只计算左侧Y轴宽度\n        offsetWidth = Math.max(self.mainYAxisBaseOffset, self.leftYAxisLabelLength * labelFontSize);\n        self.leftYAxisOffset = offsetWidth;\n      } else if (!self.leftYAxisLabelLength) {\n        // 如果没有左侧Y轴，只计算右侧Y轴宽度\n        offsetWidth = Math.max(self.mainYAxisBaseOffset, self.rightYAxisLabelLength * labelFontSize);\n        self.rightYAxisOffset = offsetWidth;\n      } else {\n        // 如果两侧Y轴都有，只计算左右Y轴宽度的和\n        offsetWidth = Math.max(self.mainYAxisBaseOffset, self.leftYAxisLabelLength * labelFontSize);\n        self.leftYAxisOffset = Math.max(self.mainYAxisBaseOffset, self.leftYAxisLabelLength * labelFontSize);\n        offsetWidth += self.rightYAxisLabelLength * labelFontSize;\n        self.rightYAxisOffset = self.rightYAxisLabelLength * labelFontSize;\n      }\n      if (hideAxisLabelFlag || labelFontSize === 0) {\n        //隐藏轴标签后，偏置归零\n        self.leftYAxisOffset = 0;\n        self.rightYAxisOffset = 0;\n        offsetWidth = 0;\n      }\n    } else {\n      console.log(\"需要设置Y轴！\");\n      return;\n    }\n    let realDrawWidth = totalWidth - 2 * offsetWidth / 3;\n    self.realDrawWidth = realDrawWidth;\n    // X轴是数值列的情况下\n    if (xAxisMeasureFlag) {\n      self.setMeasureXAxis(xAxisMin, xAxisMax);\n      //生成刻度尺\n      if (self.measureXAxisPositiveScaleParameter && self.measureXAxisNegativeScaleParameter) {\n        let totalCount = self.measureXAxisPositiveScaleParameter.count + self.measureXAxisNegativeScaleParameter.count;\n        let positivePartHeight = realDrawWidth * self.measureXAxisPositiveScaleParameter.count / (totalCount * 1.0);\n        let negativePartHeight = realDrawWidth * self.measureXAxisNegativeScaleParameter.count / (totalCount * 1.0);\n        self.measureXAxisPositiveScaleRange = [0, self.measureXAxisPositiveScaleParameter.count * self.measureXAxisPositiveScaleParameter.scale];\n        self.measureXAxisNegativeScaleRange = [0, -1 * self.measureXAxisNegativeScaleParameter.count * self.measureXAxisNegativeScaleParameter.scale];\n        self.measureXAxisPositiveScale = d3.scale.linear().domain([0, self.measureXAxisPositiveScaleParameter.count * self.measureXAxisPositiveScaleParameter.scale]).range([negativePartHeight, realDrawWidth]);\n        self.measureXAxisNegativeScale = d3.scale.linear().domain([0, -1 * self.measureXAxisNegativeScaleParameter.count * self.measureXAxisNegativeScaleParameter.scale]).range([0, negativePartHeight]);\n      } else if (self.measureXAxisPositiveScaleParameter) {\n        let positivePartHeight = realDrawWidth;\n        self.measureXAxisPositiveScaleRange = [0, self.measureXAxisPositiveScaleParameter.count * self.measureXAxisPositiveScaleParameter.scale];\n        self.measureXAxisPositiveScale = d3.scale.linear().domain([0, self.measureXAxisPositiveScaleParameter.count * self.measureXAxisPositiveScaleParameter.scale]).range([0, positivePartHeight]);\n      } else if (self.measureXAxisNegativeScaleParameter) {\n        let negativePartHeight = realDrawWidth;\n        self.measureXAxisNegativeScaleRange = [0, -1 * self.measureXAxisNegativeScaleParameter.count * self.measureXAxisNegativeScaleParameter.scale];\n        self.measureXAxisNegativeScale = d3.scale.linear().domain([0, -1 * self.measureXAxisNegativeScaleParameter.count * self.measureXAxisNegativeScaleParameter.scale]).range([0, negativePartHeight]);\n      }\n      if (self.measureXAxisPositiveScaleParameter) {\n        let unitText;\n        let unitValue;\n        let unitFlag = false;\n        self.measureXPositiveAxisLabels = [0];\n        self.measureXPositiveAxisLabelTexts = [0];\n        for (let i = 1; i <= self.measureXAxisPositiveScaleParameter.count; i++) {\n          let curValue = i * self.measureXAxisPositiveScaleParameter.scale;\n          curValue = curValue.toFixed(10);\n          if (i === 1 && Math.abs(parseFloat(curValue)) % 1000000 === 0) {\n            unitFlag = true;\n            unitText = \"M\";\n            unitValue = 1000000;\n          } else if (i === 1 && Math.abs(parseFloat(curValue)) % 1000 === 0) {\n            unitFlag = true;\n            unitText = \"K\";\n            unitValue = 1000;\n          }\n          let realValue = parseFloat(curValue) + \"\";\n          if (unitFlag) {\n            curValue = parseFloat(curValue) / unitValue + unitText;\n          } else {\n            curValue = parseFloat(curValue) + \"\";\n          }\n          self.measureXPositiveAxisLabels.push(realValue);\n          self.measureXPositiveAxisLabelTexts.push(curValue);\n        }\n      }\n      if (self.measureXAxisNegativeScaleParameter) {\n        let unitText;\n        let unitValue;\n        let unitFlag = false;\n        self.measureXNegativeAxisLabels = [0];\n        self.measureXNegativeAxisLabelTexts = [0];\n        self.measureXNegativeAxisLabelTextsAbs = [0];\n        for (let i = 1; i <= self.measureXAxisNegativeScaleParameter.count; i++) {\n          let curValue = i * self.measureXAxisNegativeScaleParameter.scale;\n          curValue = curValue.toFixed(10);\n          if (i === 1 && Math.abs(parseFloat(curValue)) % 1000000 === 0) {\n            unitFlag = true;\n            unitText = \"M\";\n            unitValue = 1000000;\n          } else if (i === 1 && Math.abs(parseFloat(curValue)) % 1000 === 0) {\n            unitFlag = true;\n            unitText = \"K\";\n            unitValue = 1000;\n          }\n          let realValue = -1 * parseFloat(curValue) + \"\";\n          if (unitFlag) {\n            curValue = parseFloat(curValue) / unitValue + unitText;\n          } else {\n            curValue = parseFloat(curValue) + \"\";\n          }\n          self.measureXNegativeAxisLabels.push(realValue);\n          self.measureXNegativeAxisLabelTexts.push(\"-\" + curValue);\n          self.measureXNegativeAxisLabelTextsAbs.push(curValue);\n        }\n      }\n    } else {\n      self.xAxisScale = d3.scale.ordinal().domain(xLabels).rangeBands([0, realDrawWidth]);\n    }\n  };\n  return sas;\n};\n\n/***\n //设置各类容器\n * 统一计算布局\n * @params options\n *          {\n *              -   isMapFlag   -   是否是地图\n *              -   hideTimeBarFlag -   隐藏时间轴的标志\n *              -   drawWidth   -   画图容器宽度\n *              -   drawHeight  -   画图容器高度\n *              -   hideAxisXTitleFlag  -   隐藏X轴标题的标志\n *              -   axisXTitlePosition  -   X轴标题位置\n *              -   isLegendFlag    -   是否存在图例\n *              -   hideLegendFlag  -   隐藏图例的标志\n *              -   legendPosition  -   图例位置\n *              -   hideAxisYTitleFlag  -   隐藏Y轴标题的标志\n *              -   axisYTitlePosition  -   Y轴标题位置\n *              -   container   -   画图容器\n *              -   currentChart    -   画图实例对象\n *              -   chartAxis   -   画图XY轴配置\n *              -   fontSize    -   字体大小\n *          }\n *\n * 通过计算，减去XY标题图例的时间轴所占空间的宽高，得出SVG图形的画图宽高\n * @return\n *          {\n *              -   drawWidth   -   容器中画图宽度\n *              -   drawHeight  -   容器中画图高度\n *              -   svgDiv  -   SVG图形容器\n *              -   svgDivHeight    -   SVG容器高度\n *              -   svgDivWidth     -   SVG容器宽度\n *              -   svgJQ           -   SVG容器中SVG标签的Jquery对象\n *              -   suspendDiv      -   悬浮框的容器\n *              -   legendBar       -   图例的容器\n *              -   legendLineHeight    -   图例容器的高度\n *              -   legendLineWidth     -   图例容器的宽度\n *              -   titleDom            -   调用currentChart实例中生成的画图标题的元素\n *                      {\n *                          yTitleDom   -   Y轴标题的元素\n *                          xTitleDom   -   X轴标题的元素\n *                      }\n *               -  leftTitleBar        -   左侧标题的容器\n *               -  rightTitleBar       -   右侧标题的容器\n *               -  topTitleBar         -   顶部标题的容器\n *               -  bottomTitleBar      -   底部标题的容器\n *               -  topOffset           -   画图区域顶部偏置    ？？\n *               -  leftOffset          -   画图区域左侧偏置    ？？\n *               -  rightOffset         -   画图区域右侧偏置    ？？\n *               -  finalRightOffset    -\n *               -  xLabelSpace         -\n *               -  mapDiv              -   Map地图容器\n *               -  map                 -   地图对象\n *          }\n *\n */\nlet containerOp = {};\ncontainerOp.executeContainer = function (option) {\n  let self = this;\n  self.option = option;\n  let isMapFlag = option.isMapFlag; //是否是地图容器标志\n  let hideTimeBarFlag = option.hideTimeBarFlag; //隐藏时间轴标志\n  let drawWidth = option.drawWidth;\n  let drawHeight = option.drawHeight;\n  let hideAxisXTitleFlag = option.hideAxisXTitleFlag; //隐藏x轴标题标志\n  let axisXTitlePosition = option.axisXTitlePosition; //x轴标题位置\n  let isLegendFlag = option.isLegendFlag; //存在图例标志\n  let hideLegendFlag = option.hideLegendFlag; //隐藏图例标志\n  let legendPosition = option.legendPosition; //图例位置\n  let hideAxisYTitleFlag = option.hideAxisYTitleFlag; //隐藏y轴标题标志\n  let axisYTitlePosition = option.axisYTitlePosition; //y轴标题位置\n  let container = option.container;\n  let currentChart = option.currentChart;\n  let chartAxis = option.chartAxis;\n  let fontSize = option.fontSize;\n\n  // 时间轴需要的配置变量\n  const isTimeLegendFlag = option.isTimeLegendFlag;\n  const timeLabels = option.timeLabels;\n  const initXLabels = option.initXLabels;\n  const positionDatas = option.positionDatas;\n\n  // 如果隐藏动态时间进度条，drawHeight-55 [ 55 是标题高度 及 间隔高度 ]\n  if (hideTimeBarFlag) {\n    drawHeight -= 55;\n  } else {\n    drawHeight -= 90;\n  }\n\n  // 当顶部轴标题时，在问答页面，标题放入顶部时，不允许增加整体的画图高度，所以画图区域需要\n  if (!hideAxisXTitleFlag && axisXTitlePosition === \"top\") {\n    drawHeight += 30;\n  }\n  // 如果有图例列表，显示在底部，则需要占用25px的图例高度\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"bottom\") {\n    drawHeight -= 25;\n  }\n\n  //map地图容器\n  let htmlString = '';\n  htmlString += '<div class=\"mapDiv\" style=\"position: absolute;left:0;top:0;width:' + (drawWidth - ((isLegendFlag && legendPosition) === \"right\" ? 130 : 0)) + 'px;height:' + drawHeight + 'px;\"></div>';\n  let mapDiv, map;\n  if (isMapFlag) {\n    mapDiv = $(htmlString);\n    $(container).append(mapDiv);\n    mapboxgl.accessToken = 'pk.eyJ1IjoiZGF0YWZvY3VzIiwiYSI6ImNrYTZnaGR3bzA2b28yenMzM2NsdXJ5cWgifQ.ckX22kXMjZZ7rijeXSFS8A';\n    map = new mapboxgl.Map({\n      container: mapDiv[0],\n      center: [120, 39],\n      zoom: 1,\n      style: 'mapbox://styles/mapbox/light-v10'\n    });\n  }\n  //Svg容器\n  htmlString = '';\n  const svgDivStyle = {\n    pointerEvents: isMapFlag ? 'none' : '',\n    width: drawWidth + 'px'\n  };\n  // debugger;\n  const svgStyle = {\n    overflow: 'hidden',\n    zIndex: '0',\n    width: drawWidth - ((isLegendFlag && legendPosition) === 'right' ? isMapFlag ? 130 : 100 : 0) + 'px'\n    // height: drawHeight + 'px',\n  };\n  htmlString += `<div class=\"svgDiv\" style=\"${convertObjToStyleStr(svgDivStyle)}\"><svg style=\"${convertObjToStyleStr(svgStyle)}\"></svg></div>`;\n  let svgDiv = $(htmlString);\n  let svgJQ = svgDiv.find(\"svg\");\n  if (isMapFlag) svgJQ.remove();\n  $(container).append(svgDiv);\n  //悬浮框容器\n  htmlString = '<div class=\"suspendDiv\" style=\"position: absolute;pointer-events: none\"></div>';\n  let suspendDiv = $(htmlString);\n  $(container).append(suspendDiv);\n  suspendDiv.css(\"z-index\", 1);\n  console.log('处理容器！');\n\n  //图例底部容器\n  let legendBar;\n  let legendLineHeight = 25;\n  let legendLineWidth = parseInt(drawWidth * 2 / 3);\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"bottom\") {\n    let styleStr;\n    styleStr = \"width:\" + legendLineWidth + \"px;\";\n    styleStr += \"height:\" + legendLineHeight + \"px;\";\n    let htmlStr = '<div class=\"legend-bar-bottom\" style=\"' + styleStr + '\"></div>';\n    legendBar = $(htmlStr);\n    $(container).append(legendBar);\n  }\n\n  //图例右部容器\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"right\") {\n    legendLineHeight = parseInt(drawHeight * 2 / 3);\n    legendLineWidth = 120;\n    let styleStr = \"position: absolute;\";\n    styleStr += \"top:\" + parseInt(drawHeight * 1 / 3) + \"px;\";\n    styleStr += \"right:\" + 0 + \"px;\";\n    styleStr += \"width:\" + legendLineWidth + \"px;\";\n    styleStr += \"height:\" + legendLineHeight + \"px;\";\n    styleStr += \"display:flex;\";\n    styleStr += \"flex-direction:column;\";\n    styleStr += \"align-items: center;\";\n    let htmlStr = '<div style=\"' + styleStr + '\"></div>';\n    legendBar = $(htmlStr);\n    $(container).append(legendBar);\n  }\n  let titleDom = currentChart.drawChartAxisTitle(true);\n  //左部标题容器\n  let leftTitleBar;\n  if (!hideAxisYTitleFlag && axisYTitlePosition === 'left') {\n    let styleStr = \"position: absolute;\";\n    styleStr += \"top:\" + 20 + \"px;\";\n    styleStr += \"left:\" + 0 + \"px;\";\n    styleStr += \"width:\" + 24 + \"px;\";\n    styleStr += \"height:\" + (drawHeight - 40) + \"px;\";\n    styleStr += \"display:flex;\";\n    styleStr += \"flex-direction:column;\";\n    styleStr += \"align-items: center;\";\n    styleStr += \"justify-content: center\";\n    let htmlStr = '<div style=\"' + styleStr + '\"></div>';\n    leftTitleBar = $(htmlStr);\n    $(container).append(leftTitleBar);\n    if (titleDom.yTitleDom) {\n      if (!chartAxis.curYAxis || !chartAxis.curYAxis[2]) {\n        titleDom.yTitleDom.innerHTML = \"<div class='y-title-left'  style='display: flex;'>\" + titleDom.yInnerStr + \"</div>\";\n        titleDom.yTitleDom.className = \"chart-title y-title chart-vertical-title-left left\";\n        leftTitleBar.append(titleDom.yTitleDom);\n      } else {\n        titleDom.yTitleDom.innerHTML = \"<div class='yAxis-title-list' >\" + titleDom.yInnerStr + \"</div>\";\n        titleDom.yTitleDom.className = \"chart-title y-title chart-vertical-title left chart-list-container\";\n        leftTitleBar.append(titleDom.yTitleDom);\n      }\n    }\n  }\n\n  //右部标题容器\n  let rightTitleBar;\n  if (!hideAxisYTitleFlag && axisYTitlePosition === 'right') {\n    let styleStr = \"position: absolute;\";\n    styleStr += \"top:\" + 20 + \"px;\";\n    styleStr += \"right:\" + 0 + \"px;\";\n    styleStr += \"width:\" + 24 + \"px;\";\n    styleStr += \"height:\" + (drawHeight - 40) + \"px;\";\n    styleStr += \"display:flex;\";\n    styleStr += \"flex-direction:column;\";\n    styleStr += \"align-items: center;\";\n    styleStr += \"justify-content: center\";\n    let htmlStr = '<div style=\"' + styleStr + '\"></div>';\n    rightTitleBar = $(htmlStr);\n    $(container).append(rightTitleBar);\n    if (titleDom.yTitleDom) {\n      if (!chartAxis.curYAxis || !chartAxis.curYAxis[2]) {\n        titleDom.yTitleDom.innerHTML = \"<div class='y-title-left'  style='display: flex;'>\" + titleDom.yInnerStr + \"</div>\";\n        titleDom.yTitleDom.className = \"chart-title y-title chart-vertical-title-left left\";\n        rightTitleBar.append(titleDom.yTitleDom);\n      } else {\n        titleDom.yTitleDom.innerHTML = \"<div class='yAxis-title-list' style='margin-left: -70px;'>\" + titleDom.yInnerStr + \"</div>\";\n        titleDom.yTitleDom.className = \"chart-title y-title chart-vertical-title left chart-list-container\";\n        rightTitleBar.append(titleDom.yTitleDom);\n      }\n    }\n  }\n\n  //底部Y轴标题容器\n  let bottomYTitleBar;\n  if (!hideAxisYTitleFlag && axisYTitlePosition === 'bottom') {\n    let styleStr = \"position: relative;\";\n    styleStr += \"display:flex;\";\n    styleStr += \"align-items: center;\";\n    styleStr += \"justify-content: center\";\n    let htmlStr = '<div style=\"' + styleStr + '\"></div>';\n    bottomYTitleBar = $(htmlStr);\n    $(container).append(bottomYTitleBar);\n    if (titleDom.yTitleDom) {\n      if (!chartAxis.curYAxis || !chartAxis.curYAxis[2]) {\n        titleDom.yTitleDom.innerHTML = \"<div class='y-title-bottom'>\" + titleDom.yInnerStr + \"</div>\";\n        titleDom.yTitleDom.className = \"chart-title y-title chart-horizontal-title bottom\";\n        bottomYTitleBar.append(titleDom.yTitleDom);\n      } else {\n        titleDom.yTitleDom.innerHTML = \"<div class='yAxis-title-list' style=''>\" + titleDom.yInnerStr + \"</div>\";\n        titleDom.yTitleDom.className = \"chart-title y-title chart-horizontal-title bottom chart-list-container\";\n        bottomYTitleBar.append(titleDom.yTitleDom);\n      }\n    }\n  }\n\n  //顶部X轴标题容器\n  let topTitleBar;\n  if (!hideAxisXTitleFlag && axisXTitlePosition === 'top') {\n    let styleStr = \"position: absolute;\";\n    styleStr += \"top:\" + 0 + \"px;\";\n    styleStr += \"left:\" + 20 + \"px;\";\n    styleStr += \"width:\" + (drawWidth - 40) + \"px;\";\n    styleStr += \"height:\" + 40 + \"px;\";\n    styleStr += \"display:flex;\";\n    styleStr += \"align-items: center;\";\n    styleStr += \"justify-content: center\";\n    let htmlStr = '<div style=\"' + styleStr + '\"></div>';\n    topTitleBar = $(htmlStr);\n    $(container).append(topTitleBar);\n    if (titleDom.xTitleDom) {\n      titleDom.xTitleDom.className = \"chart-title x-title chart-horizontal-title bottom\";\n      topTitleBar.append(titleDom.xTitleDom);\n    }\n  }\n\n  // 绘制时间轴容器\n  if (option.hasTimeline) {\n    console.log('executeContainer中，有时间轴');\n    let htmlStr = `<div class=\"time-bar-container\">`;\n    // 播放按钮\n    htmlStr += '<div class=\"time-bar-play-btn\"><i class=\"time-bar-play-btn-icon icon-triangle-right-1\"></i></div>';\n    // 开始时间文字: 图例是时间轴，则取curTime中的时间信息，X轴是时间轴，则取X轴中的时间信息\n    htmlStr += '<div class=\"time-bar-start-time\" title=\"' + (isTimeLegendFlag ? timeLabels[0] : initXLabels[0]) + '\">' + (isTimeLegendFlag ? timeLabels[0] : initXLabels[0]) + '</div>';\n    // 时间条\n    htmlStr += '<div class=\"time-bar-line\"></div>';\n    // 结束时间文字\n\n    const rangeFinalPosition = positionDatas.length - 1; //选中区间末尾位置\n    htmlStr += '<div class=\"time-bar-end-time\" title=\"' + (isTimeLegendFlag ? timeLabels[rangeFinalPosition] : initXLabels[rangeFinalPosition]) + '\">' + (isTimeLegendFlag ? timeLabels[rangeFinalPosition] : initXLabels[rangeFinalPosition]) + '</div>';\n    htmlStr += '</div>';\n    const timeBarContainer = $(htmlStr);\n    $(container).append(timeBarContainer);\n  } else {\n    console.log('容器处理 - 没有时间轴');\n  }\n\n  //底部X轴标题容器\n  let bottomTitleBar;\n  if (!hideAxisXTitleFlag && axisXTitlePosition === 'bottom') {\n    let styleStr = \"position: relative;\";\n    styleStr += \"display:flex;\";\n    styleStr += \"align-items: center;\";\n    styleStr += \"justify-content: center\";\n    let htmlStr = '<div class=\"bottom-title-bar\" style=\"' + styleStr + '\"></div>';\n    bottomTitleBar = $(htmlStr);\n    $(container).append(bottomTitleBar);\n    if (titleDom.xTitleDom) {\n      titleDom.xTitleDom.className = \"chart-title x-title chart-horizontal-title bottom\";\n      bottomTitleBar.append(titleDom.xTitleDom);\n    }\n  }\n\n  //四周偏置\n  let topOffset = fontSize * 2;\n  if (isMapFlag) topOffset = 0;\n  //当顶部轴标题时\n  if (!hideAxisXTitleFlag && axisXTitlePosition === \"top\") {\n    topOffset += 30;\n  }\n  let leftOffset = 0;\n  if (!hideAxisYTitleFlag && axisYTitlePosition === \"left\") {\n    // 左Y轴宽度，在没有Y轴 或Y轴数量小于2时，leftOffset是20\n    if (!chartAxis.curYAxis || !chartAxis.curYAxis[2]) {\n      leftOffset += 20;\n    } else {\n      leftOffset += 130;\n    }\n  }\n\n  // todo - rightOffset暂时只给条形图使用\n  let rightOffset = (isLegendFlag && legendPosition) === \"right\" ? 100 : 0;\n  // 地图模式下，Y轴标题允许放在右侧\n  if (isMapFlag) {\n    rightOffset = 0;\n    if (!hideAxisYTitleFlag && axisYTitlePosition === \"right\") {\n      if (!chartAxis.curYAxis || !chartAxis.curYAxis[2]) {\n        rightOffset += 20;\n      } else {\n        rightOffset += 120;\n      }\n    }\n  }\n\n  // Y轴标题放在右侧的情况下，计算rightOffset\n  let finalRightOffset = rightOffset;\n  if (!hideAxisYTitleFlag && axisYTitlePosition === \"right\") {\n    if (!chartAxis.curYAxis || !chartAxis.curYAxis[2]) {\n      rightOffset += 20;\n    } else {\n      rightOffset += 120;\n    }\n  }\n  let xLabelSpace = 30;\n  let autoFlexHeight = svgDiv.height() - 10;\n  drawHeight = autoFlexHeight - 3;\n  if (svgJQ) svgJQ.attr('height', autoFlexHeight + 10 + 'px');\n  return {\n    drawWidth: drawWidth,\n    drawHeight: drawHeight,\n    svgDiv: svgDiv,\n    svgDivHeight: drawHeight,\n    svgDivWidth: drawWidth,\n    svgJQ: svgJQ,\n    suspendDiv: suspendDiv,\n    legendBar: legendBar,\n    legendLineHeight: legendLineHeight,\n    legendLineWidth: legendLineWidth,\n    titleDom: titleDom,\n    leftTitleBar: leftTitleBar,\n    rightTitleBar: rightTitleBar,\n    bottomYTitleBar: bottomYTitleBar,\n    topTitleBar: topTitleBar,\n    bottomTitleBar: bottomTitleBar,\n    topOffset: topOffset,\n    leftOffset: leftOffset,\n    rightOffset: rightOffset,\n    finalRightOffset: finalRightOffset,\n    xLabelSpace: xLabelSpace,\n    mapDiv: mapDiv,\n    map: map\n  };\n};\n// 更新悬浮区域的容器\ncontainerOp.drawSuspendDiv = function (suspendDiv) {\n  suspendDiv.empty();\n  let tempStyleStr = \"padding-left:8px;\";\n  tempStyleStr += \"padding-right:8px;\";\n  tempStyleStr += \"padding-top:8px;\";\n  tempStyleStr += \"padding-bottom:8px;\";\n  tempStyleStr += \"border-radius: 3px;\";\n  tempStyleStr += \"border: 1px solid #ddd;\";\n  tempStyleStr += \"max-width: 200px;\";\n  tempStyleStr += \"min-width: 100px;\";\n  tempStyleStr += \"text-align: left;\";\n  tempStyleStr += \"background-color: rgba(255,255,255,0.8);\";\n  tempStyleStr += \"display:none;\";\n  let tempHtmlStr = '<div style=\"' + tempStyleStr + '\"></div>';\n  let suspendContainerDom = $(tempHtmlStr);\n  suspendDiv.append(suspendContainerDom);\n  return suspendContainerDom;\n};\n\n//时间轴相关对象状态及操作\nfunction getTimeOp() {\n  //时序控制\n  let timeOp = {};\n  /**\n   * 初始化时间轴对象的属性\n   * @param   option  -   动画图对象的属性\n   *              {\n   *                  -   isTimeLegendFlag    -   translateData后返回的数据isTimeLegendFlag 是都是时间图例的标志\n   *                  -   positionDatas       -   translateData后返回的数据positionDatas 转换数据\n   *                  -   timeLabels          -   translateData后返回的数据timeLabels 时间标签数组\n   *              }\n   *\n   * @return  初始化timeOp对象中的参数\n   *      -   timeBar             时间轴DOM容器\n   *      -   playBottom          播放按钮DOM\n   *      -   timeOperateHead     头部控制点DOM\n   *      -   timeOperateTail     尾部控制点DOM\n   *      -   rangeCoverLine      头尾控制点之间的时间覆盖线DOM\n   *      -   scrollMode          时间模式，默认是为离散模式\n   *\n   *      -   option              画图实例中的各种配置对象集合\n   *\n   *      -   rangeCount\n   *      -   rangeFinalPosition\n   *      -   rangeHeadPosition\n   *      -   rangeTailPosition\n   *      -   reductDimFlag\n   * */\n  timeOp.initial = function (option) {\n    let self = this;\n    self.timeBar = null; //时间轴dom实例\n    self.playBottom = null; //播放按钮dom实例\n    self.timeOperateHead = null; //头部时间控制点dom实例\n    self.timeOperateTail = null; //尾部时间控制点dom实例\n    self.rangeCoverLine = null; //时间覆盖线dom实例\n    self.scrollMode = \"dispersed\"; //时间控制点拖拽模式，默认离散模式。没有连续模式\n    self.option = option;\n    //离散区间变量\n    self.rangeCount = option.positionDatas.length - 1; //当前选中的时间区间\n    self.rangeFinalPosition = option.positionDatas.length - 1; //选中区间末尾位置\n    self.rangeHeadPosition = 0; //选中区间的头部位置\n    self.rangeTailPosition = self.rangeFinalPosition; //选中区间的尾部位置\n    self.reductDimFlag = false; //区间情形，双点重合模式标志，已废弃\n    //当图例是时间列时，更改时间轴模式\n    if (option.isTimeLegendFlag) {\n      self.rangeCount = option.timeLabels.length - 1;\n      self.rangeFinalPosition = option.timeLabels.length - 1;\n      self.rangeHeadPosition = 0;\n      self.rangeTailPosition = 0;\n    }\n  };\n  /***\n   * 创建时间轴容器,\n   * -    通过option中的配置将initial中初始化的时间轴的DOM元素填充\n   * -    执行画图 option.drawFrame\n   * -    增加事件监控\n   * -    往timeOp对象中增加播放状态参数\n   *              {\n   *                  playState           -   播放状态\n   *                  handOperateFlag     -   手动操作的标志\n   *                  runPlay             -   播放函数\n   *              }\n   * */\n  timeOp.createElements = function () {\n    let self = this;\n    //播放定时器 绑定到图形实例上\n    let currentChart = self.option.currentChart || {};\n    //清楚可能残留的定时器\n    clearTimeout(currentChart.playFrameTimer);\n    currentChart.playFrameTimer = null;\n    //播放状态\n    self.playState = false;\n    //手动操作标志\n    self.handOperateFlag = false;\n    //定义播放函数\n    self.runPlay = null;\n    let isOverLapTwoDragButtonFlag = self.option.isOverLapTwoDragButtonFlag; //重叠两个控制点标志\n    let isLegendFlag = self.option.isLegendFlag; //存在图例标志\n    let hideLegendFlag = self.option.hideLegendFlag; //隐藏图例标志\n    let legendPosition = self.option.legendPosition; //图例位置标志\n    let hideAxisXTitleFlag = self.option.hideAxisXTitleFlag; //隐藏x轴标题标志\n    let axisXTitlePosition = self.option.axisXTitlePosition; //x轴标题位置\n    let drawWidth = self.option.drawWidth;\n    let drawHeight = self.option.drawHeight;\n    let isTimeLegendFlag = self.option.isTimeLegendFlag; //时间轴模式\n    let timeLabels = self.option.timeLabels; //时间轴数组\n    let initXLabels = self.option.initXLabels; //x轴数组\n    let container = self.option.container; //图形绘制容器\n    let positionDatas = self.option.positionDatas; //处理后的数据\n    let columns = self.option.columns; //原始行列数据\n    let chartAxis = self.option.chartAxis;\n    let drawFrame = self.option.drawFrame; //绘制单帧图形 function\n    let hideTimeBarFlag = self.option.hideTimeBarFlag; //隐藏时间轴\n    let timePlayModel = self.option.timePlayModel; //播放模式\n    let playEndPauseTime = self.option.playEndPauseTime; //整体播放结束后暂停时间\n    let playStartPauseTime = self.option.playStartPauseTime; //整体播放开始前暂停时间\n    let playConstituteTime = self.option.playConstituteTime; //单帧播放持续时间\n\n    // 填充时间轴内部元素并绑定响应事件\n    (() => {\n      const timeContainer = $(container).find('.time-bar-container');\n      self.playBottom = timeContainer.find(\".time-bar-play-btn-icon\");\n      self.timeBar = timeContainer.find(\".time-bar-line\"); // 时间条\n\n      // debugger;\n      let htmlStr = '<div class=\"time-operate-head-label\">' + (isTimeLegendFlag ? timeLabels[0] : initXLabels[0]) + '</div>';\n      let suspendHeadLabels = $(htmlStr);\n      htmlStr = '<div class=\"time-operate-tail-label\">' + (isTimeLegendFlag ? timeLabels[self.rangeFinalPosition] : initXLabels[self.rangeFinalPosition]) + '</div>';\n      let suspendTailLabels = $(htmlStr);\n      let styleStr;\n      // 创建提示悬浮框底部三角\n\n      // 悬浮条的头三角\n      htmlStr = `<div class=\"time-operate-head-label-triangle\"><span class=\"icon-triangle-down1\"></span></div>`;\n      const suspendHeadTriangle = $(htmlStr);\n\n      // 悬浮条的尾三角\n      htmlStr = `<div class=\"time-operate-tail-label-triangle\"><span class=\"icon-triangle-down1\"></span></div>`;\n      const suspendTailTriangle = $(htmlStr);\n\n      // 图例是时间轴时，头尾重叠。X轴是时间轴时，头尾不重叠\n\n      // 创建区间覆盖线\n      htmlStr = '<div class=\"range-cover-line\" style=\"width: 100%\"></div>';\n      self.rangeCoverLine = $(htmlStr);\n      self.timeBar.append(self.rangeCoverLine);\n\n      // 左侧的拖动按钮\n      htmlStr = '<div class=\"time-operate-head-btn\"><div class=\"time-operate-circle\"></div></div>';\n      self.timeOperateHead = $(htmlStr);\n      self.timeOperateHead.append(suspendHeadLabels);\n      self.timeOperateHead.append(suspendHeadTriangle);\n      self.timeBar.append(self.timeOperateHead);\n\n      // 右侧的拖动按钮\n      htmlStr = '<div class=\"time-operate-tail-btn\"><div class=\"time-operate-circle\"></div></div>';\n      self.timeOperateTail = $(htmlStr);\n      self.timeOperateTail.append(suspendTailLabels);\n      self.timeOperateTail.append(suspendTailTriangle);\n      self.timeBar.append(self.timeOperateTail);\n\n      //绑定时轴按钮的拖拽事件\n      self.timeOperateHead.unbind(\"mousedown\");\n      self.timeOperateHead.bind(\"mousedown\", function (e) {\n        document.body.style.cursor = 'grabbing';\n        self.timeOperateTail.css('cursor', 'grabbing');\n        self.timeBar.css('cursor', 'grabbing');\n        e.stopPropagation();\n        //手动操作\n        self.handOperateFlag = true;\n        //终止播放\n        self.playBottom.addClass(\"icon-triangle-right-1\");\n        self.playBottom.removeClass(\"icon-stop-1\");\n        clearTimeout(currentChart.playFrameTimer);\n        self.playState = false;\n        const startX = e.clientX;\n\n        // 一个区间的长度\n        const timeBarWidth = self.timeBar[0].offsetWidth;\n        let rangeWidth = timeBarWidth / self.rangeCount;\n        console.log('区间个数');\n\n        // 起点的位置\n        let prePosition = self.rangeHeadPosition;\n        let preRelativeRangeCount = 0;\n\n        // 拖动按钮\n        $(document).bind(\"mousemove\", function (e) {\n          let moveWidth = e.clientX - startX;\n\n          // 离散拖动\n          if (self.scrollMode === \"dispersed\") {\n            // 移动的距离占整体的百分比：最小移动1个百分比\n            let relativeMoveRangeCount = Math.floor(Math.abs(moveWidth) / rangeWidth);\n            let restWidth = Math.abs(moveWidth) - relativeMoveRangeCount * rangeWidth;\n            if (restWidth >= rangeWidth * 0.7) {\n              relativeMoveRangeCount += 1;\n            }\n            if (moveWidth < 0) relativeMoveRangeCount *= -1;\n            //如果是向起始点拖拽，则取判断偏置的补\n            if (Math.abs(relativeMoveRangeCount) < Math.abs(preRelativeRangeCount)) {\n              if (restWidth >= rangeWidth * 0.3) {\n                if (moveWidth < 0) relativeMoveRangeCount -= 1;else relativeMoveRangeCount += 1;\n              }\n            }\n            let neoPosition = Math.min(self.rangeCount, Math.max(0, relativeMoveRangeCount + self.rangeHeadPosition));\n            if (neoPosition !== prePosition) {\n              prePosition = neoPosition;\n              preRelativeRangeCount = relativeMoveRangeCount;\n              let minPosition = Math.min(self.rangeTailPosition, prePosition);\n              let maxPosition = Math.max(self.rangeTailPosition, prePosition);\n              if (self.reductDimFlag) {\n                console.log('重叠拖动');\n                self.timeOperateHead.css(\"left\", prePosition * rangeWidth + \"px\");\n                self.timeOperateTail.css(\"left\", prePosition * rangeWidth + \"px\");\n                suspendHeadLabels.text(isTimeLegendFlag ? timeLabels[prePosition] : initXLabels[prePosition]);\n                suspendTailLabels.text(isTimeLegendFlag ? timeLabels[prePosition] : initXLabels[prePosition]);\n              } else {\n                if (isTimeLegendFlag || minPosition !== maxPosition || true) {\n                  self.timeOperateHead.css(\"left\", prePosition * rangeWidth + \"px\");\n                  self.rangeCoverLine.css(\"left\", minPosition * rangeWidth + \"px\");\n                  self.rangeCoverLine.css(\"width\", (maxPosition - minPosition) * rangeWidth + \"px\");\n                  suspendHeadLabels.text(initXLabels[prePosition]);\n                }\n              }\n              let frameOption = {\n                datas: columns,\n                chartAxis: chartAxis,\n                width: drawWidth,\n                height: drawHeight,\n                pStart: self.reductDimFlag ? prePosition : minPosition,\n                pEnd: self.reductDimFlag ? prePosition : maxPosition,\n                perTime: 200\n              };\n              if (isTimeLegendFlag) {\n                frameOption = {\n                  datas: columns,\n                  chartAxis: chartAxis,\n                  width: drawWidth,\n                  height: drawHeight,\n                  pStart: 0,\n                  pEnd: positionDatas.length - 1,\n                  timeStampIdx: prePosition,\n                  perTime: 200\n                };\n              }\n              if (isTimeLegendFlag || minPosition !== maxPosition || true) drawFrame(frameOption);\n            }\n          }\n        });\n\n        // 放开按钮\n        $(container).one(\"mouseup\", function (e) {\n          document.body.style.cursor = null;\n          self.timeOperateTail.css('cursor', 'grab');\n          self.timeBar.css('cursor', '');\n          $(document).unbind(\"mousemove\");\n          if (self.scrollMode === \"dispersed\") {\n            //更新按钮的位置\n            if (self.reductDimFlag) {\n              self.rangeHeadPosition = prePosition;\n              self.rangeTailPosition = prePosition;\n            } else {\n              if (prePosition === self.rangeTailPosition) {\n                //如果两点重叠，则不变(不允许重叠)\n                if (isOverLapTwoDragButtonFlag) self.rangeHeadPosition = prePosition;\n              } else {\n                self.rangeHeadPosition = prePosition;\n              }\n            }\n            if (self.rangeHeadPosition > self.rangeTailPosition) {\n              let temp = self.rangeHeadPosition;\n              self.rangeHeadPosition = self.rangeTailPosition;\n              self.rangeTailPosition = temp;\n              self.timeOperateHead.css(\"left\", self.rangeHeadPosition * rangeWidth + \"px\");\n              self.timeOperateTail.css(\"left\", self.rangeTailPosition * rangeWidth + \"px\");\n              suspendHeadLabels.text(isTimeLegendFlag ? timeLabels[self.rangeHeadPosition] : initXLabels[self.rangeHeadPosition]);\n              suspendTailLabels.text(isTimeLegendFlag ? timeLabels[self.rangeTailPosition] : initXLabels[self.rangeTailPosition]);\n            }\n            if (self.rangeHeadPosition === self.rangeTailPosition) {\n              //reductDimFlag=true;\n            }\n          }\n        });\n      });\n      self.timeOperateTail.unbind(\"mousedown\");\n      // 右侧按钮 - 按下圆圈拖动进度条的时候，绘制目标帧\n      self.timeOperateTail.bind(\"mousedown\", function (e) {\n        document.body.style.cursor = 'grabbing';\n        self.timeOperateTail.css('cursor', 'grabbing');\n        self.timeBar.css('cursor', 'grabbing');\n        e.stopPropagation();\n        //手动操作\n        self.handOperateFlag = true;\n        //终止播放\n        self.playBottom.addClass(\"icon-triangle-right-1\");\n        self.playBottom.removeClass(\"icon-stop-1\");\n        clearTimeout(currentChart.playFrameTimer);\n        self.playState = false;\n        let startX = e.clientX;\n        const timeBarWidth = self.timeBar[0].offsetWidth;\n        let rangeWidth = timeBarWidth / self.rangeCount;\n        let prePosition = self.rangeTailPosition;\n        let preRelativeRangeCount = 0;\n        $(document).bind(\"mousemove\", function (e) {\n          let moveWidth = e.clientX - startX;\n          if (self.scrollMode === \"dispersed\") {\n            let relativeMoveRangeCount = Math.floor(Math.abs(moveWidth) / rangeWidth);\n            let restWidth = Math.abs(moveWidth) - relativeMoveRangeCount * rangeWidth;\n            if (restWidth >= rangeWidth * 0.7) {\n              relativeMoveRangeCount += 1;\n            }\n            if (moveWidth < 0) relativeMoveRangeCount *= -1;\n            //如果是向起始点拖拽，则取判断偏置的补\n            if (Math.abs(relativeMoveRangeCount) < Math.abs(preRelativeRangeCount)) {\n              if (restWidth >= rangeWidth * 0.3) {\n                if (moveWidth < 0) relativeMoveRangeCount -= 1;else relativeMoveRangeCount += 1;\n              }\n            }\n            let neoPosition = Math.min(self.rangeCount, Math.max(0, relativeMoveRangeCount + self.rangeTailPosition));\n            if (neoPosition !== prePosition) {\n              prePosition = neoPosition;\n              preRelativeRangeCount = relativeMoveRangeCount;\n              let minPosition = Math.min(self.rangeHeadPosition, prePosition);\n              let maxPosition = Math.max(self.rangeHeadPosition, prePosition);\n              if (self.reductDimFlag) {\n                self.timeOperateHead.css(\"left\", prePosition * rangeWidth + \"px\");\n                self.timeOperateTail.css(\"left\", prePosition * rangeWidth + \"px\");\n                suspendHeadLabels.text(isTimeLegendFlag ? timeLabels[prePosition] : initXLabels[prePosition]);\n                suspendTailLabels.text(isTimeLegendFlag ? timeLabels[prePosition] : initXLabels[prePosition]);\n              } else {\n                if (isTimeLegendFlag || minPosition !== maxPosition || true) {\n                  self.timeOperateTail.css(\"left\", prePosition * rangeWidth + \"px\");\n                  self.rangeCoverLine.css(\"left\", minPosition * rangeWidth + \"px\");\n                  self.rangeCoverLine.css(\"width\", (maxPosition - minPosition) * rangeWidth + \"px\");\n                  suspendTailLabels.text(isTimeLegendFlag ? timeLabels[prePosition] : initXLabels[prePosition]);\n                }\n              }\n              let frameOption = {\n                datas: columns,\n                chartAxis: chartAxis,\n                width: drawWidth,\n                height: drawHeight,\n                pStart: self.reductDimFlag ? prePosition : minPosition,\n                pEnd: self.reductDimFlag ? prePosition : maxPosition,\n                perTime: 200\n              };\n              if (isTimeLegendFlag) {\n                frameOption = {\n                  datas: columns,\n                  chartAxis: chartAxis,\n                  width: drawWidth,\n                  height: drawHeight,\n                  pStart: 0,\n                  pEnd: positionDatas.length - 1,\n                  timeStampIdx: prePosition,\n                  perTime: 200\n                };\n              }\n              if (isTimeLegendFlag || minPosition !== maxPosition || true) drawFrame(frameOption);\n            }\n          }\n        });\n        $(container).one(\"mouseup\", function (e) {\n          document.body.style.cursor = null;\n          self.timeOperateTail.css('cursor', 'grab');\n          self.timeBar.css('cursor', '');\n          $(document).unbind(\"mousemove\");\n          if (self.scrollMode === \"dispersed\") {\n            //更新按钮的位置\n            if (self.reductDimFlag) {\n              self.rangeHeadPosition = prePosition;\n              self.rangeTailPosition = prePosition;\n            } else {\n              if (prePosition === self.rangeHeadPosition) {\n                //如果两点重叠，则不变(不允许重叠)\n                if (isOverLapTwoDragButtonFlag) self.rangeHeadPosition = prePosition;\n              } else {\n                self.rangeTailPosition = prePosition;\n              }\n            }\n            if (self.rangeHeadPosition > self.rangeTailPosition) {\n              let temp = self.rangeHeadPosition;\n              self.rangeHeadPosition = self.rangeTailPosition;\n              self.rangeTailPosition = temp;\n              self.timeOperateHead.css(\"left\", self.rangeHeadPosition * rangeWidth + \"px\");\n              self.timeOperateTail.css(\"left\", self.rangeTailPosition * rangeWidth + \"px\");\n              suspendHeadLabels.text(isTimeLegendFlag ? timeLabels[self.rangeHeadPosition] : initXLabels[self.rangeHeadPosition]);\n              suspendTailLabels.text(isTimeLegendFlag ? timeLabels[self.rangeTailPosition] : initXLabels[self.rangeTailPosition]);\n            }\n            if (self.rangeHeadPosition === self.rangeTailPosition) {\n              //reductDimFlag=true;\n            }\n          }\n        });\n      });\n\n      //绑定覆盖线拖拽事件 - 拖拽整体的时间区间\n      self.rangeCoverLine.unbind(\"mousedown\");\n      self.rangeCoverLine.bind(\"mousedown\", function (e) {\n        e.stopPropagation();\n        if (isTimeLegendFlag) {\n          return;\n        }\n        //手动操作\n        self.handOperateFlag = true;\n        //终止播放\n        self.playBottom.addClass(\"icon-triangle-right-1\");\n        self.playBottom.removeClass(\"icon-stop-1\");\n        clearTimeout(currentChart.playFrameTimer);\n        self.playState = false;\n        let startX = e.clientX;\n        const timeBarWidth = self.timeBar[0].offsetWidth;\n        let rangeWidth = timeBarWidth / self.rangeCount;\n        let curHeadPosition = self.rangeHeadPosition;\n        let curTailPosition = self.rangeTailPosition;\n        $(document).bind(\"mousemove\", function (e) {\n          let moveWidth = e.clientX - startX;\n          if (self.scrollMode === \"dispersed\") {\n            let relativeMoveRangeCount = Math.floor(Math.abs(moveWidth) / rangeWidth);\n            let restWidth = Math.abs(moveWidth) - relativeMoveRangeCount * rangeWidth;\n            if (restWidth >= rangeWidth * 0.5) {\n              relativeMoveRangeCount += 1;\n            }\n            if (moveWidth < 0) relativeMoveRangeCount *= -1;\n            if (self.rangeHeadPosition + relativeMoveRangeCount >= 0 && self.rangeTailPosition + relativeMoveRangeCount <= self.rangeFinalPosition) {\n              curHeadPosition = self.rangeHeadPosition + relativeMoveRangeCount;\n              curTailPosition = self.rangeTailPosition + relativeMoveRangeCount;\n              self.timeOperateHead.css(\"left\", curHeadPosition * rangeWidth + \"px\");\n              self.timeOperateTail.css(\"left\", curTailPosition * rangeWidth + \"px\");\n              self.rangeCoverLine.css(\"left\", curHeadPosition * rangeWidth + \"px\");\n              self.rangeCoverLine.css(\"width\", (curTailPosition - curHeadPosition) * rangeWidth + \"px\");\n              suspendHeadLabels.text(initXLabels[curHeadPosition]);\n              suspendTailLabels.text(initXLabels[curTailPosition]);\n              let frameOption = {\n                datas: columns,\n                chartAxis: chartAxis,\n                width: drawWidth,\n                height: drawHeight,\n                pStart: curHeadPosition,\n                pEnd: curTailPosition,\n                perTime: 400,\n                testFlag: true\n              };\n              drawFrame(frameOption);\n            }\n          }\n        });\n        $(container).one(\"mouseup\", function (e) {\n          $(document).unbind(\"mousemove\");\n          if (self.scrollMode === \"dispersed\") {\n            //更新按钮的位置\n            self.rangeHeadPosition = curHeadPosition;\n            self.rangeTailPosition = curTailPosition;\n          }\n        });\n      });\n\n      //绑定时间轴底轴点击事件 - 控制单点进度\n      self.timeBar.unbind(\"click\");\n      self.timeBar.bind(\"click\", function (e) {\n        e.stopPropagation();\n        //手动操作\n        self.handOperateFlag = true;\n        //终止播放\n        self.playBottom.addClass(\"icon-triangle-right-1\");\n        self.playBottom.removeClass(\"icon-stop-1\");\n        clearTimeout(currentChart.playFrameTimer);\n        self.playState = false;\n        let timeBarPosition = self.timeBar[0].getBoundingClientRect();\n        let startX = e.clientX;\n        const timeBarWidth = self.timeBar[0].offsetWidth;\n        let rangeWidth = timeBarWidth / self.rangeCount;\n        let relativeX = startX - timeBarPosition.x;\n        if (relativeX < 0) return;\n        if (!isTimeLegendFlag) self.reductDimFlag = false;\n        let relativeMoveRangeCount = Math.floor(relativeX / rangeWidth);\n        let restWidth = relativeX - relativeMoveRangeCount * rangeWidth;\n        if (restWidth >= rangeWidth * 0.5) {\n          relativeMoveRangeCount += 1;\n        }\n        let originalPosition = self.rangeHeadPosition;\n        let isChangeFlag = true;\n        if (relativeMoveRangeCount < self.rangeHeadPosition && relativeMoveRangeCount < self.rangeTailPosition) {\n          self.rangeHeadPosition = relativeMoveRangeCount;\n        } else if (relativeMoveRangeCount > self.rangeHeadPosition && relativeMoveRangeCount > self.rangeTailPosition) {\n          self.rangeTailPosition = relativeMoveRangeCount;\n        } else if (relativeMoveRangeCount === self.rangeHeadPosition && relativeMoveRangeCount === self.rangeTailPosition) {\n          if (restWidth > 0.5 * rangeWidth) {\n            relativeMoveRangeCount = Math.max(0, self.rangeHeadPosition - 1);\n            self.rangeHeadPosition = relativeMoveRangeCount;\n          } else {\n            relativeMoveRangeCount = Math.min(10, self.rangeTailPosition + 1);\n            self.rangeTailPosition = relativeMoveRangeCount;\n          }\n        } else if (relativeMoveRangeCount === self.rangeHeadPosition) {\n          relativeMoveRangeCount = Math.max(0, self.rangeHeadPosition - 1);\n          self.rangeHeadPosition = relativeMoveRangeCount;\n        } else if (relativeMoveRangeCount === self.rangeTailPosition) {\n          relativeMoveRangeCount = Math.min(10, self.rangeTailPosition + 1);\n          self.rangeTailPosition = relativeMoveRangeCount;\n        } else {\n          isChangeFlag = false;\n        }\n        if (isChangeFlag) {\n          if (isTimeLegendFlag) {\n            if (self.rangeHeadPosition < originalPosition) {\n              self.rangeTailPosition = self.rangeHeadPosition;\n            } else if (self.rangeTailPosition > originalPosition) {\n              self.rangeHeadPosition = self.rangeTailPosition;\n            }\n          }\n          self.timeOperateHead.css(\"left\", self.rangeHeadPosition * rangeWidth + \"px\");\n          self.timeOperateTail.css(\"left\", self.rangeTailPosition * rangeWidth + \"px\");\n          self.rangeCoverLine.css(\"left\", self.rangeHeadPosition * rangeWidth + \"px\");\n          self.rangeCoverLine.css(\"width\", (self.rangeTailPosition - self.rangeHeadPosition) * rangeWidth + \"px\");\n          suspendHeadLabels.text(isTimeLegendFlag ? timeLabels[self.rangeHeadPosition] : initXLabels[self.rangeHeadPosition]);\n          suspendTailLabels.text(isTimeLegendFlag ? timeLabels[self.rangeTailPosition] : initXLabels[self.rangeTailPosition]);\n          let frameOption = {\n            datas: columns,\n            chartAxis: chartAxis,\n            width: drawWidth,\n            height: drawHeight,\n            pStart: self.rangeHeadPosition,\n            pEnd: self.rangeTailPosition,\n            perTime: 500\n          };\n          if (isTimeLegendFlag) {\n            self.reductDimFlag = true;\n            frameOption = {\n              datas: columns,\n              chartAxis: chartAxis,\n              width: drawWidth,\n              height: drawHeight,\n              pStart: 0,\n              pEnd: positionDatas.length - 1,\n              timeStampIdx: self.rangeHeadPosition,\n              perTime: 500\n            };\n          }\n          drawFrame(frameOption);\n        }\n      });\n\n      //显示隐藏动画轴\n      if (hideTimeBarFlag) {\n        timeContainer.css(\"visibility\", \"hidden\");\n        self.rangeCoverLine.css(\"visibility\", \"hidden\");\n        self.timeOperateHead.css(\"visibility\", \"hidden\");\n        self.timeOperateTail.css(\"visibility\", \"hidden\");\n      }\n\n      //绑定播放事件\n      let playHeadPosition, playTailPosition;\n      let totalTime = playConstituteTime * 1000;\n      let perTime = playConstituteTime * 1000;\n      self.playState = false;\n\n      // 自动播放或操作进度条来播放单帧\n      const playFrame = function (startPosition, endPosition, isHead) {\n        let frameOption = {\n          datas: columns,\n          chartAxis: chartAxis,\n          width: drawWidth,\n          height: drawHeight,\n          pStart: startPosition,\n          pEnd: endPosition,\n          prohibitSuspend: endPosition !== self.rangeFinalPosition,\n          perTime: perTime\n        };\n        if (isTimeLegendFlag) {\n          frameOption = {\n            datas: columns,\n            chartAxis: chartAxis,\n            width: drawWidth,\n            height: drawHeight,\n            pStart: 0,\n            pEnd: positionDatas.length - 1,\n            prohibitSuspend: endPosition !== self.rangeFinalPosition,\n            timeStampIdx: startPosition,\n            perTime: perTime\n          };\n        }\n        drawFrame(frameOption);\n        self.rangeHeadPosition = startPosition;\n        self.rangeTailPosition = endPosition;\n        const timeBarWidth = self.timeBar[0].offsetWidth;\n        let rangeWidth = timeBarWidth / self.rangeCount;\n        self.timeOperateHead.css(\"left\", self.rangeHeadPosition * rangeWidth + \"px\");\n        self.timeOperateTail.css(\"left\", self.rangeTailPosition * rangeWidth + \"px\");\n        self.rangeCoverLine.css(\"left\", self.rangeHeadPosition * rangeWidth + \"px\");\n        self.rangeCoverLine.css(\"width\", (self.rangeTailPosition - self.rangeHeadPosition) * rangeWidth + \"px\");\n        suspendHeadLabels.text(isTimeLegendFlag ? timeLabels[self.rangeHeadPosition] : initXLabels[self.rangeHeadPosition]);\n        suspendTailLabels.text(isTimeLegendFlag ? timeLabels[self.rangeTailPosition] : initXLabels[self.rangeTailPosition]);\n        let nextEndPosition = endPosition + 1;\n        if (nextEndPosition <= self.rangeFinalPosition) {\n          currentChart.playFrameTimer = setTimeout(function () {\n            if (isTimeLegendFlag) {\n              playFrame(nextEndPosition, nextEndPosition);\n            } else {\n              playFrame(startPosition, nextEndPosition);\n            }\n          }, isHead ? 10 : perTime);\n        } else {\n          self.playState = false;\n          self.playBottom.addClass(\"icon-triangle-right-1\");\n          self.playBottom.removeClass(\"icon-stop-1\");\n          clearTimeout(currentChart.playFrameTimer);\n          if (!self.handOperateFlag && timePlayModel === \"always\") {\n            setTimeout(function () {\n              self.runPlay(true);\n            }, playEndPauseTime * 1000);\n          }\n        }\n      };\n      // 开始运行\n      self.runPlay = function (ignoreHead) {\n        if (self.playState) {\n          self.playState = false;\n          self.playBottom.addClass(\"icon-triangle-right-1\");\n          self.playBottom.removeClass(\"icon-stop-1\");\n          clearTimeout(currentChart.playFrameTimer);\n          return;\n        }\n        self.playState = true;\n        self.playBottom.removeClass(\"icon-triangle-right-1\");\n        self.playBottom.addClass(\"icon-stop-1\");\n        if (isTimeLegendFlag) {\n          //当行进到最后一个之后，重置到开头\n          if (self.rangeTailPosition === self.rangeHeadPosition && self.rangeTailPosition === self.rangeFinalPosition) {\n            //同时也要重置动画状态缓存\n            self.option.incrementRecordObject = null;\n            self.option.prevIncrementRecord = null;\n            playHeadPosition = 0;\n            playTailPosition = 0;\n            //perTime=totalTime/Math.max((rangeFinalPosition),1);\n            playFrame(playHeadPosition, playTailPosition, ignoreHead);\n          }\n          //如果是时间图例的情况，只有一个点前进\n          else if (self.rangeTailPosition === self.rangeHeadPosition) {\n            playHeadPosition = self.rangeHeadPosition;\n            playTailPosition = self.rangeHeadPosition;\n            //perTime=totalTime/Math.max((rangeFinalPosition),1);\n            playFrame(playHeadPosition, playTailPosition, ignoreHead);\n          }\n        } else {\n          //如果尾部定位在最后一个位置，则从首部定位的后一位开始\n          if (self.rangeTailPosition === self.rangeFinalPosition) {\n            playHeadPosition = self.rangeHeadPosition;\n            if (isOverLapTwoDragButtonFlag) playTailPosition = self.rangeHeadPosition;else playTailPosition = self.rangeHeadPosition + 1;\n            //perTime=totalTime/Math.max((rangeFinalPosition),1);\n            playFrame(playHeadPosition, playTailPosition, ignoreHead);\n          }\n          //如果尾部不在最后一个位置且首尾重合，则从首部定位的后一位开始\n          else if (self.rangeHeadPosition === self.rangeTailPosition) {\n            playHeadPosition = self.rangeHeadPosition;\n            if (isOverLapTwoDragButtonFlag) playTailPosition = self.rangeHeadPosition;else playTailPosition = self.rangeHeadPosition + 1;\n            //perTime=totalTime/Math.max((rangeFinalPosition-playHeadPosition),1);\n            playFrame(playHeadPosition, playTailPosition, ignoreHead);\n          }\n          //如果尾部不在最后一个位置，则从尾部直接开始\n          else {\n            playHeadPosition = self.rangeHeadPosition;\n            playTailPosition = self.rangeTailPosition;\n            //perTime=totalTime/Math.max((rangeFinalPosition-playHeadPosition),1);\n            playFrame(playHeadPosition, playTailPosition, ignoreHead);\n          }\n        }\n      };\n      let clickEvent = function () {\n        if ('ontouchstart' in document.documentElement === true) return 'touchstart';else return 'click';\n      }();\n      self.playBottom.unbind(clickEvent);\n      self.playBottom.bind(clickEvent, function (e) {\n        self.runPlay(true);\n      });\n\n      //绑定悬浮标签显示与隐藏事件\n      let showSuspendLabel = function () {\n        suspendHeadLabels.css(\"display\", \"\");\n        suspendHeadTriangle.css(\"display\", \"\");\n        suspendTailLabels.css(\"display\", \"\");\n        suspendTailTriangle.css(\"display\", \"\");\n      };\n      let hiddenSuspendLabel = function () {\n        suspendHeadLabels.css(\"display\", \"none\");\n        suspendHeadTriangle.css(\"display\", \"none\");\n        suspendTailLabels.css(\"display\", \"none\");\n        suspendTailTriangle.css(\"display\", \"none\");\n      };\n      timeContainer.unbind(\"mouseover\");\n      timeContainer.bind(\"mouseover\", function (e) {\n        showSuspendLabel();\n      });\n      timeContainer.unbind(\"mouseout\");\n      timeContainer.bind(\"mouseout\", function (e) {\n        hiddenSuspendLabel();\n      });\n      self.rangeCoverLine.unbind(\"mouseover\");\n      self.rangeCoverLine.bind(\"mouseover\", function (e) {\n        showSuspendLabel();\n      });\n      self.rangeCoverLine.unbind(\"mouseout\");\n      self.rangeCoverLine.bind(\"mouseout\", function (e) {\n        hiddenSuspendLabel();\n      });\n      self.timeOperateHead.unbind(\"mouseover\");\n      self.timeOperateHead.bind(\"mouseover\", function (e) {\n        showSuspendLabel();\n      });\n      self.timeOperateHead.unbind(\"mouseout\");\n      self.timeOperateHead.bind(\"mouseout\", function (e) {\n        hiddenSuspendLabel();\n      });\n      self.timeOperateTail.unbind(\"mouseover\");\n      self.timeOperateTail.bind(\"mouseover\", function (e) {\n        showSuspendLabel();\n      });\n      self.timeOperateTail.unbind(\"mouseout\");\n      self.timeOperateTail.bind(\"mouseout\", function (e) {\n        hiddenSuspendLabel();\n      });\n    })();\n  };\n  timeOp.registerFn = function ({\n    incrementRecordObject,\n    prevIncrementRecord,\n    drawFrame\n  }) {};\n\n  // 初始时进行播放\n  timeOp.play = function () {\n    let self = this;\n    const drawFrame = self.option.drawFrame; //展示当前动态数据的第一帧，相当于动态图的 poster\n    const columns = self.option.columns; //原始行列数据\n    const chartAxis = self.option.chartAxis;\n    const drawWidth = self.option.drawWidth;\n    const drawHeight = self.option.drawHeight;\n    const isTimeLegendFlag = self.option.isTimeLegendFlag; //时间轴模式\n    const positionDatas = self.option.positionDatas; //处理后的数据\n    const timePlayModel = self.option.timePlayModel; //播放模式\n    const playEndPauseTime = self.option.playEndPauseTime; //整体播放结束后暂停时间\n    const playStartPauseTime = self.option.playStartPauseTime || 0; //整体播放开始前暂停时间\n    const playConstituteTime = self.option.playConstituteTime; //单帧播放持续时间\n\n    let frameOption = {\n      datas: columns,\n      chartAxis: chartAxis,\n      width: drawWidth,\n      height: drawHeight,\n      pStart: 0,\n      pEnd: positionDatas.length - 1\n    };\n    if (isTimeLegendFlag) {\n      self.reductDimFlag = true;\n      frameOption = {\n        datas: columns,\n        chartAxis: chartAxis,\n        width: drawWidth,\n        height: drawHeight,\n        pStart: 0,\n        pEnd: positionDatas.length - 1,\n        timeStampIdx: self.rangeHeadPosition,\n        perTime: 500\n      };\n    }\n    drawFrame(frameOption);\n    // 只播放一次或循环播放情况下，初始时开启播放\n    if (timePlayModel === \"first\" || timePlayModel === \"always\") {\n      setTimeout(() => {\n        self.runPlay(true);\n      }, playStartPauseTime * 1000);\n    }\n  };\n  return timeOp;\n}\n\n//定义绘制节点图形Path d的函数\n// 获取三角形形状Path\nlet shapeTriangle = function (R) {\n  let offset = R;\n  let str = \"M\" + (R - offset) + \" \" + (0 - offset) + \" \";\n  str += \"L\" + (2 * R - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"L\" + (0 - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"L\" + (R - offset) + \" \" + (0 - offset) + \" \";\n  return str;\n};\n// 获取菱形形状Path\nlet shapeDiamond = function (R) {\n  let offset = R;\n  let str = \"M\" + (R - offset) + \" \" + (0 - offset) + \" \";\n  str += \"L\" + (2 * R - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (R - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"L\" + (0 - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (R - offset) + \" \" + (0 - offset) + \" \";\n  return str;\n};\n// 获取四角星形状Path\nlet shapeStar = function (R) {\n  let offset = R;\n  let str = \"M\" + (R - offset) + \" \" + (0 - offset) + \" \";\n  str += \"A\" + (R + 2) + \" \" + (R + 2) + \" 0 0 0 \" + (2 * R - offset) + \" \" + (R - offset) + \" \";\n  str += \"A\" + (R + 2) + \" \" + (R + 2) + \" 0 0 0 \" + (R - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"A\" + (R + 2) + \" \" + (R + 2) + \" 0 0 0 \" + (0 - offset) + \" \" + (R - offset) + \" \";\n  str += \"A\" + (R + 2) + \" \" + (R + 2) + \" 0 0 0 \" + (R - offset) + \" \" + (0 - offset) + \" \";\n  return str;\n};\n// 获取五角星形状Path\nlet shapeFiveStar = function (R) {\n  let offset = R;\n  let outerPoints = [];\n  let r = R * Math.sin(Math.PI * 18 / 180) / Math.sin(Math.PI * 36 / 180);\n  let angleOffset = -18;\n  for (let i = 0; i < 5; i++) {\n    outerPoints.push([R + R * Math.cos(Math.PI * (72 * i + angleOffset) / 180), R + R * Math.sin(Math.PI * (72 * i + angleOffset) / 180)]);\n  }\n  let interPoints = [];\n  for (let i = 0; i < 5; i++) {\n    interPoints.push([R + r * Math.cos(Math.PI * (72 * i + 36 + angleOffset) / 180), R + r * Math.sin(Math.PI * (72 * i + 36 + angleOffset) / 180)]);\n  }\n  let str = \"\";\n  for (let i = 0; i < 5; i++) {\n    if (i === 0) {\n      str += \"M\" + (outerPoints[i][0] - offset) + \" \" + (outerPoints[i][1] - offset) + \" \";\n      str += \"L\" + (interPoints[i][0] - offset) + \" \" + (interPoints[i][1] - offset) + \" \";\n    } else {\n      str += \"L\" + (outerPoints[i][0] - offset) + \" \" + (outerPoints[i][1] - offset) + \" \";\n      str += \"L\" + (interPoints[i][0] - offset) + \" \" + (interPoints[i][1] - offset) + \" \";\n    }\n  }\n  str += \"L\" + (outerPoints[0][0] - offset) + \" \" + (outerPoints[0][1] - offset) + \" \";\n  return str;\n};\n// 获取六边形形状Path\nlet shapeHexagon = function (R) {\n  let offset = R;\n  let edge = 2 * R * Math.sqrt(2) / (Math.sqrt(3) + 1);\n  let ox1 = (2 * R - edge) / 2,\n    ox2 = ox1 + edge;\n  let h = Math.sqrt(3) * edge;\n  let oy1 = (2 * R - h) / 2,\n    oy2 = 2 * R - oy1;\n  let str = \"M\" + (ox1 - offset) + \" \" + (oy1 - offset) + \" \";\n  str += \"L\" + (ox2 - offset) + \" \" + (oy1 - offset) + \" \";\n  str += \"L\" + (2 * R - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (ox2 - offset) + \" \" + (oy2 - offset) + \" \";\n  str += \"L\" + (ox1 - offset) + \" \" + (oy2 - offset) + \" \";\n  str += \"L\" + (0 - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (ox1 - offset) + \" \" + (oy1 - offset) + \" \";\n  return str;\n};\n// 获取钻石形状Path\nlet shapeJewel = function (R) {\n  let offset = R;\n  let edge = 2 * R * Math.sqrt(2) / (Math.sqrt(3) + 1);\n  let ox1 = (2 * R - edge) / 2,\n    ox2 = ox1 + edge;\n  let h = Math.sqrt(3) * edge;\n  let oy1 = (2 * R - h) / 2;\n  let str = \"M\" + (ox1 - offset) + \" \" + (oy1 - offset) + \" \";\n  str += \"L\" + (ox2 - offset) + \" \" + (oy1 - offset) + \" \";\n  str += \"L\" + (2 * R - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (R - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"L\" + (0 - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (ox1 - offset) + \" \" + (oy1 - offset) + \" \";\n  return str;\n};\n// 获取X型形状Path\nlet shapeX = function (R) {\n  let offset = R;\n  let ox1 = 0.2 * 2 * R,\n    ox2 = 2 * R - ox1;\n  let oy1 = 0.2 * 2 * R,\n    oy2 = 2 * R - oy1;\n  let oxc = 2 * R * 0.3,\n    oyc = 2 * R * 0.3;\n  let str = \"M\" + (ox1 - offset) + \" \" + (0 - offset) + \" \";\n  str += \"L\" + (R - offset) + \" \" + (oyc - offset) + \" \";\n  str += \"L\" + (ox2 - offset) + \" \" + (0 - offset) + \" \";\n  str += \"L\" + (2 * R - offset) + \" \" + (oy1 - offset) + \" \";\n  str += \"L\" + (2 * R - oxc - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (2 * R - offset) + \" \" + (oy2 - offset) + \" \";\n  str += \"L\" + (ox2 - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"L\" + (R - offset) + \" \" + (2 * R - oyc - offset) + \" \";\n  str += \"L\" + (ox1 - offset) + \" \" + (2 * R - offset) + \" \";\n  str += \"L\" + (0 - offset) + \" \" + (oy2 - offset) + \" \";\n  str += \"L\" + (oxc - offset) + \" \" + (R - offset) + \" \";\n  str += \"L\" + (0 - offset) + \" \" + (oy1 - offset) + \" \";\n  str += \"L\" + (ox1 - offset) + \" \" + (0 - offset) + \" \";\n  return str;\n};\n//绘制图例和时间框\nlet legendAndDate = {};\n/**\n * 绘制图例容器 与 时间大标签[即居于图形中间的当前事件标签]\n * 图例容器支持位置： 右侧，底部\n * 时间标签支持位置： 右上，左上，右下，左下，中间\n * */\nlegendAndDate.drawElements = function (option) {\n  let legendEles = option.legendEles; //图形中关联图例的dom元素s\n  let isEleStroke = option.isEleStroke; //绘制图形描边标志\n  let svg = option.svg;\n  let isLegendFlag = option.isLegendFlag;\n  let hideLegendFlag = option.hideLegendFlag; //隐藏图例\n  let legendPosition = option.legendPosition; //图例位置 增加上 左\n  let legendBar = option.legendBar;\n  let legendLineWidth = option.legendLineWidth;\n  let legends = option.legends;\n  let legendType = option.legendType;\n  let fontSizeFlag = option.fontSizeFlag;\n  let legendFontSize = option.legendFontSize;\n  let fontSize = option.fontSize;\n  let labelColor = option.labelColor; //标签颜色\n  let legendFontColor = option.legendFontColor; //图例字体颜色\n  let curLegendDoms = option.curLegendDoms; //图例元素s\n  let nodeBorderColor = option.nodeBorderColor; //图形描边颜色\n  let nodeShape = option.nodeShape; //图形形状\n  let legendShape = option.legendShape; //图例形状\n  let fixedLegendIdx = option.fixedLegendIdx; //固定住的图例序号\n  let callBackAmendFixeDLegendIdx = option.callBackAmendFixeDLegendIdx;\n  let localColor = option.localColor; //主题颜色数组\n  let mouseoutTimer = option.mouseoutTimer; //鼠标防抖定时器引用\n  let legendTexts = option.legendTexts; //数据标签s\n  let labelTextFontSizeFlag = option.labelTextFontSizeFlag; //标签字体大小标志\n  let curLabelTextFontSize = option.curLabelTextFontSize; //标签字体大小\n  let labelTextFontColorFlag = option.labelTextFontColorFlag; //标签字体颜色标志\n  let curLabelTextFontColor = option.curLabelTextFontColor; //标签字体颜色\n  let drawWidth = option.drawWidth;\n  let drawHeight = option.drawHeight;\n  let legendLineHeight = option.legendLineHeight;\n  let nodeShapeArray = option.nodeShapeArray; //多形状情况，每个图例的形状\n\n  let isTimeLegendFlag = option.isTimeLegendFlag;\n  let hidetimeLabelFlag = option.hidetimeLabelFlag; //隐藏时间轴标签\n  let timeLabelPosition = option.timeLabelPosition; //时间轴标签位置\n  let timeLabels = option.timeLabels;\n  let timeStampIdx = option.timeStampIdx; //时间戳\n  let timeLabelFontSize = option.timeLabelFontSize; //时间轴标签字体大小\n  let leftOffset = option.leftOffset;\n  let rightOffset = option.rightOffset;\n  let topOffset = option.topOffset;\n  let timeLabelFormat = option.timeLabelFormat || \"default\"; //时间轴标签时间格式\n\n  // debugger\n\n  //绘制底部图例\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"bottom\") {\n    legendBar.empty();\n    let htmlStr = '<div style=\"height: 20px;width: ' + (legendLineWidth - 101) + 'px;display: flex;justify-content: center;\"></div>';\n    let legendContainer = $(htmlStr);\n    legendBar.append(legendContainer);\n    htmlStr = '<div style=\"margin-top: -6px;margin-left: 30px;\">';\n    htmlStr += '<span class=\"left-legend-control\">◀</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"legend-control-page\">1/2</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"right-legend-control\">▶</span>';\n    htmlStr += '</div>';\n    let legendControl = $(htmlStr);\n    legendBar.append(legendControl);\n    let minInterval = 35;\n    //legend分页\n    let legendDistinct = [];\n    //当前页累计长度\n    let curLegendEntireLength = 0;\n    //定位页数\n    let legendDistinctLocate = -1;\n    //载入图例信息\n    let computeStringLength = function (str) {\n      let tempLength = 0;\n      if (!str) return tempLength;\n      for (let i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) > 127 || str.charCodeAt(i) == 94) {\n          tempLength += 2;\n        } else {\n          tempLength += 1;\n        }\n      }\n      return tempLength;\n    };\n    legends.forEach(function (ld, index) {\n      let curLegendName;\n      if (legendType === \"legend\") {\n        curLegendName = ld;\n      } else {\n        curLegendName = ld.name;\n      }\n      if (curLegendEntireLength === 0) {\n        legendDistinctLocate++;\n        legendDistinct[legendDistinctLocate] = [];\n        legendDistinct[legendDistinctLocate].push({\n          d: curLegendName,\n          index: index\n        });\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          curLegendEntireLength = 0;\n        }\n      } else {\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2 + minInterval;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          legendDistinctLocate++;\n          legendDistinct[legendDistinctLocate] = [];\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n          curLegendEntireLength = 0;\n          curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n          if (curLegendEntireLength >= legendLineWidth - 101) {\n            curLegendEntireLength = 0;\n          }\n        } else {\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n        }\n      }\n    });\n    //图例字体大小有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontSizeFlag = false;\n    let curLegendFontSize;\n    if (fontSizeFlag) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = fontSize;\n    }\n    if (legendFontSize) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = legendFontSize;\n    }\n    //图例字体颜色有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontColorFlag = false;\n    let curLegendFontColor;\n    if (labelColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = labelColor;\n    }\n    if (legendFontColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = legendFontColor;\n    }\n\n    //更新图例页\n    let updateLegendPage = function (page) {\n      legendContainer.empty();\n      curLegendDoms = [];\n      legendDistinct[page].forEach(function (ld, tempIndex) {\n        let name = ld.d,\n          index = ld.index;\n        //处理图例形状\n        if (nodeShape === \"repeat\") {\n          legendShape = nodeShapeArray[index % nodeShapeArray.length];\n        } else {\n          legendShape = nodeShape;\n        }\n        let curColor;\n        if (fixedLegendIdx === -1) {\n          curColor = localColor[index % localColor.length];\n        } else {\n          if (fixedLegendIdx === tempIndex) {\n            curColor = localColor[index % localColor.length];\n          } else {\n            curColor = \"rgba(198,200,200,0.3)\";\n          }\n        }\n        htmlStr = '<div style=\"display: flex;align-items: center;' + (tempIndex === 0 ? '' : 'margin-left:' + (minInterval - 4) + 'px;') + '\">';\n        htmlStr += '<div class=\"legend-square\" style=\"height: 15px;width: 12px;\">' + '<svg style=\"width: 12px; height: 12px\">';\n        switch (legendShape) {\n          case \"circle\":\n            htmlStr += '<circle class=\"legend-svg-icon\" r=\"6\" cx=\"6\" cy=\"6\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"rect\":\n            htmlStr += '<rect class=\"legend-svg-icon\" width=\"12\" height=\"12\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"triangle\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeTriangle(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"diamond\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeDiamond(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"star\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"fivestar\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeFiveStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"hexagon\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeHexagon(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"jewel\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeJewel(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"x\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeX(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n        }\n        htmlStr += '</svg></div>';\n        htmlStr += '<div class=\"legend-text\" style=\"margin-left: 5px;' + (legendFontSizeFlag ? 'font-size:' + curLegendFontSize + 'px;' : '') + (legendFontColorFlag ? 'color:' + curLegendFontColor + ';' : '') + '\">' + name + '</div>';\n        htmlStr += '</div>';\n        let curLegend = $(htmlStr);\n        curLegendDoms.push(curLegend);\n        legendContainer.append(curLegend);\n        //点击事件，固定突出的图例\n        curLegend.unbind(\"click\");\n        curLegend.bind(\"click\", function () {\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          if (fixedLegendIdx === -1) {\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n          } else if (fixedLegendIdx !== tempIndex) {\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n            if (mouseoutTimer) clearTimeout(mouseoutTimer);\n            //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n            curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[tempIndex % localColor.length]);\n            curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            curLegendDoms.forEach(function (cld, idx) {\n              if (idx !== tempIndex) {\n                let geryColor = \"rgba(198,200,200,0.3)\";\n                let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[idx % localColor.length], true), 0.4);\n                //cld.find(\".legend-square\").css(\"background-color\",transparentColor);\n                cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n                cld.find(\".legend-text\").css(\"color\", geryColor);\n              }\n            });\n            let geryColor = \"rgba(198,200,200,0.3)\";\n            legendEles.forEach(function (lcs, idx) {\n              if (idx !== tempIndex) {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  lc.attr(\"fill\", geryColor);\n                  if (isEleStroke) lc.attr(\"stroke\", geryColor);\n                });\n              } else {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  lc.attr(\"fill\", localColor[idx % localColor.length]);\n                  if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.7));\n                });\n              }\n            });\n            legendTexts.forEach(function (lts, idx) {\n              if (idx !== tempIndex) {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return \"rgba(198,200,200,0.3)\";\n                  });\n                });\n              } else {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                  });\n                });\n              }\n            });\n          } else {\n            callBackAmendFixeDLegendIdx(-1);\n            fixedLegendIdx = -1;\n          }\n        });\n        //悬浮事件，突出图例\n        curLegend.unbind(\"mouseover\");\n        curLegend.bind(\"mouseover\", function () {\n          if (fixedLegendIdx > -1) return;\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[tempIndex % localColor.length]);\n          curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n          curLegendDoms.forEach(function (cld, idx) {\n            if (idx !== tempIndex) {\n              let geryColor = \"rgba(198,200,200,0.3)\";\n              cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n              cld.find(\".legend-text\").css(\"color\", geryColor);\n            }\n          });\n          let geryColor = \"rgba(198,200,200,0.3)\";\n          legendEles.forEach(function (lcs, idx) {\n            if (idx !== tempIndex) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                lc.attr(\"fill\", geryColor);\n                if (isEleStroke) lc.attr(\"stroke\", geryColor);\n              });\n            } else {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                lc.attr(\"fill\", localColor[idx % localColor.length]);\n                if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.7));\n              });\n            }\n          });\n          legendTexts.forEach(function (lts, idx) {\n            if (idx !== tempIndex) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return \"rgba(198,200,200,0.3)\";\n                });\n              });\n            } else {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            }\n          });\n        });\n        //鼠标移出事件，取消突出图例\n        curLegend.unbind(\"mouseout\");\n        curLegend.bind(\"mouseout\", function () {\n          if (fixedLegendIdx > -1) return;\n          mouseoutTimer = setTimeout(function () {\n            curLegendDoms.forEach(function (cld, idx) {\n              //cld.find(\".legend-square\").css(\"background-color\",localColor[idx]);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", localColor[idx % localColor.length]);\n              cld.find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            });\n            legendEles.forEach(function (lcs, idx) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                lc.attr(\"fill\", localColor[idx % localColor.length]);\n                if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.7));\n              });\n            });\n            legendTexts.forEach(function (lts) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            });\n          }, 200);\n        });\n      });\n      if (page < legendDistinct.length - 1) {\n        legendContainer.append($(\"<span style='margin-top: -3px'>...</span>\"));\n      }\n    };\n    let currentPage = 0;\n    updateLegendPage(currentPage);\n    //当有多段图例时,图例切换事件\n    legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n    if (legendDistinct.length > 1) {\n      legendControl.find(\".left-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".left-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage > 0) {\n          currentPage--;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n      legendControl.find(\".right-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".right-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage < legendDistinct.length - 1) {\n          currentPage++;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n    } else {\n      legendControl.css(\"display\", \"none\");\n      legendBar.css(\"left\", parseInt((drawWidth - legendLineWidth) / 2 + 50) + \"px\");\n    }\n  }\n\n  //绘制右部图例\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"right\") {\n    //图例字体大小有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontSizeFlag = false;\n    let curLegendFontSize = 14;\n    if (fontSizeFlag) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = fontSize;\n    }\n    if (legendFontSize) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = legendFontSize;\n    }\n    //图例字体颜色有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontColorFlag = false;\n    let curLegendFontColor;\n    if (labelColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = labelColor;\n    }\n    if (legendFontColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = legendFontColor;\n    }\n    legendBar.empty();\n    let htmlStr = '<div style=\"display: flex;flex-direction:column;justify-content: center;\"></div>';\n    let legendContainer = $(htmlStr);\n    legendBar.append(legendContainer);\n    htmlStr = '<div style=\"margin-top: 6px;\">';\n    htmlStr += '<span class=\"left-legend-control\">◀</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"legend-control-page\">1/2</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"right-legend-control\">▶</span>';\n    htmlStr += '</div>';\n    let legendControl = $(htmlStr);\n    legendBar.append(legendControl);\n    let minInterval = 35;\n    //legend分页\n    let legendDistinct = [];\n    //当前页累计长度\n    let curLegendEntireLength = 0;\n    //定位页数\n    let legendDistinctLocate = -1;\n    legends.forEach(function (ld, index) {\n      let curLegendName;\n      if (legendType === \"legend\") {\n        curLegendName = ld;\n      } else {\n        curLegendName = ld.name;\n      }\n      if (curLegendEntireLength === 0) {\n        legendDistinctLocate++;\n        legendDistinct[legendDistinctLocate] = [];\n        legendDistinct[legendDistinctLocate].push({\n          d: curLegendName,\n          index: index\n        });\n        curLegendEntireLength += Math.max(minInterval, curLegendFontSize * 1 + 10);\n        if (curLegendEntireLength >= legendLineHeight - 40) {\n          curLegendEntireLength = 0;\n        }\n      } else {\n        curLegendEntireLength += Math.max(minInterval, curLegendFontSize * 1 + 10);\n        if (curLegendEntireLength >= legendLineHeight - 40) {\n          legendDistinctLocate++;\n          legendDistinct[legendDistinctLocate] = [];\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n          curLegendEntireLength = 0;\n          curLegendEntireLength += Math.max(minInterval, curLegendFontSize * 1 + 10);\n          if (curLegendEntireLength >= legendLineHeight - 40) {\n            curLegendEntireLength = 0;\n          }\n        } else {\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n        }\n      }\n    });\n\n    //更新图例页\n    let updateLegendPage = function (page) {\n      legendContainer.empty();\n      curLegendDoms = [];\n      legendDistinct[page].forEach(function (ld, tempIndex) {\n        let name = ld.d,\n          index = ld.index;\n        //处理图例形状\n        if (nodeShape === \"repeat\") {\n          legendShape = nodeShapeArray[index % nodeShapeArray.length];\n        } else {\n          legendShape = nodeShape;\n        }\n        let curColor;\n        if (fixedLegendIdx === -1) {\n          curColor = localColor[index % localColor.length];\n        } else {\n          if (fixedLegendIdx === tempIndex) {\n            curColor = localColor[index % localColor.length];\n          } else {\n            curColor = \"rgba(198,200,200,0.3)\";\n          }\n        }\n        htmlStr = '<div style=\"display: flex;align-items:center;margin-top: 10px\">';\n        htmlStr += '<div class=\"legend-square\" style=\"height: 15px;width: 12px;\">' + '<svg style=\"width: 12px; height: 12px\">';\n        switch (legendShape) {\n          case \"circle\":\n            htmlStr += '<circle class=\"legend-svg-icon\" r=\"6\" cx=\"6\" cy=\"6\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"rect\":\n            htmlStr += '<rect class=\"legend-svg-icon\" width=\"12\" height=\"12\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"triangle\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeTriangle(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"diamond\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeDiamond(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"star\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"fivestar\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeFiveStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"hexagon\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeHexagon(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"jewel\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeJewel(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"x\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeX(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n        }\n        htmlStr += '</svg></div>';\n        htmlStr += '<div class=\"legend-text\" style=\"margin-left: 5px;' + (legendFontSizeFlag ? 'font-size:' + curLegendFontSize + 'px;' : '') + (legendFontColorFlag ? 'color:' + curLegendFontColor + ';' : '') + '\">' + name + '</div>';\n        htmlStr += '</div>';\n        let curLegend = $(htmlStr);\n        curLegendDoms.push(curLegend);\n        legendContainer.append(curLegend);\n        //点击事件，固定突出的图例\n        curLegend.unbind(\"click\");\n        curLegend.bind(\"click\", function () {\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          if (fixedLegendIdx === -1) {\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n          } else if (fixedLegendIdx !== tempIndex) {\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n            if (mouseoutTimer) clearTimeout(mouseoutTimer);\n            //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n            curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[tempIndex % localColor.length]);\n            curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            curLegendDoms.forEach(function (cld, idx) {\n              if (idx !== tempIndex) {\n                let geryColor = \"rgba(198,200,200,0.3)\";\n                let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[idx % localColor.length], true), 0.4);\n                //cld.find(\".legend-square\").css(\"background-color\",transparentColor);\n                cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n                cld.find(\".legend-text\").css(\"color\", geryColor);\n              }\n            });\n            let geryColor = \"rgba(198,200,200,0.3)\";\n            legendEles.forEach(function (lcs, idx) {\n              if (idx !== tempIndex) {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  lc.attr(\"fill\", geryColor);\n                  if (isEleStroke) lc.attr(\"stroke\", geryColor);\n                });\n              } else {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  lc.attr(\"fill\", localColor[idx % localColor.length]);\n                  if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.7));\n                });\n              }\n            });\n            legendTexts.forEach(function (lts, idx) {\n              if (idx !== tempIndex) {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return \"rgba(198,200,200,0.3)\";\n                  });\n                });\n              } else {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                  });\n                });\n              }\n            });\n          } else {\n            callBackAmendFixeDLegendIdx(-1);\n            fixedLegendIdx = -1;\n          }\n        });\n        //悬浮事件，突出图例\n        curLegend.unbind(\"mouseover\");\n        curLegend.bind(\"mouseover\", function () {\n          if (fixedLegendIdx > -1) return;\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[tempIndex % localColor.length]);\n          curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n          curLegendDoms.forEach(function (cld, idx) {\n            if (idx !== tempIndex) {\n              let geryColor = \"rgba(198,200,200,0.3)\";\n              let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[idx % localColor.length], true), 0.4);\n              //cld.find(\".legend-square\").css(\"background-color\",transparentColor);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n              cld.find(\".legend-text\").css(\"color\", geryColor);\n            }\n          });\n          let geryColor = \"rgba(198,200,200,0.3)\";\n          legendEles.forEach(function (lcs, idx) {\n            if (idx !== tempIndex) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                lc.attr(\"fill\", geryColor);\n                if (isEleStroke) lc.attr(\"stroke\", geryColor);\n              });\n            } else {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                lc.attr(\"fill\", localColor[idx % localColor.length]);\n                if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.7));\n              });\n            }\n          });\n          legendTexts.forEach(function (lts, idx) {\n            if (idx !== tempIndex) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return \"rgba(198,200,200,0.3)\";\n                });\n              });\n            } else {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            }\n          });\n        });\n        //鼠标移出事件，取消突出图例\n        curLegend.unbind(\"mouseout\");\n        curLegend.bind(\"mouseout\", function () {\n          if (fixedLegendIdx > -1) return;\n          mouseoutTimer = setTimeout(function () {\n            curLegendDoms.forEach(function (cld, idx) {\n              //cld.find(\".legend-square\").css(\"background-color\",localColor[idx]);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", localColor[idx % localColor.length]);\n              cld.find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            });\n            legendEles.forEach(function (lcs, idx) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                lc.attr(\"fill\", localColor[idx % localColor.length]);\n                if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.7));\n              });\n            });\n            legendTexts.forEach(function (lts) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            });\n          }, 200);\n        });\n      });\n      if (page < legendDistinct.length - 1) {\n        legendContainer.append($(\"<span style='margin-top: -3px'>...</span>\"));\n      }\n    };\n    let currentPage = 0;\n    updateLegendPage(currentPage);\n    //当有多段图例时,图例切换事件\n    legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n    if (legendDistinct.length > 1) {\n      legendControl.find(\".left-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".left-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage > 0) {\n          currentPage--;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n      legendControl.find(\".right-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".right-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage < legendDistinct.length - 1) {\n          currentPage++;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n    } else {\n      legendControl.css(\"display\", \"none\");\n      //legendBar.css(\"left\",parseInt((drawWidth-(legendLineWidth))/2+50)+\"px\");\n    }\n  }\n\n  //绘制单帧时间的date框\n  if (isTimeLegendFlag && !hidetimeLabelFlag) {\n    if (timeLabelPosition === \"topRight\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      svg.append(\"text\").text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"end\").attr(\"stroke\", \"rgba(210,210,210,0.7)\").attr(\"style\", \"fill:rgba(210,210,210,0.7);font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (drawWidth - 60 - rightOffset) + \",\" + (topOffset + 2 * fontSize) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"topLeft\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      svg.append(\"text\").text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"start\").attr(\"stroke\", \"rgba(210,210,210,0.7)\").attr(\"style\", \"fill:rgba(210,210,210,0.7);font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (leftOffset + 60) + \",\" + (topOffset + 2 * fontSize) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"bottomRight\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      svg.append(\"text\").text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"end\").attr(\"stroke\", \"rgba(210,210,210,0.7)\").attr(\"style\", \"fill:rgba(210,210,210,0.7);font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (drawWidth - 60 - rightOffset) + \",\" + (drawHeight - 20) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"bottomLeft\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      svg.append(\"text\").text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"start\").attr(\"stroke\", \"rgba(210,210,210,0.7)\").attr(\"style\", \"fill:rgba(210,210,210,0.7);font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (leftOffset + 60) + \",\" + (drawHeight - 20) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"center\") {\n      let showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      if (timeLabelFormat === \"ymd\") {\n        showText = timeLabels[timeStampIdx];\n      }\n      svg.append(\"text\").text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"middle\").attr(\"stroke\", \"rgba(210,210,210,0.7)\").attr(\"style\", \"fill:rgba(210,210,210,0.7);font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (leftOffset + (drawWidth - rightOffset - leftOffset) / 2) + \",\" + (topOffset + drawHeight - 20) / 2 + \")\";\n      });\n    }\n  }\n};\n//绘制图例\nlet legend = {};\nlegend.drawElement = function (option) {\n  let legendEles = option.legendEles;\n  let isEleStroke = option.isEleStroke;\n  let isLegendFlag = option.isLegendFlag;\n  let hideLegendFlag = option.hideLegendFlag;\n  let legendPosition = option.legendPosition;\n  let legendBar = option.legendBar;\n  let legendLineWidth = option.legendLineWidth;\n  let legends = option.legends;\n  let legendType = option.legendType;\n  let fontSizeFlag = option.fontSizeFlag;\n  let legendFontSize = option.legendFontSize;\n  let fontSize = option.fontSize;\n  let labelColor = option.labelColor;\n  let legendFontColor = option.legendFontColor;\n  let curLegendDoms = option.curLegendDoms;\n  let nodeShape = option.nodeShape;\n  let nodeBorderColor = option.nodeBorderColor;\n  let legendShape = option.legendShape;\n  let fixedLegendIdx = option.fixedLegendIdx;\n  let callBackAmendFixeDLegendIdx = option.callBackAmendFixeDLegendIdx;\n  let localColor = option.localColor;\n  let mouseoutTimer = option.mouseoutTimer;\n  let legendTexts = option.legendTexts;\n  let labelTextFontSizeFlag = option.labelTextFontSizeFlag;\n  let curLabelTextFontSize = option.curLabelTextFontSize;\n  let labelTextFontColorFlag = option.labelTextFontColorFlag;\n  let curLabelTextFontColor = option.curLabelTextFontColor;\n  let drawWidth = option.drawWidth;\n  let legendLineHeight = option.legendLineHeight;\n  let nodeShapeArray = option.nodeShapeArray;\n  let elementTransparent = option.elementTransparent || 1;\n  let nodeBodyColor = option.nodeBodyColor;\n  let linkColor = option.linkColor;\n  const isColorSetExtended = !!option.isColorSetExtended;\n  const changeActiveLegend = option.changeActiveLegend;\n\n  // 在底部图例的容器中 - 绘制图例\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"bottom\") {\n    legendBar.empty();\n    // debugger;\n\n    let htmlStr = '<div style=\"height: 20px;width: ' + (legendLineWidth - 101) + 'px;display: flex;justify-content: center;\"></div>';\n    let legendContainer = $(htmlStr);\n    legendBar.append(legendContainer);\n    htmlStr = '<div style=\"margin-top: -6px;margin-left: 30px;\">';\n    htmlStr += '<span class=\"left-legend-control\">◀</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"legend-control-page\">1/2</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"right-legend-control\">▶</span>';\n    htmlStr += '</div>';\n    let legendControl = $(htmlStr);\n    legendBar.append(legendControl);\n    let minInterval = 35;\n    //legend分页\n    let legendDistinct = [];\n    //当前页累计长度\n    let curLegendEntireLength = 0;\n    //定位页数\n    let legendDistinctLocate = -1;\n    //载入图例信息\n    let computeStringLength = function (str) {\n      let tempLength = 0;\n      if (!str) return tempLength;\n      for (let i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) > 127 || str.charCodeAt(i) == 94) {\n          tempLength += 2;\n        } else {\n          tempLength += 1;\n        }\n      }\n      return tempLength;\n    };\n    legends.forEach(function (ld, index) {\n      let curLegendName;\n      if (legendType === \"legend\") {\n        curLegendName = ld;\n      } else {\n        curLegendName = ld.name;\n      }\n      // 分页为什么这样写\n      if (curLegendEntireLength === 0) {\n        legendDistinctLocate++;\n        legendDistinct[legendDistinctLocate] = [];\n        legendDistinct[legendDistinctLocate].push({\n          d: curLegendName,\n          index: index\n        });\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          curLegendEntireLength = 0;\n        }\n      } else {\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2 + minInterval;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          legendDistinctLocate++;\n          legendDistinct[legendDistinctLocate] = [];\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n          curLegendEntireLength = 0;\n          curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n          if (curLegendEntireLength >= legendLineWidth - 101) {\n            curLegendEntireLength = 0;\n          }\n        } else {\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n        }\n      }\n    });\n    //图例字体大小有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontSizeFlag = false;\n    let curLegendFontSize;\n    if (fontSizeFlag) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = fontSize;\n    }\n    if (legendFontSize) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = legendFontSize;\n    }\n    //图例字体颜色有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontColorFlag = false;\n    let curLegendFontColor;\n    if (labelColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = labelColor;\n    }\n    if (legendFontColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = legendFontColor;\n    }\n\n    //更新图例页\n    let updateLegendPage = function (page) {\n      legendContainer.empty();\n      curLegendDoms = [];\n      // 当前页的所有图例\n      legendDistinct[page].forEach(function (ld, tempIndex) {\n        let name = ld.d,\n          index = ld.index;\n        //处理图例形状\n        if (nodeShape === \"repeat\") {\n          legendShape = nodeShapeArray[index % nodeShapeArray.length];\n        } else {\n          legendShape = nodeShape;\n        }\n        let curColor;\n        if (fixedLegendIdx === -1) {\n          curColor = localColor[index % localColor.length];\n        } else {\n          if (fixedLegendIdx === tempIndex) {\n            curColor = localColor[index % localColor.length];\n          } else {\n            curColor = \"rgba(198,200,200,0.3)\";\n          }\n        }\n        htmlStr = '<div style=\"display: flex;align-items: center;' + (tempIndex === 0 ? '' : 'margin-left:' + (minInterval - 4) + 'px;') + '\">';\n        htmlStr += '<div class=\"legend-square\" style=\"height: 15px;width: 12px;\">' + '<svg style=\"width: 12px; height: 12px\">';\n        switch (legendShape) {\n          case \"circle\":\n            htmlStr += '<circle class=\"legend-svg-icon\" r=\"6\" cx=\"6\" cy=\"6\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"rect\":\n            htmlStr += '<rect class=\"legend-svg-icon\" width=\"12\" height=\"12\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"triangle\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeTriangle(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"diamond\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeDiamond(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"star\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"fivestar\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeFiveStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"hexagon\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeHexagon(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"jewel\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeJewel(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"x\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeX(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n        }\n        htmlStr += '</svg></div>';\n        htmlStr += '<div class=\"legend-text\" style=\"margin-left: 5px;' + (legendFontSizeFlag ? 'font-size:' + curLegendFontSize + 'px;' : '') + (legendFontColorFlag ? 'color:' + curLegendFontColor + ';' : '') + '\">' + name + '</div>';\n        htmlStr += '</div>';\n        let curLegend = $(htmlStr);\n        curLegendDoms.push(curLegend);\n        legendContainer.append(curLegend);\n\n        // curLegendDoms 是当前页的图例元素数组\n        // BUG: tempIndex 是当前图例在当前页的索引，导致每一页图例所应用的颜色组都相同\n        // 计算得到图例在所有图例中的索引\n        const beforeCurPageCount = legendDistinct.slice(0, page).reduce((sumCount, curPage) => sumCount + curPage.length, 0);\n        const curLegendIndex = tempIndex + beforeCurPageCount;\n\n        //点击事件，固定突出的图例\n        curLegend.unbind(\"click\");\n        curLegend.bind(\"click\", function () {\n          // 防止外界节点悬浮时，各节点恢复初始颜色\n          const chartContainer = document.querySelector('.chart-container');\n          if (chartContainer) {\n            if (chartContainer.hasAttribute('data-lock-legend')) {\n              chartContainer.removeAttribute('data-lock-legend');\n            } else {\n              chartContainer.setAttribute('data-lock-legend', 'true');\n            }\n          }\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          if (fixedLegendIdx === -1) {\n            // 点击固定图例\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n          } else if (fixedLegendIdx !== tempIndex) {\n            // 切换固定的图例\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n            if (mouseoutTimer) clearTimeout(mouseoutTimer);\n\n            // 固定当前图例的颜色\n            curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[(isColorSetExtended ? curLegendIndex : tempIndex) % localColor.length]);\n            curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            // 当前页的其他图例置灰\n            curLegendDoms.forEach(function (cld, idx) {\n              if (idx !== tempIndex) {\n                const geryColor = \"rgba(198,200,200,0.3)\";\n                cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n                cld.find(\".legend-text\").css(\"color\", geryColor);\n              }\n            });\n            const geryColor = \"rgba(198,200,200,0.3)\";\n            legendEles.forEach(function (lcs, idx) {\n              // tempIndex 是图例在当前页的索引\n              if (idx !== (isColorSetExtended ? curLegendIndex : tempIndex) && lcs.legendIdx !== (isColorSetExtended ? curLegendIndex : tempIndex)) {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  if (lc.distinctType === \"link\") {\n                    lc.attr(\"stroke\", geryColor);\n                  } else {\n                    lc.attr(\"fill\", geryColor);\n                    if (isEleStroke) lc.attr(\"stroke\", geryColor);\n                  }\n                });\n              } else {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  if (lc.distinctType === \"link\") {\n                    lc.attr(\"stroke\", linkColor ? linkColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                  } else {\n                    lc.attr(\"fill\", nodeBodyColor ? nodeBodyColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                    if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.9));\n                  }\n                });\n              }\n            });\n            legendTexts.forEach(function (lts, idx) {\n              if (idx !== tempIndex && lts.legendIdx !== tempIndex) {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return \"rgba(198,200,200,0.3)\";\n                  });\n                });\n              } else {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                  });\n                });\n              }\n            });\n          } else {\n            // 取消固定图例\n            callBackAmendFixeDLegendIdx(-1);\n            fixedLegendIdx = -1;\n          }\n          typeof changeActiveLegend === 'function' && changeActiveLegend(fixedLegendIdx === -1 ? '' : curLegend[0].textContent);\n        });\n        //悬浮事件，突出图例\n        curLegend.unbind(\"mouseover\");\n        curLegend.bind(\"mouseover\", function () {\n          if (fixedLegendIdx > -1) return;\n          typeof changeActiveLegend === 'function' && changeActiveLegend(curLegend[0].textContent);\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[(isColorSetExtended ? curLegendIndex : tempIndex) % localColor.length]);\n          curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n          curLegendDoms.forEach(function (cld, idx) {\n            if (idx !== tempIndex) {\n              const geryColor = \"rgba(198,200,200,0.3)\";\n              cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n              cld.find(\".legend-text\").css(\"color\", geryColor);\n            }\n          });\n          let geryColor = \"rgba(198,200,200,0.3)\";\n\n          // legendEles 不是当前页的图例元素数组，而是所有图例元素的二维数组\n          legendEles.forEach(function (lcs, idx) {\n            // lcs 是某一类图例所包含的所有元素的数组\n            if (idx !== (isColorSetExtended ? curLegendIndex : tempIndex) && lcs.legendIdx !== (isColorSetExtended ? curLegendIndex : tempIndex)) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                if (lc.distinctType === \"link\") {\n                  lc.attr(\"stroke\", geryColor);\n                } else {\n                  lc.attr(\"fill\", geryColor);\n                  if (isEleStroke) lc.attr(\"stroke\", geryColor);\n                }\n              });\n            } else {\n              // 是当前图例的元素\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                if (lc.distinctType === \"link\") {\n                  lc.attr(\"stroke\", linkColor ? linkColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                } else {\n                  lc.attr(\"fill\", nodeBodyColor ? nodeBodyColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                  if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.9));\n                }\n              });\n            }\n          });\n          legendTexts.forEach(function (lts, idx) {\n            if (idx !== (isColorSetExtended ? curLegendIndex : tempIndex) && lts.legendIdx !== (isColorSetExtended ? curLegendIndex : tempIndex)) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.style(\"fill\", function () {\n                  return \"rgba(198,200,200,0.3)\";\n                });\n                lt.attr(\"fill\", function () {\n                  return \"rgba(198,200,200,0.3)\";\n                });\n              });\n            } else {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.style(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            }\n          });\n        });\n        curLegend.unbind(\"mouseout\");\n        function indexInAllPages(idx) {\n          const beforeCurPageCount = legendDistinct.slice(0, page).reduce((sumCount, curPage) => sumCount + curPage.length, 0);\n          return beforeCurPageCount + idx;\n        }\n\n        // 鼠标移出事件，取消突出图例\n        curLegend.bind(\"mouseout\", function () {\n          if (fixedLegendIdx > -1) return;\n          typeof changeActiveLegend === 'function' && changeActiveLegend();\n          mouseoutTimer = setTimeout(function () {\n            curLegendDoms.forEach(function (cld, idx) {\n              cld.find(\".legend-svg-icon\").attr(\"fill\", localColor[(isColorSetExtended ? indexInAllPages(idx) : idx) % localColor.length]);\n              cld.find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            });\n\n            // 更新画布中当前图例下的所有元素的样式\n            legendEles.forEach(function (lcs, idx) {\n              lcs.forEach(function (lc) {\n                if (!lc) {\n                  return;\n                }\n                if (lc.distinctType === \"link\") {\n                  lc.attr(\"stroke\", linkColor ? linkColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                } else {\n                  lc.attr(\"fill\", nodeBodyColor ? nodeBodyColor : _DataFocusMethod.hex2Rgba(localColor[(isColorSetExtended ? indexInAllPages(idx) : idx) % localColor.length], elementTransparent));\n                  if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[(isColorSetExtended ? indexInAllPages(idx) : idx) % localColor.length], 0.9));\n                }\n              });\n            });\n            legendTexts.forEach(function (lts) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.style(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            });\n          }, 200);\n        });\n      });\n      if (page < legendDistinct.length - 1) {\n        legendContainer.append($(\"<span style='margin-top: -3px'>...</span>\"));\n      }\n    };\n    let currentPage = 0;\n    updateLegendPage(currentPage);\n    //当有多段图例时,图例切换事件\n    legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n    if (legendDistinct.length > 1) {\n      legendControl.find(\".left-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".left-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage > 0) {\n          currentPage--;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n      legendControl.find(\".right-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".right-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage < legendDistinct.length - 1) {\n          currentPage++;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n    } else {\n      legendControl.css(\"display\", \"none\");\n      legendBar.css(\"left\", parseInt((drawWidth - legendLineWidth) / 2 + 50) + \"px\");\n    }\n  }\n\n  //绘制右部图例\n  if (isLegendFlag && !hideLegendFlag && legendPosition === \"right\") {\n    //图例字体大小有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontSizeFlag = false;\n    let curLegendFontSize = 14;\n    if (fontSizeFlag) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = fontSize;\n    }\n    if (legendFontSize) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = legendFontSize;\n    }\n    //图例字体颜色有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontColorFlag = false;\n    let curLegendFontColor;\n    if (labelColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = labelColor;\n    }\n    if (legendFontColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = legendFontColor;\n    }\n    legendBar.empty();\n    let htmlStr = '<div style=\"display: flex;flex-direction:column;justify-content: center;\"></div>';\n    let legendContainer = $(htmlStr);\n    legendBar.append(legendContainer);\n    htmlStr = '<div style=\"margin-top: 6px;\">';\n    htmlStr += '<span class=\"left-legend-control\">◀</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"legend-control-page\">1/2</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"right-legend-control\">▶</span>';\n    htmlStr += '</div>';\n    let legendControl = $(htmlStr);\n    legendBar.append(legendControl);\n    let minInterval = 35;\n    //legend分页\n    let legendDistinct = [];\n    //当前页累计长度\n    let curLegendEntireLength = 0;\n    //定位页数\n    let legendDistinctLocate = -1;\n    legends.forEach(function (ld, index) {\n      let curLegendName;\n      if (legendType === \"legend\") {\n        curLegendName = ld;\n      } else {\n        curLegendName = ld.name;\n      }\n      if (curLegendEntireLength === 0) {\n        legendDistinctLocate++;\n        legendDistinct[legendDistinctLocate] = [];\n        legendDistinct[legendDistinctLocate].push({\n          d: curLegendName,\n          index: index\n        });\n        curLegendEntireLength += Math.max(minInterval, curLegendFontSize * 1 + 10);\n        if (curLegendEntireLength >= legendLineHeight - 40) {\n          curLegendEntireLength = 0;\n        }\n      } else {\n        curLegendEntireLength += Math.max(minInterval, curLegendFontSize * 1 + 10);\n        if (curLegendEntireLength >= legendLineHeight - 40) {\n          legendDistinctLocate++;\n          legendDistinct[legendDistinctLocate] = [];\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n          curLegendEntireLength = 0;\n          curLegendEntireLength += Math.max(minInterval, curLegendFontSize * 1 + 10);\n          if (curLegendEntireLength >= legendLineHeight - 40) {\n            curLegendEntireLength = 0;\n          }\n        } else {\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n        }\n      }\n    });\n\n    //更新图例页\n    let updateLegendPage = function (page) {\n      legendContainer.empty();\n      curLegendDoms = [];\n      legendDistinct[page].forEach(function (ld, tempIndex) {\n        let name = ld.d,\n          index = ld.index;\n        //处理图例形状\n        if (nodeShape === \"repeat\") {\n          legendShape = nodeShapeArray[index % nodeShapeArray.length];\n        } else {\n          legendShape = nodeShape;\n        }\n        let curColor;\n        if (fixedLegendIdx === -1) {\n          curColor = localColor[index % localColor.length];\n        } else {\n          if (fixedLegendIdx === tempIndex) {\n            curColor = localColor[index % localColor.length];\n          } else {\n            curColor = \"rgba(198,200,200,0.3)\";\n          }\n        }\n        htmlStr = '<div style=\"display: flex;align-items:center;margin-top: 10px\">';\n        htmlStr += '<div class=\"legend-square\" style=\"height: 15px;width: 12px;\">' + '<svg style=\"width: 12px; height: 12px\">';\n        switch (legendShape) {\n          case \"circle\":\n            htmlStr += '<circle class=\"legend-svg-icon\" r=\"6\" cx=\"6\" cy=\"6\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"rect\":\n            htmlStr += '<rect class=\"legend-svg-icon\" width=\"12\" height=\"12\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"triangle\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeTriangle(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"diamond\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeDiamond(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"star\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"fivestar\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeFiveStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"hexagon\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeHexagon(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"jewel\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeJewel(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"x\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeX(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n        }\n        htmlStr += '</svg></div>';\n        htmlStr += '<div class=\"legend-text\" style=\"margin-left: 5px;' + (legendFontSizeFlag ? 'font-size:' + curLegendFontSize + 'px;' : '') + (legendFontColorFlag ? 'color:' + curLegendFontColor + ';' : '') + '\">' + name + '</div>';\n        htmlStr += '</div>';\n        let curLegend = $(htmlStr);\n        curLegendDoms.push(curLegend);\n        legendContainer.append(curLegend);\n\n        // 计算得到图例在所有图例中的索引\n        const beforeCurPageCount = legendDistinct.slice(0, page).reduce((sumCount, curPage) => sumCount + curPage.length, 0);\n        const curLegendIndex = tempIndex + beforeCurPageCount;\n\n        //点击事件，固定突出的图例\n        curLegend.unbind(\"click\");\n        curLegend.bind(\"click\", function () {\n          // 防止外界节点悬浮时，各节点恢复初始颜色\n          const chartContainer = document.querySelector('.chart-container');\n          if (chartContainer) {\n            if (chartContainer.hasAttribute('data-lock-legend')) {\n              chartContainer.removeAttribute('data-lock-legend');\n            } else {\n              chartContainer.setAttribute('data-lock-legend', 'true');\n            }\n          }\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          if (fixedLegendIdx === -1) {\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n          } else if (fixedLegendIdx !== tempIndex) {\n            fixedLegendIdx = tempIndex;\n            callBackAmendFixeDLegendIdx(tempIndex);\n            if (mouseoutTimer) clearTimeout(mouseoutTimer);\n            //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n            curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[(isColorSetExtended ? curLegendIndex : tempIndex) % localColor.length]);\n            curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            curLegendDoms.forEach(function (cld, idx) {\n              if (idx !== tempIndex) {\n                let geryColor = \"rgba(198,200,200,0.3)\";\n                let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[idx % localColor.length], true), 0.4);\n                //cld.find(\".legend-square\").css(\"background-color\",transparentColor);\n                cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n                cld.find(\".legend-text\").css(\"color\", geryColor);\n              }\n            });\n            let geryColor = \"rgba(198,200,200,0.3)\";\n            legendEles.forEach(function (lcs, idx) {\n              if (idx !== (isColorSetExtended ? curLegendIndex : tempIndex) && lcs.legendIdx !== (isColorSetExtended ? curLegendIndex : tempIndex)) {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  if (lc.distinctType === \"link\") {\n                    lc.attr(\"stroke\", geryColor);\n                  } else {\n                    lc.attr(\"fill\", geryColor);\n                    if (isEleStroke) lc.attr(\"stroke\", geryColor);\n                  }\n                });\n              } else {\n                lcs.forEach(function (lc) {\n                  if (!lc) return;\n                  if (lc.distinctType === \"link\") {\n                    lc.attr(\"stroke\", linkColor ? linkColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                  } else {\n                    lc.attr(\"fill\", nodeBodyColor ? nodeBodyColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                    if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.9));\n                  }\n                });\n              }\n            });\n            legendTexts.forEach(function (lts, idx) {\n              if (idx !== tempIndex) {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return \"rgba(198,200,200,0.3)\";\n                  });\n                });\n              } else {\n                lts.forEach(function (lt) {\n                  if (!lt) return;\n                  lt.attr(\"style\", function () {\n                    return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                  });\n                  lt.attr(\"fill\", function () {\n                    return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                  });\n                });\n              }\n            });\n          } else {\n            callBackAmendFixeDLegendIdx(-1);\n            fixedLegendIdx = -1;\n          }\n          typeof changeActiveLegend === 'function' && changeActiveLegend(fixedLegendIdx === -1 ? '' : curLegend[0].textContent);\n        });\n        //悬浮事件，突出图例\n        curLegend.unbind(\"mouseover\");\n        curLegend.bind(\"mouseover\", function () {\n          if (fixedLegendIdx > -1) return;\n          typeof changeActiveLegend === 'function' && changeActiveLegend(curLegend[0].textContent);\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[(isColorSetExtended ? curLegendIndex : tempIndex) % localColor.length]);\n          curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n          // 不属于当前图例的元素置灰\n          curLegendDoms.forEach(function (cld, idx) {\n            if (idx !== tempIndex) {\n              let geryColor = \"rgba(198,200,200,0.3)\";\n              cld.find(\".legend-svg-icon\").attr(\"fill\", geryColor);\n              cld.find(\".legend-text\").css(\"color\", geryColor);\n            }\n          });\n          let geryColor = \"rgba(198,200,200,0.3)\";\n          legendEles.forEach(function (lcs, idx) {\n            if (idx !== (isColorSetExtended ? curLegendIndex : tempIndex) && lcs.legendIdx !== (isColorSetExtended ? curLegendIndex : tempIndex)) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                if (lc.distinctType === \"link\") {\n                  lc.attr(\"stroke\", geryColor);\n                } else {\n                  lc.attr(\"fill\", geryColor);\n                  if (isEleStroke) lc.attr(\"stroke\", geryColor);\n                }\n              });\n            } else {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                if (lc.distinctType === \"link\") {\n                  lc.attr(\"stroke\", linkColor ? linkColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                } else {\n                  lc.attr(\"fill\", nodeBodyColor ? nodeBodyColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                  if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.9));\n                }\n              });\n            }\n          });\n          legendTexts.forEach(function (lts, idx) {\n            if (idx !== (isColorSetExtended ? curLegendIndex : tempIndex)) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + \"rgba(198,200,200,0.3)\" + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return \"rgba(198,200,200,0.3)\";\n                });\n              });\n            } else {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            }\n          });\n        });\n        //鼠标移出事件，取消突出图例\n        curLegend.unbind(\"mouseout\");\n        function indexInAllPages(idx) {\n          const beforeCurPageCount = legendDistinct.slice(0, page).reduce((sumCount, curPage) => sumCount + curPage.length, 0);\n          return beforeCurPageCount + idx;\n        }\n        curLegend.bind(\"mouseout\", function () {\n          if (fixedLegendIdx > -1) return;\n          typeof changeActiveLegend === 'function' && changeActiveLegend();\n          mouseoutTimer = setTimeout(function () {\n            curLegendDoms.forEach(function (cld, idx) {\n              //cld.find(\".legend-square\").css(\"background-color\",localColor[idx]);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", localColor[(isColorSetExtended ? indexInAllPages(idx) : idx) % localColor.length]);\n              cld.find(\".legend-text\").css(\"color\", legendFontColorFlag ? curLegendFontColor : \"\");\n            });\n            legendEles.forEach(function (lcs, idx) {\n              lcs.forEach(function (lc) {\n                if (!lc) return;\n                if (lc.distinctType === \"link\") {\n                  lc.attr(\"stroke\", linkColor ? linkColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], elementTransparent));\n                } else {\n                  lc.attr(\"fill\", nodeBodyColor ? nodeBodyColor : _DataFocusMethod.hex2Rgba(localColor[(isColorSetExtended ? indexInAllPages(idx) : idx) % localColor.length], elementTransparent));\n                  if (isEleStroke) lc.attr(\"stroke\", nodeBorderColor ? nodeBorderColor : _DataFocusMethod.hex2Rgba(localColor[idx % localColor.length], 0.9));\n                }\n              });\n            });\n            legendTexts.forEach(function (lts) {\n              lts.forEach(function (lt) {\n                if (!lt) return;\n                lt.attr(\"style\", function () {\n                  return \"fill:\" + (labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\") + (labelTextFontSizeFlag ? \";font-size:\" + curLabelTextFontSize + \"px\" : \"\");\n                });\n                lt.attr(\"fill\", function () {\n                  return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n                });\n              });\n            });\n          }, 200);\n        });\n      });\n      if (page < legendDistinct.length - 1) {\n        legendContainer.append($(\"<span style='margin-top: -3px'>...</span>\"));\n      }\n    };\n    let currentPage = 0;\n    updateLegendPage(currentPage);\n    //当有多段图例时,图例切换事件\n    legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n    if (legendDistinct.length > 1) {\n      legendControl.find(\".left-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".left-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage > 0) {\n          currentPage--;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n      legendControl.find(\".right-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".right-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage < legendDistinct.length - 1) {\n          currentPage++;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n    } else {\n      legendControl.css(\"display\", \"none\");\n      //legendBar.css(\"left\",parseInt((drawWidth-(legendLineWidth))/2+50)+\"px\");\n    }\n  }\n};\n//绘制饼图图例\nlet ringLegend = {};\nringLegend.drawElement = function (option) {\n  let nodeMap = option.nodeMap;\n  let totalValue = option.totalValue;\n  let detailTitle = option.detailTitle;\n  let finalList = option.finalList;\n  let subDetailTitle = option.subDetailTitle;\n  let omitSubText = option.omitSubText;\n  let yHeader = option.yHeader;\n  let d3 = option.d3;\n  let pathDoms = option.pathDoms;\n  let guideLines = option.guideLines;\n  let labels = option.labels;\n  let emphasisPath = option.emphasisPath;\n  let arcPath = option.arcPath;\n  let arcAngles = option.arcAngles;\n  let isLegendFlag = option.isLegendFlag;\n  let hideLegendFlag = option.hideLegendFlag;\n  let legendBar = option.legendBar;\n  let legendLineWidth = option.legendLineWidth;\n  let legends = option.legends;\n  let legendType = option.legendType;\n  let fontSizeFlag = option.fontSizeFlag;\n  let legendFontSize = option.legendFontSize;\n  let fontSize = option.fontSize;\n  let labelColor = option.labelColor;\n  let legendFontColor = option.legendFontColor;\n  let curLegendDoms = option.curLegendDoms;\n  let nodeShape = option.nodeShape;\n  let legendShape = option.legendShape;\n  let fixedLegendIdx = option.fixedLegendIdx;\n  let localColor = option.localColor;\n  let mouseoutTimer = option.mouseoutTimer;\n  let drawWidth = option.drawWidth;\n  let nodeShapeArray = option.nodeShapeArray;\n  //绘制底部图例\n  if (isLegendFlag && !hideLegendFlag) {\n    legendBar.empty();\n    let htmlStr = '<div style=\"height: 20px;width: ' + (legendLineWidth - 101) + 'px;display: flex;justify-content: center;\"></div>';\n    let legendContainer = $(htmlStr);\n    legendBar.append(legendContainer);\n    htmlStr = '<div style=\"margin-top: -6px;margin-left: 30px;\">';\n    htmlStr += '<span class=\"left-legend-control\">◀</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"legend-control-page\">1/2</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"right-legend-control\">▶</span>';\n    htmlStr += '</div>';\n    let legendControl = $(htmlStr);\n    legendBar.append(legendControl);\n    let minInterval = 35;\n    //legend分页\n    let legendDistinct = [];\n    //当前页累计长度\n    let curLegendEntireLength = 0;\n    //定位页数\n    let legendDistinctLocate = -1;\n    //载入图例信息\n    let computeStringLength = function (str) {\n      let tempLength = 0;\n      if (!str) return tempLength;\n      for (let i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) > 127 || str.charCodeAt(i) == 94) {\n          tempLength += 2;\n        } else {\n          tempLength += 1;\n        }\n      }\n      return tempLength;\n    };\n    legends.forEach(function (ld, index) {\n      let curLegendName;\n      if (legendType === \"legend\") {\n        curLegendName = ld;\n      } else {\n        curLegendName = ld.name;\n      }\n      if (curLegendEntireLength === 0) {\n        legendDistinctLocate++;\n        legendDistinct[legendDistinctLocate] = [];\n        legendDistinct[legendDistinctLocate].push({\n          d: curLegendName,\n          index: index\n        });\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          curLegendEntireLength = 0;\n        }\n      } else {\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2 + minInterval;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          legendDistinctLocate++;\n          legendDistinct[legendDistinctLocate] = [];\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n          curLegendEntireLength = 0;\n          curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n          if (curLegendEntireLength >= legendLineWidth - 101) {\n            curLegendEntireLength = 0;\n          }\n        } else {\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n        }\n      }\n    });\n    //图例字体大小有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontSizeFlag = false;\n    let curLegendFontSize;\n    if (fontSizeFlag) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = fontSize;\n    }\n    if (legendFontSize) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = legendFontSize;\n    }\n    //图例字体颜色有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontColorFlag = false;\n    let curLegendFontColor;\n    if (labelColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = labelColor;\n    }\n    if (legendFontColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = legendFontColor;\n    }\n\n    //更新图例页\n    let updateLegendPage = function (page) {\n      legendContainer.empty();\n      curLegendDoms = [];\n      legendDistinct[page].forEach(function (ld, tempIndex) {\n        let name = ld.d,\n          index = ld.index;\n        //处理图例形状\n        if (nodeShape === \"repeat\") {\n          legendShape = nodeShapeArray[index % nodeShapeArray.length];\n        } else {\n          legendShape = nodeShape;\n        }\n        let curColor;\n        if (fixedLegendIdx === -1) {\n          curColor = localColor[index % localColor.length];\n        } else {\n          if (fixedLegendIdx === tempIndex) {\n            curColor = localColor[index % localColor.length];\n          } else {\n            curColor = \"rgba(198,200,200,0.3)\";\n          }\n        }\n        htmlStr = '<div style=\"display: flex;align-items: center;' + (tempIndex === 0 ? '' : 'margin-left:' + (minInterval - 4) + 'px;') + '\">';\n        htmlStr += '<div class=\"legend-square\" style=\"height: 15px;width: 12px;\">' + '<svg style=\"width: 12px; height: 12px\">';\n        switch (legendShape) {\n          case \"circle\":\n            htmlStr += '<circle class=\"legend-svg-icon\" r=\"6\" cx=\"6\" cy=\"6\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"rect\":\n            htmlStr += '<rect class=\"legend-svg-icon\" width=\"12\" height=\"12\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"triangle\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeTriangle(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"diamond\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeDiamond(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"star\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"fivestar\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeFiveStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"hexagon\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeHexagon(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"jewel\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeJewel(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"x\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeX(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n        }\n        htmlStr += '</svg></div>';\n        htmlStr += '<div class=\"legend-text\" style=\"margin-left: 5px;' + (legendFontSizeFlag ? 'font-size:' + curLegendFontSize + 'px;' : '') + (legendFontColorFlag ? 'color:' + curLegendFontColor + ';' : '') + '\">' + name + '</div>';\n        htmlStr += '</div>';\n        let curLegend = $(htmlStr);\n        curLegendDoms.push(curLegend);\n        legendContainer.append(curLegend);\n        //悬浮事件，突出图例\n        curLegend.unbind(\"mouseover\");\n        curLegend.bind(\"mouseover\", function () {\n          if (timeOp.playState) return;\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", \"\");\n          curLegendDoms.forEach(function (cld, idx) {\n            if (idx !== tempIndex) {\n              let geryColor = \"rgba(198,200,200,0.3)\";\n              let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[idx], true), 0.4);\n              //cld.find(\".legend-square\").css(\"background-color\",transparentColor);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", transparentColor);\n              cld.find(\".legend-text\").css(\"color\", geryColor);\n            }\n          });\n          let showIndex = finalList.length - 1;\n          for (let l = 0; l < finalList.length; l++) {\n            if (finalList[l].name === name) {\n              showIndex = l;\n              break;\n            }\n          }\n          pathDoms[showIndex].transition().duration(200).ease(d3.easeLinear).attr(\"fill\", localColor[index]).attr(\"stroke\", localColor[index]).attr(\"d\", emphasisPath(arcAngles[showIndex]));\n          if (guideLines[showIndex]) guideLines[showIndex].attr(\"stroke\", localColor[index]);\n          if (labels[showIndex]) labels[showIndex].attr(\"fill\", labelColor ? labelColor : \"\").attr(\"style\", \"fill:\" + (labelColor ? labelColor : \"inherit\") + (fontSizeFlag ? \";font-size:\" + fontSize + \"px\" : \"\"));\n          detailTitle.text(_DataFocusMethod.formatData(finalList[showIndex].sortValue, yHeader));\n          subDetailTitle.text(omitSubText(finalList[showIndex].name + \"\"));\n          pathDoms.forEach(function (dd, idx) {\n            if (idx === showIndex) return;\n            let geryColor = \"rgba(198,200,200,0.3)\";\n            let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[nodeMap[finalList[idx].name]], true), 0.4);\n            dd.transition().duration(200).ease(d3.easeLinear).attr(\"fill\", transparentColor).attr(\"stroke\", transparentColor).attr(\"d\", arcPath(arcAngles[idx]));\n            if (guideLines[idx]) guideLines[idx].attr(\"stroke\", transparentColor);\n            if (labels[idx]) labels[idx].attr(\"fill\", geryColor).attr(\"style\", \"fill:\" + geryColor + (fontSizeFlag ? \";font-size:\" + fontSize + \"px\" : \"\"));\n          });\n        });\n        //鼠标移出事件，取消突出图例\n        curLegend.unbind(\"mouseout\");\n        curLegend.bind(\"mouseout\", function () {\n          if (timeOp.playState) return;\n          mouseoutTimer = setTimeout(function () {\n            curLegendDoms.forEach(function (cld, idx) {\n              //cld.find(\".legend-square\").css(\"background-color\",localColor[idx]);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", localColor[idx]);\n              cld.find(\".legend-text\").css(\"color\", \"\");\n            });\n            pathDoms.forEach(function (dd, idx) {\n              dd.transition().duration(200).ease(d3.easeLinear).attr(\"fill\", localColor[nodeMap[finalList[idx].name]]).attr(\"stroke\", localColor[nodeMap[finalList[idx].name]]).attr(\"d\", arcPath(arcAngles[idx]));\n              if (guideLines[idx]) guideLines[idx].attr(\"stroke\", localColor[nodeMap[finalList[idx].name]]);\n              if (labels[idx]) labels[idx].attr(\"fill\", labelColor ? labelColor : \"\").attr(\"style\", \"fill:\" + (labelColor ? labelColor : \"inherit\") + (fontSizeFlag ? \";font-size:\" + fontSize + \"px\" : \"\"));\n            });\n            detailTitle.text(_DataFocusMethod.formatData(totalValue, yHeader));\n            subDetailTitle.text(omitSubText(\"Total\"));\n          }, 200);\n        });\n      });\n      if (page < legendDistinct.length - 1) {\n        legendContainer.append($(\"<span style='margin-top: -3px'>...</span>\"));\n      }\n    };\n    let currentPage = 0;\n    updateLegendPage(currentPage);\n    //当有多段图例时,图例切换事件\n    legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n    if (legendDistinct.length > 1) {\n      legendControl.find(\".left-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".left-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage > 0) {\n          currentPage--;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n      legendControl.find(\".right-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".right-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage < legendDistinct.length - 1) {\n          currentPage++;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n    } else {\n      legendControl.css(\"display\", \"none\");\n      legendBar.css(\"left\", parseInt((drawWidth - legendLineWidth) / 2 + 50) + \"px\");\n    }\n  }\n};\n//绘制漏斗图图例\nlet funnelLegend = {};\nfunnelLegend.drawElement = function (option) {\n  let nodeMap = option.nodeMap;\n  let totalValue = option.totalValue;\n  let detailTitle = option.detailTitle;\n  let finalList = option.finalList;\n  let subDetailTitle = option.subDetailTitle;\n  let omitSubText = option.omitSubText;\n  let yHeader = option.yHeader;\n  let d3 = option.d3;\n  let pathDoms = option.pathDoms;\n  let guideLines = option.guideLines;\n  let labels = option.labels;\n  let emphasisPath = option.emphasisPath;\n  let arcPath = option.arcPath;\n  let arcAngles = option.arcAngles;\n  let isLegendFlag = option.isLegendFlag;\n  let hideLegendFlag = option.hideLegendFlag;\n  let legendBar = option.legendBar;\n  let legendLineWidth = option.legendLineWidth;\n  let legends = option.legends;\n  let legendType = option.legendType;\n  let fontSizeFlag = option.fontSizeFlag;\n  let legendFontSize = option.legendFontSize;\n  let fontSize = option.fontSize;\n  let labelColor = option.labelColor;\n  let legendFontColor = option.legendFontColor;\n  let curLegendDoms = option.curLegendDoms;\n  let nodeShape = option.nodeShape;\n  let legendShape = option.legendShape;\n  let fixedLegendIdx = option.fixedLegendIdx;\n  let localColor = option.localColor;\n  let mouseoutTimer = option.mouseoutTimer;\n  let drawWidth = option.drawWidth;\n  let nodeShapeArray = option.nodeShapeArray;\n  //绘制底部图例\n  if (isLegendFlag && !hideLegendFlag) {\n    legendBar.empty();\n    let htmlStr = '<div style=\"height: 20px;width: ' + (legendLineWidth - 101) + 'px;display: flex;justify-content: center;\"></div>';\n    let legendContainer = $(htmlStr);\n    legendBar.append(legendContainer);\n    htmlStr = '<div style=\"margin-top: -6px;margin-left: 30px;\">';\n    htmlStr += '<span class=\"left-legend-control\">◀</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"legend-control-page\">1/2</span>';\n    htmlStr += '<span style=\"margin-left: 5px;\" class=\"right-legend-control\">▶</span>';\n    htmlStr += '</div>';\n    let legendControl = $(htmlStr);\n    legendBar.append(legendControl);\n    let minInterval = 35;\n    //legend分页\n    let legendDistinct = [];\n    //当前页累计长度\n    let curLegendEntireLength = 0;\n    //定位页数\n    let legendDistinctLocate = -1;\n    //载入图例信息\n    let computeStringLength = function (str) {\n      let tempLength = 0;\n      if (!str) return tempLength;\n      for (let i = 0; i < str.length; i++) {\n        if (str.charCodeAt(i) > 127 || str.charCodeAt(i) == 94) {\n          tempLength += 2;\n        } else {\n          tempLength += 1;\n        }\n      }\n      return tempLength;\n    };\n    legends.forEach(function (ld, index) {\n      let curLegendName;\n      if (legendType === \"legend\") {\n        curLegendName = ld;\n      } else {\n        curLegendName = ld.name;\n      }\n      if (curLegendEntireLength === 0) {\n        legendDistinctLocate++;\n        legendDistinct[legendDistinctLocate] = [];\n        legendDistinct[legendDistinctLocate].push({\n          d: curLegendName,\n          index: index\n        });\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          curLegendEntireLength = 0;\n        }\n      } else {\n        curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2 + minInterval;\n        if (curLegendEntireLength >= legendLineWidth - 101) {\n          legendDistinctLocate++;\n          legendDistinct[legendDistinctLocate] = [];\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n          curLegendEntireLength = 0;\n          curLegendEntireLength += 16 + 5 + computeStringLength(curLegendName) * fontSize / 2;\n          if (curLegendEntireLength >= legendLineWidth - 101) {\n            curLegendEntireLength = 0;\n          }\n        } else {\n          legendDistinct[legendDistinctLocate].push({\n            d: curLegendName,\n            index: index\n          });\n        }\n      }\n    });\n    //图例字体大小有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontSizeFlag = false;\n    let curLegendFontSize;\n    if (fontSizeFlag) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = fontSize;\n    }\n    if (legendFontSize) {\n      legendFontSizeFlag = true;\n      curLegendFontSize = legendFontSize;\n    }\n    //图例字体颜色有三个来源, 继承/全局字体配置/图例字体配置\n    let legendFontColorFlag = false;\n    let curLegendFontColor;\n    if (labelColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = labelColor;\n    }\n    if (legendFontColor) {\n      legendFontColorFlag = true;\n      curLegendFontColor = legendFontColor;\n    }\n\n    //更新图例页\n    let updateLegendPage = function (page) {\n      legendContainer.empty();\n      curLegendDoms = [];\n      legendDistinct[page].forEach(function (ld, tempIndex) {\n        let name = ld.d,\n          index = ld.index;\n        //处理图例形状\n        if (nodeShape === \"repeat\") {\n          legendShape = nodeShapeArray[index % nodeShapeArray.length];\n        } else {\n          legendShape = nodeShape;\n        }\n        let curColor;\n        if (fixedLegendIdx === -1) {\n          curColor = localColor[index % localColor.length];\n        } else {\n          if (fixedLegendIdx === tempIndex) {\n            curColor = localColor[index % localColor.length];\n          } else {\n            curColor = \"rgba(198,200,200,0.3)\";\n          }\n        }\n        htmlStr = '<div style=\"display: flex;align-items: center;' + (tempIndex === 0 ? '' : 'margin-left:' + (minInterval - 4) + 'px;') + '\">';\n        htmlStr += '<div class=\"legend-square\" style=\"height: 15px;width: 12px;\">' + '<svg style=\"width: 12px; height: 12px\">';\n        switch (legendShape) {\n          case \"circle\":\n            htmlStr += '<circle class=\"legend-svg-icon\" r=\"6\" cx=\"6\" cy=\"6\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"rect\":\n            htmlStr += '<rect class=\"legend-svg-icon\" width=\"12\" height=\"12\" stroke=\"none\" fill=\"' + curColor + '\"/>';\n            break;\n          case \"triangle\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeTriangle(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"diamond\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeDiamond(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"star\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"fivestar\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeFiveStar(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"hexagon\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeHexagon(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"jewel\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeJewel(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n          case \"x\":\n            htmlStr += '<path class=\"legend-svg-icon\" d=\"' + shapeX(6) + '\" transform=\"translate(6,6)\" stroke=\"none\" fill=\"' + curColor + '\" />';\n            break;\n        }\n        htmlStr += '</svg></div>';\n        htmlStr += '<div class=\"legend-text\" style=\"margin-left: 5px;' + (legendFontSizeFlag ? 'font-size:' + curLegendFontSize + 'px;' : '') + (legendFontColorFlag ? 'color:' + curLegendFontColor + ';' : '') + '\">' + name + '</div>';\n        htmlStr += '</div>';\n        let curLegend = $(htmlStr);\n        curLegendDoms.push(curLegend);\n        legendContainer.append(curLegend);\n        //悬浮事件，突出图例\n        curLegend.unbind(\"mouseover\");\n        curLegend.bind(\"mouseover\", function () {\n          if (timeOp.playState) return;\n          if (mouseoutTimer) clearTimeout(mouseoutTimer);\n          //curLegendDoms[tempIndex].find(\".legend-square\").css(\"background-color\",localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-svg-icon\").attr(\"fill\", localColor[tempIndex]);\n          curLegendDoms[tempIndex].find(\".legend-text\").css(\"color\", \"\");\n          curLegendDoms.forEach(function (cld, idx) {\n            if (idx !== tempIndex) {\n              let geryColor = \"rgba(198,200,200,0.3)\";\n              let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[idx], true), 0.4);\n              //cld.find(\".legend-square\").css(\"background-color\",transparentColor);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", transparentColor);\n              cld.find(\".legend-text\").css(\"color\", geryColor);\n            }\n          });\n          pathDoms[index].attr(\"fill\", localColor[index % localColor.length]).attr(\"stroke\", localColor[index % localColor.length]);\n          if (labels[index]) labels[index].attr(\"fill\", \"\").attr(\"style\", \"fill:\" + (labelColor ? labelColor : \"inherit\") + (fontSizeFlag ? \";font-size:\" + fontSize + \"px\" : \"\"));\n          pathDoms.forEach(function (dd, idx) {\n            if (idx === index) return;\n            let geryColor = \"rgba(198,200,200,0.3)\";\n            let transparentColor = _DataFocusMethod.hex2Rgba(_DataFocusMethod.rgba2Hex(localColor[index % localColor.length], true), 0.4);\n            dd.attr(\"fill\", geryColor).attr(\"stroke\", geryColor);\n            if (labels[idx]) labels[idx].attr(\"fill\", geryColor).attr(\"style\", \"fill:\" + geryColor + (fontSizeFlag ? \";font-size:\" + fontSize + \"px\" : \"\"));\n          });\n        });\n        //鼠标移出事件，取消突出图例\n        curLegend.unbind(\"mouseout\");\n        curLegend.bind(\"mouseout\", function () {\n          if (timeOp.playState) return;\n          mouseoutTimer = setTimeout(function () {\n            curLegendDoms.forEach(function (cld, idx) {\n              //cld.find(\".legend-square\").css(\"background-color\",localColor[idx]);\n              cld.find(\".legend-svg-icon\").attr(\"fill\", localColor[idx]);\n              cld.find(\".legend-text\").css(\"color\", \"\");\n            });\n            pathDoms.forEach(function (dd, idx) {\n              dd.attr(\"fill\", localColor[idx % localColor.length]).attr(\"stroke\", localColor[idx % localColor.length]);\n              if (labels[idx]) labels[idx].attr(\"fill\", labelColor ? labelColor : \"\").attr(\"style\", \"fill:\" + (labelColor ? labelColor : \"inherit\") + (fontSizeFlag ? \";font-size:\" + fontSize + \"px\" : \"\"));\n            });\n          }, 200);\n        });\n      });\n      if (page < legendDistinct.length - 1) {\n        legendContainer.append($(\"<span style='margin-top: -3px'>...</span>\"));\n      }\n    };\n    let currentPage = 0;\n    updateLegendPage(currentPage);\n    //当有多段图例时,图例切换事件\n    legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n    if (legendDistinct.length > 1) {\n      legendControl.find(\".left-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".left-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage > 0) {\n          currentPage--;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n      legendControl.find(\".right-legend-control\").unbind(\"mousedown\");\n      legendControl.find(\".right-legend-control\").bind(\"mousedown\", function () {\n        if (currentPage < legendDistinct.length - 1) {\n          currentPage++;\n          updateLegendPage(currentPage);\n          legendControl.find(\".legend-control-page\").text(currentPage + 1 + \"/\" + legendDistinct.length);\n        }\n      });\n    } else {\n      legendControl.css(\"display\", \"none\");\n      legendBar.css(\"left\", parseInt((drawWidth - legendLineWidth) / 2 + 50) + \"px\");\n    }\n  }\n};\n//绘制date框标签\nlet dateBlock = {};\ndateBlock.drawElements = function (option) {\n  let svg = option.svg;\n  let fontSize = option.fontSize;\n  let drawWidth = option.drawWidth;\n  let drawHeight = option.drawHeight;\n  let isTimeLegendFlag = option.isTimeLegendFlag;\n  let hidetimeLabelFlag = option.hidetimeLabelFlag;\n  let timeLabelPosition = option.timeLabelPosition;\n  let timeLabels = option.timeLabels;\n  let timeStampIdx = option.timeStampIdx;\n  let timeLabelFontSize = option.timeLabelFontSize;\n  let leftOffset = option.leftOffset;\n  let rightOffset = option.rightOffset;\n  let topOffset = option.topOffset;\n  let color = option.color || \"rgba(210,210,210,0.7)\";\n  let timeLabelFormat = option.timeLabelFormat || \"default\";\n  let dateBlockDom;\n  //绘制单帧时间的date框\n  if (isTimeLegendFlag && !hidetimeLabelFlag) {\n    dateBlockDom = svg.append(\"text\");\n    dateBlockDom.attr(\"pointer-events\", \"none\").style(\"pointer-events\", \"none\");\n    if (timeLabelPosition === \"topRight\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      dateBlockDom.text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"end\").attr(\"stroke\", color).attr(\"style\", \"fill:\" + color + \";font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (drawWidth - 60 - rightOffset) + \",\" + (topOffset * 1.0 + timeLabelFontSize * 1.0) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"topLeft\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      dateBlockDom.text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"start\").attr(\"stroke\", color).attr(\"style\", \"fill:\" + color + \";font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (leftOffset + 60) + \",\" + (topOffset * 1.0 + timeLabelFontSize * 1.0) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"bottomRight\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      dateBlockDom.text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"end\").attr(\"stroke\", color).attr(\"style\", \"fill:\" + color + \";font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (drawWidth - 60 - rightOffset) + \",\" + (drawHeight * 1.0 - 20) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"bottomLeft\") {\n      let showText = timeLabels[timeStampIdx];\n      if (timeLabelFormat === \"y\") {\n        showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      }\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      dateBlockDom.text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"start\").attr(\"stroke\", color).attr(\"style\", \"fill:\" + color + \";font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (leftOffset * 1.0 + 60) + \",\" + (drawHeight - 20) + \")\";\n      });\n    }\n    if (timeLabelPosition === \"center\") {\n      let showText = timeLabels[timeStampIdx].split(\"-\")[0];\n      if (timeLabelFormat === \"ym\") {\n        let strList = timeLabels[timeStampIdx].split(\"-\");\n        showText = strList[0] + \"-\" + strList[1];\n      }\n      if (timeLabelFormat === \"ymd\") {\n        showText = timeLabels[timeStampIdx];\n      }\n      dateBlockDom.text(showText).attr(\"class\", 'labels').attr(\"text-anchor\", \"middle\").attr(\"stroke\", color).attr(\"style\", \"fill:\" + color + \";font-size:\" + timeLabelFontSize + \"px;\").attr(\"font-family\", \"Arial, Helvetica, sans-serif\").attr(\"font-weight\", 600).attr(\"transform\", function () {\n        return \"translate(\" + (leftOffset * 1.0 + (drawWidth - rightOffset - leftOffset) / 2) + \",\" + (topOffset * 1.0 + drawHeight * 1.0 - 20) / 2 + \")\";\n      });\n    }\n  }\n  return dateBlockDom;\n};\n/**\n 零散方法\n */\n//计算字符串长度，中文算1个字符 ， 英文算0.7个字符\nfunction getByteLen(val) {\n  var len = 0;\n  for (let i = 0; i < val.length; i++) {\n    let a = val.charAt(i);\n    if (a.match(/[^\\x00-\\xff]/ig) != null) {\n      len += 1;\n    } else {\n      len += 0.7;\n    }\n  }\n  return len;\n}\n//计算数字的小数位\nfunction getDecimalPlaces(theValue) {\n  let str = theValue + \"\";\n  let decimalStr = str.split(\".\")[1];\n  if (!decimalStr) return 0;else {\n    return decimalStr.length;\n  }\n}\n\n/**\n 生成4个近似的颜色\n */\nfunction getShallowRGB(maxColorObject, R, G, B) {\n  let threshold = 20;\n  let offset = 5;\n  let result = [];\n  let an = 40;\n  let shen = 35;\n  let liang = 8;\n  let dan = -10;\n  //暗 深 亮 淡\n  for (var d in maxColorObject) {\n    if (d == 'R') {\n      result = [[R - an, G - an + 10, B - an + 10], [R - shen, G - shen - 25, B - shen - 25], [R + liang, G - liang + 40, B - liang + 40], [R - dan, G - dan + 40, B - dan + 40]];\n    } else if (d == 'G') {\n      result = [[R - an + 10, G - an, B - an + 10], [R - shen - 25, G - shen, B - shen - 25], [R - liang + 40, G + liang, B - liang + 40], [R - dan + 40, G - dan, B - dan + 40]];\n    } else if (d == 'B') {\n      result = [[R - an + 10, G - an + 10, B - an], [R - shen - 25, G - shen - 25, B - shen], [R - liang + 40, G - liang + 40, B + liang], [R - dan + 40, G - dan + 40, B - dan]];\n    }\n  }\n  return result;\n}\n//找到最大的RGB\nfunction findMaxRGB(R, G, B) {\n  let max;\n  let index;\n  if (R >= G && R >= B) {\n    max = R;\n    index = 'R';\n  }\n  if (G >= R && G >= B) {\n    max = G;\n    index = 'G';\n  }\n  if (B >= R && B >= G) {\n    max = B;\n    index = 'B';\n  }\n  return {\n    [index]: max\n  };\n}\n//16进制转RGB\nfunction foramgeRGB(color) {\n  // 16进制颜色值的正则\n  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\n  // 把颜色值变成小写\n  color = color.toLowerCase();\n  if (reg.test(color)) {\n    // 如果只有三位的值，需变成六位，如：#fff => #ffffff\n    if (color.length === 4) {\n      var colorNew = \"#\";\n      for (var i = 1; i < 4; i += 1) {\n        colorNew += color.slice(i, i + 1).concat(color.slice(i, i + 1));\n      }\n      color = colorNew;\n    }\n    // 处理六位的颜色值，转为RGB\n    var colorChange = [];\n    for (var i = 1; i < 7; i += 2) {\n      colorChange.push(parseInt(\"0x\" + color.slice(i, i + 2)));\n    }\n    return colorChange;\n  } else {\n    return color;\n  }\n}\n;\nfunction formatColorList(originalColor, cl) {\n  let ans = [originalColor];\n  for (let i = 0; i < cl.length; i++) {\n    let cc = cl[i];\n    let str = \"rgba(\";\n    for (let j = 0; j < cc.length; j++) {\n      str += Math.max(0, cc[j]) + \",\";\n    }\n    str += \",1)\";\n    ans.push(_DataFocusMethod.rgba2Hex(str, true));\n  }\n  return ans;\n}\nfunction generateSimilarColor(color) {\n  let normColor = _DataFocusMethod.rgba2Hex(color, true);\n  let curRgb = foramgeRGB(normColor);\n  let cR = curRgb[0];\n  let cG = curRgb[1];\n  let cB = curRgb[2];\n  let maxColorObject = findMaxRGB(cR, cG, cB);\n  return formatColorList(color, getShallowRGB(maxColorObject, cR, cG, cB));\n}\n\n/**\n 曲线绘制方法\n */\nlet curveMaker = {};\n\n//获取二阶贝塞尔曲线\nfunction getBezier2Curve(pt1, pt2, pt3, cutCount) {\n  let np1x, np1y, np2x, np2y;\n  let pts = [];\n  let line1XStep = (pt2.x - pt1.x) * 1.0 / cutCount;\n  let line1YStep = (pt2.y - pt1.y) * 1.0 / cutCount;\n  let line2XStep = (pt3.x - pt2.x) * 1.0 / cutCount;\n  let line2YStep = (pt3.y - pt2.y) * 1.0 / cutCount;\n  let ansx, ansy;\n  for (let i = 0; i <= cutCount; i++) {\n    np1x = pt1.x + line1XStep * i;\n    np1y = pt1.y + line1YStep * i;\n    np2x = pt2.x + line2XStep * i;\n    np2y = pt2.y + line2YStep * i;\n    ansx = (np2x - np1x) * 1.0 * i / cutCount + np1x;\n    ansy = (np2y - np1y) * 1.0 * i / cutCount + np1y;\n    pts.push({\n      x: ansx,\n      y: ansy\n    });\n  }\n  return pts;\n}\n//获取三阶贝塞尔曲线\nfunction getBezier3Curve(points, cutCount) {\n  let pt1 = points[0],\n    pt2 = points[1],\n    pt3 = points[2],\n    pt4 = points[3];\n  let curve1 = getBezier2Curve(pt1, pt2, pt3, cutCount);\n  let curve2 = getBezier2Curve(pt2, pt3, pt4, cutCount);\n  let curXStep, curYStep, curSp, curEp;\n  let ansx, ansy;\n  let pts = [];\n  for (let i = 0; i <= cutCount; i++) {\n    curSp = curve1[i];\n    curEp = curve2[i];\n    curXStep = (curEp.x - curSp.x) * 1.0 / cutCount;\n    curYStep = (curEp.y - curSp.y) * 1.0 / cutCount;\n    ansx = curXStep * i + curSp.x;\n    ansy = curYStep * i + curSp.y;\n    pts.push({\n      x: ansx,\n      y: ansy\n    });\n  }\n  return pts;\n}\n//过三定点确定一条二阶贝塞尔曲线，获取其控制点\nfunction getCentralPointForBezier2(pt1, pt2, pt3, a) {\n  let ansx = ((a - 1) * (a - 1) * pt1.x + a * a * pt3.x - pt2.x) / (2 * a * a - 2 * a);\n  let ansy = ((a - 1) * (a - 1) * pt1.y + a * a * pt3.y - pt2.y) / (2 * a * a - 2 * a);\n  return {\n    x: ansx,\n    y: ansy\n  };\n}\n//获取向量的角度 360°\nfunction getAngleFromVector(x, y) {\n  let k;\n  let angle;\n  if (x === 0) {\n    if (y > 0) angle = 90;else angle = 270;\n  } else {\n    k = y / x;\n    angle = Math.atan(k) / Math.PI * 180;\n    if (x < 0) angle += 180;\n  }\n  if (angle < 0) angle += 360;\n  if (angle >= 360) angle -= 360;\n  return angle;\n}\n//获取两向量的距离和夹角\nfunction getDistanceAndAngle(sv, tv) {\n  let cx = tv.x - sv.x;\n  let cy = tv.y - sv.y;\n  let distance = Math.sqrt(cx * cx + cy * cy);\n  let angle = getAngleFromVector(cx, cy);\n  return {\n    distance: distance,\n    angle: angle\n  };\n}\n\n//分形渐进一条曲线\nlet finalAngle;\nfunction fractalApproach(startP, endP, sAngle, tAngle, distance, lineList, sharpness) {\n  let clockwise = true;\n  let bwAngle;\n  if (tAngle > sAngle) {\n    if (tAngle - sAngle > 180) {\n      clockwise = false;\n      bwAngle = 360 - (tAngle - sAngle);\n    } else {\n      clockwise = true;\n      bwAngle = tAngle - sAngle;\n    }\n  } else {\n    if (sAngle - tAngle > 180) {\n      clockwise = true;\n      bwAngle = 360 - (sAngle - tAngle);\n    } else {\n      clockwise = false;\n      bwAngle = sAngle - tAngle;\n    }\n  }\n  let ansAngle;\n  const miniStep = 5;\n  let rate = Math.ceil(distance / miniStep);\n  if (clockwise) {\n    ansAngle = sAngle + bwAngle / Math.max(1, rate * sharpness);\n  } else {\n    ansAngle = sAngle - bwAngle / Math.max(1, rate * sharpness);\n  }\n  if (ansAngle < 0) ansAngle += 360;\n  if (ansAngle >= 360) ansAngle -= 360;\n  let ansx = distance / rate * Math.cos(ansAngle / 180 * Math.PI);\n  let ansy = distance / rate * Math.sin(ansAngle / 180 * Math.PI);\n  let ansP = {\n    x: startP.x + ansx,\n    y: startP.y + ansy\n  };\n  lineList.push(ansP);\n  let nextR = getDistanceAndAngle(ansP, endP);\n  if (nextR.distance < 5) {\n    finalAngle = ansAngle;\n    return;\n  }\n  fractalApproach(ansP, endP, ansAngle, nextR.angle, nextR.distance, lineList, sharpness);\n}\n//过任意定点通过分形渐进法获得一条圆滑的曲线\nfunction createCurveByPoints(points, startAngle, sharpness) {\n  finalAngle = startAngle;\n  let tR;\n  let tempLine;\n  let ansLines = [];\n  for (let i = 0; i < points.length - 1; i++) {\n    let tempStart = points[i];\n    let tempEnd = points[i + 1];\n    tR = getDistanceAndAngle(tempStart, tempEnd);\n    tempLine = [tempStart];\n    fractalApproach(tempStart, tempEnd, finalAngle, tR.angle, tR.distance, tempLine, sharpness);\n    ansLines.push(tempLine);\n  }\n  return ansLines;\n}\n//三次贝塞尔曲线\nfunction bezier3funcX(uu, controlP) {\n  let part0 = controlP[0].x * uu * uu * uu;\n  let part1 = 3 * controlP[1].x * uu * uu * (1 - uu);\n  let part2 = 3 * controlP[2].x * uu * (1 - uu) * (1 - uu);\n  let part3 = controlP[3].x * (1 - uu) * (1 - uu) * (1 - uu);\n  return part0 + part1 + part2 + part3;\n}\nfunction bezier3funcY(uu, controlP) {\n  let part0 = controlP[0].y * uu * uu * uu;\n  let part1 = 3 * controlP[1].y * uu * uu * (1 - uu);\n  let part2 = 3 * controlP[2].y * uu * (1 - uu) * (1 - uu);\n  let part3 = controlP[3].y * (1 - uu) * (1 - uu) * (1 - uu);\n  return part0 + part1 + part2 + part3;\n}\n//过任意定点绘制一个闭合的圆滑曲线\nfunction createCloseCurve(originPoints, sharpness) {\n  if (!originPoints) return;\n  let scale = sharpness;\n  let midPoints = [];\n  let curvePoint = [];\n  let originCount = originPoints || originPoints.length;\n  //生成中点\n  for (let i = 0; i < originCount; i++) {\n    let nexti = (i + 1) % originCount;\n    midPoints[i] = {};\n    midPoints[i].x = (originPoints[i].x + originPoints[nexti].x) / 2.0;\n    midPoints[i].y = (originPoints[i].y + originPoints[nexti].y) / 2.0;\n  }\n\n  //平移中点\n  let extrapoints = [];\n  for (let i = 0; i < originCount; i++) {\n    let nexti = (i + 1) % originCount;\n    let backi = (i + originCount - 1) % originCount;\n    let midinmid = {};\n    midinmid.x = (midPoints[i].x + midPoints[backi].x) / 2.0;\n    midinmid.y = (midPoints[i].y + midPoints[backi].y) / 2.0;\n    let offsetx = originPoints[i].x - midinmid.x;\n    let offsety = originPoints[i].y - midinmid.y;\n    let extraindex = 2 * i;\n    extrapoints[extraindex] = {};\n    extrapoints[extraindex].x = midPoints[backi].x + offsetx;\n    extrapoints[extraindex].y = midPoints[backi].y + offsety;\n    //朝 originPoints[i]方向收缩\n    let addx = (extrapoints[extraindex].x - originPoints[i].x) * scale;\n    let addy = (extrapoints[extraindex].y - originPoints[i].y) * scale;\n    extrapoints[extraindex].x = originPoints[i].x + addx;\n    extrapoints[extraindex].y = originPoints[i].y + addy;\n    let extranexti = (extraindex + 1) % (2 * originCount);\n    extrapoints[extranexti] = {};\n    extrapoints[extranexti].x = midPoints[i].x + offsetx;\n    extrapoints[extranexti].y = midPoints[i].y + offsety;\n    //朝 originPoints[i]方向收缩\n    addx = (extrapoints[extranexti].x - originPoints[i].x) * scale;\n    addy = (extrapoints[extranexti].y - originPoints[i].y) * scale;\n    extrapoints[extranexti].x = originPoints[i].x + addx;\n    extrapoints[extranexti].y = originPoints[i].y + addy;\n  }\n  let controlPoint = [];\n  //生成4控制点。产生贝塞尔曲线\n  for (let i = 0; i < originCount; i++) {\n    controlPoint[0] = originPoints[i];\n    let extraindex = 2 * i;\n    controlPoint[1] = extrapoints[extraindex + 1];\n    let extranexti = (extraindex + 2) % (2 * originCount);\n    controlPoint[2] = extrapoints[extranexti];\n    let nexti = (i + 1) % originCount;\n    controlPoint[3] = originPoints[nexti];\n    let u = 1.0;\n    while (u >= 0) {\n      let px = bezier3funcX(u, controlPoint);\n      let py = bezier3funcY(u, controlPoint);\n      //u的步长决定曲线的疏密\n      u -= 0.02;\n      let tempP = {\n        x: px,\n        y: py\n      };\n      //存入曲线点\n      curvePoint.push(tempP);\n    }\n  }\n  return curvePoint;\n}\n//确定中心点获取圆周上的点\nfunction getCirclePoint(angle, radius, centerPt) {\n  let ansx = radius * Math.cos(angle / 180 * Math.PI) + centerPt.x;\n  let ansy = radius * Math.sin(angle / 180 * Math.PI) + centerPt.y;\n  return {\n    x: ansx,\n    y: ansy\n  };\n}\n//调转180度\nfunction reverseAngle(angle) {\n  let ans = angle + 180;\n  if (ans >= 360) ans -= 360;\n  return ans;\n}\n//规范到0-360度\nfunction normalizeAngle(angle) {\n  let ans = angle;\n  if (ans >= 360) ans -= 360;\n  if (ans < 0) ans += 360;\n  return ans;\n}\n//角度相减\nfunction minusAngle(a, b) {\n  let ans;\n  ans = normalizeAngle(a + 360 - b);\n  return ans;\n}\n//角度转化\nfunction rad2grade(angle) {\n  let ans;\n  ans = angle / Math.PI * 180;\n  return ans;\n}\n//将点集转化为Svg的d\nfunction points2d(points) {\n  let str = \"\";\n  for (let i = 0; i < points.length; i++) {\n    if (i === 0) {\n      str += \"M\" + points[i].x + \" \" + points[i].y + \" \";\n    } else {\n      str += \"L\" + points[i].x + \" \" + points[i].y + \" \";\n    }\n  }\n  return str;\n}\n//将多条线段组合成一条线段\nfunction combatLines(lines) {\n  let neoLine = [];\n  lines.forEach(function (line) {\n    for (let i = 0; i < line.length; i++) {\n      neoLine.push(line[i]);\n    }\n  });\n  return neoLine;\n}\ncurveMaker.getBezier2Curve = getBezier2Curve;\ncurveMaker.getBezier3Curve = getBezier3Curve;\ncurveMaker.getCentralPointForBezier2 = getCentralPointForBezier2;\ncurveMaker.getAngleFromVector = getAngleFromVector;\ncurveMaker.getDistanceAndAngle = getDistanceAndAngle;\ncurveMaker.fractalApproach = fractalApproach;\ncurveMaker.createCurveByPoints = createCurveByPoints;\ncurveMaker.bezier3funcX = bezier3funcX;\ncurveMaker.bezier3funcY = bezier3funcY;\ncurveMaker.createCloseCurve = createCloseCurve;\ncurveMaker.getCirclePoint = getCirclePoint;\ncurveMaker.reverseAngle = reverseAngle;\ncurveMaker.normalizeAngle = normalizeAngle;\ncurveMaker.minusAngle = minusAngle;\ncurveMaker.rad2grade = rad2grade;\ncurveMaker.points2d = points2d;\ncurveMaker.combatLines = combatLines;\nexports.timeOp = getTimeOp;\nexports.timeData = timeData;\nexports.timeAxisSystem = timeAxisSystem;\nexports.containerOp = containerOp;\nexports.legendAndDate = legendAndDate;\nexports.legend = legend;\nexports.ringLegend = ringLegend;\nexports.funnelLegend = funnelLegend;\nexports.dateBlock = dateBlock;\nexports.getByteLen = getByteLen;\nexports.getDecimalPlaces = getDecimalPlaces;\nexports.generateSimilarColor = generateSimilarColor;\nexports.curveMaker = curveMaker;\nlet ATSF = exports;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ATSF);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.plugin/animationTimeSequenceFrame.js?");

/***/ })

}]);