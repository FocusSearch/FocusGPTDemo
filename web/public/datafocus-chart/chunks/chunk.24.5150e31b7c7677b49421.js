(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[24],{

/***/ "../src-v5/assets/js/charts.system.senior/correlationAnalysis.js":
/*!***********************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.senior/correlationAnalysis.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../charts.plugin/animationTimeSequenceFrame */ \"../src-v5/assets/js/charts.plugin/animationTimeSequenceFrame.js\");\n/* harmony import */ var _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/common/CommonDrawAxis */ \"../src-v5/assets/js/common/CommonDrawAxis.js\");\n\n\n\n/** 相关图画图组件 **/\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  chartType: 'correlationAnalysis',\n  //  图形名 [ * 必填项 ]\n  chartDisplayNameKey: \"chart-name-title\",\n  //  图形名称中英文Key [ * 必填项 ]\n  chartDescriptionKey: \"chart-description-title\",\n  //  图形描述中英文Key [ * 必填项 ]\n\n  /** 至少两个数值列，数据至少2条 */\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n\n    // 搜索数据至少两个数值列且搜索条数至少两条\n    if (searchResultStatistic && searchResultStatistic.measureColumns) {\n      if (searchResultStatistic.measureColumns.length > 1 && searchResultStatistic.queryResultCount > 1) {\n        satisfiedFlag = true;\n      }\n    }\n    return satisfiedFlag;\n  },\n  // 图形配置元素 [ * 必填项 ]\n  needAxis: {\n    // 默认yAxis是数值列 [数组]\n    'yAxis': {\n      i18nKey: \"chart-y-axis-title\",\n      //  Y轴显示名的key [ 非必填项 ]\n      allowMultiYAxis: false,\n      //  是否允许左右侧边Y轴 [ 非必填项 ]\n\n      /**\r\n       * 默认Y轴的数量 [ 非必填项 ]\r\n       * 允许系统默认图形配置元素后 ，\r\n       * needAxis中存在Y轴，默认Y轴的数量，—1时即所有的除Size以外的数值列 ；\r\n       * 如果为>0的数值，则取相应数量以内的数值列\r\n       */\n      defaultYAxisNumber: -1\n    }\n  },\n  /**\r\n   * 1. Y轴不允许为空\r\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let theErrorMsgKey = '';\n    if (!theAxisConfig) {\n      theErrorMsgKey = 'chart-axis-config-null-error';\n      return theErrorMsgKey;\n    }\n\n    // 2.Y轴不允许为空\n    if (!theAxisConfig.yAxis || !theAxisConfig.yAxis.length) {\n      theErrorMsgKey = 'chart-xy-axis-null';\n      return theErrorMsgKey;\n    }\n    return theErrorMsgKey;\n  },\n  /** 画图方法 **/\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n    let container = options.container;\n    const self = this;\n\n    // 使用皮尔逊相关系数法 ， 计算相关系数的数据\n    let coMatrix = []; //  相关系数对象矩阵\n    let theMinRelation = 0; //  最小的相关系数\n    let theMaxRelation = 1; //  最大的相关系数 [ 因为自己和自己是完全相关，所以最大值一定是1 ]\n    let globeNodeList = []; //  需要计算的列信息数组\n    function analysisData(data) {\n      if (!data || !data.headers || !data.columns) return false;\n      let headers = data.headers;\n      let columns = data.columns;\n      let curYAxis = options.chartAxis.curYAxis;\n      //统计所有数值列编号\n      let yAxisIdxList = [];\n      curYAxis && curYAxis.forEach(function (yAxis) {\n        yAxisIdxList.push(yAxis.idx);\n      });\n\n      //统计节点列 及 初始化邻接矩阵\n      for (let i = 0; i < yAxisIdxList.length; i++) {\n        let theYAxisHeader = headers && headers[yAxisIdxList[i]];\n        if (!theYAxisHeader) break;\n        globeNodeList.push({\n          idx: yAxisIdxList[i],\n          name: theYAxisHeader.displayName || theYAxisHeader.col_name,\n          data_type: theYAxisHeader.data_type\n        });\n      }\n\n      //初始化邻接矩阵, 中间线值是1，其他初始化为0\n      for (let i = 0; i < globeNodeList.length; i++) {\n        coMatrix[i] = [];\n        for (let j = 0; j < globeNodeList.length; j++) {\n          if (i === j) coMatrix[i][j] = 1;else coMatrix[i][j] = 0;\n        }\n      }\n      //使用皮尔逊相关系数法，计算两两节点间的相关系数\n      for (let i = 0; i < globeNodeList.length; i++) {\n        for (let j = i + 1; j < globeNodeList.length; j++) {\n          let qNode = globeNodeList[i];\n          let pNode = globeNodeList[j];\n          //计算q节点的期望 和 计算p节点的期望\n          let qExpectation = 0;\n          let pExpectation = 0;\n          for (let k = 0; k < columns.length; k++) {\n            let curRow = columns[k];\n            let qValue = curRow[qNode.idx] * 1.0;\n            qExpectation += qValue;\n            let pValue = curRow[pNode.idx] * 1.0;\n            pExpectation += pValue;\n          }\n          if (columns.length > 0) qExpectation = qExpectation / columns.length;\n          if (columns.length > 0) pExpectation = pExpectation / columns.length;\n\n          //计算q节点的标准差 和 计算p节点的标准差\n          let qStandardDeviation = 0;\n          let pStandardDeviation = 0;\n          for (let k = 0; k < columns.length; k++) {\n            let curRow = columns[k];\n            let qValue = curRow[qNode.idx] * 1.0;\n            qStandardDeviation += (qValue - qExpectation) * (qValue - qExpectation);\n            let pValue = curRow[pNode.idx] * 1.0;\n            pStandardDeviation += (pValue - pExpectation) * (pValue - pExpectation);\n          }\n          qStandardDeviation = Math.sqrt(qStandardDeviation);\n          pStandardDeviation = Math.sqrt(pStandardDeviation);\n\n          //计算q节点和p节点的协方差\n          let covariance = 0;\n          for (let k = 0; k < columns.length; k++) {\n            let curRow = columns[k];\n            let pValue = curRow[pNode.idx] * 1.0;\n            let qValue = curRow[qNode.idx] * 1.0;\n            covariance += (qValue - qExpectation) * (pValue - pExpectation);\n          }\n\n          // 计算相关系数值\n          let r = 0;\n          if (qStandardDeviation !== 0 && pStandardDeviation !== 0) {\n            r = covariance / (qStandardDeviation * pStandardDeviation);\n            theMinRelation = Math.min(theMinRelation, r);\n            theMaxRelation = Math.max(theMaxRelation, r);\n          }\n          coMatrix[i][j] = coMatrix[j][i] = r;\n        }\n      }\n    }\n    analysisData(options.datas);\n    if (!globeNodeList && !globeNodeList.length) {\n      console.log('没有有效的数据');\n      return false;\n    }\n\n    // 计算聚类排序的数据\n    let hClustTree;\n    let neoIdxList = [];\n    function hClustSort(matrix) {\n      let neoMatrix = [],\n        lenMatrix = matrix.length;\n      let nodeList = [];\n      for (let i = 0; i < lenMatrix; i++) {\n        let nd = {\n          member: [i],\n          children: []\n        };\n        nodeList.push(nd);\n      }\n      let avoidEndless = 0;\n      while (true) {\n        avoidEndless++;\n        if (avoidEndless > 3000) break;\n        let mergeI,\n          mergeJ,\n          maxRelative = -100;\n        for (let i = 0; i < nodeList.length; i++) {\n          for (let j = i + 1; j < nodeList.length; j++) {\n            let curNdI = nodeList[i],\n              curNdJ = nodeList[j];\n            let tempRelative = 0;\n            for (let l = 0; l < curNdI.member.length; l++) {\n              for (let k = 0; k < curNdJ.member.length; k++) {\n                let tpi = curNdI.member[l],\n                  tpj = curNdJ.member[k];\n                if (matrix[tpi][tpj]) tempRelative += matrix[tpi][tpj];\n              }\n            }\n            tempRelative = tempRelative / (curNdI.member.length * curNdJ.member.length);\n            if (tempRelative > maxRelative) {\n              maxRelative = tempRelative;\n              mergeI = i;\n              mergeJ = j;\n            }\n          }\n        }\n        let neoNd = {\n          member: [],\n          children: []\n        };\n        neoNd.distance = maxRelative;\n        nodeList[mergeI].member.forEach(function (m) {\n          neoNd.member.push(m);\n        });\n        nodeList[mergeJ].member.forEach(function (m) {\n          neoNd.member.push(m);\n        });\n        neoNd.children.push(nodeList[mergeI]);\n        neoNd.children.push(nodeList[mergeJ]);\n        nodeList.splice(mergeJ, 1);\n        nodeList.splice(mergeI, 1);\n        nodeList.push(neoNd);\n        if (nodeList.length === 1) break;\n      }\n      let root = nodeList[0];\n      hClustTree = root;\n      function deepSearch(nd) {\n        if (nd.children.length === 0) {\n          neoIdxList.push(nd.member[0]);\n        } else {\n          let forStable = true;\n          nd.children[0].member.forEach(function (ml) {\n            nd.children[1].member.forEach(function (mr) {\n              if (ml < mr) forStable = false;\n            });\n          });\n          //forStable=false;\n          if (forStable) {\n            deepSearch(nd.children[1]);\n            deepSearch(nd.children[0]);\n          } else {\n            deepSearch(nd.children[0]);\n            deepSearch(nd.children[1]);\n          }\n        }\n      }\n      deepSearch(root);\n      neoIdxList = neoIdxList.reverse();\n      for (let i = 0; i < lenMatrix; i++) {\n        for (let j = 0; j < lenMatrix; j++) {\n          if (!neoMatrix[i]) neoMatrix[i] = [];\n          neoMatrix[i][j] = matrix[neoIdxList[i]][neoIdxList[j]];\n        }\n      }\n      let neoIdxValueMap = {},\n        theNewNodeList = [];\n      for (let i = 0; i < neoIdxList.length; i++) {\n        let theNodeIndex = neoIdxList[i];\n        neoIdxValueMap[i] = globeNodeList[theNodeIndex];\n        theNewNodeList.push(globeNodeList[theNodeIndex]);\n      }\n      globeNodeList = theNewNodeList;\n      return neoMatrix;\n    }\n    let labelFontSize = 10;\n    let displayType = \"normal\";\n    let rectType = \"rect\";\n    let poleColorZero = \"#ffffff\";\n    let poleColorPositive = \"#1f3b6f\"; //  正数比例尺的颜色\n    let poleColorNegative = \"#cb4136\"; //  负数比例尺的颜色\n    let labelColor = \"#fff\"; //  标签颜色\n    let showLabelFlag = true;\n    let labelText = \"%_VALUE\";\n    let suspendText = \"%_LABEL_X  %_BR %_LABEL_Y %_BR %_VALUE\";\n    let addRect = 0;\n    let addRectList = [];\n    let addRectCount = 0;\n    let isHCluster = false; //  是否基于聚类排序\n    let addRectWidth = 2;\n    let addRectColor = \"#cb4136\"; //  聚类排序颜色\n    let rotate;\n    let maxLabelHeightPercent = 0.2; //  水平方向的属性标签名占的最大高度百分比\n    let maxLabelWidthPercent = 0.2; //  垂直方向的属性标签名占的最大宽度百分比\n    let highLightColor = \"#feb41c\";\n    let gridLineWidth = 1; //  网格线宽度\n    let gridLineColor = \"#fafafb\"; //  网格线颜色\n\n    if (options.chartConfigures) {\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.font_size_label)) {\n        labelFontSize = parseInt(options.chartConfigures.font_size_label);\n      }\n      if (options.chartConfigures.correlation_method) {\n        switch (options.chartConfigures.correlation_method) {\n          case \"option_correlation_method_upper\":\n            displayType = \"upper\";\n            break;\n          case \"option_correlation_method_lower\":\n            displayType = \"lower\";\n            break;\n          case \"option_correlation_method_normal\":\n          default:\n            displayType = \"normal\";\n            break;\n        }\n      }\n      if (options.chartConfigures.correlation_rect_type) {\n        switch (options.chartConfigures.correlation_rect_type) {\n          case \"option_correlation_rect_type_color\":\n            rectType = \"rect\";\n            break;\n          case \"option_correlation_rect_type_circle\":\n            rectType = \"circle\";\n            break;\n          default:\n            rectType = \"rect\";\n            break;\n        }\n      }\n      if (options.chartConfigures.correlation_positive_color) {\n        poleColorPositive = options.chartConfigures.correlation_positive_color;\n        poleColorPositive = _DataFocusMethod.rgba2Hex(poleColorPositive, true);\n      }\n      if (options.chartConfigures.correlation_negative_color) {\n        poleColorNegative = options.chartConfigures.correlation_negative_color;\n        poleColorNegative = _DataFocusMethod.rgba2Hex(poleColorNegative, true);\n      }\n\n      // 显示标签\n      if (options.chartConfigures.label_text_visible) {\n        showLabelFlag = true;\n      }\n      if (options.chartConfigures.label_text_color) {\n        labelColor = options.chartConfigures.label_text_color;\n      }\n      if (options.chartConfigures.label_text_regex) {\n        labelText = options.chartConfigures.label_text_regex;\n      }\n      if (options.chartConfigures.suspend_text_regex) {\n        suspendText = options.chartConfigures.suspend_text_regex;\n      }\n\n      // 聚类排序\n      if (options.chartConfigures.correlative_sort_visible) {\n        isHCluster = options.chartConfigures.correlative_sort_visible;\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.correlation_add_rect)) {\n        addRect = parseInt(options.chartConfigures.correlation_add_rect);\n      }\n      if (options.chartConfigures.correlation_add_rect_color) {\n        addRectColor = options.chartConfigures.correlation_add_rect_color;\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.correlation_add_rect_width)) {\n        addRectWidth = parseInt(options.chartConfigures.correlation_add_rect_width);\n      }\n\n      // 网格线配置\n      if (options.chartConfigures.grid_color) {\n        gridLineColor = options.chartConfigures.grid_color;\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.grid_width)) {\n        gridLineWidth = parseInt(options.chartConfigures.grid_width);\n        gridLineWidth = Math.max(gridLineWidth, 0);\n      }\n\n      // 数值刻度的倾斜角度\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.correlation_axis_revolve)) {\n        rotate = parseInt(options.chartConfigures.correlation_axis_revolve);\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.attribute_label_max_height)) {\n        maxLabelHeightPercent = parseFloat(options.chartConfigures.attribute_label_max_height);\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.attribute_label_max_width)) {\n        maxLabelWidthPercent = parseFloat(options.chartConfigures.attribute_label_max_width);\n      }\n    }\n\n    //处理聚类排序\n    function findGroup(nd) {\n      if (nd.children.length === 0) return;\n      let smallerNd, biggerNd;\n      if (!nd.children[0].distance) {\n        smallerNd = nd.children[0];\n        biggerNd = nd.children[1];\n      } else if (!nd.children[1].distance) {\n        smallerNd = nd.children[1];\n        biggerNd = nd.children[0];\n      } else if (nd.children[0].distance < nd.children[1].distance) {\n        smallerNd = nd.children[0];\n        biggerNd = nd.children[1];\n      } else {\n        smallerNd = nd.children[1];\n        biggerNd = nd.children[0];\n      }\n      addRectList[addRectCount] = smallerNd.member;\n      addRectCount++;\n      if (addRectCount === addRect - 1) {\n        addRectList[addRectCount] = biggerNd.member;\n      } else {\n        findGroup(biggerNd);\n      }\n    }\n    if (isHCluster) {\n      coMatrix = hClustSort(coMatrix);\n      if (addRect > neoIdxList.length) addRect = neoIdxList.length;\n      if (addRect > 1) {\n        findGroup(hClustTree);\n      } else if (addRect === 1) {\n        addRectList[0] = hClustTree.member;\n      }\n    }\n\n    // 准备画图容器 ， 绘制标题元素等\n    let d3 = options.plugins.d3,\n      currentChart = options.currentChart,\n      chartAxis = options.chartAxis;\n    currentChart.clearChartSvg();\n    let containerResult = _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"].containerOp.executeContainer({\n      hideTimeBarFlag: true,\n      drawWidth: $(container).width(),\n      drawHeight: $(container).height(),\n      isLegendFlag: false,\n      hideAxisYTitleFlag: true,\n      hideAxisXTitleFlag: true,\n      container: container,\n      currentChart: currentChart,\n      chartAxis: chartAxis,\n      fontSize: labelFontSize\n    });\n    if (!containerResult || !containerResult.svgDiv) return false;\n    let svg = d3.select(containerResult.svgDiv.find(\"svg\")[0]);\n    svg.style(\"font-size\", labelFontSize + \"px\");\n    svg.style(\"font-weight\", \"normal\");\n\n    // 获取画图区域的总宽高\n    let totalWidth = containerResult.svgJQ.width(),\n      totalHeight = containerResult.svgJQ.height();\n    /**\r\n     * @20221229以前目前矩阵热力图画图的规则是将相关系数矩阵放在画图区域中间，上下间隔一致；左右间隔一致，没有将上侧和左侧刻度宽度计算在内\r\n     *\r\n     * 最新的规则，将所有属性刻度的最大长度计算出来，通过这个长度计算剩余空间中的宽高来计算单元格宽度及左右的偏移量\r\n     * */\n    let theMaxLabelWidth = 0,\n      theMaxLabelHeight = 0,\n      currentLabelTextList = [];\n    globeNodeList && globeNodeList.forEach(function (node) {\n      let theTextSize = currentChart.getStrSizeByCanvas('string', node.name, {\n        fontSize: labelFontSize\n      });\n      theMaxLabelWidth = Math.max(theMaxLabelWidth, theTextSize.width);\n      theMaxLabelHeight = Math.max(theMaxLabelHeight, theTextSize.height);\n      currentLabelTextList.push(node.name);\n    });\n    // 计算矩阵的总宽度[ 矩阵图形是一个正方形 ]\n    let theOffsetWidth = Math.min(theMaxLabelWidth, totalWidth * maxLabelWidthPercent),\n      theOffsetHeight = Math.min(theMaxLabelWidth, totalHeight * maxLabelHeightPercent),\n      theScaleDomWidth = 0,\n      //  比例尺元素的宽度\n      theScaleDomHeight = 0; //  比例尺元素的高度\n    // 颜色比例尺放在右侧\n    theScaleDomWidth += labelFontSize; //  比例尺高度\n    theScaleDomWidth += 10; //  比例尺标签线及间隔\n\n    let theLabelSize = currentChart.getStrSizeByCanvas('string', '0.60', {\n      fontSize: labelFontSize\n    });\n    theScaleDomWidth += theLabelSize.width; //  比例尺标签宽度\n\n    // 预留10的空隙[ 这个10是水平刻度标签与图形中间的间隔及图形与颜色比例尺的间隔之和 ]\n    let theRectTotalWidth = Math.min(totalWidth - theOffsetWidth - theScaleDomWidth - (currentLabelTextList.length + 1) * gridLineWidth - 10, totalHeight - theOffsetHeight - theScaleDomHeight - (currentLabelTextList.length + 1) * gridLineWidth - 10),\n      theRectTotalWidthWidthBorder = theRectTotalWidth + (currentLabelTextList.length + 1) * gridLineWidth;\n\n    // 画垂直方向的刻度坐标尺【 左侧刻度 】\n    let verticalAttrContainer, horizontalAttrContainer, theTopOffsetHeight, theLeftOffsetWidth, theMatrixContainer;\n\n    // 正三角的热力图， 横线属性轴在顶部 ， 纵向属性轴在右侧\n    if (displayType === 'upper') {\n      console.log(\"上三角状态\");\n      // 1. 先画右侧属性轴 [ 因为顶部属性轴的高度不确定 ]\n      verticalAttrContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawVerticalAttributeAxis(currentLabelTextList, {\n        currentChart: currentChart,\n        position: 'right',\n        type: 'dotline',\n        container: svg[0][0],\n        fontSize: labelFontSize,\n        height: theRectTotalWidthWidthBorder,\n        maxWidth: totalWidth * maxLabelWidthPercent,\n        labelStepHeight: theMaxLabelHeight,\n        padding: gridLineWidth,\n        outPadding: gridLineWidth\n      });\n      // 画水平方向的刻度坐标尺 【 顶部刻度 】\n      // 2. 再画顶部属性轴 [ 因为左侧属性轴的宽度可以通过getStrSizeByCanvas确定，顶部偏移由顶部属性轴确定 ]\n      horizontalAttrContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawHorizontalAttributeAxis(currentLabelTextList, {\n        currentChart: currentChart,\n        position: 'top',\n        type: 'dotline',\n        container: svg[0][0],\n        fontSize: labelFontSize,\n        width: theRectTotalWidthWidthBorder,\n        maxHeight: totalHeight * maxLabelHeightPercent,\n        labelStepWidth: 20,\n        rotate: rotate,\n        padding: gridLineWidth,\n        outPadding: gridLineWidth\n      });\n\n      // 调整顶部属性轴 及 左侧属性轴的位置\n      // [ 顶部的偏移量计算 = 总画图高度 - （数据标签高度 + 热力块及边框总高度 + 模块的间隔和[标签与热力块的间隔5 + 热力块与比例尺的间隔5] + 比例尺颜色高度 ） ] (间隔5是通过计算theRectTotalWidth时，垂直方向预留了10个元素， 给两个间隔，每个间隔5 )\n      // [ 左侧的偏移量计算 = 总画图宽度 - （数据标签宽度 + 热力块及边框总宽度 + 模块的间隔和[标签与热力块的间隔5 + 热力块与比例尺的间隔5 ] + 比例尺颜色宽度 ） ] (间隔10是通过计算theRectTotalWidth时，水平方向预留了10个元素，给两个间隔，每个间隔5 )\n      theTopOffsetHeight = Math.max(0, (totalHeight - (horizontalAttrContainer.maxLabelHeight + theRectTotalWidthWidthBorder + (theScaleDomHeight ? 10 : 5) + theScaleDomHeight)) / 2); // 整个图形的左右的偏移量\n      theLeftOffsetWidth = Math.max(0, (totalWidth - (verticalAttrContainer.maxLabelWidth + theRectTotalWidthWidthBorder + (theScaleDomWidth ? 10 : 5) + theScaleDomWidth)) / 2); // 整个图形顶部的偏移量\n      horizontalAttrContainer.attributeContainer.attr(\"transform\", \"translate(\" + theLeftOffsetWidth + \" , \" + theTopOffsetHeight + \")\");\n      verticalAttrContainer.attributeContainer.attr(\"transform\", \"translate(\" + (theLeftOffsetWidth + theRectTotalWidthWidthBorder + 5) + \" , \" + (theTopOffsetHeight + horizontalAttrContainer.maxLabelHeight + 5) + \" )\");\n\n      // 3. 画热力矩阵\n      theMatrixContainer = svg.append(\"g\").attr(\"class\", \"hot-matrix-container\").attr(\"transform\", \"translate(\" + theLeftOffsetWidth + \",\" + (theTopOffsetHeight + horizontalAttrContainer.maxLabelHeight + 5) + \")\");\n    }\n    // 下三角的热力图， 横线属性轴在底部 ， 纵向属性轴在左侧\n    else if (displayType === 'lower') {\n      console.log(\"下三角状态\");\n      // 1. 先画右侧属性轴 [ 因为顶部属性轴的高度不确定 ]\n      verticalAttrContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawVerticalAttributeAxis(currentLabelTextList, {\n        currentChart: currentChart,\n        position: 'left',\n        type: 'dotline',\n        container: svg[0][0],\n        fontSize: labelFontSize,\n        height: theRectTotalWidthWidthBorder,\n        maxWidth: totalWidth * maxLabelWidthPercent,\n        labelStepHeight: theMaxLabelHeight,\n        padding: gridLineWidth,\n        outPadding: gridLineWidth\n      });\n      // 画水平方向的刻度坐标尺 【 顶部刻度 】\n      // 2. 再画顶部属性轴 [ 因为左侧属性轴的宽度可以通过getStrSizeByCanvas确定，顶部偏移由顶部属性轴确定 ]\n      horizontalAttrContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawHorizontalAttributeAxis(currentLabelTextList, {\n        currentChart: currentChart,\n        position: 'bottom',\n        type: 'dotline',\n        container: svg[0][0],\n        fontSize: labelFontSize,\n        width: theRectTotalWidthWidthBorder,\n        maxHeight: totalHeight * maxLabelHeightPercent,\n        labelStepWidth: 20,\n        rotate: rotate,\n        padding: gridLineWidth,\n        outPadding: gridLineWidth\n      });\n\n      // 调整顶部属性轴 及 左侧属性轴的位置\n      // [ 顶部的偏移量计算 = 总画图高度 - （数据标签高度 + 热力块及边框总高度 + 模块的间隔和[标签与热力块的间隔5 + 热力块与比例尺的间隔5] + 比例尺颜色高度 ） ] (间隔5是通过计算theRectTotalWidth时，垂直方向预留了10个元素， 给两个间隔，每个间隔5 )\n      // [ 左侧的偏移量计算 = 总画图宽度 - （数据标签宽度 + 热力块及边框总宽度 + 模块的间隔和[标签与热力块的间隔5 + 热力块与比例尺的间隔5 ] + 比例尺颜色宽度 ） ] (间隔10是通过计算theRectTotalWidth时，水平方向预留了10个元素，给两个间隔，每个间隔5 )\n      theTopOffsetHeight = Math.max(0, (totalHeight - (horizontalAttrContainer.maxLabelHeight + theRectTotalWidthWidthBorder + (theScaleDomHeight ? 10 : 5) + theScaleDomHeight)) / 2); // 整个图形的左右的偏移量\n      theLeftOffsetWidth = Math.max(0, (totalWidth - (verticalAttrContainer.maxLabelWidth + theRectTotalWidthWidthBorder + (theScaleDomWidth ? 10 : 5) + theScaleDomWidth)) / 2); // 整个图形顶部的偏移量\n      horizontalAttrContainer.attributeContainer.attr(\"transform\", \"translate(\" + (theLeftOffsetWidth + verticalAttrContainer.maxLabelWidth + 5) + \" , \" + (theTopOffsetHeight + theRectTotalWidthWidthBorder + 5) + \")\");\n      verticalAttrContainer.attributeContainer.attr(\"transform\", \"translate(\" + theLeftOffsetWidth + \" , \" + theTopOffsetHeight + \" )\");\n\n      // 3. 画热力矩阵\n      theMatrixContainer = svg.append(\"g\").attr(\"class\", \"hot-matrix-container\").attr(\"transform\", \"translate(\" + (theLeftOffsetWidth + verticalAttrContainer.maxLabelWidth + 5) + \",\" + theTopOffsetHeight + \")\");\n    }\n    // 正方形的热力图 ， 横向属性轴在底部 ， 纵向属性轴在左侧\n    else {\n      // 1. 先画左侧属性轴 [ 因为顶部属性轴的高度不确定（粗略计算为属性轴垂直的高度） ]\n      verticalAttrContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawVerticalAttributeAxis(currentLabelTextList, {\n        currentChart: currentChart,\n        position: 'left',\n        type: 'dotline',\n        container: svg[0][0],\n        fontSize: labelFontSize,\n        height: theRectTotalWidthWidthBorder,\n        maxWidth: totalWidth * maxLabelWidthPercent,\n        labelStepHeight: theMaxLabelHeight,\n        padding: gridLineWidth,\n        outPadding: gridLineWidth\n      });\n      // 画水平方向的刻度坐标尺 【 顶部刻度 】\n      // 2. 再画底部属性轴 [ 因为左侧属性轴的宽度可以通过getStrSizeByCanvas确定，顶部偏移由顶部属性轴确定 ]\n      horizontalAttrContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawHorizontalAttributeAxis(currentLabelTextList, {\n        currentChart: currentChart,\n        position: 'bottom',\n        type: 'dotline',\n        container: svg[0][0],\n        fontSize: labelFontSize,\n        width: theRectTotalWidthWidthBorder,\n        maxHeight: totalHeight * maxLabelHeightPercent,\n        labelStepWidth: 20,\n        rotate: rotate,\n        padding: gridLineWidth,\n        outPadding: gridLineWidth\n      });\n\n      // 调整顶部属性轴 及 左侧属性轴的位置\n      // [ 顶部的偏移量计算 = 总画图高度 - （数据标签高度 + 热力块及边框总高度 + 模块的间隔和[标签与热力块的间隔5 + 热力块与比例尺的间隔5] + 比例尺颜色高度 ） ] (间隔5是通过计算theRectTotalWidth时，垂直方向预留了10个元素， 给两个间隔，每个间隔5 )\n      // [ 左侧的偏移量计算 = 总画图宽度 - （数据标签宽度 + 热力块及边框总宽度 + 模块的间隔和[标签与热力块的间隔5 + 热力块与比例尺的间隔5 ] + 比例尺颜色宽度 ） ] (间隔10是通过计算theRectTotalWidth时，水平方向预留了10个元素，给两个间隔，每个间隔5 )\n      theTopOffsetHeight = Math.max(0, (totalHeight - (horizontalAttrContainer.maxLabelHeight + theRectTotalWidthWidthBorder + (theScaleDomHeight ? 10 : 5) + theScaleDomHeight)) / 2); // 整个图形的左右的偏移量\n      theLeftOffsetWidth = Math.max(0, (totalWidth - (verticalAttrContainer.maxLabelWidth + theRectTotalWidthWidthBorder + (theScaleDomWidth ? 10 : 5) + theScaleDomWidth)) / 2); // 整个图形顶部的偏移量\n      horizontalAttrContainer.attributeContainer.attr(\"transform\", \"translate(\" + (verticalAttrContainer.maxLabelWidth + theLeftOffsetWidth) + \" , \" + (theTopOffsetHeight + theRectTotalWidthWidthBorder) + \")\");\n      verticalAttrContainer.attributeContainer.attr(\"transform\", \"translate(\" + theLeftOffsetWidth + \" , \" + theTopOffsetHeight + \" )\");\n\n      // 3. 画热力矩阵\n      theMatrixContainer = svg.append(\"g\").attr(\"class\", \"hot-matrix-container\").attr(\"transform\", \"translate(\" + (theLeftOffsetWidth + verticalAttrContainer.maxLabelWidth + 5) + \",\" + theTopOffsetHeight + \")\");\n    }\n    window.d3 = d3;\n    // 绘制热力块\n    let hotColorPositive = function (num) {\n      let startColor = d3.rgb(d3.interpolate(d3.rgb(poleColorZero), d3.rgb(poleColorPositive))(0.1)),\n        endColor = d3.rgb(poleColorPositive);\n      let theColor = d3.rgb(startColor.r + (endColor.r - startColor.r) * Math.pow(num, 2), startColor.g + (endColor.g - startColor.g) * Math.pow(num, 1.2), startColor.b + (endColor.b - startColor.b) * Math.pow(num, 0.8));\n      return theColor;\n    };\n    let hotColorNegative = function (num) {\n      let startColor = d3.rgb(d3.interpolate(d3.rgb(poleColorZero), d3.rgb(poleColorNegative))(0.1)),\n        endColor = d3.rgb(poleColorNegative);\n      let theColor = d3.rgb(startColor.r + (endColor.r - startColor.r) * Math.pow(num / theMinRelation, 1), startColor.g + (endColor.g - startColor.g) * Math.pow(num / theMinRelation, 1), startColor.b + (endColor.b - startColor.b) * Math.pow(num / theMinRelation, 1));\n      return theColor;\n    };\n    for (let i = 0; i < coMatrix.length; i++) {\n      let theRowData = coMatrix[i];\n      let theRowContainer = theMatrixContainer && theMatrixContainer.append(\"g\").attr(\"class\", \"matrix-row-container\").attr(\"transform\", \"translate(0 , \" + verticalAttrContainer.scale(currentLabelTextList[i]) + \")\");\n      for (let j = 0; j < theRowData.length; j++) {\n        let theCellData = theRowData[j];\n        if (displayType === 'upper') {\n          if (i > j) continue;\n        } else if (displayType === 'lower') {\n          if (j > i) continue;\n        }\n        let theBackgroundColor;\n        if (theCellData >= 0) {\n          theBackgroundColor = hotColorPositive(theCellData);\n        } else {\n          theBackgroundColor = hotColorNegative(theCellData);\n        }\n        let theRectDom = theRowContainer.append(\"g\").attr(\"class\", \"matrix-cell-dom\").attr(\"transform\", \"translate(\" + horizontalAttrContainer.scale(currentLabelTextList[j]) + \" , 0 )\");\n        let theHotMatrixDom;\n        if (rectType === 'circle') {\n          theHotMatrixDom = theRectDom.append(\"circle\").attr(\"class\", 'matrix-cell-rect').attr(\"cx\", horizontalAttrContainer.rangeBand / 2).attr(\"cy\", verticalAttrContainer.rangeBand / 2).attr(\"r\", verticalAttrContainer.rangeBand / 2);\n        } else {\n          theHotMatrixDom = theRectDom.append(\"rect\").attr(\"class\", 'matrix-cell-rect').attr(\"width\", horizontalAttrContainer.rangeBand).attr(\"height\", verticalAttrContainer.rangeBand);\n        }\n        theHotMatrixDom.attr(\"row\", i).attr(\"column\", j).attr(\"stroke-width\", 0).attr(\"color\", theBackgroundColor).attr(\"fill\", theBackgroundColor).on(\"mouseover\", function () {\n          let theDom = d3.select(this),\n            i = theDom.attr(\"row\"),\n            j = theDom.attr(\"column\");\n          theDom.style(\"fill\", highLightColor);\n          let theData = coMatrix[i] && coMatrix[i][j],\n            theLabelX = currentLabelTextList[i],\n            theLabelY = currentLabelTextList[j];\n          let theSuspendText = self.chartConfigureAdvanced.translateMacro(suspendText, {\n            value: theData,\n            labelX: theLabelX,\n            labelY: theLabelY\n          });\n          // 显示悬浮文本\n          currentChart.positionChartPrompt(d3.event, theSuspendText);\n        }).on(\"mouseout\", function () {\n          d3.selectAll(\".matrix-cell-rect\").style(\"fill\", function () {\n            let theDom = d3.select(this);\n            theDom.attr(\"color\");\n          });\n\n          // 清除悬浮文本\n          currentChart.clearChartPrompt();\n        });\n        if (showLabelFlag) {\n          theRectDom.append(\"text\").attr(\"class\", \"text showLabels\").attr(\"text-anchor\", \"middle\").attr(\"transform\", \"translate(\" + horizontalAttrContainer.rangeBand / 2 + \" , \" + (verticalAttrContainer.rangeBand / 2 + theMaxLabelHeight * 1 / 3) + \")\").attr(\"row\", i).attr(\"column\", j).style(\"pointer-events\", \"none\").style(\"fill\", labelColor || \"inherit\").text(function () {\n            let theDom = d3.select(this),\n              i = theDom.attr(\"row\"),\n              j = theDom.attr(\"column\");\n            let theData = coMatrix[i] && coMatrix[i][j],\n              theLabelX = currentLabelTextList[i],\n              theLabelY = currentLabelTextList[j];\n            let theLabelRegex = self.chartConfigureAdvanced.translateMacro(labelText, {\n              value: _DataFocusMethod.formatData(theData),\n              labelX: theLabelX,\n              labelY: theLabelY\n            });\n\n            // 如果当前标签宽度超过了单元格的宽度，则截取\n            let theTextSize = currentChart.getStrSizeByCanvas('string', theLabelRegex, {\n              fontSize: labelFontSize\n            });\n            if (theTextSize.width - 5 > horizontalAttrContainer.rangeBand) {\n              let theSubText = '';\n              for (let i = 0; i < theLabelRegex.length; i++) {\n                let chart = theLabelRegex.charAt(i);\n                theSubText += chart;\n                let theSubTextSize = currentChart.getStrSizeByCanvas('string', theSubText, {\n                  fontSize: options.fontSize\n                });\n                if (theSubTextSize.width > horizontalAttrContainer.rangeBand) {\n                  break;\n                }\n              }\n              if (theSubText.length === theLabelRegex.length) {\n                return theLabelRegex;\n              } else {\n                theSubText = theSubText.substring(0, theSubText.length - 1);\n                return theSubText + '..';\n              }\n            }\n            return theLabelRegex;\n          });\n        }\n      }\n    }\n\n    // 绘制网格线[ 网格线宽度及网格线颜色 ]\n    if (gridLineWidth) {\n      let theGridContainer = theMatrixContainer.append(\"g\").attr(\"class\", \"matrix-grid-container\").attr(\"transform\", \"translate(0 , 0)\");\n      // 横向的网格线\n      for (let i = 0; i <= coMatrix.length; i++) {\n        let theStartIndex,\n          theWidthNumber = 0;\n        // 上三角\n        if (displayType === 'upper') {\n          theStartIndex = Math.max(i - 1, 0);\n          theWidthNumber = Math.min(coMatrix.length + 1 - i, coMatrix.length);\n        }\n        // 下三角\n        else if (displayType === 'lower') {\n          theStartIndex = 0;\n          theWidthNumber = Math.min(i + 1, coMatrix.length);\n        } else {\n          theStartIndex = 0;\n          theWidthNumber = coMatrix.length;\n        }\n        theGridContainer.append(\"line\").attr(\"class\", \"grid-horizontal-line\").attr(\"theStartIndex\", theStartIndex).attr(\"theWidthNumber\", theWidthNumber).attr(\"x1\", theStartIndex * horizontalAttrContainer.rangeBand + theStartIndex * gridLineWidth).attr(\"x2\", theStartIndex * horizontalAttrContainer.rangeBand + theStartIndex * gridLineWidth + theWidthNumber * horizontalAttrContainer.rangeBand + theWidthNumber * gridLineWidth + (i === coMatrix.length ? gridLineWidth : 0)).attr(\"y1\", i * verticalAttrContainer.rangeBand + i * gridLineWidth + gridLineWidth / 2).attr(\"y2\", i * verticalAttrContainer.rangeBand + i * gridLineWidth + gridLineWidth / 2).attr(\"stroke-width\", gridLineWidth).attr(\"stroke\", gridLineColor);\n      }\n      // 纵向的网格线\n      for (let i = 0; i <= coMatrix.length; i++) {\n        let theStartIndex,\n          theHeightNumber = 0;\n        // 上三角\n        if (displayType === 'upper') {\n          theStartIndex = 0;\n          theHeightNumber = Math.min(i + 1, coMatrix.length);\n        }\n        // 下三角\n        else if (displayType === 'lower') {\n          theStartIndex = Math.max(i - 1, 0);\n          theHeightNumber = Math.min(coMatrix.length + 1 - i, coMatrix.length);\n        } else {\n          theStartIndex = 0;\n          theHeightNumber = coMatrix.length;\n        }\n        theGridContainer.append(\"line\").attr(\"class\", \"grid-vertical-line\").attr(\"theStartIndex\", theStartIndex).attr(\"theHeightNumber\", theHeightNumber).attr(\"x1\", i * horizontalAttrContainer.rangeBand + i * gridLineWidth + gridLineWidth / 2).attr(\"x2\", i * horizontalAttrContainer.rangeBand + i * gridLineWidth + gridLineWidth / 2).attr(\"y1\", theStartIndex * verticalAttrContainer.rangeBand + theStartIndex * gridLineWidth).attr(\"y2\", theStartIndex * verticalAttrContainer.rangeBand + theStartIndex * gridLineWidth + theHeightNumber * verticalAttrContainer.rangeBand + theHeightNumber * gridLineWidth).attr(\"stroke-width\", gridLineWidth).attr(\"stroke\", gridLineColor);\n      }\n    }\n\n    // 在开启聚类排序后，绘制分组框[ 绘制个数依据分类组数 ]\n    if (addRectList && addRectList.length) {\n      let theGroupClusterContainer = theMatrixContainer.append(\"g\").attr(\"class\", \"group-cluster-grid-container\").attr(\"transform\", \"translate(0 , 0)\");\n      addRectList.forEach(function (nbs) {\n        let startIndex = neoIdxList.length,\n          endIndex = 0;\n        nbs.forEach(function (nbIndex) {\n          if (neoIdxList.indexOf(nbIndex) < startIndex) startIndex = neoIdxList.indexOf(nbIndex);\n          if (neoIdxList.indexOf(nbIndex) > endIndex) endIndex = neoIdxList.indexOf(nbIndex);\n        });\n        let x1 = startIndex * (horizontalAttrContainer.rangeBand + gridLineWidth);\n        let y1 = startIndex * (verticalAttrContainer.rangeBand + gridLineWidth);\n        let x2 = (endIndex + 1) * (horizontalAttrContainer.rangeBand + gridLineWidth) + gridLineWidth;\n        let y2 = (endIndex + 1) * (verticalAttrContainer.rangeBand + gridLineWidth) + gridLineWidth;\n        theGroupClusterContainer.append(\"path\").attr(\"class\", \"group-cluster-path-item\").attr(\"d\", function () {\n          let tempstr = \"M\" + x1 + \" \" + y1 + \" \";\n          tempstr += \"L\" + x2 + \" \" + y1 + \" \";\n          tempstr += \"L\" + x2 + \" \" + y2 + \" \";\n          tempstr += \"L\" + x1 + \" \" + y2 + \" \";\n          tempstr += \"L\" + x1 + \" \" + y1 + \" \";\n          return tempstr;\n        }).attr(\"fill\", \"none\").attr(\"stroke-width\", addRectWidth).attr(\"stroke\", addRectColor);\n      });\n    }\n\n    // 绘制左侧颜色比例尺[ 一直在图形的最右侧 ]\n    let theColorScaleContainer = svg.append(\"g\").attr(\"class\", \"color-scale-container\").attr(\"transform\", \"translate( \" + (theLeftOffsetWidth + theRectTotalWidthWidthBorder + verticalAttrContainer.maxLabelWidth + 10) + \" ,\" + (theTopOffsetHeight + (displayType === 'lower' || displayType === 'normal' ? 0 : horizontalAttrContainer.maxLabelHeight + 5)) + \")\");\n    let theColorScaleLabelList = ['1', '0.8', '0.6', '0.4', '0.2', '0'];\n    ['-0.2', '-0.4', '-0.6', '-0.8', '-1'].forEach(function (nbs) {\n      let theR = parseFloat(nbs);\n      if (Math.abs(theR / 0.2) <= Math.floor(Math.abs(theMinRelation / 0.2))) {\n        theColorScaleLabelList.push(nbs);\n      }\n    });\n    let defDom = svg.append(\"defs\");\n    let linerGradient;\n    linerGradient = defDom.append(\"linearGradient\").attr(\"id\", \"linearColor-positive\").attr(\"x1\", \"0%\").attr(\"y1\", \"0%\").attr(\"x2\", \"0%\").attr(\"y2\", \"100%\");\n    linerGradient.append(\"stop\").attr(\"offset\", \"0%\").style(\"stop-color\", poleColorPositive);\n    theColorScaleLabelList.forEach(function (nbs, index) {\n      let theR = parseFloat(nbs);\n      if (theR < 0) {\n        linerGradient.append(\"stop\").attr(\"offset\", 100 * (index + 1) / theColorScaleLabelList.length + \"%\").style(\"stop-color\", hotColorNegative(theR));\n      } else {\n        linerGradient.append(\"stop\").attr(\"offset\", 100 * (index + 1) / theColorScaleLabelList.length + \"%\").style(\"stop-color\", hotColorPositive(theR));\n      }\n    });\n    theColorScaleContainer.append(\"rect\").attr(\"x\", \"0\").attr(\"y\", \"0\").attr(\"width\", labelFontSize).attr(\"height\", theRectTotalWidthWidthBorder).attr(\"fill\", \"url(#\" + linerGradient.attr(\"id\") + \")\").attr(\"stroke-width\", 1).attr(\"stroke\", \"#000\");\n    let verticalScaleContainer = _pc_assets_js_common_CommonDrawAxis__WEBPACK_IMPORTED_MODULE_1__[\"default\"].drawVerticalAttributeAxis(theColorScaleLabelList, {\n      currentChart: currentChart,\n      position: 'right',\n      type: 'dotline',\n      container: theColorScaleContainer[0][0],\n      fontSize: labelFontSize,\n      height: theRectTotalWidthWidthBorder,\n      maxWidth: currentChart.getStrSizeByCanvas(\"string\", \"-0.895\", {\n        fontSize: labelFontSize\n      }).width,\n      labelStepHeight: theMaxLabelHeight,\n      padding: gridLineWidth,\n      outPadding: gridLineWidth\n    });\n    verticalScaleContainer.attributeContainer.attr(\"transform\", \"translate(\" + (labelFontSize + 5) + \" , 0)\");\n  },\n  // 当前图形的配置项[ *新增图形必填项 ]\n  chartConfigureList: [{\n    key: \"category_general\",\n    title: \"category_chart_general\",\n    options: [{\n      key: \"font_size_label\",\n      title: \"option_font_size_label\",\n      description: \"option_font_size_label_desc\",\n      type: \"input\",\n      defaultNumber: 10\n    }, {\n      key: \"correlation_method\",\n      title: \"option_correlation_method\",\n      description: \"option_correlation_method_desc\",\n      type: \"selectTile\",\n      selection: [\"option_correlation_method_normal\", \"option_correlation_method_upper\", \"option_correlation_method_lower\"],\n      defaultValue: \"option_correlation_method_normal\"\n    }, {\n      key: \"correlation_rect_type\",\n      title: \"option_correlation_rect_type\",\n      description: \"option_correlation_rect_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_correlation_rect_type_color\", \"option_correlation_rect_type_circle\"],\n      defaultValue: \"option_correlation_rect_type_color\"\n    }, {\n      key: \"correlation_positive_color\",\n      title: \"option_correlation_positive_color\",\n      description: \"option_correlation_positive_color_desc\",\n      type: \"color\",\n      defaultColor: \"#163369\",\n      hideAlpha: true\n    }, {\n      key: \"correlation_negative_color\",\n      title: \"option_correlation_negative_color\",\n      description: \"option_correlation_negative_color_desc\",\n      type: \"color\",\n      defaultColor: \"#cb4136\",\n      hideAlpha: true\n    }, {\n      key: \"correlation_high_light_color\",\n      title: \"option_correlation_high_light_color\",\n      description: \"option_correlation_high_light_color_desc\",\n      type: \"color\",\n      defaultColor: \"#feb41c\"\n    }]\n  },\n  // 聚类排序\n  {\n    key: \"category_sort\",\n    title: \"category_sort\",\n    options: [{\n      key: \"correlative_sort_visible\",\n      title: \"option_correlative_sort_visible\",\n      description: \"option_correlative_sort_visible_desc\",\n      type: 'checkbox'\n    }, {\n      key: \"correlation_add_rect\",\n      title: \"option_correlation_add_rect\",\n      description: \"option_correlation_add_rect_desc\",\n      type: \"input\",\n      min: 0,\n      max: 10,\n      defaultNumber: 0,\n      require: 'correlative_sort_visible'\n    }, {\n      key: \"correlation_add_rect_color\",\n      title: \"option_correlation_add_rect_color\",\n      description: \"option_correlation_add_rect_color_desc\",\n      type: 'color',\n      defaultColor: \"#cb4136\",\n      require: 'correlative_sort_visible'\n    }, {\n      key: \"correlation_add_rect_width\",\n      title: \"option_correlation_add_rect_width\",\n      description: \"option_correlation_add_rect_width_desc\",\n      type: \"input\",\n      min: 1,\n      max: 5,\n      defaultNumber: 2,\n      require: 'correlative_sort_visible'\n    }]\n  },\n  // 网格线配置\n  {\n    key: \"category_grid_line\",\n    title: \"category_grid_line\",\n    options: [{\n      key: \"grid_color\",\n      title: \"option_grid_color\",\n      description: \"option_grid_color_desc\",\n      type: \"color\",\n      defaultColor: \"#fafafb\"\n    }, {\n      key: \"grid_width\",\n      title: \"option_grid_width\",\n      description: \"option_grid_width_desc\",\n      type: \"input\",\n      defaultNumber: 1,\n      min: 0,\n      max: 5\n    }]\n  },\n  // 数值刻度配置\n  {\n    key: \"category_attribute_scale\",\n    title: \"category_attribute_scale\",\n    options: [\n    // 最大宽度\n    {\n      key: \"attribute_label_max_width\",\n      title: \"option_attribute_label_max_width\",\n      description: \"option_attribute_label_max_width_desc\",\n      type: \"input\",\n      min: 0,\n      max: 1,\n      step: 0.1,\n      defaultNumber: 0.2\n    },\n    // 最大高度\n    {\n      key: \"attribute_label_max_height\",\n      title: \"option_attribute_label_max_height\",\n      description: \"option_attribute_label_max_height_desc\",\n      type: \"input\",\n      min: 0,\n      max: 1,\n      step: 0.1,\n      defaultNumber: 0.2\n    },\n    // 倾斜角度\n    {\n      key: \"correlation_axis_revolve\",\n      title: \"option_correlation_axis_revolve\",\n      description: \"option_correlation_axis_revolve_desc\",\n      type: \"input\",\n      min: 0,\n      max: 90,\n      defaultNumber: 30\n    }]\n  },\n  // 数据标签\n  {\n    key: \"category_label\",\n    title: \"category_label\",\n    options: [{\n      key: \"label_text_visible\",\n      title: \"option_label_text_visible\",\n      description: \"option_label_text_visible_desc\",\n      type: 'checkbox',\n      defaultValue: true\n    }, {\n      key: \"label_text_color\",\n      title: \"option_label_text_color\",\n      description: \"option_label_text_color_desc\",\n      type: 'color',\n      require: 'label_text_visible',\n      defaultColor: \"#fff\"\n    }, {\n      key: \"label_text_regex\",\n      title: \"option_label_text_regex\",\n      description: \"option_label_text_regex_correlation_desc\",\n      type: \"chartRichText\",\n      require: 'label_text_visible'\n    }]\n  },\n  // 悬浮文本设置\n  {\n    key: \"category_suspend_text\",\n    title: \"category_suspend_text\",\n    options: [{\n      key: \"suspend_text_regex\",\n      title: \"option_suspend_text_regex\",\n      description: \"option_suspend_text_regex_correlation_desc\",\n      type: \"chartRichText\"\n    }]\n  }],\n  // 自定义宏\n  chartConfigureAdvanced: {\n    withoutColumnNFlag: true,\n    chartMacroList: [{\n      key: '%_VALUE',\n      nameKey: '%_VALUE',\n      descriptionKey: '%_VALUE_desc'\n    }, {\n      key: '%_LABEL_X',\n      nameKey: '%_LABEL_X',\n      descriptionKey: '%_LABEL_X_desc'\n    }, {\n      key: '%_LABEL_Y',\n      nameKey: '%_LABEL_Y',\n      descriptionKey: '%_LABEL_X_desc'\n    }, {\n      key: '%_BR',\n      nameKey: '%_BR',\n      descriptionKey: '%_BR_desc'\n    }],\n    // 依据当前配置，将 %_NAME:%_VALUE 转译成真实值显示\n    /**\r\n     * @param configMacroStr    -   用户配置的带宏的内容\r\n     * @param options\r\n     *          {\r\n     *              type        -\r\n     *\r\n     *              xLabel       -   图形单元对应的属性值 用于实现%_NAME %_CATEGORY_NAME\r\n     *              xLabelIndex  -   图形单元对应的属性索引，用于实现 %_CATEGORY_NUMBER\r\n     *              xLabelTotal  -   图形单元对应的属性上所有值的总和用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              xLabelNumber -   图形单元对应的属性上所有值的个数用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              yValue       -   图形单元对应的值 用于实现 %_VALUE\r\n     *              yAxis        -   图形单元对应的值列 用于实现 %_VALUE_NAME  %_SERIES_NAME\r\n     *              legend       -   图形单元对应的图例名(为空时说明是多Y轴) 用于实现 %_SERIES_NAME\r\n     *              legendIndex  -   图形单元对应的图例索引 用于实现 %_SERIES_NUMBER\r\n     *              legendTotal  -   图形单元对应的图例上所有值的总和,用于实现 %_PERCENT_OF_TOTAL\r\n     *              rowData -  图形单元对应的一整行数据 用于实现%_COLUMN_N的宏\r\n     *          }\r\n     * */\n    translateMacro: function (configMacroStr, options) {\n      options = options || {};\n      if (!configMacroStr) return false;\n      let macroRegex = /%(_[A-Z0-9]*){1,}/g;\n      let theMatchedTextValue = '',\n        matchedIndex = 0;\n      macroRegex.lastIndex = -1;\n      for (let i = 0, execResult; (execResult = macroRegex.exec(configMacroStr)) && i < 100; i++) {\n        if (!execResult || !execResult[0][0]) break;\n        let theMatchStr = execResult[0],\n          theMatchIndex = execResult.index;\n        theMatchedTextValue += configMacroStr.substring(matchedIndex, Math.max(theMatchIndex, matchedIndex));\n        switch (theMatchStr) {\n          case \"%_VALUE\":\n            theMatchedTextValue += options.value || '';\n            break;\n          case \"%_LABEL_X\":\n            theMatchedTextValue += options.labelX || '';\n            break;\n          case \"%_LABEL_Y\":\n            theMatchedTextValue += options.labelY || '';\n            break;\n          case \"%_BR\":\n            theMatchedTextValue += options.type === 'label' ? '\\n' : '<br/>';\n            break;\n          default:\n            if (theMatchStr.startsWith(\"%_COLUMN_\")) {\n              let theColumnN = parseInt(theMatchStr.substring(9));\n              if (!isNaN(theColumnN) && options.rowData && theColumnN > 0 && theColumnN <= options.rowData.length) {\n                theMatchedTextValue += _DataFocusMethod.formatData(options.rowData[theColumnN - 1], options.headers && options.headers[theColumnN - 1]);\n              }\n            }\n            break;\n        }\n        matchedIndex = theMatchIndex + theMatchStr.length;\n      }\n      if (matchedIndex < configMacroStr.length) {\n        theMatchedTextValue += configMacroStr.substring(matchedIndex);\n      }\n      return theMatchedTextValue;\n    }\n  },\n  // 为模板问答生成样例数据\n  getTemplateData: function () {\n    let theTemplateData = {\n      headers: [{\n        idx: 0,\n        col_id: '10001',\n        col_uuid: '10001',\n        col_name: '样例人口',\n        data_type: 'MEASURE',\n        operator: '',\n        geo_type: '',\n        col_type: 'int'\n      }, {\n        idx: 1,\n        col_id: '10002',\n        col_uuid: '10002',\n        col_name: '样例收入',\n        data_type: 'MEASURE',\n        operator: '',\n        geo_type: '',\n        col_type: 'double'\n      }, {\n        idx: 2,\n        col_id: '10003',\n        col_uuid: '10003',\n        col_name: '样例消费',\n        data_type: 'MEASURE',\n        operator: '',\n        geo_type: '',\n        col_type: 'double'\n      }],\n      columns: [[800000, 5621.56, 804.25], [1200000, 6600.56, 1502.25], [1400000, 6842.56, 1589.25], [1500000, 7458.56, 1758.25], [1700000, 8526.56, 1825.25], [1900000, 9052.56, 2047.25]],\n      default_chart: {\n        type: 'correlationAnalysis',\n        yAxis: [0, 1, 2]\n      },\n      charts: [{\n        type: 'correlationAnalysis',\n        yAxis: [0, 1, 2]\n      }]\n    };\n    return theTemplateData;\n  },\n  // 当前图形定制的中英文[ 配置XY轴，图表配置 ] [ *新增图形必填项 ]\n  i18nObj: {\n    chinese: {\n      \"chart-name-title\": \"相关热力图\",\n      \"chart-description-title\": \"至少两个数值列且至少两行搜索数据，计算其相关系数矩阵\",\n      \"chart-x-axis-title\": \"X轴\",\n      \"chart-y-axis-title\": \"Y轴\",\n      \"chart-multi-y-axis-title\": \"右侧副Y轴\",\n      \"chart-legend-title\": \"图例\",\n      \"chart-axis-config-null-error\": \"系统没有传入当前用户的Axis配置信息\",\n      \"chart-xy-axis-null\": \"X轴或Y轴不能为空\",\n      \"chart-left-y-axis-null\": \"左侧主Y轴不允许为空\",\n      \"chart-legend-too-much\": \"图例只允许一个\",\n      \"chart-y-axis-too-much-with-legend\": \"图例存在时，Y轴只允许一个\",\n      \"chart-x-legend-axis-not-equal\": \"X轴不允许与图例相同\",\n      \"chart-need-all-attribute-columns\": \"当前图形需要将所有的属性列利用起来\",\n      \"category_chart_general\": \"通用\",\n      \"option_chart_color_theme\": \"颜色主题\",\n      \"option_correlation_font_size\": \"字体大小\",\n      \"option_correlation_font_size_desc\": \"设置字体大小\",\n      \"option_correlation_font_color\": \"字体颜色\",\n      \"option_correlation_font_color_desc\": \"设置字体颜色\",\n      \"option_correlation_background_color\": \"背景颜色\",\n      \"option_correlation_background_color_desc\": \"设置背景颜色\",\n      \"option_correlation_method\": \"展示方式\",\n      \"option_correlation_method_desc\": \"设置展示方式\",\n      \"option_correlation_method_normal\": \"默认\",\n      \"option_correlation_method_upper\": \"上三角\",\n      \"option_correlation_method_lower\": \"下三角\",\n      \"option_correlation_rect_size_type\": \"单元格大小类型\",\n      \"option_correlation_rect_size_type_desc\": \"默认自动适配单元大小\",\n      \"option_correlation_rect_size_type_default\": \"默认\",\n      \"option_correlation_rect_size_type_number\": \"数值\",\n      \"option_correlation_rect_size\": \"单元格大小\",\n      \"option_correlation_rect_size_desc\": \"设置单元格大小\",\n      \"option_correlation_rect_type\": \"图形类型\",\n      \"option_correlation_rect_type_desc\": \"设置图形类型\",\n      \"option_correlation_rect_type_color\": \"色块\",\n      \"option_correlation_rect_type_circle\": \"圆形\",\n      \"option_correlation_positive_color\": \"正相关颜色\",\n      \"option_correlation_positive_color_desc\": \"设置正数(>0)的颜色比例尺终止颜色，起始颜色为白色#fff\",\n      \"option_correlation_negative_color\": \"负相关颜色\",\n      \"option_correlation_negative_color_desc\": \"设置负数(<0)的颜色比例尺终止颜色，起始颜色为白色#fff\",\n      \"option_correlation_high_light_color\": \"高亮颜色\",\n      \"option_correlation_high_light_color_desc\": \"设置鼠标移入热力块时的背景颜色，默认为 #feb41c \",\n      \"option_suspend_text_show\": \"显示悬浮文本\",\n      \"option_suspend_text_show_desc\": \"显示悬浮文本\",\n      \"option_label_text_regex_correlation_desc\": \"要显示的文本。有以下替换宏可用：<br /> %_VALUE - 可显示原本的数值 <br /> %_LABEL_X - 显示横向X轴的标签<br /> %_LABEL_Y - 显示纵向X轴的标签 <br />%_BR - 换行符\",\n      \"option_suspend_text_regex_correlation_desc\": \"要显示的文本。有以下替换宏可用：<br /> %_VALUE - 可显示原本的数值 <br /> %_LABEL_X - 显示横向X轴的标签<br /> %_LABEL_Y - 显示纵向X轴的标签 <br />%_BR - 换行符\",\n      \"category_sort\": \"聚类排序\",\n      \"option_correlative_sort_visible\": \"基于聚类排序\",\n      \"option_correlative_sort_visible_desc\": \"层级聚类后，根据类间距离排序\",\n      \"option_correlation_add_rect\": \"分类组数\",\n      \"option_correlation_add_rect_desc\": \"设置聚类的分类组数\",\n      \"option_correlation_add_rect_color\": \"分组框颜色\",\n      \"option_correlation_add_rect_color_desc\": \"设置分组框颜色\",\n      \"option_correlation_add_rect_width\": \"分组框宽度\",\n      \"option_correlation_add_rect_width_desc\": \"设置分组框宽度\",\n      \"option_attribute_label_max_width\": \"刻度最大宽度\",\n      \"option_attribute_label_max_width_desc\": \"配置纵向摆放的刻度标签的最大宽度占画图区域的宽度的百分比，默认不得超过画图区域宽度的20%\",\n      \"option_attribute_label_max_height\": \"刻度最大高度\",\n      \"option_attribute_label_max_height_desc\": \"配置横向摆放的刻度标签的最大高度占画图区域的高度的百分比，默认不得超过画图区域高度的20%\",\n      \"option_correlation_axis_revolve\": \"顶部刻度旋转角度\",\n      \"option_correlation_axis_revolve_desc\": \"设置顶部属性刻度值的固定旋转角度，默认情况判断每个数据块是否能放下属性刻度值，放不下的情况下，统一旋转30度\",\n      \"%_VALUE\": '相关系数',\n      \"%_LABEL_X\": '横坐标刻度',\n      \"%_LABEL_Y\": '纵坐标刻度',\n      \"%_BR\": '换行'\n    },\n    english: {\n      \"chart-name-title\": \"Correlation Chart\",\n      \"chart-description-title\": \"At least two measures and at least two records and calculate its correlation coefficient matrix\",\n      \"chart-x-axis-title\": \"X Axis\",\n      \"chart-y-axis-title\": \"Y Axis\",\n      \"chart-multi-y-axis-title\": \"The second Y Axis\",\n      \"chart-legend-title\": \"Legend\",\n      \"chart-axis-config-null-error\": \"here is no information of current Axis\",\n      \"chart-xy-axis-null\": \"X Axis or Y Axis can not be empty\",\n      \"chart-left-y-axis-null\": \"Left sub Y Axis can not be empty\",\n      \"chart-legend-too-much\": \"There must be only one legend\",\n      \"chart-y-axis-too-much-with-legend\": \"If legend exists，only one Y Axis can exist\",\n      \"chart-x-legend-axis-not-equal\": \"The X axis is not allowed to be the same as the legend\",\n      \"chart-need-all-attribute-columns\": \"Current chart need all attribute columns\",\n      \"category_chart_general\": \"General\",\n      \"option_chart_color_theme\": \"Color Theme\",\n      \"option_correlation_font_size\": \"Font Size\",\n      \"option_correlation_font_size_desc\": \"Setting font size\",\n      \"option_correlation_font_color\": \"Font Color\",\n      \"option_correlation_font_color_desc\": \"Setting font color\",\n      \"option_correlation_background_color\": \"Background Color\",\n      \"option_correlation_background_color_desc\": \"Setting background color\",\n      \"option_correlation_method\": \"Display method\",\n      \"option_correlation_method_desc\": \"Setting display method\",\n      \"option_correlation_method_normal\": \"normal\",\n      \"option_correlation_method_upper\": \"upper\",\n      \"option_correlation_method_lower\": \"lower\",\n      \"option_correlation_rect_size_type\": \"Type of cell size\",\n      \"option_correlation_rect_size_type_desc\": \"As default, the size of cell will adjust by auto\",\n      \"option_correlation_rect_size_type_default\": \"Default\",\n      \"option_correlation_rect_size_type_number\": \"Number\",\n      \"option_correlation_rect_size\": \"Cell Size\",\n      \"option_correlation_rect_size_desc\": \"Setting cell size\",\n      \"option_correlation_rect_type\": \"Element Type\",\n      \"option_correlation_rect_type_desc\": \"Setting element type\",\n      \"option_correlation_rect_type_color\": \"Color Block\",\n      \"option_correlation_rect_type_circle\": \"Circle\",\n      \"option_correlation_positive_color\": \"Positive Color\",\n      \"option_correlation_positive_color_desc\": \"Set the ending color of the color scale of the positive number (>0), and the starting color is white # fff\",\n      \"option_correlation_negative_color\": \"Negative Color\",\n      \"option_correlation_negative_color_desc\": \"Set the ending color of the negative (<0) color scale, and the starting color is white # fff\",\n      \"option_correlation_high_light_color\": \"Highlight color\",\n      \"option_correlation_high_light_color_desc\": \"Set the background color when the mouse moves into the heating block. The default is # feb41c\",\n      \"option_suspend_text_show\": \"Show Suspend Text\",\n      \"option_suspend_text_show_desc\": \"Show suspend text\",\n      \"option_label_text_regex_correlation_desc\": \"The text to display. <br/>The following substitution macros are available ：<br /> %_VALUE - display original value <br /> %_LABEL_X - display x axis label<br /> %_LABEL_Y - display y axis label <br />  %_BR - Newline character \",\n      \"option_suspend_text_regex_correlation_desc\": \"The text to display. <br/>The following substitution macros are available ：<br /> %_VALUE - display original value <br /> %_LABEL_X - display x axis label<br /> %_LABEL_Y - display y axis label <br />  %_BR - Newline character \",\n      \"category_sort\": \"Clustering Sort\",\n      \"option_correlative_sort_visible\": \"Clustering Sort\",\n      \"option_correlative_sort_visible_desc\": \"hCluster based Sort\",\n      \"option_correlation_add_rect\": \"Category Group Number\",\n      \"option_correlation_add_rect_desc\": \"Setting category group number\",\n      \"option_correlation_add_rect_color\": \"Group Rect Color\",\n      \"option_correlation_add_rect_color_desc\": \"Setting group rect color\",\n      \"option_correlation_add_rect_width\": \"Group Rect Width\",\n      \"option_correlation_add_rect_width_desc\": \"Setting group rect width\",\n      \"option_correlation_axis_interval\": \"Label Interval\",\n      \"option_correlation_axis_interval_desc\": \"Label interval\",\n      \"option_correlation_axis_revolve\": \"Label Revolve\",\n      \"option_correlation_axis_revolve_desc\": \"Label revolve\"\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.senior/correlationAnalysis.js?");

/***/ }),

/***/ "../src-v5/assets/js/common/CommonDrawAxis.js":
/*!****************************************************!*\
  !*** ../src-v5/assets/js/common/CommonDrawAxis.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/** 通用的画属性坐标轴/数值坐标轴的方法集合 **/\n\nlet CommonDrawAxis = {\n  /**\r\n   * 画图形中的属性坐标轴，可画在图形区域中的上下水平方向摆放\r\n   *  @param  [Array<String>]attributeValueList   -   属性值列表\r\n   *  @param  options                             -   画属性坐标轴时的其他配置【 画图区域是个长方形 】\r\n   *          {\r\n   *              [FocusChart Object]currentChart     -   当前画图的对象实例\r\n   *              [String]position                    -   属性坐标轴的位置    top: 横在顶部；bottom: 横在底部\r\n   *              [string]type                        -   属性坐标轴的类型    timeline: 时间轴 ； levelline： 分层的属性轴 ； dotline : 单个点轴\r\n   *\r\n   *              [Array<Object>]attributeValueMap    -   属性轴attributeValueList对应的每个刻度的分层对象\r\n   *                             levelline的情况下对象结构： {labelText1: {level1: 'label1', level2: 'label2'}}\r\n   *                             timeline的情况下对象结构：{labelText1: {show: true , showType: 'hour' , hour:'12时' , minute: '45分' .... }}\r\n   *\r\n   *              [Number]width           -   属性轴的比例尺宽度，在position是top或bottom时才有效\r\n   *              [Number]maxHeight       -   属性轴占的最大高度，在position是top或bottom时才有效\r\n   *              [Number]rotate          -   属性轴是dotline时才有效\r\n   *\r\n   *              [Number]labelStepWidth  -   每个属性刻度的所占的最小宽度，在position是top或bottom时才有效\r\n   *              [Number]padding         -   每个属性刻度中间的间隔\r\n   *              [Number]outPadding      -   整个刻度轴两边的间隔\r\n   *          }\r\n   * */\n  drawHorizontalAttributeAxis: function (attributeValueList, options) {\n    options = options || {};\n    if (!attributeValueList || !attributeValueList.length || !options.container || !options.currentChart) return false;\n    let type = options.type || 'dotline',\n      position = options.position || 'bottom',\n      padding = options.padding || 0,\n      outPadding = options.outPadding || 0;\n    if (['top', 'bottom'].indexOf(position) === -1 || !options.width) return false;\n    let currentChart = options.currentChart,\n      conf = currentChart.defaultConf;\n    let theAttributeContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.container).append(\"g\").attr(\"class\", \"axis x-axis x-axis-horizontal\");\n    let theMaxValueSize = {\n        width: 0,\n        height: 0\n      },\n      theAttributeValueMap = {};\n    attributeValueList && attributeValueList.forEach(function (value, index) {\n      let theValueSize = currentChart.getStrSizeByCanvas('string', value, {\n        fontSize: options.fontSize\n      });\n      theMaxValueSize.width = Math.max(theValueSize.width, theMaxValueSize.width);\n      theMaxValueSize.height = Math.max(theValueSize.height, theMaxValueSize.height);\n      theAttributeValueMap[value] = index;\n    });\n    let returnResult = {}; //  返回的对象\n    // 横着摆放刻度标签的情况下[ 水平摆放标签放不下时，需要倾斜摆放 ]\n    options.labelStepWidth = _DataFocusMethod.isPureNumber(options.labelStepWidth) ? options.labelStepWidth || 50 : 50;\n    let theWidth = options.width - outPadding * 2 - padding * (attributeValueList.length - 1),\n      theXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(attributeValueList).rangeBands([0, theWidth]),\n      theXRangeBand = theXScale.rangeBand(),\n      columnLabelStep = Math.ceil(options.labelStepWidth / theXRangeBand),\n      theXLabelRotate = 0;\n    columnLabelStep = Math.max(1, columnLabelStep);\n    let theReturnScale = function (label) {\n      let theIndex = theAttributeValueMap[label] || 0;\n      return theXScale(label) + outPadding + Math.max(theIndex, 0) * padding;\n    };\n    if (type === 'dotline') {\n      // 当前刻度间隔放不下最大的刻度值时，默认情况下需要倾斜放置刻度\n      if (_DataFocusMethod.isPureNumber(options.defaultRotate)) theXLabelRotate = options.defaultRotate;\n      if (theMaxValueSize.width > theXRangeBand) {\n        if (_DataFocusMethod.isPureNumber(options.rotate)) {\n          theXLabelRotate = options.rotate;\n        } else {\n          theXLabelRotate = theXLabelRotate || 30;\n        }\n      }\n\n      //绘制刻度下的x轴显示信息[ 所有的刻度中至少显示一个 ]\n      let haveShowALabelFlag = false;\n      let attributeLabelList = theAttributeContainer.selectAll(\"g.label\").data(attributeValueList && attributeValueList.filter(function (d, i) {\n        let theShowFlag = !(!d || i % columnLabelStep !== Math.ceil(columnLabelStep / 2) && columnLabelStep !== 1);\n        haveShowALabelFlag = haveShowALabelFlag || theShowFlag;\n\n        // 如果等到最后一条数据，还没有显示过一个标签，则最后一个标签必须显示\n        if (i === attributeValueList.length - 1 && !haveShowALabelFlag) {\n          theShowFlag = true;\n        }\n        return theShowFlag;\n      })).enter().append(\"g\").attr(\"class\", \"x-axis label\").attr(\"transform\", function (d) {\n        return \"translate(\" + theReturnScale(d) + \", 0)\";\n      });\n\n      // 绘制刻度值\n      let attributeLabelTexts = attributeLabelList.append(\"text\").attr(\"class\", \"text\").attr(\"transform\", function () {\n        let theCosValue = Math.cos(theXLabelRotate * Math.PI / 180);\n        return 'translate(' + (theXLabelRotate ? theXRangeBand / 2 + theXRangeBand / 4 * Math.pow(theCosValue, 4) : theXRangeBand / 2) + ', ' + theMaxValueSize.height / 2 * Math.cos(theXLabelRotate * Math.PI / 180) + ' ) ' + (theXLabelRotate ? ' rotate(-' + theXLabelRotate + ')' : '');\n      }).attr(\"text-anchor\", theXLabelRotate ? 'end' : 'middle').style(\"dominant-baseline\", \"central\");\n      attributeLabelTexts.text(function (d) {\n        let dtext = d;\n        if (d.startsWith(conf.totalPrefix)) {\n          dtext = d.replace(conf.totalPrefix, \"\");\n        }\n        let theSinRotate = Math.sin(Math.PI / 2 - Math.abs(theXLabelRotate) / 180 * Math.PI),\n          theCosRotate = Math.cos(Math.PI / 2 - Math.abs(theXLabelRotate) / 180 * Math.PI);\n        let theTextSize = currentChart.getStrSizeByCanvas('string', dtext, {\n            fontSize: options.fontSize\n          }),\n          baseTextHeight = options.maxHeight;\n        if (!dtext) return;\n        // 如果当前倾斜放置不够当前文本，则需要截取\n        if (theTextSize.width * theSinRotate + theTextSize.height * theCosRotate > baseTextHeight) {\n          let theSubText = '';\n          for (let i = 0; i < dtext.length; i++) {\n            let chart = dtext.charAt(i);\n            theSubText += chart;\n            let theSubTextSize = currentChart.getStrSizeByCanvas('string', theSubText, {\n              fontSize: options.fontSize\n            });\n            if (theSubTextSize.width * theSinRotate + theTextSize.height * theCosRotate > baseTextHeight) {\n              break;\n            }\n          }\n          if (theSubText.length === dtext.length) {\n            return dtext;\n          } else {\n            return theSubText + '...';\n          }\n        }\n        return dtext;\n      }).append(\"title\").text(function (d) {\n        return d;\n      });\n      let theMaxLabelHeight = 0;\n      attributeLabelTexts && attributeLabelTexts.each(function () {\n        let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this),\n          theBoundingHeight = theDom[0][0] && theDom[0][0].getBoundingClientRect().height;\n        theMaxLabelHeight = Math.max(theMaxLabelHeight, theBoundingHeight);\n      });\n\n      // 如果标签是在上面，则文本是在\n      if (position === 'top') {\n        attributeLabelTexts.attr('transform', function () {\n          let theCosValue = Math.cos(theXLabelRotate * Math.PI / 180);\n          return 'translate(' + (theXLabelRotate ? theXRangeBand / 2 - theXRangeBand / 4 * Math.pow(theCosValue, 4) : theXRangeBand / 2) + ', ' + (theMaxLabelHeight - theMaxValueSize.height / 2 * Math.cos(theXLabelRotate * Math.PI / 180)) + ') ' + (theXLabelRotate ? ' rotate(-' + theXLabelRotate + ')' : '');\n        }).attr(\"text-anchor\", theXLabelRotate ? 'start' : 'middle');\n      }\n    }\n    let theMaxLabelHeight = 0;\n    let theBoundingHeight = theAttributeContainer[0][0] && theAttributeContainer[0][0].getBoundingClientRect().height;\n    theMaxLabelHeight = Math.max(theMaxLabelHeight, theBoundingHeight);\n    returnResult.maxLabelHeight = theMaxLabelHeight;\n    returnResult.scale = theReturnScale;\n    returnResult.rangeBand = theXRangeBand;\n    returnResult.attributeContainer = theAttributeContainer;\n    return returnResult;\n  },\n  /**\r\n   * 画图形中的属性坐标轴，可画在图形区域中的左右垂直方向\r\n   *  @param  [Array<String>]attributeValueList   -   属性值列表\r\n   *  @param  options                             -   画属性坐标轴时的其他配置【 画图区域是个长方形 】\r\n   *          {\r\n   *              [FocusChart Object]currentChart     -   当前画图的对象实例\r\n   *              [String]position                    -   属性坐标轴的位置    left: 竖直在左侧 ； right: 竖直在右侧；\r\n   *              [string]type                        -   属性坐标轴的类型    timeline: 时间轴 ； levelline： 分层的属性轴 ； dotline : 单个点轴\r\n   *\r\n   *              [Array<Object>]attributeValueMap    -   属性轴attributeValueList对应的每个刻度的分层对象\r\n   *                             levelline的情况下对象结构： {labelText1: {level1: 'label1', level2: 'label2'}}\r\n   *                             timeline的情况下对象结构：{labelText1: {show: true , showType: 'hour' , hour:'12时' , minute: '45分' .... }}\r\n   *\r\n   *              [Number]height          -   属性轴比例尺高度，在position是left或right时才有效\r\n   *              [Number]maxWidth        -   属性轴占的最大宽度，在position是left或right时才有效\r\n   *              [Number]labelStepHeight -   每个属性刻度的所占的最小高度，在position是left或right时才有效\r\n   *              [Number]padding         -   每个属性刻度中间的间隔\r\n   *              [Number]outPadding      -   整个刻度轴两边的间隔\r\n   *          }\r\n   * */\n  drawVerticalAttributeAxis: function (attributeValueList, options) {\n    options = options || {};\n    if (!attributeValueList || !attributeValueList.length || !options.container || !options.currentChart) return false;\n    let type = options.type || 'dotline',\n      position = options.position || 'left',\n      padding = options.padding || 0,\n      outPadding = options.outPadding || 0;\n    if (['left', 'right'].indexOf(position) === -1 || !options.height) return false;\n    let currentChart = options.currentChart,\n      conf = currentChart.defaultConf;\n    let theAttributeContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.container).append(\"g\").attr(\"class\", \"axis x-axis x-axis-vertical\");\n    let theMaxValueSize = {\n        width: 0,\n        height: 0\n      },\n      theAttributeValueMap = {};\n    attributeValueList && attributeValueList.forEach(function (value, index) {\n      let theValueSize = currentChart.getStrSizeByCanvas('string', value, {\n        fontSize: options.fontSize\n      });\n      theMaxValueSize.width = Math.max(theValueSize.width, theMaxValueSize.width);\n      theMaxValueSize.height = Math.max(theValueSize.height, theMaxValueSize.height);\n      theAttributeValueMap[value] = index;\n    });\n    let returnResult = {}; //  返回的对象\n    options.labelStepHeight = _DataFocusMethod.isPureNumber(options.labelStepWidth) ? options.labelStepWidth || 1 : theMaxValueSize.height;\n    let theHeight = options.height - outPadding * 2 - padding * (attributeValueList.length - 1),\n      theXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(attributeValueList).rangeBands([0, theHeight]),\n      theXRangeBand = theXScale.rangeBand(),\n      columnLabelStep = Math.ceil(options.labelStepHeight / theXRangeBand);\n    columnLabelStep = Math.max(1, columnLabelStep);\n    let theReturnScale = function (label) {\n      let theIndex = theAttributeValueMap[label] || 0;\n      return theXScale(label) + outPadding + Math.max(theIndex, 0) * padding;\n    };\n    let theMaxLabelWidth = 0;\n    if (type === 'dotline') {\n      //绘制刻度下的x轴显示信息[ 所有的刻度中至少显示一个 ]\n      let haveShowALabelFlag = false;\n      let attributeLabelList = theAttributeContainer.selectAll(\"g.label\").data(attributeValueList && attributeValueList.filter(function (d, i) {\n        let theShowFlag = !(!d || i % columnLabelStep !== Math.ceil(columnLabelStep / 2) && columnLabelStep !== 1);\n        haveShowALabelFlag = haveShowALabelFlag || theShowFlag;\n\n        // 如果等到最后一条数据，还没有显示过一个标签，则最后一个标签必须显示\n        if (i === attributeValueList.length - 1 && !haveShowALabelFlag) {\n          theShowFlag = true;\n        }\n        return theShowFlag;\n      })).enter().append(\"g\").attr(\"class\", \"x-axis label\").attr(\"transform\", function (d) {\n        return \"translate(0 ,\" + theReturnScale(d) + \")\";\n      });\n\n      // 绘制刻度值\n      let attributeLabelTexts = attributeLabelList.append(\"text\").attr(\"class\", \"text\").attr(\"transform\", 'translate( ' + theMaxValueSize.width + ' ,' + (theXRangeBand / 2 + theMaxValueSize.height / 3) + ' ) ').attr(\"text-anchor\", 'end').text(function (d) {\n        let dtext = d;\n        if (d.startsWith(conf.totalPrefix)) {\n          dtext = d.replace(conf.totalPrefix, \"\");\n        }\n        let theTextSize = currentChart.getStrSizeByCanvas('string', dtext),\n          baseTextWidth = options.maxWidth - 8;\n        if (!dtext) return;\n        // 如果当前倾斜放置不够当前文本，则需要截取\n        if (theTextSize.width > baseTextWidth) {\n          let theSubText = '';\n          for (let i = 0; i < dtext.length; i++) {\n            let chart = dtext.charAt(i);\n            theSubText += chart;\n            let theSubTextSize = currentChart.getStrSizeByCanvas('string', theSubText);\n            if (theSubTextSize.width >= baseTextWidth) break;\n          }\n          if (theSubText.length === dtext.length) {\n            return dtext;\n          } else {\n            return theSubText + '...';\n          }\n        }\n        return dtext;\n      });\n      attributeLabelTexts.append(\"title\").text(function (d) {\n        return d;\n      });\n      let theBoundingHeight = theAttributeContainer[0][0] && theAttributeContainer[0][0].getBoundingClientRect().width;\n      theMaxLabelWidth = Math.max(theMaxLabelWidth, theBoundingHeight);\n      attributeLabelTexts.attr(\"transform\", \"translate(\" + theMaxLabelWidth + \" , \" + (theXRangeBand / 2 + theMaxValueSize.height / 3) + \")\");\n      // 如果标签是在右侧，则文本是在\n      if (position === 'right') {\n        attributeLabelTexts.attr(\"text-anchor\", 'start').attr(\"transform\", 'translate( 0 ,' + (theXRangeBand / 2 + theMaxValueSize.height / 3) + ' ) ');\n      }\n    }\n    returnResult.maxLabelWidth = theMaxLabelWidth;\n    returnResult.scale = theReturnScale;\n    returnResult.rangeBand = theXRangeBand;\n    returnResult.attributeContainer = theAttributeContainer;\n    return returnResult;\n  },\n  drawMeasureAxis: function () {}\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (CommonDrawAxis);\n\n//# sourceURL=webpack:///../src-v5/assets/js/common/CommonDrawAxis.js?");

/***/ })

}]);