(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[10],{

/***/ "../src-v5/assets/js/charts.system.basic/column/ColumnChartComponent.js":
/*!******************************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/column/ColumnChartComponent.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pc/assets/js/charts.components/LegendComponent */ \"../src-v5/assets/js/charts.components/LegendComponent.js\");\n// 辅助柱形图画图的组件\n\n\n\n\nlet ColumnChartComponent = {\n  /**\r\n   * 画水平平铺，垂直摆放的柱形图中的柱子 [ 每个Attribute刻度中多个柱子是并排的 ]\r\n   * @param chartSetData  -   当前需要画的数据数组\r\n   * @param options       -    画图辅助信息\r\n   *          {\r\n   *              chartDetailContainer    -   画图的区域\r\n   *              conf                    -   图形实例的配置\r\n   *              chartAxis               -   图轴配置\r\n   *              attributeAxis           -   属性刻度轴的标尺配置\r\n   *              measureAxis             -   数值刻度的标尺配置\r\n   *\r\n   *              curYAxis                -   当前的Y轴\r\n   *              yIndex                  -   当前Y轴的顺序\r\n   *              yLength                 -   图轴配置中的Y的总数\r\n   *              legendType              -   图例类型 legendAxis: 图例属性列 ； yAxis : 多个Y轴\r\n   *              legendValue             -   legendAxis下当前的图例值 ； yAxis下当前Y轴的col_id\r\n   *              legendIndex             -   legendAxis下当前的图例顺序 ； yAxis下当前Y轴的顺序\r\n   *              prevColumnIndex         -   柱子是从左往后依次画的，左侧已画的柱子的索引\r\n   *\r\n   *              translateLeft           -   画图区域的左偏移\r\n   *              translateTop            -   画图区域的顶部偏移\r\n   *              scaleMeasureHeight      -   数值刻度比例尺的高度 ， 即画图区域的高度\r\n   *              columnWidth             -   柱宽\r\n   *              outPadding              -   柱子在刻度内的左偏移\r\n   *              animateFlag             -   是否需要动画\r\n   *\r\n   *              colorAssignedToScaleFlag    -   在没有图例情况下，是否将主题颜色按X轴刻度分配的标志\r\n   *              getColorFunc                -   按顺序获取颜色的方法\r\n   *              chartCustomLegend           -   自定义的刻度颜色\r\n   *\r\n   *              analaysisData               -   数据分析的结果\r\n   *              thePositiveOutlierColor     -   数据分析结果正向离群值的颜色\r\n   *              theNegativeOutlierColor     -   数据分析结果负向离群值的颜色\r\n   *\r\n   *              mouseoverCallback           -    鼠标移入事件的响应方法\r\n   *              mouseoutCallback            -    鼠标移出事件的响应方法\r\n   *              mousedownCallback           -    鼠标点击事件的响应方法\r\n   *          }\r\n   * **/\n  drawHorizontalColumnChartSet: function (chartSetData, options) {\n    if (!chartSetData) return false;\n    options = options || {};\n    if (!options.chartDetailContainer || !options.attributeAxis || !options.measureAxis || !options.curYAxis) return false;\n    let theChartDetailContainer = options.chartDetailContainer,\n      duration = options.duration,\n      attributeAxis = options.attributeAxis,\n      measureAxis = options.measureAxis,\n      legendType = options.legendType,\n      legendValue = options.legendValue,\n      legendIndex = options.legendIndex,\n      prevColumnIndex = options.prevColumnIndex || 0,\n      translateLeft = parseFloat(options.translateLeft),\n      translateTop = parseFloat(options.translateTop),\n      scaleMeasureHeight = parseFloat(options.scaleMeasureHeight),\n      theColumnWidth = parseFloat(options.columnWidth),\n      theOutPadding = parseFloat(options.outPadding),\n      colorAssignedToScaleFlag = options.colorAssignedToScaleFlag,\n      getColorFunc = typeof options.getColorFunc === 'function' ? options.getColorFunc : '',\n      thePositiveOutlierColor = options.thePositiveOutlierColor,\n      theNegativeOutlierColor = options.theNegativeOutlierColor;\n    let theLegendChart = theChartDetailContainer;\n\n    // 每根柱子的群组\n    const columnBars = theLegendChart.selectAll('g.chartset-columns').data(chartSetData, row => row.x0).join(enter => enter.append('g').classed('chartset-columns', true).attr(\"style\", \"cursor:pointer;\").attr(\"xLabel\", function (d) {\n      return d['x0'] + \"\";\n    }).attr(\"transform\", function (d) {\n      return 'translate(' + attributeAxis.scale(d['x0']) + ',' + scaleMeasureHeight + ')';\n    }), update => update.attr(\"transform\", function (d) {\n      return 'translate(' + attributeAxis.scale(d['x0']) + ',' + scaleMeasureHeight + ')';\n    }), exit => exit.remove());\n    let theYAxis = options.curYAxis,\n      theYIndex = options.yIndex || 0,\n      theLegendIndex = options.legendIndex || 0,\n      theYLength = options.yLength;\n    let theScaleFunc = theYAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc,\n      theScaleMeasure = theYAxis.direction !== 'right' ? measureAxis.firstMeasure : measureAxis.secondMeasure;\n    let colorFormats = theYAxis.header && theYAxis.header.colorFormattings;\n    // 因为Y轴的刻度比例尺是值越小高度越大, 计算Y轴柱高时需要调整\n    theScaleFunc.range([0, scaleMeasureHeight]);\n\n    // 矩形颜色\n    function getRectColor(d, i) {\n      let theDefaultColor, theColumnColor;\n      // 柱子颜色规则使用的颜色优先级最高\n      if (_DataFocusMethod.isPureNumber(d['y' + theYIndex]) && colorFormats && colorFormats.length > 0) {\n        theColumnColor = _DataFocusMethod.calcTheColor(d['y' + theYIndex], colorFormats, {\n          rowData: d.rowData\n        });\n      }\n\n      /**\r\n       * 各个柱子的颜色规则\r\n       * 1、 多Y轴的情况下，用户配置的Y轴颜色优先级最高\r\n       * 2、 多图例的情况下，用户配置的图例颜色优先级最高\r\n       * 3、 没有用户配置的情况下，则分配主题颜色 ；\r\n       *      - 未配置颜色分配到各个刻度属性时，将主题的颜色，顺序时按图例数量或Y轴顺序分配的\r\n       *      - 配置颜色分配到各个刻度属性时，且无图例且没有多Y轴时，顺序按X轴刻度的顺序分配\r\n       * */\n      let theColorIndex = theLegendIndex;\n      if (colorAssignedToScaleFlag) {\n        theColorIndex = i;\n        // 如果用户配置了自定义颜色，需要一句当前X轴刻度在自定义图例颜色中找对应的颜色\n        if (options.xLabelColorList && options.xLabelColorList.length) {\n          let theMatchedXColor = options.xLabelColorList.find(function (theLegend) {\n            return d.x0 && theLegend.id === d.x0;\n          });\n          if (theMatchedXColor && theMatchedXColor.color) theDefaultColor = theMatchedXColor.color;\n        }\n        // 如果将颜色分配到各个柱子，则必须直接返回无需使用图例的颜色\n        return theColumnColor || theDefaultColor || getColorFunc(theColorIndex);\n      }\n      if (!theDefaultColor && getColorFunc) theDefaultColor = getColorFunc(theColorIndex);\n      let theRealColumnColor = theColumnColor || options.legendConfig && options.legendConfig.color || theDefaultColor;\n      // 如果当前行是数据分析结果的离群值，则需要高亮显示\n      let theAnalaysisData = options.analaysisData || [];\n      if (theAnalaysisData.length) {\n        let theRowIndex = d.rowIndex;\n        let outlierFlagObj = theAnalaysisData.find(function (outlier) {\n          return outlier.index + '' === theRowIndex + '';\n        });\n\n        // 如果是正离群值,则是高亮颜色 ； 负数离群值，将当前元素的颜色置灰\n        if (outlierFlagObj) {\n          if (outlierFlagObj.sign) {\n            theRealColumnColor = thePositiveOutlierColor;\n          } else {\n            theRealColumnColor = theNegativeOutlierColor;\n          }\n        }\n      }\n      return theRealColumnColor;\n    }\n\n    // 在每个柱子的群组中添加rect\n    columnBars.each(function (parentData, parentIndex) {\n      const currentColumnGroup = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(this);\n\n      // 矫正每个柱子的位置\n      function setColumnRect(rect) {\n        rect.attr(\"z-index\", \"3\").attr(\"stroke\", \"none\").attr(\"x\", 0).attr(\"y\", function (d) {\n          let curd = d['y' + theYIndex];\n          if (!_DataFocusMethod.isPureNumber(curd)) return;\n          if (curd > 0) {\n            return -theScaleFunc(curd);\n          } else {\n            return -theScaleFunc(0);\n          }\n        }).attr(\"width\", theColumnWidth).attr(\"height\", function (d) {\n          let curd = d['y' + theYIndex];\n          if (!_DataFocusMethod.isPureNumber(curd)) return;\n          if (curd > 0) {\n            return theScaleFunc(curd) - theScaleFunc(0);\n          } else {\n            let theTickScale = theScaleMeasure.measureTickScale;\n            return theScaleFunc(theTickScale.min - curd);\n          }\n        }).attr(\"transform\", \"translate(\" + (prevColumnIndex * theColumnWidth + theOutPadding / 2) + \", 0)\").attr(\"alarm-status\", function (d) {\n          return d[\"alarm\" + theYIndex];\n        }).attr(\"color\", function (d) {\n          return getRectColor(d, parentIndex);\n        }).style(\"fill\", function (d) {\n          return getRectColor(d, parentIndex);\n        });\n      }\n      currentColumnGroup.selectAll('rect').data(parentData => [parentData]).join(enter => enter.append('rect').call(setColumnRect).attr(\"height\", 0).attr(\"y\", -theScaleFunc(0)).attr('legendId', options.legendConfig && options.legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].generateLegendId(legendType, legendValue)).on(\"mousemove\", function (event, d) {\n        let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n        _DataFocusMethod.stopEventDefault(event);\n        theDom.attr(\"stroke\", theDom.attr(\"color\")).attr(\"stroke-width\", \"3px\").style(\"transition\", \"all ease-in 0.1s\");\n        typeof options.mouseoverCallback === 'function' && options.mouseoverCallback.call(this, event, d);\n      }).on(\"mouseout\", function (event, d) {\n        let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n        _DataFocusMethod.stopEventDefault(event);\n        theDom.attr(\"stroke\", \"none\").attr(\"stroke-width\", \"\").style(\"transition\", \"\");\n        typeof options.mouseoutCallback === 'function' && options.mouseoutCallback.call(this, event, d);\n      }).on(\"mousedown\", function (event, d) {\n        // // 移动端的mousedown事件不执行\n        typeof options.mousedownCallback === 'function' && options.mousedownCallback.call(this, event, d);\n      }).transition().duration(duration.columnEnter).call(setColumnRect), update => update.transition().duration(duration.update).call(setColumnRect), exit => exit.remove());\n    });\n\n    // 计算完之后恢复刻度的比例尺\n    theScaleFunc.range([scaleMeasureHeight, 0]);\n  },\n  /**\r\n   *\r\n   * 画水平平铺，垂直摆放的柱形图中的柱子对应的标签 [ 每个Attribute刻度中多个柱子是并排的 ]\r\n   * @param chartSetData  -   当前需要画的数据数组\r\n   * @param options       -    画图辅助信息\r\n   *          {\r\n   *              chartDetailContainer    -   画图的区域\r\n   *              conf                    -   图形实例的配置\r\n   *              chartAxis               -   图轴配置\r\n   *              attributeAxis           -   属性刻度轴的标尺配置\r\n   *              measureAxis             -   数值刻度的标尺配置\r\n   *\r\n   *              curYAxis                -   当前的Y轴\r\n   *              yIndex                  -   当前Y轴的顺序\r\n   *              yLength                 -   图轴配置中的Y的总数\r\n   *              legendType              -   图例类型 legendAxis: 图例属性列 ； yAxis : 多个Y轴\r\n   *              legendValue             -   legendAxis下当前的图例值 ； yAxis下当前Y轴的col_id\r\n   *              legendIndex             -   legendAxis下当前的图例顺序 ； yAxis下当前Y轴的顺序\r\n   *\r\n   *              translateLeft           -   画图区域的左偏移\r\n   *              translateTop            -   画图区域的顶部偏移\r\n   *              scaleMeasureHeight      -   数值刻度比例尺的高度 ， 即画图区域的高度\r\n   *              scaleAttributeWidth     -   X轴属性刻度比例尺的宽度，即画图区域的宽度\r\n   *              columnWidth             -   柱宽\r\n   *              outPadding              -   柱子在刻度内的左偏移\r\n   *              animateFlag             -   是否有动画\r\n   *\r\n   *              labelPosition           -   标签的位置, in：柱形图里面 ； center: 柱形图中间 ;  out： 柱形图外面 ； default: 自适应，如果外面放的下放外面，外面放不下就放里面，如果都放不下则不显示\r\n   *              labelRotation           -   标签旋转的角度，0： 不旋转 ； 90: 旋转90度 ； 270： 旋转270度 【目前只开放了3中角度】\r\n   *              labelVisibleMap         -   显示的标签集合 all: 显示所有标签  ； standard： 只显示最大最小\r\n   *              labelAllowOverlap       -   标签内容是否允许重叠  默认是不允许重叠\r\n   *         }\r\n   * **/\n  drawHorizontalColumnLabelSet: function (chartSetData, options) {\n    if (!chartSetData || !chartSetData.length) return false;\n    options = options || {};\n    if (!options.chartDetailContainer || !options.attributeAxis || !options.measureAxis || !options.curYAxis) return false;\n    let theChartDetailContainer = options.chartDetailContainer,\n      attributeAxis = options.attributeAxis,\n      measureAxis = options.measureAxis,\n      legendType = options.legendType,\n      legendValue = options.legendValue,\n      legendIndex = options.legendIndex,\n      prevColumnIndex = options.prevColumnIndex || 0,\n      //  已画的图例的顺序【 因为存在隐藏的图例 】\n\n      translateLeft = parseFloat(options.translateLeft),\n      translateTop = parseFloat(options.translateTop),\n      scaleMeasureHeight = parseFloat(options.scaleMeasureHeight),\n      scaleAttributeWidth = parseFloat(options.scaleAttributeWidth),\n      theColumnWidth = parseFloat(options.columnWidth),\n      theOutPadding = parseFloat(options.outPadding),\n      animateFlag = !!options.animateFlag,\n      labelChartSpace = 3,\n      //  标签局内局外时，与柱形的距离\n      labelFontSize = options.labelFontSize || 10,\n      labelFontColor = options.labelFontColor === undefined ? 'inherit' : options.labelFontColor,\n      labelFontBold = options.labelFontBold === undefined ? 'inherit' : options.labelFontBold ? 'bold' : '500',\n      labelFontItalic = options.labelFontItalic === undefined ? 'inherit' : options.labelFontItalic ? 'italic' : 'normal',\n      labelPosition = options.labelPosition || \"default\",\n      labelRotation = options.labelRotation || 0,\n      labelVisibleMap = options.labelVisibleMap || 'all',\n      labelAllowOverlap = !!options.labelAllowOverlap,\n      drewLabelArray = options.drewLabelArray || [],\n      generateLabelTextFunc = typeof options.generateLabelTextFunc === 'function' && options.generateLabelTextFunc;\n    let theLegendChart = theChartDetailContainer;\n    let theYAxis = options.curYAxis,\n      theYIndex = options.yIndex || 0;\n    let columnBars = theLegendChart.selectAll(\"g.columns-labels\").data(chartSetData).enter().append(\"g\").attr(\"class\", 'columns-labels').attr(\"style\", \"cursor:pointer;\").attr(\"xLabel\", function (d) {\n      return d['x0'] + \"\";\n    }).style('font-size', labelFontSize + 'px').style(\"fill\", labelFontColor).style(\"font-weight\", labelFontBold).style(\"font-style\", labelFontItalic).attr(\"transform\", function (d) {\n      return 'translate(0 , 0)';\n    });\n    let theScaleFunc = theYAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc,\n      theScaleMeasure = theYAxis.direction !== 'right' ? measureAxis.firstMeasure : measureAxis.secondMeasure;\n    // 因为Y轴的刻度比例尺是值越小高度越大, 计算Y轴柱高时需要调整\n    theScaleFunc.range([0, scaleMeasureHeight]);\n    let theMaxDomain = theScaleFunc.domain()[1],\n      theMinDomain = theScaleFunc.domain()[0];\n    let theLegendYMax = -Infinity,\n      theLegendYMaxIndex = -1,\n      theLegendYMin = Infinity,\n      theLegendYMinIndex = -1,\n      theLegendYDataIndex = {};\n    chartSetData.forEach(function (data, index) {\n      let d = data['y' + theYIndex];\n      if (_DataFocusMethod.isPureNumber(d)) {\n        theLegendYMax = Math.max(d, theLegendYMax);\n        theLegendYMin = Math.min(d, theLegendYMin);\n        theLegendYDataIndex[d] = index;\n      }\n    });\n    theLegendYMaxIndex = theLegendYDataIndex[theLegendYMax];\n    theLegendYMinIndex = theLegendYDataIndex[theLegendYMin];\n    let textContainer = columnBars.filter(function (d, index) {\n      // 需要判断当前标签是否需要显示\n      if (labelVisibleMap !== 'all' && index !== theLegendYMaxIndex && index !== theLegendYMinIndex) return false;\n      let curd = d['y' + theYIndex],\n        message = generateLabelTextFunc && generateLabelTextFunc(d) || curd || '';\n      // 数据标签可以换行，有换行时，得换行显示\n      let messageArray = message.trim().split('\\n'),\n        maxMessageWidth = 0,\n        maxMessageHeight = 0;\n      for (let i = 0; i < messageArray.length; i++) {\n        let theMsg = messageArray[i],\n          theMetrics = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theMsg, {\n            fontSize: labelFontSize\n          });\n        maxMessageWidth = Math.max(theMetrics.width, maxMessageWidth);\n        maxMessageHeight += theMetrics.height;\n      }\n      let messageWidth = maxMessageWidth,\n        messageHeight = maxMessageHeight,\n        scale = 1,\n        theDataIndex = prevColumnIndex || 0,\n        //    不能使用图例顺序legendIndex || theYIndex，因为存在临时隐藏的图例\n        oX = attributeAxis.scale(d['x0']) + (theDataIndex * theColumnWidth + theColumnWidth / 2 + theOutPadding / 2),\n        oY = theScaleFunc(curd) + messageHeight / 2,\n        originX = oX,\n        originY = oY,\n        overlapFlag = false;\n      // 当前标签的位置信息\n      let curTextPosition = {\n        originX: originX,\n        //  标签元素的rotate位置\n        originY: originY,\n        //  标签元素的rotate位置\n        oX: oX,\n        //  标签元素的translate位置[ 标签的区域的中心点x ]\n        oY: oY,\n        //  标签元素的translate位置[ 标签的区域的中心点y ]\n\n        x: oX - messageWidth / 2,\n        //  标签矩形的左上角点的x\n        y: oY - messageHeight / 2,\n        //  标签矩形的左上角点的y\n        width: messageWidth,\n        //  标签的宽度\n        height: messageHeight,\n        //  标签的高度\n        messageArray: messageArray,\n        //  标签的内容数组【多行的数组】\n        messageHeight: maxMessageHeight / (messageArray.length || 1) //  每行标签的高度\n      };\n      // 负值的OY位置\n      if (curd < 0) {\n        if (labelPosition === 'in') {\n          // 图形内靠边，负数往上移动\n          oY = theScaleFunc(curd) + messageHeight / 2;\n          scale = -1;\n        } else if (labelPosition === 'center') {\n          // 图形中居中,应在可视区域中间居中\n          oY = Math.max(theScaleFunc(theMinDomain) + (theScaleFunc(0) - theScaleFunc(theMinDomain)) / 2, theScaleFunc(curd) + (theScaleFunc(0) - theScaleFunc(curd)) / 2);\n          scale = 0;\n        } else {\n          // 图形外靠边[默认]\n          oY = theScaleFunc(curd) - messageHeight / 2;\n          scale = 1;\n        }\n        curTextPosition.originX = oX;\n        curTextPosition.originY = oY;\n        curTextPosition.oX = oX;\n        curTextPosition.oY = oY;\n        curTextPosition.x = oX - messageWidth / 2;\n        curTextPosition.y = oY - scale * messageHeight / 2;\n        curTextPosition.width = messageWidth;\n        curTextPosition.height = messageHeight;\n\n        // 如果负数标签旋转，则中心点是往下移 ，则所占矩形的起点 及 宽高的值得调整\n        if (labelRotation > 0) {\n          if (labelPosition === 'in') {\n            // 图形内靠边，负数往上旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageWidth - messageHeight / 2;\n          } else if (labelPosition === 'center') {\n            // 图形居中，居中旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageWidth / 2;\n          } else {\n            // 标签居图形外，负数往下旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageHeight / 2;\n          }\n          curTextPosition.width = messageHeight;\n          curTextPosition.height = messageWidth;\n        }\n\n        // 如果与图形之间有间隔 , 父数，标签居外时标签下移； 居中时不移动； 局内时上移； [ 由scale决定 ]\n        if (labelChartSpace) {\n          curTextPosition.oY = curTextPosition.oY - scale * labelChartSpace;\n          curTextPosition.y = curTextPosition.y - scale * labelChartSpace;\n        }\n\n        // 负数数往下超出了区域\n        // 默认情况下，负值如果图形下方放的下，图形外靠边；如果图形外放不下，网上移动放不下的距离\n        if (curTextPosition.y - curTextPosition.height < 0) {\n          curTextPosition.y = curTextPosition.height;\n          curTextPosition.oY = curTextPosition.height / 2;\n          curTextPosition.originY = curTextPosition.height / 2;\n        }\n      }\n      // 正值的OY位置\n      else {\n        if (labelPosition === 'in') {\n          // 图形内靠边\n          oY = theScaleFunc(curd) - messageHeight / 2;\n          scale = -1;\n        } else if (labelPosition === 'center') {\n          // 图形中居中,应在可视区域中间居中\n          oY = Math.min(theScaleFunc(theMaxDomain) - (theScaleFunc(theMaxDomain) - theScaleFunc(0)) / 2, theScaleFunc(curd) - (theScaleFunc(curd) - theScaleFunc(0)) / 2);\n          scale = 0;\n        } else {\n          // 图形外靠边[默认]\n          oY = theScaleFunc(curd) + messageHeight / 2;\n          scale = 1;\n        }\n        curTextPosition.originX = oX;\n        curTextPosition.originY = oY;\n        curTextPosition.oX = oX;\n        curTextPosition.oY = oY;\n        curTextPosition.x = oX - messageWidth / 2;\n        curTextPosition.y = oY + scale * messageHeight / 2;\n        curTextPosition.width = messageWidth;\n        curTextPosition.height = messageHeight;\n\n        // 如果正数标签旋转，则中心点是往下移 ，则所占矩形的起点 及 宽高的值得调整\n        if (labelRotation > 0) {\n          if (labelPosition === 'in') {\n            // 图形内靠边，正数往下旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageHeight / 2;\n          } else if (labelPosition === 'center') {\n            // 图形居中，居中旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageWidth / 2;\n          } else {\n            // 图形居外，正数往上旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageWidth - messageHeight / 2;\n          }\n          curTextPosition.width = messageHeight;\n          curTextPosition.height = messageWidth;\n        }\n\n        // 如果与图形之间有间隔 , 正数，标签上移\n        if (labelChartSpace) {\n          curTextPosition.oY = curTextPosition.oY + scale * labelChartSpace;\n          curTextPosition.y = curTextPosition.y + scale * labelChartSpace;\n        }\n\n        // 正数往上超出了区域\n        // 默认情况下，如果图形上方放的下，图形外靠边；如果图形外放不下，则正数往下移动放不下的距离\n        if (scaleMeasureHeight + translateTop < curTextPosition.y) {\n          curTextPosition.y = scaleMeasureHeight + translateTop - curTextPosition.height;\n          curTextPosition.oY = scaleMeasureHeight + translateTop - curTextPosition.height / 2;\n          curTextPosition.originY = scaleMeasureHeight + translateTop - curTextPosition.height / 2;\n        }\n      }\n\n      // 左右超出画图区域无需分正负数\n      // 如果当前数据标签显示区域超出了图形左侧范围，则标签往左放 ； 当前数据标签超出右侧图形范围，则标签往左放 ；\n      if (curTextPosition.x < 0) {\n        // 标签左侧超出了图形\n        curTextPosition.x = 0;\n        curTextPosition.oX = curTextPosition.width / 2;\n        curTextPosition.originX = curTextPosition.width / 2;\n      } else if (curTextPosition.x + curTextPosition.width > scaleAttributeWidth) {\n        // 标签右侧超出了图形\n        curTextPosition.x = scaleAttributeWidth - curTextPosition.width;\n        curTextPosition.oX = scaleAttributeWidth - curTextPosition.width / 2;\n        curTextPosition.originX = scaleAttributeWidth - curTextPosition.width / 2;\n      }\n\n      // 如果配置允许重叠（即allowOverlap = true) 则不需要判断文字标签是否会重叠了\n      for (let i = drewLabelArray.length - 1; !labelAllowOverlap && i >= 0; i--) {\n        let compScatterTextDom = drewLabelArray[i],\n          curScatterTextDom = curTextPosition;\n\n        // 数据标签经过垂直旋转后的矩形信息需要更新\n        if (labelRotation !== 0) {\n          curScatterTextDom = {\n            x: curTextPosition.x + curTextPosition.width / 2 - curTextPosition.height / 2,\n            y: curTextPosition.y + curTextPosition.height / 2 - curTextPosition.width / 2,\n            width: curTextPosition.height,\n            height: curTextPosition.width\n          };\n          compScatterTextDom = {\n            x: compScatterTextDom.x + compScatterTextDom.width / 2 - compScatterTextDom.height / 2,\n            y: compScatterTextDom.y + compScatterTextDom.height / 2 - compScatterTextDom.width / 2,\n            width: compScatterTextDom.height,\n            height: compScatterTextDom.width\n          };\n        }\n        if (_pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isOverlap(curScatterTextDom, compScatterTextDom)) {\n          overlapFlag = true;\n          break;\n        }\n      }\n      if (labelAllowOverlap || !overlapFlag) {\n        drewLabelArray.push(curTextPosition);\n        d.labelPosition = curTextPosition;\n        return true;\n      }\n      return false;\n    }).append(\"g\");\n\n    /*\r\n    // 主要用于矫正位置的rect [ 本地测试使用 ]\r\n    textContainer.append(\"rect\")\r\n        .style(\"fill\" , \"none\")\r\n        .attr(\"width\", function(d){\r\n            let position = d.labelPosition ;\r\n              return position && position.width ;\r\n        })\r\n        .attr(\"height\", function(d){\r\n            let position = d.labelPosition ;\r\n              return position && position.height ;\r\n        })\r\n        .attr(\"x\", function(d){\r\n            let position = d.labelPosition ;\r\n              return position && (position.oX - position.width / 2) ;\r\n        })\r\n        .attr(\"y\", function(d){\r\n            let position = d.labelPosition ;\r\n              return position && (scaleMeasureHeight - position.oY - position.height / 2) ;\r\n        }); */\n    let texts = textContainer.append(\"text\").attr(\"class\", \"labels show-labels\").style(\"fill\", \"inherit\").style(\"stroke\", \"none\").style(\"text-anchor\", \"middle\").style(\"dominant-baseline\", \"middle\").attr(\"x\", function (d) {\n      let position = d.labelPosition;\n      return position && position.oX;\n    }).attr(\"y\", function (d) {\n      let position = d.labelPosition;\n      return position && scaleMeasureHeight - position.oY;\n    }).attr('legendId', options.legendConfig && options.legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].generateLegendId(legendType, legendValue)).attr(\"transform\", \"rotate(\" + labelRotation + \")\").attr(\"transform-origin\", function (d) {\n      let position = d.labelPosition;\n      if (position && labelRotation > 0) {\n        return position.originX + 'px ' + (scaleMeasureHeight - position.originY) + 'px';\n      }\n    });\n    // 数据标签换行的处理\n    texts.each(function (d) {\n      let position = d.labelPosition,\n        theTextDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this),\n        theMessageArray = position && position.messageArray;\n      if (theMessageArray && theMessageArray.length) {\n        for (let i = 0; i < theMessageArray.length; i++) {\n          theTextDom.append(\"tspan\").style(\"dominant-baseline\", \"inherit\").attr(\"x\", position.oX).attr(\"y\", scaleMeasureHeight - position.oY - position.messageHeight * theMessageArray.length / 2 + position.messageHeight / 2 + i * position.messageHeight).text(theMessageArray[i]);\n        }\n      }\n    });\n\n    // 计算完之后恢复刻度的比例尺\n    theScaleFunc.range([scaleMeasureHeight, 0]);\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ColumnChartComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/column/ColumnChartComponent.js?");

/***/ })

}]);