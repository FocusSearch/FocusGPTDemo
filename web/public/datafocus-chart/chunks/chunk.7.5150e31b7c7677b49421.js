(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[7],{

/***/ "../src-v5/assets/js/charts.components/MouseOverChartComponent.js":
/*!************************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/MouseOverChartComponent.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n// 鼠标移入图形区域 及 X轴刻度区域后的响应组件\n\nlet MouseOverChartComponent = {\n  /**\r\n   * 处理鼠标在图形部分移动的事件，高亮对应X刻度的区域\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   需要监控mouseover的SVG的元素[DOM元素]\r\n   *              direction       -   X轴的方向，horizontal: 水平方向移动 ; vertical: 垂直方向移动 ;\r\n   *\r\n   *              hoverTranslateLeft  -   移动模块的左侧偏移量\r\n   *              hoverTranslateTop   -   移动模块的顶部偏移\r\n   *              hoverWidth          -   移动模块的宽度\r\n   *              hoverHeight         -   移动模块的高度\r\n   *\r\n   *              mousemoveCallback   -   鼠标移动的事件回调\r\n   *              mouseoutCallback    -   鼠标移出的事件回调\r\n   *          }\r\n   * **/\n  handleSvgMouseOverEvent: function (options) {\n    options = options || {};\n    if (!options.svgContainer) return false;\n    let self = this,\n      direction = options.direction || 'horizontal',\n      width = parseFloat(options.width) || 0,\n      height = parseFloat(options.height) || 0,\n      left = parseFloat(options.left) || 0,\n      top = parseFloat(options.top) || 0,\n      prevStartIndex = parseInt(options.prevStart) || 0,\n      hoverWidth = parseFloat(options.hoverWidth) || 0,\n      hoverHeight = parseFloat(options.hoverHeight) || 0;\n    if (!width || !height || !hoverWidth || !hoverHeight) return false;\n    self.removeHoverAreaDom({\n      svgContainer: options.svgContainer\n    });\n    typeof options.mouseoutCallback === 'function' && options.mouseoutCallback();\n    _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.svgContainer).on('mousemove', null).on('mouseout', null).on(\"mousemove\", function () {\n      let coordinate = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mouse(this);\n      if (!coordinate) return;\n      let theOffsetX = coordinate[0],\n        theOffsetY = coordinate[1];\n      // 如果当前鼠标在X轴的可视移动范围内，则高亮对应刻度的区域\n      if (theOffsetX > left && theOffsetX < left + width && theOffsetY > top && theOffsetY <= top + height) {\n        // 计算当前鼠标位置所属的X轴刻度，显示对应区域\n        let theHoverDom = self.appendHoverAreaDom({\n          svgContainer: options.svgContainer,\n          hoverWidth: hoverWidth,\n          hoverHeight: hoverHeight,\n          direction: direction\n        });\n\n        // 水平方向移动\n        if (direction === 'horizontal') {\n          let theLabelIndex = Math.floor((theOffsetX - left) / hoverWidth),\n            theLeft = theLabelIndex * hoverWidth;\n          theHoverDom.attr(\"transform\", \"translate(\" + (left + theLeft) + \", \" + top + \")\");\n          typeof options.mousemoveCallback === 'function' && options.mousemoveCallback({\n            event: _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event,\n            xLabelIndex: theLabelIndex + prevStartIndex\n          });\n        }\n        // 垂直方向移动\n        else {\n          let theLabelIndex = Math.floor((theOffsetY - top) / hoverHeight),\n            theTop = theLabelIndex * hoverHeight;\n          theHoverDom.attr(\"transform\", \"translate(\" + left + \", \" + (top + theTop) + \")\");\n          typeof options.mousemoveCallback === 'function' && options.mousemoveCallback({\n            event: _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event,\n            xLabelIndex: theLabelIndex + prevStartIndex\n          });\n        }\n      }\n    }).on(\"mouseout\", function () {\n      let event = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event;\n      self.removeHoverAreaDom({\n        svgContainer: options.svgContainer\n      });\n      typeof options.mouseoutCallback === 'function' && options.mouseoutCallback();\n    });\n  },\n  /**\r\n   * 处理鼠标在多层X轴图形部分鼠标移入的事件，高亮对应X刻度的区域\r\n   * --- 注： 该方法依赖于AttributeAxisComponent.drawAttributeLevelLineAxis画多层X轴的中每个刻度上有 prevWidth 及 level / level-length 等属性 --\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   需要监控mouseover的SVG的元素[DOM元素]\r\n   *              direction       -   X轴的方向，horizontal: 水平方向移动 ; vertical: 垂直方向移动 ;\r\n   *\r\n   *              left            -   X轴的左侧偏移值\r\n   *              top             -   X轴的顶部偏移值\r\n   *              prevStart       -   当前整个X轴的起始点\r\n   *\r\n   *              hoverWidth          -   移动模块的宽度\r\n   *              hoverHeight         -   移动模块的高度\r\n   *\r\n   *              mousemoveCallback   -   鼠标移动的事件回调\r\n   *              mouseoutCallback    -   鼠标移出的事件回调\r\n   *          }\r\n   * **/\n  handleXLevelMouseOverEvent: function (options) {\n    options = options || {};\n    if (!options.svgContainer) return false;\n    let self = this,\n      direction = options.direction || 'horizontal',\n      left = parseFloat(options.left) || 0,\n      leafLeft = parseFloat(options.leafLeft) || 0,\n      top = parseFloat(options.top) || 0,\n      prevStartIndex = parseInt(options.prevStart) || 0,\n      separate = parseFloat(options.separate) || 0; //  X刻度与图形之间的间隔\n    self.removeHoverAreaDom({\n      svgContainer: options.svgContainer\n    });\n    typeof options.mouseoutCallback === 'function' && options.mouseoutCallback();\n    _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.svgContainer).selectAll(\".level-label-item\").on('mouseover.hover', null).on('mouseout.hover', null).on(\"mouseover.hover\", function () {\n      let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this),\n        theLevelIndex = parseInt(theDom.attr(\"level\")) || 0,\n        theLevelLength = parseInt(theDom.attr(\"level-length\")) || 0,\n        prevWidth = parseFloat(theDom.attr(\"prevWidth\")) || 0,\n        prevHeight = parseFloat(theDom.attr(\"prevHeight\")) || 0,\n        width = parseFloat(theDom.attr(\"width\")) || 0,\n        height = parseFloat(theDom.attr(\"height\")) || 0,\n        hoverWidth = parseFloat(options.hoverWidth) || 0,\n        hoverHeight = parseFloat(options.hoverHeight) || 0;\n      const prevLevelTotalWidth = parseFloat(theDom.attr('prevLevelTotalWidth')) || 0;\n      const leafLabelIndex = parseFloat(theDom.attr('leafLabelIndex')) || 0;\n\n      // 多层X轴在水平方向上\n      if (direction === 'horizontal') {\n        if (width) {\n          let theHoverDom = self.appendHoverAreaDom({\n            svgContainer: options.svgContainer,\n            hoverWidth: width,\n            hoverHeight: hoverHeight,\n            direction: direction\n          });\n\n          // 如果当前刻度宽度\n          if (theLevelIndex === theLevelLength - 1) {\n            let coordinate = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].mouse(this),\n              theOffsetX = coordinate[0] + prevWidth;\n            let theLabelIndex = Math.floor(theOffsetX / hoverWidth),\n              theLeft = theLabelIndex * hoverWidth;\n            theHoverDom.attr(\"transform\", \"translate(\" + (left + theLeft) + \", \" + top + \")\");\n            typeof options.mousemoveCallback === 'function' && options.mousemoveCallback({\n              event: _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event,\n              xLabelIndex: theLabelIndex + prevStartIndex\n            });\n          } else {\n            typeof options.mouseoutCallback === 'function' && options.mouseoutCallback();\n          }\n          let theXLabelHeight = (theLevelLength - theLevelIndex - 1) * height;\n          if (theXLabelHeight > 0) theXLabelHeight += separate;\n          theHoverDom.attr(\"transform\", \"translate(\" + (left + prevWidth) + \", \" + (top + theXLabelHeight) + \")\");\n        }\n      } else {\n        let theHoverDom = self.appendHoverAreaDom({\n          svgContainer: options.svgContainer,\n          hoverWidth: hoverWidth,\n          hoverHeight: height,\n          // 每个叶子Label的高度\n          direction: direction\n        });\n\n        // 如果当前刻度宽度是叶子level\n        if (theLevelIndex === theLevelLength - 1) {\n          const theTop = leafLabelIndex * hoverHeight;\n          theHoverDom.attr(\"transform\", `translate(${leafLeft}, ${top + theTop})`);\n          typeof options.mousemoveCallback === 'function' && options.mousemoveCallback({\n            event: _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event,\n            xLabelIndex: leafLabelIndex + prevStartIndex\n          });\n        } else {\n          // 横向偏移\n          let theXLabelWidth = prevLevelTotalWidth;\n          if (theXLabelWidth > 0) theXLabelWidth += separate;\n          theHoverDom.attr('transform', `translate(${left + theXLabelWidth + width}, ${top + prevHeight})`);\n          typeof options.mouseoutCallback === 'function' && options.mouseoutCallback();\n        }\n      }\n    }).on(\"mouseout.hover\", function () {\n      self.removeHoverAreaDom({\n        svgContainer: options.svgContainer\n      });\n      typeof options.mouseoutCallback === 'function' && options.mouseoutCallback();\n    });\n  },\n  /**\r\n   * 增加高亮刻度的区域元素\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   画图容器\r\n   *              hoverWidth      -   高亮区间的宽度\r\n   *              hoverHeight     -   高亮区间的高度\r\n   *              direction       -   horizontal边界在底部， vertical 边界在左侧\r\n   *          }\r\n   * */\n  appendHoverAreaDom: function (options) {\n    options = options || {};\n    if (!options.svgContainer) return false;\n    let theContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.svgContainer),\n      theHoverDom = theContainer.select(\".hover-area-dom\");\n    let hoverWidth = parseFloat(options.hoverWidth) || 0,\n      hoverHeight = parseFloat(options.hoverHeight) || 0;\n    const direction = options.direction === 'vertical' ? 'vertical' : 'horizontal';\n    if (!theHoverDom[0][0]) {\n      theHoverDom = theContainer.append(\"g\").attr(\"class\", \"hover-area-dom\").attr(\"pointer-events\", 'none');\n      theHoverDom.append(\"rect\")\n      // .style(\"fill\" , \"rgba(93 , 25 , 128 , 0.1)\")\n      .style(\"fill\", \"rgba(137,137,137,0.3)\").style(\"stroke\", \"none\").attr(\"x\", \"0\").attr(\"y\", \"0\").attr(\"width\", hoverWidth).attr(\"height\", hoverHeight);\n      if (direction === 'horizontal') {\n        theHoverDom.append(\"line\").style(\"stroke\", \"rgba(93 , 25 , 128)\").style(\"stroke-width\", \"1\").attr(\"x1\", \"0\").attr(\"y1\", hoverHeight).attr(\"x2\", hoverWidth).attr(\"y2\", hoverHeight);\n      } else if (direction === 'vertical') {\n        theHoverDom.append(\"line\").style(\"stroke\", \"rgba(93 , 25 , 128)\").style(\"stroke-width\", \"1\").attr(\"x1\", \"0\").attr(\"x2\", \"0\").attr(\"y1\", \"0\").attr(\"y2\", hoverHeight);\n      }\n    }\n    return theHoverDom;\n  },\n  /**\r\n   * 删除高亮刻度的区域元素\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   画图容器\r\n   *          }\r\n   */\n  removeHoverAreaDom: function (options) {\n    options = options || {};\n    if (!options.svgContainer) return false;\n    let theContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.svgContainer);\n    theContainer.select(\".hover-area-dom\").remove();\n  }\n};\n\n// let theMapping = theDistinctMapping[d] ;\n// if(!theMapping) return '' ;\n//\n// let thePrevRangeBandLength = theMapping.prevLength || 0;\n// let thePrevWidth = thePrevRangeBandLength * theXRangeBand ,\n//     theWidth = (theMapping.length || 0) * theXRangeBand;\n// let theTextSize = CommonComponent.getStrSizeByCanvas('string' , d , {fontSize: axisFontSize}) ;\n// let theHoverDom = MouseOverChartComponent.appendHoverAreaDom({\n//     svgContainer: options.svgContainer ,\n//     hoverWidth: theWidth ,\n//     hoverHeight: options.drawHeight - (theTextSize.height * i),\n// }) ;\n// theHoverDom.attr(\"transform\" , \"translate(\"+ thePrevWidth +\", 0)\") ;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MouseOverChartComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/MouseOverChartComponent.js?");

/***/ }),

/***/ "../src-v5/assets/js/charts.components/ZoomChartComponent.js":
/*!*******************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/ZoomChartComponent.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n// 图形缩放的处理\n\nlet ZoomChartComponent = {\n  /**\r\n   * 缩放图形中的柱形宽度\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   svg画图元素\r\n   *              start           -   当前的X轴刻度起点\r\n   *              pageSize        -   每页的X轴刻度数\r\n   *              zoomingFunc     -   缩放的方法\r\n   *              zoomRelativeToMouse        -   是否依据鼠标所在位置进行缩放\r\n   *          }\r\n   * **/\n  zoomColumnChart: function (options) {\n    options = options || {};\n    if (!options.svgContainer) return false;\n    let theStart = parseInt(options.start) || 0,\n      theSteps = parseInt(options.steps) || 0;\n    const previousSteps = theSteps;\n    _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(options.svgContainer).call(_pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].behavior.zoom().scaleExtent([0, 100]).on(\"zoom\", function () {\n      let event = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event,\n        theScale = event.scale;\n      // 缩放\n      if (theScale > 1) {\n        // 放大柱宽，减少每页的数量\n        theSteps = Math.floor(theSteps / 1.5);\n        theSteps = Math.max(1, theSteps);\n      } else {\n        // 缩小柱宽，增加每页的数量\n        theSteps = Math.ceil(theSteps * 1.5);\n        theSteps = Math.max(1, theSteps);\n      }\n      if (options.zoomRelativeToMouse) {\n        // 依据鼠标所在位置进行缩放，确保缩放后，当前鼠标所在位置的图形元素位于图形中央\n        const {\n          sourceEvent: {\n            offsetX\n          }\n        } = event;\n        // 鼠标位置在画布的百分比\n        const positionPercent = offsetX / options.svgContainer.getBoundingClientRect().width;\n        // 缩放前，鼠标所在位置的刻度序号\n        const middle = Math.round((theStart + theStart + previousSteps) * positionPercent);\n        theStart = Math.round(middle - theSteps / 2);\n        theStart = Math.max(0, theStart);\n      }\n      typeof options.zoomingFunc === 'function' && options.zoomingFunc({\n        type: 'zoom',\n        start: theStart,\n        steps: theSteps,\n        animateFlag: false\n      });\n    })).on(\"mousedown.zoom\", null).on(\"mousemove.zoom\", null).on(\"dblclick.zoom\", null).on(\"touchstart.zoom\", null).on(\"wheel\", function () {\n      _DataFocusMethod.stopEventDefault(_pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].event);\n    });\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ZoomChartComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/ZoomChartComponent.js?");

/***/ })

}]);