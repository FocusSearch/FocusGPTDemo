(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[32],{

/***/ "../src-v5/assets/js/charts.system.senior/analysisGroup.js":
/*!*****************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.senior/analysisGroup.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../charts.plugin/animationTimeSequenceFrame */ \"../src-v5/assets/js/charts.plugin/animationTimeSequenceFrame.js\");\n\n\n/** 相关图画图组件 **/\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  chartType: 'analysisGroup',\n  //  图形名 [ * 必填项 ]\n  chartDisplayNameKey: \"chart-name-title\",\n  //  图形名称中英文Key [ * 必填项 ]\n  chartDescriptionKey: \"chart-description-title\",\n  //  图形描述中英文Key [ * 必填项 ]\n\n  /**\n   * 判断图形允许画的方法 [ * 必填项 ]\n   * 适合柱状图的条件 ， 聚合数据且至少一个属性列及至少一个数值列\n   * @param searchResultStatistic\n   *          {\n   *              aggregatedFlag  搜索数据是否聚合的标志\n   *\n   *              measureColumns    数值列数量\n   *              attributeColumns  属性列数量\n   *              legendColumns     能作为图例的属性列数量（distinct_count < 50 的列）\n   *              dateColumns       日期列数量\n   *              lonColumns        经度列数量\n   *              latColumns        纬度列数量\n   *              queryResultCount    查询数据结果条目\n   *              regionColumns        地理列数组（1：国家集合；1.5：国家；2：省集合；2.5：省；3：市集合；3.5：市；4：区集合；4.5：区；0：其他地理列）\n   *          }\n   *\n   * @return Boolean  true: 当前数据适合画当前图形；false: 当前数据不适合画当前图形\n   * */\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n\n    // 至少两个属性类。其余一个为属性列或数值列\n    if (searchResultStatistic && searchResultStatistic.aggregatedFlag && searchResultStatistic.attributeColumns && searchResultStatistic.measureColumns) {\n      if (searchResultStatistic.measureColumns.length >= 0 && searchResultStatistic.attributeColumns.length >= 3) {\n        satisfiedFlag = true;\n      }\n      if (searchResultStatistic.measureColumns.length >= 1 && searchResultStatistic.attributeColumns.length >= 2) {\n        satisfiedFlag = true;\n      }\n    }\n    return satisfiedFlag;\n  },\n  // 图形配置元素 [ * 必填项 ]\n  needAxis: {\n    // 起点实体和终点实体\n    columns: {\n      i18nKey: \"chart-columns-title\"\n    },\n    // 起点属性和终点属性（图例）\n    rows: {\n      i18nKey: \"chart-rows-title\"\n    },\n    // 边\n    values: {\n      i18nKey: \"chart-values-title\"\n    }\n  },\n  // 获取当前图形可用的轴配置\n  generateSatisfiedAxes: {\n    // 起点实体和终点实体（Column）的类型为属性列。默认规则即可满足\n\n    // Rows 为属性类和数值列\n    rowsAction: function (searchResultStatistic) {\n      const attributeColumns = searchResultStatistic.attributeColumns || [];\n      const measureColumns = searchResultStatistic.measureColumns || [];\n      return [...attributeColumns.map(function (h) {\n        return h.idx;\n      }), ...measureColumns.map(function (h) {\n        return h.idx;\n      })];\n    },\n    // 边既可以为属性列，也可以为数值列\n    valuesAction: function (searchResultStatistic) {\n      const attributeColumns = searchResultStatistic.attributeColumns || [];\n      const measureColumns = searchResultStatistic.measureColumns || [];\n      return [...attributeColumns.map(h => h.idx), ...measureColumns.map(h => h.idx)];\n    }\n  },\n  pickAxesFromSatisfied: {\n    // TODO: Find a way to access needAxis in this method.\n    columnsAction: function (theChartType, chartAxis) {\n      return chartAxis.columnArea.slice(0, 2);\n    },\n    rowsAction: function (theChartType, chartAxis) {\n      const prefillRow = chartAxis.rowArea.find(function (row) {\n        const isRowUsedInColumns = chartAxis.curColumns.find(column => column.index === row.index);\n        return row.columnType === 'attribute' && !isRowUsedInColumns;\n      });\n      return prefillRow ? [prefillRow] : [];\n    },\n    valuesAction: function (theChartType, chartAxis) {\n      let prefillValue = chartAxis.valueArea.find(function (valueColumn) {\n        const isValueUsedInColumns = chartAxis.curColumns.find(column => column.index === valueColumn.index);\n        const isValueUsedInRows = chartAxis.curRows.find(row => row.index === valueColumn.index);\n        return !isValueUsedInColumns && !isValueUsedInRows;\n      });\n      if (!prefillValue && chartAxis.curRows.length) {\n        prefillValue = chartAxis.curRows[0];\n        chartAxis.curRows = [];\n      }\n      return prefillValue ? [prefillValue] : [];\n    }\n  },\n  /**\n   * 判断当前图形的Axis配置是否合法 [ * 必填项 ]\n   * 例：X轴不允许为空，Y轴不允许为空，X轴不允许与图例列相同\n   * @params [Object]theAxisConfig      -   当前用户手动配置的规则\n   *          {\n   *              xAxis: [{\n   *                  index\n   *                  columnId\n   *                  type\n   *              }] ,\n   *              yAxis: [{\n   *                  index\n   *                  columnId\n   *              }] ,\n   *              legend: [{\n   *                  index\n   *                  columnId\n   *              }] ,\n   *\n   *              // 搜素数据的统计信息\n   *              searchResultStatistic: {\n   *                  aggregatedFlag  搜索数据是否聚合的标志\n   *\n   *                  measureColumns    数值列数量\n   *                  attributeColumns  属性列数量\n   *                  legendColumns     能作为图例的属性列数量（distinct_count < 50 的列）\n   *                  dateColumns       日期列数量\n   *                  lonColumns        经度列数量\n   *                  latColumns        纬度列数量\n   *                  queryResultCount    查询数据结果条目\n   *                  regionColumns        地理列数组（1：国家集合；1.5：国家；2：省集合；2.5：省；3：市集合；3.5：市；4：区集合；4.5：区；0：其他地理列）\n   *              }\n   *          }\n   *\n   * 判断条件：\n   * 1. xAxis不允许为空\n   * 2. yAxis不允许为空\n   * 3. 主Y轴不允许为空\n   * 4. legend只允许一个\n   * 5. legend存在时Y轴只允许一个\n   * 6. legend不允许与xAxis重复\n   *\n   * @return [String]errorKey -   错误提示对应的key;\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let theErrorMsgKey = '';\n    if (!theAxisConfig) {\n      theErrorMsgKey = 'chart-axis-config-null-error';\n      return theErrorMsgKey;\n    }\n\n    // 1. columns 不能为空，长度等于2\n    if (!theAxisConfig.columns || !theAxisConfig.columns.length) {\n      theErrorMsgKey = 'chart-entity-null';\n      return theErrorMsgKey;\n    }\n    if (theAxisConfig.columns.length !== 2) {\n      theErrorMsgKey = 'chart-entity-correspond';\n      return theErrorMsgKey;\n    }\n\n    // 2. 起始点的图例列或数值列。最多只能有一个\n    if (theAxisConfig.rows && theAxisConfig.rows.length > 1) {\n      theErrorMsgKey = 'chart-legend-correspond';\n      return theErrorMsgKey;\n    }\n\n    // 3. 边属性。有且仅有一个\n    if (!theAxisConfig.values) {\n      return 'chart-edge-null';\n    } else {\n      if (theAxisConfig.values.length === 0) {\n        return 'chart-edge-null';\n      } else if (theAxisConfig.values.length > 1) {\n        return 'chart-edge-too-much';\n      } else if (theAxisConfig.values[0]) {\n        const conflictValue = theAxisConfig.rows.find(row => row.index === theAxisConfig.values[0].index);\n        if (conflictValue) return 'chart-edge-same-with-legend';\n      }\n    }\n    return theErrorMsgKey;\n  },\n  // 当前图形的配置项[ *新增图形必填项 ]\n  chartConfigureList: [\n  // 公共配置\n  {\n    key: \"category_general\",\n    title: \"category_chart_general\",\n    options: [\n    // 背景颜色\n    // {\n    //     key: \"style_background_color\",\n    //     title: \"option_style_background_color\",\n    //     description: \"option_style_background_color_desc\",\n    //     type: \"color\"\n    // },\n    //主题颜色\n    {\n      key: \"chart_color_theme\",\n      title: \"option_chart_color_theme\",\n      description: \"option_chart_color_theme_desc\",\n      type: \"select\",\n      selection: [\"option_chart_theme_one\", \"option_chart_theme_two\", \"option_chart_theme_three\", \"option_chart_theme_four\", \"option_chart_theme_five\", \"option_chart_theme_six\", \"option_chart_theme_seven\", \"option_chart_theme_custom\"],\n      require: \"node_color_mode=option_node_color_mode_partition\"\n    },\n    //自定义\n    {\n      key: \"chart_custom_theme\",\n      title: \"option_chart_custom_theme\",\n      description: \"option_chart_custom_theme_desc\",\n      type: \"colorList\",\n      require: \"chart_color_theme=option_chart_theme_custom\"\n    },\n    //搜索记录\n    {\n      key: \"chart_page_size\",\n      title: \"option_chart_page_size\",\n      description: \"option_chart_page_size_desc\",\n      onlyConfigFlag: true,\n      type: \"input\",\n      defaultNumber: 1000,\n      withoutSlider: true\n    }]\n  },\n  // 布局配置\n  {\n    key: \"category_layout\",\n    title: \"category_layout\",\n    options: [\n    //视图模式\n    {\n      key: \"entire_force_model\",\n      title: \"option_entire_force_model\",\n      description: \"option_entire_force_model_desc\",\n      type: \"select\",\n      selection: [\"option_entire_force_center_gravitation\", \"option_entire_force_around_repulsive\", \"option_entire_force_radial\"]\n    },\n    // 中心引力：节点引力大小\n    {\n      key: \"node_gravity_force\",\n      title: \"option_node_gravity_force\",\n      description: \"option_node_gravity_force_desc\",\n      type: \"input\",\n      min: 0,\n      max: 2000,\n      defaultNumber: 80,\n      withoutSlider: true,\n      require: \"entire_force_model=option_entire_force_center_gravitation\"\n    },\n    // 边缘斥力：节点斥力大小\n    {\n      key: \"node_repulsive_force\",\n      title: \"option_node_repulsive_force\",\n      description: \"option_node_repulsive_force_desc\",\n      type: \"input\",\n      min: 0,\n      max: 2000,\n      defaultNumber: 80,\n      withoutSlider: true,\n      require: \"entire_force_model=option_entire_force_around_repulsive\"\n    },\n    // 圆形布局：力场强度\n    {\n      key: \"layout_radial_strength\",\n      title: \"option_layout_radial_strength\",\n      description: \"option_layout_radial_strength_desc\",\n      type: \"input\",\n      require: \"entire_force_model=option_entire_force_radial\",\n      min: 0,\n      max: 1,\n      defaultNumber: 1,\n      step: 0.1,\n      withoutSlider: true\n    },\n    // 圆形布局：力场半径\n    {\n      key: \"layout_radial_radius\",\n      title: \"option_layout_radial_radius\",\n      description: \"option_layout_radial_radius_desc\",\n      require: \"entire_force_model=option_entire_force_radial\",\n      type: \"input\",\n      min: 20,\n      max: 1000,\n      defaultNumber: 200,\n      withoutSlider: true\n    },\n    // 通用：碰撞时节点重合百分比\n    {\n      key: \"node_overlap_max_rate\",\n      title: \"option_node_overlap_max_rate\",\n      description: \"option_node_overlap_max_rate_desc\",\n      type: \"input\",\n      min: 0,\n      max: 80,\n      defaultNumber: 0,\n      withoutSlider: true\n    },\n    // 通用：节点最小距离：manyBody\n    {\n      key: \"node_min_distance\",\n      title: \"option_node_min_distance\",\n      description: \"option_node_min_distance\",\n      type: \"input\",\n      min: 0,\n      max: 2000,\n      defaultNumber: 1,\n      withoutSlider: true\n    },\n    // 通用：节点最大距离：manyBody\n    {\n      key: \"node_max_distance\",\n      title: \"option_node_max_distance\",\n      description: \"option_node_max_distance_desc\",\n      type: \"input\",\n      min: 80,\n      max: 5000,\n      defaultNumber: 5000,\n      withoutSlider: true\n    },\n    // 通用：连线长度\n    {\n      key: \"edge_link_distance\",\n      title: \"option_edge_link_distance\",\n      description: \"option_edge_link_distance_desc\",\n      type: \"input\",\n      min: 20,\n      max: 500,\n      defaultNumber: 30,\n      step: 10,\n      withoutSlider: true\n    },\n    // 通用：力场中连边的自适应刚性\n    {\n      key: \"adjust_link_rigidity_re\",\n      title: \"option_adjust_link_rigidity_re\",\n      description: \"option_adjust_link_rigidity_re_desc\",\n      type: \"checkbox\",\n      value: false\n    },\n    // 通用：连线强度\n    {\n      key: \"edge_link_rigidity\",\n      title: \"option_edge_link_rigidity\",\n      description: \"option_edge_link_rigidity_desc\",\n      type: \"input\",\n      require: \"!adjust_link_rigidity_re\",\n      min: 0,\n      max: 1,\n      defaultNumber: 0.1,\n      step: 0.01,\n      withoutSlider: true\n    }]\n  },\n  // 节点配置\n  {\n    key: \"category_node\",\n    title: \"category_node\",\n    options: [\n    // 颜色模式：Static、Ranking、Partition\n    {\n      key: \"node_color_mode\",\n      title: \"option_node_color_mode\",\n      description: \"option_node_color_mode_desc\",\n      type: \"select\",\n      selection: [\"option_node_color_mode_static\", \"option_node_color_mode_ranking\", \"option_node_color_mode_partition\"]\n    },\n    // ranking: 节点 Ranking 时的依据：1度，2数值列\n    {\n      key: \"node_ranking_condition\",\n      title: \"option_node_ranking_condition\",\n      description: \"option_node_ranking_condition_desc\",\n      type: \"select\",\n      selection: [\"option_node_ranking_by_degree\", \"option_node_ranking_by_measure\"],\n      require: \"node_color_mode=option_node_color_mode_ranking\"\n    },\n    // static: 统一的节点颜色\n    {\n      key: \"node_static_color\",\n      title: \"option_node_static_color\",\n      description: \"option_node_static_color_desc\",\n      type: \"color\",\n      value: '#000',\n      // 默认黑色，没起作用。还是undefined\n      require: \"node_color_mode=option_node_color_mode_static,option_node_color_mode_ranking\"\n    },\n    // partition: 开启节点分类的布局\n    {\n      key: \"node_category_layout\",\n      title: \"option_node_category_layout\",\n      description: \"option_node_category_layout_desc\",\n      type: \"checkbox\",\n      value: false,\n      require: 'node_color_mode=option_node_color_mode_partition'\n    },\n    // partition: 节点分类的半径\n    {\n      key: \"node_category_layout_radius\",\n      title: \"option_node_category_layout_radius\",\n      description: \"option_node_category_layout_radius_desc\",\n      type: \"input\",\n      min: 15,\n      max: 500,\n      defaultNumber: 80,\n      withoutSlider: true,\n      require: 'node_color_mode=option_node_color_mode_partition'\n    },\n    // general: 节点最小半径\n    {\n      key: \"style_node_radius_min\",\n      title: \"option_style_node_radius_min\",\n      description: \"option_style_node_radius_min_desc\",\n      type: \"input\",\n      min: 2,\n      max: 80,\n      defaultNumber: 5,\n      withoutSlider: true\n    },\n    //  general: 节点最大半径\n    {\n      key: \"style_node_radius_max\",\n      title: \"option_style_node_radius_max\",\n      description: \"option_style_node_radius_max_desc\",\n      type: \"input\",\n      min: 2,\n      max: 80,\n      defaultNumber: 20,\n      withoutSlider: true\n    },\n    // general: 节点描边宽\n    {\n      key: \"style_node_border_width\",\n      title: \"option_style_node_border_width\",\n      description: \"option_style_node_border_width_desc\",\n      type: \"input\",\n      min: 0,\n      max: 12,\n      defaultNumber: 2,\n      withoutSlider: true\n    },\n    // general: 节点描边颜色\n    {\n      key: \"style_node_border_color\",\n      title: \"option_style_node_border_color\",\n      description: \"option_style_node_border_color_desc\",\n      type: \"color\"\n    },\n    //开启固定点\n    {\n      key: \"allow_fixed_point\",\n      title: \"option_allow_fixed_point\",\n      description: \"option_allow_fixed_point_desc\",\n      type: \"checkbox\",\n      value: false,\n      hide: true\n    },\n    // 固定点的配置信息\n    {\n      key: \"fixed_dot_pos\",\n      title: \"option_fixed_dot_pos\",\n      description: \"option_fixed_dot_pos_desc\",\n      type: \"text\"\n      // hide: true\n    }]\n  },\n  // 边配置\n  {\n    key: \"category_edge\",\n    title: \"category_edge\",\n    options: [\n    // 是否打开边\n    {\n      key: \"disable_link\",\n      title: \"option_disable_link\",\n      description: \"option_disable_link_desc\",\n      type: \"checkbox\",\n      value: false\n    },\n    // 连边模式：有向、无向\n    {\n      key: \"style_link_model\",\n      title: \"option_style_link_model\",\n      description: \"option_style_link_model_desc\",\n      type: \"select\",\n      selection: [\"option_style_link_model_undirected\", \"option_style_link_model_directed\"],\n      require: \"!disable_link\"\n    },\n    // 连边颜色跟随节点\n    {\n      key: \"style_link_color_follow_node\",\n      title: \"option_style_link_color_follow_node\",\n      description: \"option_style_link_color_follow_node_desc\",\n      type: \"checkbox\",\n      value: false,\n      require: \"!disable_link\"\n    },\n    // 连线颜色\n    {\n      key: \"style_link_color\",\n      title: \"option_style_link_color\",\n      description: \"option_style_link_color_desc\",\n      type: \"color\",\n      require: \"!disable_link;!style_link_color_follow_node\"\n    },\n    // 自适应连边宽度\n    {\n      key: \"adjust_link_width_re\",\n      title: \"option_adjust_link_width_re\",\n      description: \"option_adjust_link_width_re_desc\",\n      type: \"checkbox\",\n      value: false,\n      require: \"!disable_link\"\n    },\n    // 连边宽度\n    {\n      key: \"style_link_width\",\n      title: \"option_style_link_width\",\n      description: \"option_style_link_width_desc\",\n      type: \"input\",\n      require: \"!disable_link;!adjust_link_width_re\",\n      min: 0,\n      max: 3,\n      defaultNumber: 1.5,\n      withoutSlider: true,\n      step: 0.1\n    }]\n  },\n  //图例\n  {\n    key: \"category_legend\",\n    title: \"category_chart_legend\",\n    options: [\n    // 显示图例\n    {\n      key: \"hide_chart_legend\",\n      title: \"option_hide_chart_legend\",\n      description: \"option_legend_font_family_desc\",\n      type: 'checkbox',\n      value: true\n    },\n    // 图例颜色\n    {\n      key: \"legend_font_color\",\n      title: \"option_legend_font_color\",\n      type: \"color\",\n      defaultColor: \"#585C63\",\n      require: \"!hide_chart_legend\"\n    },\n    // 自定义图例\n    {\n      key: \"chart_custom_legend\",\n      title: \"option_chart_custom_legend_1\",\n      description: \"option_chart_custom_legend_desc\",\n      type: \"attrColorArray\",\n      require: \"!hide_chart_legend\"\n    },\n    // 图例字体大小\n    {\n      key: \"legend_font_size\",\n      title: \"option_legend_font_size\",\n      type: \"input\",\n      min: 10,\n      max: 100,\n      defaultNumber: 13,\n      withoutSlider: true,\n      require: \"!hide_chart_legend\"\n    },\n    // 图例位置\n    {\n      key: \"chart_legend_position\",\n      title: \"option_chart_legend_position\",\n      type: \"select\",\n      selection: [\"option_legend_position_bottom\", \"option_legend_position_right\"],\n      require: \"!hide_chart_legend\"\n    }]\n  },\n  // 悬浮文本设置\n  {\n    key: \"category_suspend_text\",\n    title: \"category_suspend_text\",\n    options: [{\n      // 是否隐藏悬浮文本\n      key: \"hidden_hover_text\",\n      title: \"option_hidden_hover_text\",\n      description: \"option_hidden_hover_text_desc\",\n      type: \"checkbox\",\n      value: false\n    }, {\n      key: \"suspend_text_regex\",\n      title: \"option_suspend_text_regex\",\n      description: \"option_suspend_text_regex_correlation_desc\",\n      type: \"textArea\",\n      require: \"!hidden_hover_text\"\n    }]\n  },\n  //数据标签\n  {\n    key: \"category_label\",\n    title: \"category_label_1\",\n    options: [\n    // 是否显示数据标签\n    {\n      key: \"label_text_visible\",\n      title: \"option_label_text_visible\",\n      description: \"option_label_text_visible_desc\",\n      type: 'checkbox'\n    },\n    // 数据标签的颜色\n    {\n      key: \"label_text_color\",\n      title: \"option_label_text_color\",\n      description: \"option_label_text_color_desc\",\n      type: 'color',\n      require: 'label_text_visible'\n    },\n    // 数据标签内容\n    {\n      key: \"label_text_regex\",\n      title: \"option_label_text_regex\",\n      description: \"option_label_text_regex_sampleArea_desc\",\n      type: \"textArea\",\n      require: 'label_text_visible'\n    },\n    //允许重叠\n    {\n      key: \"label_text_allow_overlap\",\n      title: \"option_label_text_allow_overlap\",\n      description: \"option_label_text_allow_overlap_desc\",\n      type: \"checkbox\",\n      require: 'label_text_visible'\n    }\n    //恢复默认配置\n    // {\n    //     key: \"chart_config_restart\",\n    //     title: \"option_chart_config_restart\",\n    //     type: \"restart\",\n    // }\n    ]\n  }],\n  /**\n   * 使用个人画图方法画图形 [*必填项]\n   * @params [Object]options  -   当前图形的配置\n   *              {\n   *                  container       -   当前画图的DOM元素\n   *                  chartAxis       -   当前图形的Axis配置\n   *                  datas           -   当前画图数据\n   *                  isResize        -   是否是窗口变化引起的画图\n   *                  chartConfigures -   图形配置\n   *                  plugins         -   DataFocus提供的第三方画图库\n   *                      {\n   *                          d3  -   d3的v7版本\n   *                          echarts -   echarts的\n   *                      }\n   *              }\n   * **/\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n\n    //系统配置\n    let d3 = options.plugins.d3v7;\n    console.log(\"version : d3 v7\");\n    const locale = options.currentChart.language === 'chinese' ? 'cn' : 'en';\n    let chartBackgroundColor = \"#fff\";\n\n    // 1. 默认配置\n    let fontSize = options.currentChart.defaultConf.fontSize || 14;\n    let localColor = options.currentChart.defaultConf.localColors.slice(0);\n\n    //获取配置信息\n    let labelColor;\n    let fontSizeFlag = false;\n    let nodeShape = \"circle\"; // 图例的形状\n    let nodeShapeArray = [\"circle\", \"rect\", \"triangle\", \"diamond\", \"star\", \"fivestar\", \"hexagon\", \"jewel\", \"x\"]; // 图例的形状集合\n\n    let entireForceModel = \"center\"; // 视图模式\n\n    let nodeColorMode = 'static';\n    let nodeRankingCondition = \"degree\";\n    let nodeColor = localColor[0]; // 用于统一颜色和 Ranking 颜色\n\n    let nodeBodyColor; // 节点最终应用的颜色\n    let nodeBorderWidth = 2;\n    let nodeBorderColor;\n    let nodeRadiusMax = 50;\n    let nodeRadiusMin = 5;\n    let nodeOverlapRate = 0;\n    let nodeCategoryLayout = false; // 开启节点分类布局\n    let nodeCategoryLayoutRadius = 200; // 分类布局时距离中心的半径\n    let nodeGravityForce = 80; // 节点引力\n    let nodeRepulsiveForce = 100; // 节点斥力\n    let nodeMaxDistance; // 节点最大距离\n    let nodeMinDistance; // 节点最小距离\n    // 固定点配置\n    let fixedDotPos = '';\n    let disableLink = false;\n    let linkModel = \"undirected\";\n    let adjustLinkWidth = false;\n    let linkWidth = 1.5;\n    let linkColorFollowNode = false;\n    let linkColor;\n    let edgeLinkDistance = 30;\n    let adjustLinkRigidity = true;\n    let edgeLinkRigidity = 0.5;\n    let allowFixedPoint = false;\n    let hideAxisYTitleFlag = false;\n    let axisYTitlePosition = \"left\";\n    let hideAxisXTitleFlag = false;\n    let axisXTitlePosition = \"bottom\";\n    let hideLegendFlag;\n    let legendFontSize = 13;\n    let legendFontColor = \"#585C63\";\n    let legendPosition = \"bottom\";\n    let legendShape = \"circle\";\n    let legendCustom;\n\n    // 悬浮文本\n    let hiddenHoverText = false;\n    let suspendText = \"%_NAME\";\n\n    // 文本标签\n    let labelText = \"%_NAME\";\n    let showLabelTextFlag = false;\n    let labelTextSize = 14;\n    let labelTextColor;\n    let labelTextPosition = \"top\";\n    let overlapFlag = false;\n\n    // 圆形布局中的参数\n    const radialParam = {\n      strength: 0.75,\n      // 圆形的强度\n      radius: 250 // 半径大小\n    };\n\n    // 2. 应用配置\n    let chartConfig;\n    if (options.currentChart.defaultConf.chartConfigures) {\n      chartConfig = options.currentChart.defaultConf.chartConfigures;\n\n      //视图模式\n      if (chartConfig.entire_force_model) {\n        switch (chartConfig.entire_force_model) {\n          case \"option_entire_force_around_repulsive\":\n            entireForceModel = \"around\";\n            break;\n          case \"option_entire_force_center_gravitation\":\n            entireForceModel = \"center\";\n            break;\n          case \"option_entire_force_radial\":\n            entireForceModel = 'circle';\n            if (_DataFocusMethod.isPureNumber(chartConfig.layout_radial_radius)) {\n              radialParam.radius = chartConfig.layout_radial_radius || radialParam.radius;\n            }\n            if (_DataFocusMethod.isPureNumber(chartConfig.layout_radial_strength)) {\n              radialParam.strength = chartConfig.layout_radial_strength || radialParam.strength;\n            }\n            break;\n        }\n      }\n      if (_DataFocusMethod.isPureNumber(chartConfig.font_size_label)) {\n        fontSize = parseInt(chartConfig.font_size_label);\n        fontSizeFlag = true;\n      }\n      //字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.font_size_label)) {\n        fontSize = parseInt(chartConfig.font_size_label);\n        fontSizeFlag = true;\n      }\n      //字体颜色\n      if (chartConfig.text_font_color) {\n        labelColor = chartConfig.text_font_color;\n      }\n\n      // 节点的颜色模式\n      if (chartConfig.node_color_mode) {\n        nodeColor = chartConfig.node_static_color || nodeColor; // 用于静态颜色和 Ranking 颜色\n        switch (chartConfig.node_color_mode) {\n          case \"option_node_color_mode_static\":\n            nodeColorMode = \"static\";\n            break;\n          case \"option_node_color_mode_ranking\":\n            nodeColorMode = \"ranking\";\n            if (chartConfig.node_ranking_condition === 'option_node_ranking_by_degree') {\n              nodeRankingCondition = 'degree';\n            } else if (chartConfig.node_ranking_condition === 'option_node_ranking_by_measure') {\n              nodeRankingCondition = 'measure';\n            } else {\n              nodeRankingCondition = 'degree';\n            }\n            break;\n          case \"option_node_color_mode_partition\":\n            nodeColorMode = 'partition';\n            break;\n          default:\n            nodeColorMode = \"static\";\n        }\n      }\n      fixedDotPos = chartConfig.fixed_dot_pos || '';\n\n      //节点描边宽\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_node_border_width)) {\n        nodeBorderWidth = parseInt(chartConfig.style_node_border_width);\n      }\n      //节点描边颜色\n      if (chartConfig.style_node_border_color) {\n        nodeBorderColor = chartConfig.style_node_border_color;\n      }\n      //节点最大半径\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_node_radius_max)) {\n        nodeRadiusMax = parseInt(chartConfig.style_node_radius_max);\n      }\n      //节点最小半径\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_node_radius_min)) {\n        nodeRadiusMin = parseInt(chartConfig.style_node_radius_min);\n      }\n      // 节点的重合程度\n      if (_DataFocusMethod.isPureNumber(chartConfig.node_overlap_max_rate)) {\n        nodeOverlapRate = parseInt(chartConfig.node_overlap_max_rate);\n      }\n\n      // 是否开启节点的分类布局\n      nodeCategoryLayout = !!chartConfig.node_category_layout;\n      if (_DataFocusMethod.isPureNumber(chartConfig.node_category_layout_radius)) {\n        nodeCategoryLayoutRadius = parseInt(chartConfig.node_category_layout_radius);\n      }\n\n      // 节点斥力\n      if (_DataFocusMethod.isPureNumber(chartConfig.node_repulsive_force)) {\n        nodeRepulsiveForce = parseInt(chartConfig.node_repulsive_force);\n      }\n      // 节点引力\n      if (_DataFocusMethod.isPureNumber(chartConfig.node_gravity_force)) {\n        nodeGravityForce = parseInt(chartConfig.node_gravity_force);\n      }\n      disableLink = !!chartConfig.disable_link;\n      // 边的模式：有向或无向\n      if (chartConfig.style_link_model) {\n        switch (chartConfig.style_link_model) {\n          case \"option_style_link_model_undirected\":\n            linkModel = \"undirected\";\n            break;\n          case \"option_style_link_model_directed\":\n            linkModel = \"directed\";\n            break;\n        }\n      }\n      //自适应连边宽度\n      adjustLinkWidth = !!chartConfig.adjust_link_width_re;\n      linkColorFollowNode = !!chartConfig.style_link_color_follow_node;\n\n      //连边宽度\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_link_width)) {\n        linkWidth = parseFloat(chartConfig.style_link_width);\n      }\n      //连边颜色\n      if (chartConfig.style_link_color) {\n        linkColor = chartConfig.style_link_color;\n      }\n\n      // 连边的长度\n      if (_DataFocusMethod.isPureNumber(chartConfig.edge_link_distance)) {\n        edgeLinkDistance = chartConfig.edge_link_distance;\n      }\n\n      // 节点最大距离\n      if (_DataFocusMethod.isPureNumber(chartConfig.node_max_distance)) {\n        nodeMaxDistance = parseInt(chartConfig.node_max_distance);\n      }\n      // 节点最小距离\n      if (_DataFocusMethod.isPureNumber(chartConfig.node_min_distance)) {\n        nodeMinDistance = parseInt(chartConfig.node_min_distance);\n      }\n\n      //自适应刚性\n      adjustLinkRigidity = !!chartConfig.adjust_link_rigidity_re;\n\n      //连边刚性\n      if (_DataFocusMethod.isPureNumber(chartConfig.edge_link_rigidity)) {\n        edgeLinkRigidity = parseFloat(chartConfig.edge_link_rigidity);\n      }\n\n      //隐藏图例\n      if (chartConfig.hide_chart_legend) {\n        hideLegendFlag = true;\n      }\n      //图例字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.legend_font_size)) {\n        legendFontSize = parseInt(chartConfig.legend_font_size);\n      }\n      //图例字体颜色\n      if (chartConfig.legend_font_color) {\n        legendFontColor = chartConfig.legend_font_color;\n      }\n      //图例位置\n      if (chartConfig.chart_legend_position) {\n        switch (chartConfig.chart_legend_position) {\n          case \"option_legend_position_bottom\":\n            legendPosition = \"bottom\";\n            break;\n          case \"option_legend_position_right\":\n            legendPosition = \"right\";\n            break;\n        }\n      }\n\n      //图例位置\n      if (chartConfig.chart_legend_position) {\n        switch (chartConfig.chart_legend_position) {\n          case \"option_legend_position_bottom\":\n            legendPosition = \"bottom\";\n            break;\n          case \"option_legend_position_right\":\n            legendPosition = \"right\";\n            break;\n        }\n      }\n      hiddenHoverText = !!chartConfig.hidden_hover_text;\n      // 悬浮文本正则\n      if (chartConfig.suspend_text_regex) {\n        suspendText = chartConfig.suspend_text_regex;\n      }\n\n      // 文本标签\n      if (chartConfig.label_text_regex) {\n        labelText = chartConfig.label_text_regex;\n      }\n\n      //显示数据标签\n      if (chartConfig.label_text_visible) {\n        showLabelTextFlag = true;\n      }\n      //数据标签颜色\n      if (chartConfig.label_text_color) {\n        labelTextColor = chartConfig.label_text_color;\n      }\n      if (_DataFocusMethod.isPureNumber(chartConfig.label_text_font_size)) {\n        labelTextSize = parseInt(chartConfig.label_text_font_size);\n      }\n      //允许数据标签重叠\n      if (chartConfig.label_text_allow_overlap) {\n        overlapFlag = true;\n      }\n      //数据标签位置\n      if (chartConfig.label_text_position) {\n        switch (chartConfig.label_text_position) {\n          case \"option_label_text_position_top\":\n            labelTextPosition = \"top\";\n            break;\n          case \"option_label_text_position_center\":\n            labelTextPosition = \"center\";\n            break;\n        }\n      }\n      //开启固定点\n      if (chartConfig.allow_fixed_point) {\n        allowFixedPoint = true;\n      }\n      //自定义图例颜色\n      if (chartConfig.chart_custom_legend) {\n        legendCustom = chartConfig.chart_custom_legend;\n      }\n    }\n\n    //数据标签准备工作\n    let overLapSet = [];\n    // 检查是否重叠\n    const checkOverLap = function (box) {\n      const boxRect = {\n        left: box.x * 1,\n        top: box.y * 1,\n        right: box.x * 1 + box.width * 1,\n        bottom: box.y * 1 + box.height * 1\n      };\n      let allowFlag = true;\n      for (let i = 0; i < overLapSet.length; i++) {\n        const curBox = overLapSet[i];\n        const curBoxRect = {\n          left: curBox.x * 1,\n          top: curBox.y * 1,\n          right: curBox.x * 1 + curBox.width * 1,\n          bottom: curBox.y * 1 + curBox.height * 1\n        };\n        const xMax = Math.max(curBoxRect.right, boxRect.right);\n        const xMin = Math.min(curBoxRect.left, boxRect.left);\n        const yMax = Math.max(curBoxRect.bottom, boxRect.bottom);\n        const yMin = Math.min(curBoxRect.top, boxRect.top);\n        if (xMax - xMin > curBox.width * 1 + box.width * 1 || yMax - yMin > curBox.height * 1 + box.height * 1) {} else {\n          allowFlag = false;\n          break;\n        }\n      }\n      if (allowFlag) {\n        overLapSet.push(box);\n      }\n      return allowFlag;\n    };\n    //数据标签的字体大小有三个来源 继承/全局字体配置/轴字体配置\n    let labelTextFontSizeFlag = false;\n    let curLabelTextFontSize = 14;\n    if (fontSizeFlag) {\n      curLabelTextFontSize = fontSize;\n      labelTextFontSizeFlag = true;\n    }\n    if (labelTextSize) {\n      labelTextFontSizeFlag = true;\n      curLabelTextFontSize = labelTextSize;\n    }\n    //数据标签的字体颜色有三个来源 继承/全局字体配置/轴字体配置\n    let labelTextFontColorFlag = false;\n    let curLabelTextFontColor;\n    if (labelColor) {\n      labelTextFontColorFlag = true;\n      curLabelTextFontColor = labelColor;\n    }\n    if (labelTextColor) {\n      labelTextFontColorFlag = true;\n      curLabelTextFontColor = labelTextColor;\n    }\n    $(options.container).empty();\n    let drawWidth, drawHeight;\n    $(options.container).css(\"position\", \"relative\");\n    drawWidth = $(options.container).width();\n    drawHeight = $(options.container).height();\n\n    //处理容器\n    let isLegendFlag = true;\n    let containerOption = {\n      hideTimeBarFlag: true,\n      drawWidth: drawWidth,\n      drawHeight: drawHeight,\n      hideAxisXTitleFlag: hideAxisXTitleFlag,\n      axisXTitlePosition: axisXTitlePosition,\n      isLegendFlag: isLegendFlag,\n      // 是否存在图例\n      hideLegendFlag: hideLegendFlag,\n      legendPosition: legendPosition,\n      hideAxisYTitleFlag: hideAxisYTitleFlag,\n      axisYTitlePosition: axisYTitlePosition,\n      container: options.container,\n      currentChart: options.currentChart,\n      chartAxis: options.chartAxis,\n      fontSize: fontSize // 默认字体大小\n    };\n    let containerResult = _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"].containerOp.executeContainer(containerOption);\n    drawWidth = containerResult.drawWidth;\n    drawHeight = containerResult.drawHeight;\n    const svgDiv = containerResult.svgDiv,\n      legendBar = containerResult.legendBar,\n      legendLineHeight = containerResult.legendLineHeight,\n      legendLineWidth = containerResult.legendLineWidth;\n\n    //计算字符串长度\n    let getByteLen = _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getByteLen;\n\n    //固定住显示的图例\n    let fixedLegendIdx = -1;\n    let callBackAmendFixeDLegendIdx = function (idx) {\n      fixedLegendIdx = idx;\n    };\n    const svgContainer = d3.select(svgDiv[0]);\n    const svg = d3.select(svgDiv.find(\"svg\")[0]);\n\n    //需要引用的全局变量\n    let curLegendDoms = [];\n    let mouseoutTimer;\n    let legendsCircleDom = [];\n    let legendTexts = [];\n    const legends = []; // 去重后的图例列表\n    const legendMap = new Map();\n\n    // 当前正在高亮显示的图例。此变量为空时，所有节点和连线原样显示，为某一图例的值时，置灰非当前图例的节点和连线。\n    let highlightLegendName = '';\n    let updateLinkStrokeColor;\n    //定义力导向方法\n    function drawForceGraph({\n      nodes,\n      // an iterable of node objects (typically [{id}, …])\n      links,\n      // an iterable of link objects (typically [{source, target}, …])\n      originalLinks,\n      linkMap,\n      nodeMap\n    }, {\n      nodeGroup,\n      // given d in nodes, returns an (ordinal) value for color\n      nodeTitle,\n      nodeFill = \"#000\",\n      // node stroke fill (if not using a group color encoding)\n      nodeStroke = \"#fff\",\n      // node stroke color\n      nodeStrokeWidth = 1.5,\n      // node stroke width, in pixels\n      nodeStrokeOpacity = 1,\n      // node stroke opacity\n      nodeRadius,\n      // node radius fn\n      nodeStrength,\n      linkSource,\n      // given d in links, returns a node identifier string\n      linkTarget,\n      // given d in links, returns a node identifier string\n      linkStroke,\n      // link stroke color\n      linkStrokeOpacity = 0.8,\n      // link stroke opacity\n      linkStrokeWidth = 1.5,\n      // given d in links, returns a stroke width in pixels\n      linkStrokeLinecap = \"round\",\n      // link stroke linecap\n      linkStrength,\n      colors,\n      // an array of color strings, for the node groups: 图例颜色\n      width = 640,\n      // outer width, in pixels\n      height = 400,\n      // outer height, in pixels\n      invalidation // when this promise resolves, stop the simulation\n    } = {}) {\n      const linkSourceList = d3.map(links, linkSource); // 连线的起点节点List\n      const linkTargetList = d3.map(links, linkTarget); // 连线的终点节点List\n\n      const nodeTitleList = d3.map(nodes, nodeTitle); // 节点Title列表\n      const nodeGroupList = nodeGroup ? d3.map(nodes, nodeGroup) : null; // 节点所属Group列表(图例列表，一一对应，不去重)\n      const nodeRadiusList = typeof nodeRadius !== \"function\" ? null : d3.map(nodes, nodeRadius); // 节点半径（数值列作为实体属性）\n      const linkWidthList = typeof linkStrokeWidth !== \"function\" ? null : d3.map(links, linkStrokeWidth);\n      const linkStrokeList = typeof linkStroke !== \"function\" ? null : d3.map(links, linkStroke);\n      function parseFixedDotPos(fixedDotPosStr) {\n        let validDotPos = [];\n        for (const oneDotStr of fixedDotPosStr.split('|')) {\n          const oneDotConfig = oneDotStr.split(',');\n          if (oneDotConfig.length !== 3) {\n            continue;\n          } else {\n            const nodeName = oneDotConfig[0].trim();\n            const x = oneDotConfig[1].trim();\n            const y = oneDotConfig[2].trim();\n            if (!_DataFocusMethod.isPureNumber(x) || !_DataFocusMethod.isPureNumber(y)) {\n              continue;\n            }\n            validDotPos.push([nodeName, parseFloat(x), parseFloat(y)]);\n          }\n        }\n        return validDotPos;\n      }\n      const validDotPos = parseFixedDotPos(fixedDotPos);\n\n      // 把节点和边转换为 simulation 中可用的可变对象。\n      nodes = d3.map(nodes, (_, i) => {\n        let fx, fy;\n        const capturedFixedPos = validDotPos.find(([fixedNodeName]) => fixedNodeName === nodes[i]);\n        if (capturedFixedPos) {\n          fx = capturedFixedPos[1];\n          fy = capturedFixedPos[2];\n        }\n        return {\n          id: nodes[i],\n          fx: fx,\n          fy: fy\n        };\n      });\n      links = d3.map(links, (_, i) => ({\n        source: linkSourceList[i],\n        target: linkTargetList[i]\n      }));\n      const forceNode = d3.forceManyBody(); // 模拟引力或斥力\n      const forceLink = d3.forceLink(links).id(node => node.id); // 设置节点访问器（ 根据 link 的 source 或 target 找到节点）\n      if (nodeStrength !== undefined) forceNode.strength(nodeStrength); // 节点斥力\n      if (linkStrength !== undefined) forceLink.strength(linkStrength); // 边的刚性\n\n      if (nodeMaxDistance) {\n        forceNode.distanceMax(nodeMaxDistance);\n      }\n      if (nodeMinDistance) {\n        forceNode.distanceMin(nodeMinDistance);\n      }\n      if (edgeLinkDistance) {\n        forceLink.distance(edgeLinkDistance);\n      }\n\n      // General: 引力和斥力\n      const simulation = d3.forceSimulation(nodes).force(\"link\", forceLink).force(\"charge\", forceNode);\n      if (entireForceModel === \"center\") {\n        // 中心引力\n        simulation.force(\"center\", d3.forceCenter().strength(0.8)).force('collide', d3.forceCollide().radius(function (node) {\n          return nodeRadius(node.id) * (1 - nodeOverlapRate / 100);\n        }));\n      } else if (entireForceModel === 'around') {\n        // 边缘斥力\n        simulation.force(\"center\", d3.forceCenter()).force('x', d3.forceX()).force('y', d3.forceY()).force('collide', d3.forceCollide().strength(0.8).radius(function (node) {\n          return nodeRadius(node.id) * 2;\n        }));\n      } else {\n        // 'circle'\n        simulation.force(\"center\", d3.forceCenter()).force('circle', d3.forceRadial(radialParam.radius).strength(radialParam.strength));\n        // .force('collide', d3.forceCollide()\n        //     .radius(function (node) {\n        //         return nodeRadius(node.id)\n        //     }))\n      }\n      let isSimulationEnded = false;\n      simulation.on('tick', ticked).on('end', () => {\n        console.log('Simulation end');\n        isSimulationEnded = true;\n      });\n      if (nodeCategoryLayout && nodeGroupList) {\n        const smallRadius = 12;\n\n        // 各类别环绕画布中心\n        const getOffsetX = (node, enableSmallCircle) => {\n          const curNodeDetail = nodeMap.get(node.id);\n          const curGroupName = curNodeDetail.group;\n          const curGroupDetail = legendMap.get(curGroupName);\n          if (curGroupDetail) {\n            // 此节点有图例，获取图例的偏移位置\n            const {\n              offsetX\n            } = curGroupDetail.center;\n            if (enableSmallCircle) {\n              const curAngle = Math.PI / 6 * curGroupDetail.iterateCountX; // 平均间隔角度\n              curGroupDetail.iterateCountX++;\n              return offsetX + Math.sin(curAngle) * smallRadius;\n            } else {\n              return offsetX;\n            }\n          } else {\n            return 0;\n          }\n        };\n        const getOffsetY = (node, enableSmallCircle) => {\n          const curNodeDetail = nodeMap.get(node.id);\n          const curGroupName = curNodeDetail.group;\n          const curGroupDetail = legendMap.get(curGroupName);\n          if (curGroupDetail) {\n            // 此节点有图例，获取图例的偏移位置\n            const {\n              offsetY\n            } = curGroupDetail.center;\n            if (enableSmallCircle) {\n              const curAngle = Math.PI / 6 * curGroupDetail.iterateCountY; // 平均间隔角度\n              curGroupDetail.iterateCountY++;\n              return offsetY - Math.cos(curAngle) * smallRadius;\n            } else {\n              return offsetY;\n            }\n          } else {\n            return 0;\n          }\n        };\n\n        // 只顺时针环绕大圆\n        simulation.force('x', d3.forceX().x(node => getOffsetX(node)).strength(0.8)).force('y', d3.forceY().y(node => getOffsetY(node)).strength(0.8));\n\n        // 只环绕小圆，顺带环绕大圆：扩展 forceRadialDeep\n        // simulation.force('circle', null);\n        // simulation.force('circle', d3.forceRadialDeep(radialParam.radius)\n        //     .x(node => getOffsetX(node))\n        //     .y(node => getOffsetY(node))\n        //     .strength(radialParam.strength));\n\n        // 只环绕小圆，顺带环绕大圆：手动计算\n        // const smallCircleForceX = d3.forceX().x(node => {\n        //     return getOffsetX(node, true);\n        // }).strength(0.8);\n        // const smallCircleForceY = d3.forceY().y(node => {\n        //     return getOffsetY(node, true);\n        // }).strength(0.8);\n        // simulation.force('small-circle-x', smallCircleForceX)\n        //     .force('small-circle-y', smallCircleForceY);\n\n        // 只环绕小圆，顺带环绕大圆: 原生不可用. x 不可设置函数：https://stackoverflow.com/questions/54035048/how-to-assign-the-center-of-d3-forceradial-dynamically-using-functions\n        // simulation.force('small-circle', d3.forceRadial(35).x(getOffsetX).y(getOffsetY));\n      }\n      svg.attr(\"width\", width).attr(\"height\", height).attr(\"viewBox\", [-width / 2, -height / 2, width, height]).attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;overflow: hidden;z-index: 0;position:relative\");\n      svg.style('background', chartBackgroundColor);\n\n      // 画布的缩放、移动功能\n      (() => {\n        const zoom = d3.zoom().filter(event => {\n          event.preventDefault();\n          return !event.target.closest('.brush') && (!event.ctrlKey || event.type === 'wheel') && !event.button;\n        });\n        function resetZoomAndSpan() {\n          svg.transition().duration(750).call(zoom.transform, d3.zoomIdentity);\n        }\n        function zoomOut() {\n          svg.transition().call(zoom.scaleBy, 0.5);\n        }\n        function zoomIn() {\n          svg.transition().call(zoom.scaleBy, 2);\n        }\n        const zoomOperateContainer = svgContainer.append('div').classed('zoom-operate', true).style('position', 'absolute').style('left', '20px').style('bottom', '20px').style('width', 'max-content').style('display', 'flex');\n        zoomOperateContainer.append('a').style('background', '#fff').style('box-shadow', '0 0 5px #dfdfdf').style('padding', '4px 8px').style('border-radius', '6px').style('cursor', 'pointer').style('margin-right', '5px').text(locale === 'cn' ? '重置缩放' : 'Reset Zoom').on('click', resetZoomAndSpan);\n        zoomOperateContainer.append('a').style('background', '#fff').style('box-shadow', '0 0 5px #dfdfdf').style('padding', '4px 8px').style('border-radius', '6px').style('cursor', 'pointer').style('margin-right', '5px').text('+').on('click', zoomIn);\n        zoomOperateContainer.append('a').style('background', '#fff').style('box-shadow', '0 0 5px #dfdfdf').style('padding', '4px 8px').style('border-radius', '6px').style('cursor', 'pointer').style('margin-right', '5px').text('-').on('click', zoomOut);\n        svg.call(zoom.on(\"zoom\", function (zoomed) {\n          svg.selectAll('g').attr('transform', zoomed.transform);\n        }));\n      })();\n      if (linkColorFollowNode) {\n        // 连线的渐变定义\n        const linearGradient = svg.append('defs').selectAll('linearGradient').data(links).join('linearGradient').attr('id', ({\n          source: {\n            id: sourceName\n          },\n          target: {\n            id: targetName\n          }\n        }) => {\n          return `${sourceName.replaceAll(' ', '')}-${targetName.replaceAll(' ', '')}`;\n        }).attr('x1', \"0%\").attr('y1', '0%').attr('x2', '0%').attr('y2', '100%');\n        linearGradient.append('stop').attr('offset', '0%').attr('stop-color', ({\n          source: {\n            id: sourceName\n          },\n          target: {\n            id: targetName\n          }\n        }) => {\n          return nodeFill(targetName);\n        });\n        linearGradient.append('stop').attr('offset', '100%').attr('stop-color', ({\n          source: {\n            id: sourceName\n          },\n          target: {\n            id: targetName\n          }\n        }) => {\n          return nodeFill(sourceName);\n        });\n      }\n\n      // 有向图声明箭头样式\n      if (linkModel === \"directed\") {\n        if (linkColorFollowNode) {\n          // 如果线条跟随节点颜色，则定义颜色箭头\n          svg.append(\"defs\").selectAll(\"marker\").data(nodes).join(\"marker\").attr(\"id\", d => `arrow-${d.id}`.replaceAll(\" \", '')).attr(\"viewBox\", \"0 -5 10 10\").attr(\"refX\", 7).attr(\"refY\", -0.5).attr(\"markerWidth\", 6).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\").append(\"path\").attr(\"stroke\", \"none\").attr(\"fill\", ({\n            id: nodeName\n          }) => {\n            return nodeFill(nodeName);\n          }).attr(\"d\", \"M0,-5L10,0L0,5\");\n        } else {\n          svg.append(\"defs\").selectAll(\"marker\").data([0]).join(\"marker\").attr(\"id\", d => `arrow-${d}`).attr(\"viewBox\", \"0 -5 10 10\").attr(\"refX\", 7).attr(\"refY\", -0.5).attr(\"markerWidth\", 6).attr(\"markerHeight\", 6).attr(\"orient\", \"auto\").append(\"path\").attr(\"stroke\", \"none\").attr(\"fill\", linkStroke).attr(\"d\", \"M0,-5L10,0L0,5\");\n        }\n      }\n      function linkStrokeColor(link) {\n        if (disableLink) return 'transparent';\n        const curLinkName = originalLinks[link.index];\n        const curLinkDetail = linkMap.get(curLinkName);\n        if (highlightLegendName) {\n          // 当前连线是否属于当前图例\n          const {\n            source: curSourceNodeName,\n            target: curTargetNodeName\n          } = curLinkDetail;\n\n          // 起点的分组：\n          const curSourceNodeDetail = nodeMap.get(curSourceNodeName);\n          const curSourceGroupName = curSourceNodeDetail.group;\n\n          // 终点的分组：\n          const curTargetNodeDetail = nodeMap.get(curTargetNodeName);\n          const curTargetGroupName = curTargetNodeDetail.group;\n          if (highlightLegendName !== curSourceGroupName && highlightLegendName !== curTargetGroupName) {\n            return '#eeeeee'; // 灰色\n          }\n        }\n        if (linkColorFollowNode) {\n          const {\n            source: {\n              id: sourceName\n            },\n            target: {\n              id: targetName\n            }\n          } = link;\n          return `url(#${sourceName.replaceAll(' ', '')}-${targetName.replaceAll(' ', '')})`;\n        }\n        if (!curLinkDetail.type) {\n          return linkStroke;\n        } else {\n          return linkStroke || colors[curLinkDetail.type];\n        }\n      }\n      updateLinkStrokeColor = function () {\n        link.attr(\"stroke\", linkStrokeColor);\n      };\n      let link;\n      if (linkModel === \"directed\") {\n        // 绘制有向图连线\n        link = svg.append(\"g\").attr(\"stroke-opacity\", linkStrokeOpacity).attr(\"stroke-width\", typeof linkStrokeWidth !== \"function\" ? linkStrokeWidth : null).attr(\"stroke-linecap\", linkStrokeLinecap).attr(\"fill\", \"none\").selectAll(\"path\").data(links).join(\"path\").attr(\"stroke\", linkStrokeColor).attr(\"marker-end\", function (link) {\n          // 箭头的颜色\n          if (disableLink) return 'transparent';\n          if (linkColorFollowNode) {\n            const {\n              target: {\n                id: targetName\n              }\n            } = link;\n            return `url(#arrow-${targetName.replaceAll(' ', '')})`;\n          } else {\n            return `url(${new URL(`#arrow-${0}`, location)})`;\n          }\n        });\n      } else {\n        // 绘制无向图连线\n        link = svg.append(\"g\").attr(\"stroke-opacity\", linkStrokeOpacity).attr(\"stroke-width\", typeof linkStrokeWidth !== \"function\" ? linkStrokeWidth : null).attr(\"stroke-linecap\", linkStrokeLinecap).attr(\"fill\", \"none\").selectAll(\"line\").data(links).join(\"line\").attr(\"stroke\", linkStrokeColor);\n      }\n\n      // 没有固定点的拖动功能\n      const dragWithoutFixed = simulation => {\n        function dragstarted(event) {\n          if (!event.active) simulation.alphaTarget(0.3).restart();\n          event.subject.fx = event.subject.x;\n          event.subject.fy = event.subject.y;\n        }\n        function dragged(event) {\n          event.subject.fx = event.x;\n          event.subject.fy = event.y;\n        }\n        function dragended(event, d) {\n          if (!event.active) simulation.alphaTarget(0);\n          event.subject.fx = null;\n          event.subject.fy = null;\n          const hitDotIndex = validDotPos.findIndex(([fixedNodeName]) => fixedNodeName === d.id);\n          if (hitDotIndex > -1) {\n            validDotPos.splice(hitDotIndex, 1);\n            const fixedPosStr = validDotPos.map(record => record.join(',')).join(' | ');\n\n            // 保存点的位置字符串\n            options.currentChart.requireSetConfig({\n              key: \"fixed_dot_pos\",\n              value: fixedPosStr,\n              isResize: false,\n              disableRedraw: true\n            });\n          }\n        }\n        return d3.drag().on(\"start\", dragstarted).on(\"drag\", dragged).on(\"end\", dragended);\n      };\n\n      // 绘制节点\n      const nodesSelection = svg.append(\"g\").selectAll(\"circle\").data(nodes).join(\"circle\").attr(\"fill\", node => {\n        const nodeName = node.id;\n        return nodeFill(nodeName);\n      }).attr(\"stroke\", nodeStroke).attr(\"stroke-opacity\", nodeStrokeOpacity).attr(\"stroke-width\", nodeStrokeWidth).attr(\"r\", ({\n        id: nodeName\n      }) => nodeRadius(nodeName));\n      function getNodeGroupName(node) {\n        const nodeDetail = nodeMap.get(node.id);\n        return nodeDetail && nodeDetail.group;\n      }\n      nodesSelection.on('mouseover.tip', (e, curNode) => {\n        if (!hiddenHoverText) {\n          const nodeName = curNode.id;\n          const nodeDetail = nodeMap.get(nodeName);\n          const nodeGroup = nodeDetail.group || (locale === 'en' ? 'no groups' : '无分组');\n          const nodeMeasure = nodeDetail.measureSum || '0';\n          const nodeDegree = nodeDetail.degree || '0';\n          let curText = suspendText.replace(\"%_NAME\", nodeName);\n          curText = curText.replaceAll(\"%_GROUP\", nodeGroup);\n          curText = curText.replaceAll(\"%_MEASURE\", nodeMeasure);\n          curText = curText.replaceAll(\"%_DEGREE\", nodeDegree);\n          curText = _DataFocusMethod.translateIllegalStr(curText).replaceAll(\"%_BR\", '<br />');\n          options.currentChart.positionChartPrompt(e, curText);\n        }\n      });\n      nodesSelection.on('mouseout.tip', (e, curNode) => {\n        if (!hiddenHoverText) {\n          options.currentChart.clearChartPrompt();\n        }\n      });\n      if (nodeColorMode === 'partition') {\n        nodesSelection.on('mouseover.hover', (e, curNode) => {\n          // 防止外界节点悬浮时，各节点恢复初始颜色\n          const chartContainer = document.querySelector('.chart-container');\n          if (chartContainer.hasAttribute('data-lock-legend')) return;\n          const curGroupName = getNodeGroupName(curNode);\n          const otherNodes = nodesSelection.filter(node => !getNodeGroupName(node) || getNodeGroupName(node) !== curGroupName);\n          // otherNodes.style('opacity', '0.8');\n          otherNodes.attr('fill', '#efefef');\n          const curNodeSelection = nodesSelection.filter((_, i) => i === curNode.index);\n          curNodeSelection.attr('fill', nodeFill(curNode.id));\n          curNodeSelection.style('opacity', '1');\n          curNodeSelection.raise();\n        }).on('mouseout.hover', (e, curNode) => {\n          // 防止外界节点悬浮时，各节点恢复初始颜色\n          const chartContainer = document.querySelector('.chart-container');\n          if (chartContainer.hasAttribute('data-lock-legend')) return;\n          nodesSelection.attr(\"fill\", node => {\n            const nodeName = node.id;\n            return nodeFill(nodeName);\n          }).style('opacity', '1');\n        });\n      }\n      const updateNodeWithFixed = () => {\n        nodesSelection.classed(\"node\", true).classed(\"fixed\", d => d.fx !== undefined);\n      };\n      const updateNodeWithoutFixed = () => {\n        nodesSelection.on(\".drag\", null);\n        nodesSelection.call(dragWithoutFixed(simulation));\n      };\n      // 开启固定点的拖拽功能\n      const setFixedPoint = function () {\n        // 点击取消固定点\n        const click = function (event, d) {\n          delete d.fx;\n          delete d.fy;\n          d3.select(this).classed(\"fixed\", false);\n          simulation.alpha(1).restart();\n        };\n\n        // 开始拖动固定点\n        const dragstart = function () {\n          d3.select(this).classed(\"fixed\", true);\n        };\n\n        // 拖动结束后将该店固定到该位置\n        const dragged = function (event, d) {\n          d.fx = event.x;\n          d.fy = event.y;\n          const hitDot = validDotPos.find(([fixedNodeName]) => fixedNodeName === d.id);\n          if (hitDot) {\n            hitDot[1] = d.fx;\n            hitDot[2] = d.fy;\n          } else {\n            validDotPos.push([d.id, d.fx, d.fy]);\n          }\n          const fixedPosStr = validDotPos.map(record => record.join(',')).join(' | ');\n\n          // 保存点的位置字符串\n          options.currentChart.requireSetConfig({\n            key: \"fixed_dot_pos\",\n            value: fixedPosStr,\n            isResize: false,\n            disableRedraw: true\n          });\n          simulation.alpha(1).restart(); // 重新开启力场计算最新稳态\n        };\n        nodesSelection.call(d3.drag().on(\"start\", dragstart).on(\"drag\", dragged)).on(\"click\", click);\n      };\n      if (allowFixedPoint) {\n        // 固定点\n        updateNodeWithFixed();\n        setFixedPoint();\n      } else {\n        updateNodeWithoutFixed();\n      }\n      let label;\n      // 展示文字标签\n      if (showLabelTextFlag) {\n        // 显示文字标签\n        label = svg.append(\"g\").selectAll(\"text\").data(nodes).join(\"text\").attr(\"class\", 'labels').style(\"pointer-events\", \"none\").style(\"font-size\", function () {\n          return curLabelTextFontSize + \"px\";\n        }).style(\"fill\", function () {\n          if (fixedLegendIdx === -1) {\n            return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n          } else {\n            if (fixedLegendIdx === i) {\n              return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n            } else {\n              return \"rgba(198,200,200,0.3)\";\n            }\n          }\n        }).attr(\"fill\", function () {\n          if (fixedLegendIdx === -1) {\n            return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n          } else {\n            if (fixedLegendIdx === i) {\n              return labelTextFontColorFlag ? curLabelTextFontColor : \"inherit\";\n            } else {\n              return \"rgba(198,200,200,0.3)\";\n            }\n          }\n        }).style(\"stroke-width\", \"0\").style(\"font-weight\", \"400\").attr('text-anchor', \"middle\").text(function (curNode) {\n          const nodeName = curNode.id;\n          const nodeDetail = nodeMap.get(nodeName);\n          const nodeGroup = nodeDetail.group || (locale === 'en' ? 'no groups' : '无分组');\n          const nodeMeasure = nodeDetail.measureSum || '0';\n          const nodeDegree = nodeDetail.degree || '0';\n\n          // 生成文字标签的内容\n          let showText = labelText.replace(\"%_NAME\", nodeName);\n          showText = showText.replaceAll(\"%_GROUP\", nodeGroup);\n          showText = showText.replaceAll(\"%_MEASURE\", nodeMeasure);\n          showText = showText.replaceAll(\"%_DEGREE\", nodeDegree);\n          showText = showText.replaceAll(\"\\n\", \" \");\n          showText = _DataFocusMethod.translateIllegalStr(showText).replaceAll(\"%_BR\", '\\n');\n          let curPositionBox = {\n            x: curNode.x,\n            y: curNode.y,\n            width: getByteLen(showText) * curLabelTextFontSize,\n            height: curLabelTextFontSize\n          };\n          if (overlapFlag || checkOverLap(curPositionBox)) {\n            return showText;\n          } else {\n            return \"\";\n          }\n        });\n        label.each(function (d) {\n          // this -> textDom ,d => nodes,\n          const textDom = d3.select(this);\n          const textContentList = textDom.text().split('\\n');\n          if (textContentList.length > 1) {\n            textDom.text(\"\");\n            let offset = (curLabelTextFontSize + 2) / 2 - textContentList.length * (curLabelTextFontSize + 2) / 2;\n            textContentList.forEach(function (tc, i) {\n              if (i > 0 && tc[0] === \" \") tc = tc.slice(1);else if (tc[tc.length - 1] === \" \") {\n                tc = tc.slice(0, tc.length - 1);\n              }\n              textDom.append(\"tspan\").attr('x', d.x).attr('y', d.y + i * (curLabelTextFontSize + 2) + offset).text(tc);\n            });\n            let curPositionBox = {\n              x: d.x,\n              y: d.y,\n              width: getByteLen(textDom.text()) * curLabelTextFontSize,\n              height: curLabelTextFontSize\n            };\n            if (overlapFlag && !checkOverLap(curPositionBox)) {\n              textDom.attr('display', 'none');\n            }\n          }\n        });\n      }\n\n      // legends 是去重后的图例集合。legendsCircleDom 是对应的图例集合的DOM元素。\n      for (let i = 0; i < legends.length; i++) {\n        // 图例元素内容，每个图例初始化为一个空数组\n        legendsCircleDom[i] = [];\n        if (showLabelTextFlag) legendTexts[i] = [];\n      }\n      if (nodeGroupList) {\n        const nodeDoms = nodesSelection._groups[0];\n        nodeDoms.forEach(function (curNode) {\n          const curNodeName = curNode.__data__.id;\n          const curNodeGroupName = nodeMap.get(curNodeName).group;\n          const curGroupDetail = legendMap.get(curNodeGroupName);\n          if (curGroupDetail) {\n            const curGroupIndex = curGroupDetail.indexInList;\n            legendsCircleDom[curGroupIndex].push(d3.select(curNode));\n          }\n        });\n      }\n      if (linkWidthList && adjustLinkWidth) {\n        link && link.attr(\"stroke-width\", ({\n          index: i\n        }) => linkWidthList[i]);\n      } else {\n        link && link.attr(\"stroke-width\", linkWidth);\n      }\n      if (linkStrokeList) link && link.attr(\"stroke\", ({\n        index: i\n      }) => linkStrokeList[i]);\n\n      // if (nodeTitleList) { // 为每个节点绘制 Title\n      //     nodesSelection.append(\"title\").text(({index}) => nodeTitleList[index])\n      // }\n      if (nodeRadiusList) {\n        nodesSelection.attr(\"r\", ({\n          index: i\n        }) => nodeRadiusList[i]);\n      }\n      if (invalidation) {\n        invalidation.then(() => {\n          console.log('stop simulation');\n          simulation.stop();\n        });\n      }\n      function linkArc(d) {\n        //计算被circle截断后，线段的落点\n        let sourceR = nodeRadiusList[d.source.index] + nodeBorderWidth;\n        let targetR = nodeRadiusList[d.target.index] + nodeBorderWidth;\n        let x0 = d.source.x,\n          x1 = d.target.x,\n          y0 = d.source.y,\n          y1 = d.target.y;\n        let sourceX, sourceY, targetX, targetY;\n        if (x1 - x0 !== 0) {\n          let k = (y1 - y0) / (x1 - x0);\n          let p = y0 - k * x0;\n          let q, a, b, c, delta;\n          //计算source的截断点\n          q = p - y0;\n          a = k * k + 1;\n          b = 2 * (q * k - x0);\n          c = x0 * x0 + q * q - sourceR * sourceR;\n          delta = Math.sqrt(b * b - 4 * a * c);\n          if (x0 < x1) {\n            sourceX = (-1 * b + delta) / (2 * a);\n            sourceY = k * sourceX + p;\n          } else {\n            sourceX = (-1 * b - delta) / (2 * a);\n            sourceY = k * sourceX + p;\n          }\n          //计算target的截断点\n          q = p - y1;\n          a = k * k + 1;\n          b = 2 * (q * k - x1);\n          c = x1 * x1 + q * q - targetR * targetR;\n          delta = Math.sqrt(b * b - 4 * a * c);\n          if (x1 < x0) {\n            targetX = (-1 * b + delta) / (2 * a);\n            targetY = k * targetX + p;\n          } else {\n            targetX = (-1 * b - delta) / (2 * a);\n            targetY = k * targetX + p;\n          }\n        } else {\n          sourceX = x0;\n          targetX = x1;\n          if (y0 < y1) {\n            sourceY = y0 + sourceR;\n            targetY = y1 - sourceR;\n          } else {\n            sourceY = y0 - sourceR;\n            targetY = y1 + sourceR;\n          }\n        }\n        const r = Math.hypot(targetX - sourceX, targetY - sourceY);\n        return `M${sourceX},${sourceY}A${r},${r} 0 0,1 ${targetX},${targetY}`;\n        //const r = Math.hypot(d.target.x - d.source.x, d.target.y - d.source.y);\n        //return `M${d.source.x},${d.source.y}A${r},${r} 0 0,1 ${d.target.x},${d.target.y}`;\n      }\n\n      // 绘制每一帧\n      function ticked() {\n        if (linkModel === \"undirected\") {\n          link && link.attr(\"x1\", d => d.source.x).attr(\"y1\", d => d.source.y).attr(\"x2\", d => d.target.x).attr(\"y2\", d => d.target.y);\n        } else {\n          link && link.attr(\"d\", linkArc);\n        }\n\n        // 更新节点的位置\n        nodesSelection.attr(\"cx\", d => d.x).attr(\"cy\", d => d.y);\n\n        // 刷新帧时绘制文字（并检查文字重叠）\n        if (showLabelTextFlag) {\n          overLapSet = [];\n          label.attr(\"x\", d => d.x).attr(\"y\", d => d.y + curLabelTextFontSize / 3).text(function (curNode) {\n            const nodeName = curNode.id;\n            const nodeDetail = nodeMap.get(nodeName);\n            const nodeGroup = nodeDetail.group || (locale === 'en' ? 'no groups' : '无分组');\n            const nodeMeasure = nodeDetail.measureSum || '0';\n            const nodeDegree = nodeDetail.degree || '0';\n\n            // 生成文字标签的内容\n            let showText = labelText.replace(\"%_NAME\", nodeName);\n            showText = showText.replaceAll(\"%_GROUP\", nodeGroup);\n            showText = showText.replaceAll(\"%_MEASURE\", nodeMeasure);\n            showText = showText.replaceAll(\"%_DEGREE\", nodeDegree);\n            showText = showText.replaceAll(\"\\n\", \" \");\n            showText = _DataFocusMethod.translateIllegalStr(showText).replaceAll(\"%_BR\", '\\n');\n            let curPositionBox = {\n              x: curNode.x,\n              y: curNode.y,\n              width: getByteLen(showText) * curLabelTextFontSize,\n              height: curLabelTextFontSize\n            };\n            if (overlapFlag || checkOverLap(curPositionBox)) {\n              return showText;\n            } else {\n              return \"\";\n            }\n          });\n          label.each(function (d) {\n            // this -> textDom ,d => nodes,\n            const textDom = d3.select(this);\n            const textContentList = textDom.text().split('\\n');\n            if (textContentList.length > 1) {\n              textDom.text(\"\");\n              let offset = (curLabelTextFontSize + 2) / 2 - textContentList.length * (curLabelTextFontSize + 2) / 2;\n              textContentList.forEach(function (tc, i) {\n                if (i > 0 && tc[0] === \" \") tc = tc.slice(1);else if (tc[tc.length - 1] === \" \") {\n                  tc = tc.slice(0, tc.length - 1);\n                }\n                textDom.append(\"tspan\").attr('x', d.x).attr('y', d.y + i * (curLabelTextFontSize + 2) + offset).text(tc);\n              });\n              let curPositionBox = {\n                x: d.x,\n                y: d.y,\n                width: getByteLen(textDom.text()) * curLabelTextFontSize,\n                height: curLabelTextFontSize\n              };\n              if (overlapFlag && !checkOverLap(curPositionBox)) {\n                textDom.attr('display', 'none');\n              }\n            }\n          });\n        }\n      }\n      const exportWithFixed = () => {\n        updateNodeWithFixed();\n        setFixedPoint();\n      };\n      const exportWithoutFixed = () => {\n        updateNodeWithoutFixed();\n      };\n      // 笔刷\n      const startBoxSelection = () => {\n        // if (!isSimulationEnded) {\n        //     alert('力场正在模拟中，请稍后再试');\n        //     return;\n        // }\n        const brush = d3.brush();\n        const brushed = ({\n          selection\n        }) => {\n          if (!selection) {\n            nodesSelection.attr(\"fill\", node => {\n              const nodeName = node.id;\n              return nodeFill(nodeName);\n            }).style('opacity', '1');\n          } else {\n            const [[x0, y0], [x1, y1]] = selection;\n            const curTransform = d3.zoomTransform(svg.node());\n            const transformedSection = {\n              x0: (x0 - curTransform.x) / curTransform.k,\n              x1: (x1 - curTransform.x) / curTransform.k,\n              y0: (y0 - curTransform.y) / curTransform.k,\n              y1: (y1 - curTransform.y) / curTransform.k\n            };\n            let highlightCount = 0;\n            nodesSelection.attr('fill', node => {\n              const x = node.x;\n              const y = node.y;\n              const isSelected = x >= transformedSection.x0 && x <= transformedSection.x1 && y >= transformedSection.y0 && y <= transformedSection.y1;\n              if (isSelected) highlightCount++;\n              return isSelected ? '#f5c463' : '#efefef';\n            });\n            if (highlightCount === 0) {\n              nodesSelection.attr('fill', node => {\n                const nodeName = node.id;\n                return nodeFill(nodeName);\n              });\n            }\n          }\n        };\n        svg.append('g').attr('stroke', 'none').classed('brush', true).call(brush.on('start brush', brushed).on('end', ({\n          selection\n        }) => {\n          // if\n        }));\n      };\n      const exitBoxSelection = () => {\n        // 关闭笔刷\n        svg.select('g.brush').on(\".brush\", null);\n        svg.select('g.brush').remove();\n        nodesSelection.attr('fill', node => {\n          const nodeName = node.id;\n          return nodeFill(nodeName);\n        });\n      };\n      return {\n        exportWithFixed,\n        exportWithoutFixed,\n        startBoxSelection,\n        exitBoxSelection\n      };\n    }\n\n    // Main Task: 绘制网络图\n    function drawGroup() {\n      svg.html(\"\");\n\n      //计算图数据\n      let sourceBodyIdx = -1,\n        targetBodyIdx = -1; // 起点实体，终点实体\n      let sourceFeatureAttr = -1,\n        sourceFeatureMea = -1; // 起点属性\n      let edgeFeatureAttr = -1,\n        edgeFeatureMea = -1; // 边属性\n\n      // 轴配置\n      const {\n        curColumns,\n        curRows,\n        curValues\n      } = options.chartAxis;\n\n      // 1. 起点实体和终点实体的列ID\n      if (curColumns && curColumns.length) {\n        const [sourceEntityColumn, targetEntityColumn] = curColumns;\n        sourceBodyIdx = sourceEntityColumn.idx;\n        targetBodyIdx = targetEntityColumn.idx;\n      }\n\n      // 2. 起点图例和终点图例的列ID\n      if (curRows && curRows.length) {\n        const [sourceFeatureColumn] = curRows;\n        if (sourceFeatureColumn) {\n          if (sourceFeatureColumn.col_type === \"ATTRIBUTE\") {\n            sourceFeatureAttr = sourceFeatureColumn.idx;\n          } else {\n            sourceFeatureMea = sourceFeatureColumn.idx;\n          }\n        }\n      }\n      // 3. 边\n      if (curValues && curValues.length) {\n        const [edgeColumn] = curValues;\n        if (edgeColumn.col_type === 'ATTRIBUTE') {\n          edgeFeatureAttr = edgeColumn.idx;\n        } else {\n          edgeFeatureMea = edgeColumn.idx;\n        }\n      }\n\n      // 必要条件缺失，关闭图例\n      if (sourceFeatureAttr === -1 && edgeFeatureAttr === -1) {\n        isLegendFlag = false;\n      }\n\n      // 解析点集、边集、图例\n      const nodeMap = new Map(),\n        nodeList = [];\n      const linkMap = new Map(),\n        linkList = [];\n      if (sourceBodyIdx !== -1 && targetBodyIdx !== -1) {\n        options.datas.columns.forEach(function (row) {\n          const sourceNodeName = row[sourceBodyIdx],\n            targetNodeName = row[targetBodyIdx];\n          // 构建点集\n          for (let i = 0; i < 2; i++) {\n            const curNodeName = i === 0 ? sourceNodeName : targetNodeName;\n            // ----- 1. Ranking：改变节点的颜色和大小 -----\n\n            // 1.1. 按照节点的出入度 决定节点的颜色和大小\n            if (!nodeMap.has(curNodeName)) {\n              // 起点节点\n              const curNodeDetail = {\n                degree: 1,\n                indexInList: nodeList.length\n              };\n              if (sourceFeatureAttr !== -1) {\n                // 根据某一属性列对节点进行分组。TODO: 添加 modularity 算法自动分组\n                const curGroupName = row[sourceFeatureAttr];\n                if (i === 0) {\n                  // 暂时仅对起点应用图例. 因为表达网络关系时，起点实体和终点实体应该是同一类型的数据。\n                  curNodeDetail.group = curGroupName;\n                }\n                if (!legendMap.has(curGroupName)) {\n                  const curGroupDetail = {\n                    indexInList: legends.length\n                  };\n\n                  // 自定义图例颜色\n                  if (!hideLegendFlag && legendCustom) {\n                    for (const {\n                      legend: customGroupName,\n                      color\n                    } of legendCustom) {\n                      if (customGroupName === curGroupName) {\n                        curGroupDetail['customColor'] = color;\n                        break;\n                      }\n                    }\n                  }\n                  legendMap.set(curGroupName, curGroupDetail);\n                  legends.push(curGroupName);\n                }\n              } else if (sourceFeatureMea !== -1) {\n                curNodeDetail.measureSum = _DataFocusMethod.isPureNumber(row[sourceFeatureMea]) ? row[sourceFeatureMea] : 0;\n              }\n              nodeMap.set(curNodeName, curNodeDetail);\n              nodeList.push(curNodeName);\n            } else {\n              nodeMap.get(curNodeName).degree++;\n              if (sourceFeatureMea !== -1) {\n                nodeMap.get(curNodeName).measureSum += _DataFocusMethod.isPureNumber(row[sourceFeatureMea]) ? row[sourceFeatureMea] : 0;\n              }\n            }\n            // 1.2. todo: 按照某一个数值列决定节点的颜色和大小\n          }\n          // 每类节点的居中位置\n          if (legendMap && legendMap.size) {\n            const intervalAngle = 2 * Math.PI / legendMap.size; // 平均间隔角度\n            const spacingRadius = nodeCategoryLayoutRadius || 80;\n            legendMap.forEach(groupDetail => {\n              const curOffsetAngle = intervalAngle * groupDetail.indexInList;\n              groupDetail['center'] = {\n                offsetX: Math.sin(curOffsetAngle) * spacingRadius,\n                offsetY: -Math.cos(curOffsetAngle) * spacingRadius\n              };\n              groupDetail.iterateCountX = 0;\n              groupDetail.iterateCountY = 0;\n            });\n          }\n\n          // 构建边集\n          if (sourceNodeName && targetNodeName) {\n            const curLinkName = `${sourceNodeName}::${targetNodeName}`;\n            if (!linkMap.has(curLinkName)) {\n              const curLinkDetail = {\n                source: sourceNodeName,\n                target: targetNodeName,\n                indexInList: linkList.length\n              };\n              if (edgeFeatureMea !== -1) {\n                curLinkDetail.value = row[edgeFeatureMea];\n              } else if (edgeFeatureAttr !== -1) {\n                // 边为属性列时，边具有 type\n                curLinkDetail.type = row[edgeFeatureAttr];\n              } else {\n                curLinkDetail.value = 0;\n              }\n              // 设置连线两侧，\n              linkMap.set(curLinkName, curLinkDetail);\n              linkList.push(curLinkName);\n            } else {\n              // console.log(curLinkName + '已存在');\n            }\n          }\n        });\n      }\n\n      // 节点最大 degree 和最小 degree\n      const nodeDegreeDomain = d3.extent(nodeList, nodeName => nodeMap.get(nodeName).degree);\n      const nodeMeasureDomain = d3.extent(nodeList, nodeName => nodeMap.get(nodeName).measureSum);\n      const degreeSqrtScale = d3.scaleSqrt().domain(nodeDegreeDomain).range([nodeRadiusMin, nodeRadiusMax]);\n      const measureSqrtScale = d3.scaleSqrt().domain(nodeMeasureDomain).range([nodeRadiusMin, nodeRadiusMax]);\n      const isGroupOrRankingColumnExist = sourceFeatureAttr !== -1 || sourceFeatureMea !== -1;\n\n      // 节点的尺寸：容错\n      const getNodeRadius = function () {\n        // 选中列是数值列\n        if (isGroupOrRankingColumnExist && curRows[0].col_type === \"MEASURE\") {\n          // 排序\n          if (nodeColorMode === 'ranking') {\n            if (nodeRankingCondition === 'measure') {\n              return nodeName => measureSqrtScale(nodeMap.get(nodeName).measureSum);\n            } else if (nodeRankingCondition === 'degree') {\n              return nodeName => degreeSqrtScale(nodeMap.get(nodeName).degree);\n            }\n          } else {\n            return nodeName => degreeSqrtScale(nodeMap.get(nodeName).degree);\n          }\n        } else if (isGroupOrRankingColumnExist && curRows[0].col_type === \"ATTRIBUTE\") {\n          // 分组\n          if (nodeColorMode === 'partition') {\n            if (nodeRankingCondition === 'degree') {\n              return nodeName => degreeSqrtScale(nodeMap.get(nodeName).degree);\n            } else {\n              return () => (nodeRadiusMin + nodeRadiusMax) / 2;\n            }\n          } else {\n            return nodeName => degreeSqrtScale(nodeMap.get(nodeName).degree);\n          }\n        } else {\n          return () => (nodeRadiusMin + nodeRadiusMax) / 2;\n        }\n      };\n      const getNodeFill = function (nodeColorMode) {\n        if (nodeColorMode === 'static') {\n          return () => nodeColor;\n        } else if (nodeColorMode === 'ranking') {\n          // 按照度进行Ranking\n          if (isGroupOrRankingColumnExist && curRows[0].col_type === \"MEASURE\" && nodeRankingCondition === 'measure') {\n            // 按照数值列进行Ranking\n            const linearScale = d3.scaleLinear().domain(nodeMeasureDomain).range([0.2, 1]);\n            const colorInterpolate = d3.interpolate('#ffffffff', nodeColor);\n            return nodeName => colorInterpolate(linearScale(nodeMap.get(nodeName).measureSum));\n          } else {\n            const linearScale = d3.scaleLinear().domain(nodeDegreeDomain).range([0.2, 1]);\n            const colorInterpolate = d3.interpolate('#ffffffff', nodeColor);\n            return nodeName => colorInterpolate(linearScale(nodeMap.get(nodeName).degree));\n          }\n        } else if (isGroupOrRankingColumnExist && curRows[0].col_type === \"ATTRIBUTE\" && nodeColorMode === 'partition') {\n          const extendColorScheme = (colorSet, targetLen) => {\n            const extendedColorSet = [];\n            const countsNeedToInsert = targetLen - colorSet.length;\n            const sectionCount = colorSet.length - 1;\n            const averageCountNeedInsert = Math.floor(countsNeedToInsert / sectionCount);\n            const restCountsAfterAverage = countsNeedToInsert % sectionCount;\n            for (let i = 0; i < sectionCount; i++) {\n              const startColor = colorSet[i],\n                endColor = colorSet[i + 1];\n\n              // 多出来的从头开始分配\n              const countNeedInsert = i < restCountsAfterAverage ? averageCountNeedInsert + 1 : averageCountNeedInsert;\n              const sectionColorInterpolate = d3.interpolate(startColor, endColor);\n              extendedColorSet.push(startColor);\n              const averageRate = 1 / (countNeedInsert + 1);\n              const insertingColorSet = [...Array(countNeedInsert).keys()].map(i => sectionColorInterpolate((i + 1) * averageRate));\n              extendedColorSet.push(...insertingColorSet);\n            }\n            extendedColorSet.push(colorSet.at(-1));\n            return extendedColorSet;\n          };\n\n          // 如果颜色组小于图例个数，则扩充颜色组\n          if (localColor.length < legends.length) {\n            localColor = extendColorScheme(localColor, legends.length);\n          }\n          if (!hideLegendFlag && legendCustom) {\n            // 改变图例元素颜色\n            legendMap.forEach((legendDetail, legendName) => {\n              if (legendDetail.customColor) {\n                localColor[legendDetail.indexInList] = legendDetail.customColor;\n              }\n            });\n          }\n\n          // 主题色只有15个，需要扩充主题色。采用线性插值\n          const colorMap = d3.scaleOrdinal(legends, localColor);\n          return nodeName => {\n            const nodeDetail = nodeMap.get(nodeName);\n            const nodeGroupName = nodeDetail.group;\n            if (nodeDetail) {\n              // 自定义图例颜色\n              const groupDetail = legendMap.get(nodeGroupName);\n              if (groupDetail && groupDetail.customColor) {\n                return groupDetail.customColor;\n              }\n            }\n            if (!nodeGroupName) return '#bdbdbd'; // 没有 group 的节点。一般为终点节点\n            // 插值颜色\n            return colorMap(nodeGroupName);\n          };\n        } else {\n          return () => nodeColor;\n        }\n      };\n      const nodeTitle = function (nodeName) {\n        let title = nodeName + '\\n';\n        if (nodeColorMode === 'ranking') {\n          if (nodeRankingCondition === 'degree') {\n            title += nodeMap.get(nodeName).degree || 0;\n          } else {\n            title += nodeMap.get(nodeName).measureSum || 0;\n          }\n        } else if (nodeColorMode === 'partition') {\n          title += nodeMap.get(nodeName).group || '';\n        }\n        return title;\n      };\n      const {\n        exportWithFixed,\n        exportWithoutFixed,\n        startBoxSelection,\n        exitBoxSelection\n      } = drawForceGraph({\n        nodes: nodeList,\n        links: linkList,\n        originalLinks: linkList,\n        linkMap: linkMap,\n        nodeMap: nodeMap\n      }, {\n        nodeRadius: getNodeRadius(),\n        nodeGroup: sourceFeatureAttr !== -1 ? nodeName => nodeMap.get(nodeName).group : undefined,\n        nodeTitle: nodeTitle,\n        nodeFill: getNodeFill(nodeColorMode),\n        // 节点填充颜色\n        nodeStroke: nodeBorderColor,\n        // 节点边框颜色\n        nodeStrokeWidth: nodeBorderWidth,\n        // 节点边框宽度\n        nodeStrength: (nodeRepulsiveForce - nodeGravityForce) * -1.0,\n        // 节点斥力\n        linkSource: linkName => linkMap.get(linkName).source,\n        linkTarget: linkName => linkMap.get(linkName).target,\n        linkStrokeWidth: l => Math.sqrt(l.value),\n        // 边的宽度\n        linkStrength: adjustLinkRigidity ? undefined : edgeLinkRigidity,\n        // 边的刚性\n        linkStroke: linkColor ? linkColor : \"#999\",\n        // 边的颜色\n        colors: localColor,\n        width: drawWidth,\n        // 容器宽\n        height: drawHeight,\n        // 容器高\n        invalidation: stopPromise\n      });\n\n      // 工具栏\n      (() => {\n        const toolsContainer = svgContainer.append('div').classed('graph-tools', true).style('display', 'flex').style('flex-direction', 'column').style('width', 'max-content').style('position', 'absolute').style('right', '20px').style('top', '20px').style('padding', '8px').style('border-radius', '5px').style('background', '#fff').style('box-shadow', '0 0 15px rgba(0,0,0,.2)');\n        const showDetailOption = toolsContainer.append('label').style('display', 'flex').style('margin-top', '3px').style('align-items', 'center');\n        showDetailOption.append('input').attr('type', 'checkbox').property('checked', true).style('margin-right', '5px').on('change', function () {\n          if (!showDetailOption.property('checked')) {\n            showDetailOption.property('checked', true);\n            graphDetail.style('opacity', '0').style('visibility', 'hidden');\n          } else {\n            showDetailOption.property('checked', false);\n            graphDetail.style('opacity', '1').style('visibility', 'visible');\n          }\n        });\n        showDetailOption.append('span').text(locale === 'cn' ? '查看详情' : 'Show details');\n\n        // 固定点功能\n        const fixPointOption = toolsContainer.append('div').style('display', 'flex').style('margin-top', '3px').style('align-items', 'center').on('click', function () {\n          const curOption = d3.select(this);\n          const checkbox = curOption.select('input').node();\n          if (!checkbox.checked) {\n            exportWithFixed();\n            checkbox.checked = true;\n            options.currentChart.requireSetConfig({\n              key: \"allow_fixed_point\",\n              value: true,\n              isResize: false,\n              disableRedraw: true\n            });\n          } else {\n            exportWithoutFixed();\n            checkbox.checked = false;\n            options.currentChart.requireSetConfig({\n              key: \"allow_fixed_point\",\n              value: false,\n              isResize: false,\n              disableRedraw: true\n            });\n          }\n        });\n        fixPointOption.append('input').style('pointer-events', 'none').attr('type', 'checkbox').style('margin-right', '5px');\n        fixPointOption.append('span').text(locale === 'cn' ? '开启固定点' : 'Enable Fix point');\n        fixPointOption.select('input').node().checked = !!allowFixedPoint;\n\n        // 框选高亮功能\n        // const highlightOption = toolsContainer\n        //     .append('label')\n        //     .style('display', 'flex')\n        //     .style('margin-top', '3px')\n        //     .style('align-items', 'center');\n        // highlightOption.append('input')\n        //     .attr('type', 'checkbox')\n        //     .property('checked', false)\n        //     .style('margin-right', '5px')\n        //     .on('change', function () {\n        //         // 框选拖动\n        //         if (!highlightOption.property('checked')) {\n        //             highlightOption.property('checked', true);\n        //             // 开启功能\n        //             startBoxSelection();\n        //         } else {\n        //             highlightOption.property('checked', false);\n        //             // 关闭功能\n        //             exitBoxSelection();\n        //         }\n        //     });\n        // highlightOption.append('span').text(locale === 'cn' ? '框选高亮' : 'Box selection');\n\n        // 图的详情\n        const graphDetail = (() => {\n          const averageDegree = nodeList.reduce((acc, curNodeName) => {\n            return acc + (nodeMap.get(curNodeName) && nodeMap.get(curNodeName).degree) || 0;\n          }, 0) / nodeList.length;\n          const graphDetailContainer = svgContainer.append('div').classed('graph-detail-container', true).style('width', 'max-content').style('position', 'absolute').style('display', 'flex').style('flex-direction', 'column').style('right', '20px').style('bottom', '20px').style('padding', '8px').style('border-radius', '5px').style('background', '#fff').style('box-shadow', '0 0 15px rgba(0,0,0,.2)');\n\n          // 节点个数：\n          const nodeCountDesc = graphDetailContainer.append('div').style('margin-top', '3px').style('display', 'flex').style('justify-content', 'space-between');\n          nodeCountDesc.append('span').text(locale === 'cn' ? `节点个数` : `Number of nodes`);\n          nodeCountDesc.append('span').style('margin-left', '8px').text(nodeMap.size);\n\n          // 边的个数：\n          const linkCountDesc = graphDetailContainer.append('div').style('margin-top', '3px').style('display', 'flex').style('justify-content', 'space-between');\n          linkCountDesc.append('span').text(locale === 'cn' ? `边的条数` : `Number of links`);\n          linkCountDesc.append('span').style('margin-left', '8px').text(linkMap.size);\n\n          // 节点平均度\n          const displayAverageDegree = averageDegree.toFixed(2);\n          const adDesc = graphDetailContainer.append('div').style('margin-top', '3px').style('display', 'flex').style('justify-content', 'space-between');\n          adDesc.append('span').text(locale === 'cn' ? `节点平均度` : `Average Node degree`);\n          adDesc.append('span').style('margin-left', '8px').text(displayAverageDegree);\n\n          // 平均路径加权值\n          if (edgeFeatureMea !== -1) {\n            const [edgeMeasureColumn] = curValues;\n            const average = edgeMeasureColumn.statistics.average;\n            const displayAverage = parseFloat(average).toFixed(2);\n            const pathDesc = graphDetailContainer.append('div').style('margin-top', '3px').style('display', 'flex').style('justify-content', 'space-between');\n            pathDesc.append('span').text(locale === 'cn' ? `平均路径加权值` : `Average path weighted value`);\n            pathDesc.append('span').style('margin-left', '8px').text(displayAverage);\n          }\n          return graphDetailContainer;\n        })();\n      })();\n    }\n    let stopResolve;\n    const stopPromise = new Promise(resolve => {\n      stopResolve = resolve;\n    });\n    try {\n      drawGroup();\n    } catch (e) {\n      stopResolve();\n      throw e;\n    }\n\n    //有分组时绘制图例\n    let isAttributeGroup = false;\n    const {\n      curRows\n    } = options.chartAxis;\n    if (curRows && curRows.length) {\n      const [sourceFeatureColumn] = curRows;\n      console.log(sourceFeatureColumn);\n      if (sourceFeatureColumn.col_type === 'ATTRIBUTE') {\n        isAttributeGroup = true;\n      }\n    }\n    if (isAttributeGroup && nodeColorMode === 'partition') {\n      const legendOption = {\n        legendEles: legendsCircleDom,\n        isLegendFlag: isLegendFlag,\n        hideLegendFlag: hideLegendFlag,\n        legendPosition: legendPosition,\n        legendBar: legendBar,\n        legendLineWidth: legendLineWidth,\n        legends: legends,\n        legendType: 'legend',\n        fontSizeFlag: fontSizeFlag,\n        legendFontSize: legendFontSize,\n        fontSize: fontSize,\n        labelColor: labelColor,\n        legendFontColor: legendFontColor,\n        curLegendDoms: curLegendDoms,\n        nodeShape: nodeShape,\n        nodeBorderColor: nodeBorderColor || \"#FFF\",\n        isEleStroke: true,\n        legendShape: legendShape,\n        fixedLegendIdx: fixedLegendIdx,\n        callBackAmendFixeDLegendIdx: callBackAmendFixeDLegendIdx,\n        localColor: localColor,\n        mouseoutTimer: mouseoutTimer,\n        legendTexts: legendTexts,\n        labelTextFontSizeFlag: labelTextFontSizeFlag,\n        curLabelTextFontSize: curLabelTextFontSize,\n        labelTextFontColorFlag: labelTextFontColorFlag,\n        curLabelTextFontColor: curLabelTextFontColor,\n        drawWidth: drawWidth,\n        legendLineHeight: legendLineHeight,\n        nodeShapeArray: nodeShapeArray,\n        elementTransparent: 1.0,\n        linkColor: linkColor,\n        nodeBodyColor: nodeBodyColor,\n        isColorSetExtended: true,\n        // 影响图例分页后的颜色，颜色是否已经扩充\n        colorMap: legendMap,\n        changeActiveLegend: function (targetActiveLegendName) {\n          highlightLegendName = targetActiveLegendName;\n          typeof updateLinkStrokeColor === 'function' && updateLinkStrokeColor();\n        }\n      };\n      _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"].legend.drawElement(legendOption);\n    }\n  },\n  getTemplateData: function () {\n    return {\n      headers: [{\n        idx: 0,\n        col_id: '10001',\n        col_uuid: '10001',\n        col_name: '起点实体',\n        data_type: 'string',\n        operator: '',\n        geo_type: '',\n        col_type: 'ATTRIBUTE'\n      }, {\n        idx: 1,\n        col_id: '10002',\n        col_uuid: '10002',\n        col_name: '终点实体',\n        data_type: 'string',\n        operator: '',\n        geo_type: '',\n        col_type: 'ATTRIBUTE'\n      }, {\n        idx: 2,\n        col_id: '10003',\n        col_uuid: '10003',\n        col_name: '分组列',\n        data_type: 'string',\n        operator: '',\n        geo_type: '',\n        col_type: 'ATTRIBUTE'\n      }, {\n        idx: 3,\n        col_id: '10004',\n        col_uuid: '10004',\n        col_name: '边',\n        data_type: 'int',\n        operator: '',\n        geo_type: '',\n        col_type: 'MEASURE'\n      }],\n      columns: [[\"起点1\", \"终点1\", \"组1\", 123], [\"起点1\", \"终点2\", \"组1\", 145], [\"起点1\", \"终点3\", \"组1\", 256], [\"起点2\", \"终点4\", \"组2\", 258], [\"起点2\", \"终点5\", \"组2\", 138], [\"起点2\", \"终点6\", \"组2\", 28], [\"起点3\", \"终点7\", \"组3\", 93], [\"起点2\", \"终点8\", \"组3\", 47], [\"起点2\", \"终点9\", \"组3\", 425]],\n      default_chart: {\n        type: 'group',\n        columns: [0, 1, 2],\n        rows: [0, 1, 2],\n        time: [3]\n      },\n      charts: [{\n        type: 'group',\n        columns: [0, 1, 2],\n        rows: [0, 1, 2],\n        time: [3]\n      }]\n    };\n  },\n  // 当前图形定制的中英文[ 配置XY轴，图表配置 ] [ *新增图形必填项 ]\n  i18nObj: {\n    chinese: {\n      \"chart-name-title\": \"关系网络图\",\n      \"chart-description-title\": \"至少两个属性列表示起点和终点\",\n      \"chart-columns-title\": \"起点实体 | 终点实体\",\n      \"chart-rows-title\": \"分组列或排名列\",\n      \"chart-values-title\": \"边\",\n      \"chart-axis-config-null-error\": \"系统没有传入当前用户的Axis配置信息\",\n      \"chart-entity-null\": \"起点实体和终点实体不可为空\",\n      \"chart-entity-correspond\": \"未按顺序选中起点实体与终点实体\",\n      \"chart-legend-correspond\": \"只可选择节点分组列或节点排序列\",\n      \"chart-edge-null\": \"边不可为空\",\n      \"chart-edge-too-much\": \"只可拥有一条边\",\n      \"chart-edge-same-with-legend\": \"边不可与分组列或排名列相同\",\n      \"chart-need-all-attribute-columns\": \"当前图形需要将所有的属性列利用起来\",\n      \"category_chart_general\": \"通用\",\n      \"option_style_background_color\": \"背景颜色\",\n      \"option_style_background_color_desc\": \"配置背景颜色\",\n      \"option_chart_color_theme\": \"颜色主题\",\n      \"option_chart_custom_theme\": \"自定义主题\",\n      \"option_chart_custom_theme_desc\": \"自定义主题\",\n      \"option_label_text_regex_sampleArea_desc\": \"要显示的文本。有以下替换宏可用：<br /> %_NAME - 显示节点名字 <br /> %_GROUP - 显示节点分组<br /> %_MEASURE - 显示节点数值列 <br /> %_DEGREE - 显示节点的度<br /> %_BR - 换行符\",\n      \"category_layout\": \"布局配置\",\n      \"category_node\": \"节点配置\",\n      \"category_edge\": \"边配置\",\n      \"category_chart_style\": \"样式\",\n      \"option_entire_force_model\": \"视图模式\",\n      \"option_entire_force_model_desc\": \"设置全局保守力的模式\",\n      \"option_entire_force_center_gravitation\": '中心引力',\n      \"option_entire_force_around_repulsive\": '边缘斥力',\n      \"option_entire_force_radial\": '圆形布局',\n      // 布局力场中的参数\n      // 通用参数\n      \"option_node_gravity_force\": \"节点引力\",\n      \"option_node_gravity_force_desc\": \"设置节点间的引力\",\n      \"option_node_repulsive_force\": \"节点斥力\",\n      \"option_node_repulsive_force_desc\": \"设置节点间的斥力\",\n      \"option_adjust_link_rigidity_re\": \"自适应刚性\",\n      \"option_adjust_link_rigidity_re_desc\": \"连边刚性自适应计算\",\n      \"option_edge_link_rigidity\": \"连边刚性\",\n      \"option_edge_link_rigidity_desc\": \"设置连边刚性\",\n      \"option_edge_link_distance\": \"连边长度\",\n      \"option_edge_link_distance_desc\": \"设置连边的长度\",\n      \"option_node_overlap_max_rate\": \"节点最大重合度\",\n      \"option_node_overlap_max_rate_desc\": \"设置节点重合半径百分比。该值为 0 时，节点最近为相切\",\n      // many-body\n      \"option_node_max_distance\": \"节点最大距离\",\n      \"option_node_max_distance_desc\": \"设置节点的最大距离\",\n      \"option_node_min_distance\": \"节点最小距离\",\n      \"option_node_min_distance_desc\": \"设置节点的最小距离\",\n      // 圆形布局\n      \"option_layout_radial_strength\": \"力场强度\",\n      \"option_layout_radial_strength_desc\": \"使节点聚为圆环的力场强度\",\n      \"option_layout_radial_radius\": \"力场半径\",\n      \"option_layout_radial_radius_desc\": \"圆形力场的半径大小\",\n      \"option_node_color_mode\": \"节点颜色模式\",\n      \"option_node_color_mode_desc\": \"选择为节点填充颜色的规则\",\n      \"option_node_color_mode_static\": \"统一颜色\",\n      \"option_node_color_mode_ranking\": \"按排名区分\",\n      \"option_node_color_mode_partition\": \"按分组区分\",\n      \"option_node_ranking_condition\": \"排名依据的条件\",\n      \"option_node_ranking_condition_desc\": \"节点排名所依据的条件\",\n      \"option_node_static_color\": '节点颜色',\n      \"option_node_static_color_desc\": \"当颜色模式为“统一”时，此颜色充当静态颜色；当颜色模式为“排序”时，此颜色充当渐变主色\",\n      \"option_node_ranking_by_degree\": \"按度\",\n      \"option_node_ranking_by_measure\": \"按数值列\",\n      \"option_style_node_border_width\": \"节点描边宽(px)\",\n      \"option_style_node_border_width_desc\": \"设置节点描边的宽度\",\n      \"option_style_node_border_color\": \"节点描边颜色\",\n      \"option_style_node_border_color_desc\": \"节点描边颜色\",\n      \"option_fixed_dot_pos\": \"固定点\",\n      \"option_fixed_dot_pos_desc\": \"配置一些特定节点的固定位置。<br />如需取消特定节点的固定位置，则关闭固定点模式，再点击该点。<br />配置格式<br />1. 各点由节点名,X坐标,Y坐标构成，由逗号分隔开. <br />2.多个节点间使用 | 分隔开. <br />3. 画布中心为0,0。<br />如：北京市,100,200 | 西藏,0,0\",\n      \"option_disable_link\": \"关闭边\",\n      \"option_disable_link_desc\": \"关闭边\",\n      \"option_style_link_model\": \"连边模式\",\n      \"option_style_link_model_desc\": \"设置连边模式\",\n      \"option_style_link_model_undirected\": \"无向图\",\n      \"option_style_link_model_directed\": \"有向图\",\n      \"option_adjust_link_width_re\": \"自适应宽度\",\n      \"option_adjust_link_width_re_desc\": \"连边宽度自适应计算\",\n      \"option_style_link_width\": \"连边宽度\",\n      \"option_style_link_width_desc\": \"设置连边宽度\",\n      \"option_style_link_color_follow_node\": \"颜色跟随节点\",\n      \"option_style_link_color_follow_node_desc\": \"选中后，边的颜色与相连的节点颜色保持一致\",\n      \"option_style_link_color\": \"连边颜色\",\n      \"option_style_link_color_desc\": \"设置连边颜色\",\n      \"option_allow_fixed_point\": \"开启固定点\",\n      \"option_allow_fixed_point_desc\": \"鼠标点击固定当前节点的位置\",\n      \"option_style_node_radius_max\": \"节点最大半径\",\n      \"option_style_node_radius_max_desc\": \"节点最大半径\",\n      \"option_style_node_radius_min\": \"节点最小半径\",\n      \"option_style_node_radius_min_desc\": \"节点最小半径\",\n      \"option_node_category_layout\": \"节点分组布局\",\n      \"option_node_category_layout_desc\": \"开启后，节点可依据图例分组布局\",\n      \"option_node_category_layout_radius\": \"节点分组半径\",\n      \"option_node_category_layout_radius_desc\": \"设置节点分组圆心到画布中心的距离\",\n      \"category_chart_legend\": \"图例\",\n      \"option_hide_chart_legend\": \"隐藏图例\",\n      \"option_hide_chart_legend_desc\": \"隐藏图例\",\n      \"option_legend_font_family\": \"图例字体\",\n      \"option_legend_font_family_desc\": \"图例文字配置\",\n      \"option_legend_font_size\": \"字体大小\",\n      \"option_legend_font_size_desc\": \"设置图例的字体大小\",\n      \"option_legend_font_color\": \"字体颜色\",\n      \"option_legend_font_color_desc\": \"设置图例的字体颜色\",\n      \"option_chart_legend_position\": \"图例位置\",\n      \"option_chart_legend_position_desc\": \"设置图例的位置\",\n      \"option_legend_position_bottom\": \"底部\",\n      \"option_legend_position_right\": \"右侧\",\n      \"option_chart_custom_legend_1\": \"自定义图例\",\n      \"category_label_1\": \"数据标签\",\n      \"option_label_text_font_size\": \"字体大小\",\n      \"option_label_text_font_size_desc\": \"设置字体大小\",\n      \"option_label_text_allow_overlap\": \"允许重叠\",\n      \"option_chart_config_restart\": \"恢复默认配置\",\n      \"option_hidden_hover_text\": \"隐藏\",\n      \"option_hidden_hover_text_desc\": \"隐藏悬浮文本\",\n      \"option_suspend_text_regex_correlation_desc\": \"要显示的文本。有以下替换宏可用：<br /> %_NAME - 显示节点名字 <br /> %_GROUP - 显示节点分组<br /> %_MEASURE - 显示节点数值列 <br /> %_DEGREE - 显示节点的度<br /> %_BR - 换行符\"\n    },\n    english: {\n      \"chart-name-title\": \"Network Diagram\",\n      \"chart-description-title\": \"At least two attribute columns indicating the start and end points\",\n      \"chart-columns-title\": \"Source Entity | Target Entity\",\n      \"chart-rows-title\": \"Source Legend | Target Legend\",\n      \"chart-values-title\": \"Edge\",\n      \"chart-axis-config-null-error\": \"The system does not pass in Axis config\",\n      \"chart-entity-null\": \"The start entity and end entity cannot be empty\",\n      \"chart-entity-correspond\": \"The starting entity and the ending entity are not selected in order\",\n      \"chart-legend-correspond\": \"Up to both start and end legends\",\n      \"chart-edge-null\": \"Edge cannot be empty\",\n      \"chart-edge-too-much\": \"Only one edge can be configured\",\n      \"chart-edge-same-with-legend\": \"The edge cannot be consistent with the grouping column or ranking column\",\n      \"chart-need-all-attribute-columns\": \"The current graph needs to utilize all of the property columns\",\n      \"category_chart_general\": \"General\",\n      \"option_style_background_color\": \"Background color\",\n      \"option_style_background_color_desc\": \"Configure the background color\",\n      \"option_chart_color_theme\": \"Color Theme\",\n      \"option_chart_custom_theme\": \"Customized themes\",\n      \"option_chart_custom_theme_desc\": \"Customized themes\",\n      \"option_label_text_regex_sampleArea_desc\": \"The following replacement macros are available: <br /> %_NAME - 显示节点名字 <br /> %_GROUP - Show node group<br /> %_MEASURE - Show node value column <br /> %_DEGREE - Display the degree of the node<br /> %_BR - line break\",\n      \"category_layout\": \"Layout configuration\",\n      \"category_node\": \"Node Configuration\",\n      \"category_edge\": \"Edge configuration\",\n      \"category_chart_style\": \"Style\",\n      \"option_entire_force_model\": \"View Mode\",\n      \"option_entire_force_model_desc\": \"Set the mode of global conservative force\",\n      \"option_entire_force_center_gravitation\": 'Central Gravity',\n      \"option_entire_force_around_repulsive\": 'Edge repulsion',\n      \"option_entire_force_radial\": 'Circular layout',\n      // 布局力场中的参数\n      // 通用参数\n      \"option_node_gravity_force\": \"Node Gravity\",\n      \"option_node_gravity_force_desc\": \"Set the gravitational force between nodes\",\n      \"option_node_repulsive_force\": \"Nodal Repulsion\",\n      \"option_node_repulsive_force_desc\": \"Set the repulsion between nodes\",\n      \"option_adjust_link_rigidity_re\": \"Adaptive rigidity\",\n      \"option_adjust_link_rigidity_re_desc\": \"Adaptive calculation of continuous edge rigidity\",\n      \"option_edge_link_rigidity\": \"Continuous edge rigidity\",\n      \"option_edge_link_rigidity_desc\": \"Set rigidity of continuous edge\",\n      \"option_edge_link_distance\": \"Length of continuous edge\",\n      \"option_edge_link_distance_desc\": \"Set the length of the connected edge\",\n      \"option_node_overlap_max_rate\": \"Maximum overlap of nodes\",\n      \"option_node_overlap_max_rate_desc\": \"Set the node overlap radius percentage. If the value is 0, the nodes are nearest tangent\",\n      // many-body\n      \"option_node_max_distance\": \"Maximum distance between nodes\",\n      \"option_node_max_distance_desc\": \"Set the maximum distance of the node\",\n      \"option_node_min_distance\": \"Minimum distance between nodes\",\n      \"option_node_min_distance_desc\": \"Set the minimum distance of the node\",\n      // 圆形布局\n      \"option_layout_radial_strength\": \"Force field strength\",\n      \"option_layout_radial_strength_desc\": \"The strength of the force field that causes the nodes to cluster into a circle\",\n      \"option_layout_radial_radius\": \"Radius of force field\",\n      \"option_layout_radial_radius_desc\": \"The size of the radius of the circular force field\",\n      \"option_node_color_mode\": \"Node color mode\",\n      \"option_node_color_mode_desc\": \"Select the rule for filling the node with color\",\n      \"option_node_color_mode_static\": \"Static\",\n      \"option_node_color_mode_ranking\": \"Ranking\",\n      \"option_node_color_mode_partition\": \"Grouping\",\n      \"option_node_ranking_condition\": \"Ranking Conditions\",\n      \"option_node_ranking_condition_desc\": \"Conditions on which node ranking is based\",\n      \"option_node_static_color\": 'Node Color',\n      \"option_node_static_color_desc\": \"When the color mode is Static, this color acts as a static color; when the color mode is Ranking, this color acts as a gradient primary color\",\n      \"option_node_ranking_by_degree\": \"By degree\",\n      \"option_node_ranking_by_measure\": \"By measure\",\n      \"option_style_node_border_width\": \"Node stroke width(px)\",\n      \"option_style_node_border_width_desc\": \"Set the width of the node stroke\",\n      \"option_style_node_border_color\": \"Node stroke color\",\n      \"option_style_node_border_color_desc\": \"Node stroke color\",\n      \"option_fixed_dot_pos\": \"Fix Point\",\n      \"option_fixed_dot_pos_desc\": \"Configure the fixed position of some specific nodes. <br />1. Each point consists of node name, X coordinate, Y coordinate, separated by a comma. <br />2. Use | to separate multiple nodes.  <br />3. The center of the canvas is 0,0. e.g. Canada,100,200 | United States,0,0\",\n      \"option_disable_link\": \"Disable\",\n      \"option_disable_link_desc\": \"Disable the edges\",\n      \"option_style_link_model\": \"Edge mode\",\n      \"option_style_link_model_desc\": \"Set the edge mode\",\n      \"option_style_link_model_undirected\": \"Undirected\",\n      \"option_style_link_model_directed\": \"Directed\",\n      \"option_adjust_link_width_re\": \"Adaptive Width\",\n      \"option_adjust_link_width_re_desc\": \"Adaptive calculation of continuous edge width\",\n      \"option_style_link_width\": \"Edge width\",\n      \"option_style_link_width_desc\": \"Set the edge width\",\n      \"option_style_link_color_follow_node\": \"Color follow node\",\n      \"option_style_link_color_follow_node_desc\": \"When selected, the color of the edge is consistent with the color of the connected nodes\",\n      \"option_style_link_color\": \"Edge color\",\n      \"option_style_link_color_desc\": \"Set the edge color\",\n      \"option_allow_fixed_point\": \"Fix point\",\n      \"option_allow_fixed_point_desc\": \"Mouse click fixes the position of the current node\",\n      \"option_style_node_radius_max\": \"Maximum node radius\",\n      \"option_style_node_radius_max_desc\": \"Maximum node radius\",\n      \"option_style_node_radius_min\": \"Minimum node radius\",\n      \"option_style_node_radius_min_desc\": \"Minimum node radius\",\n      \"option_node_category_layout\": \"Node grouping layout\",\n      \"option_node_category_layout_desc\": \"When turned on, nodes can be grouped according to the legend layout\",\n      \"option_node_category_layout_radius\": \"Node grouping radius\",\n      \"option_node_category_layout_radius_desc\": \"Set the distance from the center of the node grouping circle to the center of the canvas\",\n      \"category_chart_legend\": \"Legend\",\n      \"option_hide_chart_legend\": \"Hide legend\",\n      \"option_hide_chart_legend_desc\": \"Hide legend\",\n      \"option_legend_font_family\": \"Font family\",\n      \"option_legend_font_family_desc\": \"Legend font family\",\n      \"option_legend_font_size\": \"Font size\",\n      \"option_legend_font_size_desc\": \"Set the font size of the legend\",\n      \"option_legend_font_color\": \"Font color\",\n      \"option_legend_font_color_desc\": \"Set the font color of the legend\",\n      \"option_chart_legend_position\": \"Legend Location\",\n      \"option_chart_legend_position_desc\": \"Set the location of the legend\",\n      \"option_legend_position_bottom\": \"Bottom\",\n      \"option_legend_position_right\": \"Right\",\n      \"option_chart_custom_legend_1\": \"Custom Legend\",\n      \"category_label_1\": \"Label\",\n      \"option_label_text_font_size\": \"Font size\",\n      \"option_label_text_font_size_desc\": \"Set the font size of label text\",\n      \"option_label_text_allow_overlap\": \"Allow overlap\",\n      \"option_chart_config_restart\": \"Restore the default configuration\",\n      \"option_hidden_hover_text\": \"Hidden\",\n      \"option_hidden_hover_text_desc\": \"Turn off hover text\",\n      \"option_suspend_text_regex_correlation_desc\": \"The following replacement macros are available: <br /> %_NAME - 显示节点名字 <br /> %_GROUP - Show node group<br /> %_MEASURE - Show node value column <br /> %_DEGREE - Display the degree of the node<br /> %_BR - line break\"\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.senior/analysisGroup.js?");

/***/ })

}]);