(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[33],{

/***/ "../src-v5/assets/js/charts.system.senior/crossTable.js":
/*!**************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.senior/crossTable.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../charts.plugin/animationTimeSequenceFrame */ \"../src-v5/assets/js/charts.plugin/animationTimeSequenceFrame.js\");\n\n\n/** 相关图画图组件 **/\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  chartType: 'crossTable',\n  //  图形名 [ * 必填项 ]\n  chartDisplayNameKey: \"chart-name-title\",\n  //  图形名称中英文Key [ * 必填项 ]\n  chartDescriptionKey: \"chart-description-title\",\n  //  图形描述中英文Key [ * 必填项 ]\n\n  // 搜索数据是聚合数据且至少一个属性列且至少一个数值列\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n    if (searchResultStatistic && searchResultStatistic.aggregatedFlag && searchResultStatistic.attributeColumns && searchResultStatistic.measureColumns) {\n      if (searchResultStatistic.measureColumns.length >= 1 && searchResultStatistic.attributeColumns.length >= 1) {\n        satisfiedFlag = true;\n      }\n    }\n    return satisfiedFlag;\n  },\n  // 图形配置元素 [ * 必填项 ]\n  needAxis: {\n    columns: {\n      i18nKey: \"chart-column-axis-title\",\n      required: false\n    },\n    rows: {\n      i18nKey: \"chart-row-axis-title\",\n      required: true\n    },\n    values: {}\n  },\n  /**\r\n   * 判断当前图形的Axis配置是否合法 [ * 必填项 ]\r\n   * 例：X轴不允许为空，Y轴不允许为空，X轴不允许与图例列相同\r\n   * @params [Object]theAxisConfig      -   当前用户手动配置的规则\r\n   *          {\r\n   *              xAxis: [{\r\n   *                  index\r\n   *                  columnId\r\n   *                  type\r\n   *              }] ,\r\n   *              yAxis: [{\r\n   *                  index\r\n   *                  columnId\r\n   *              }] ,\r\n   *              legend: [{\r\n   *                  index\r\n   *                  columnId\r\n   *              }] ,\r\n   *\r\n   *              // 搜素数据的统计信息\r\n   *              searchResultStatistic: {\r\n   *                  aggregatedFlag  搜索数据是否聚合的标志\r\n   *\r\n   *                  measureColumns    数值列数量\r\n   *                  attributeColumns  属性列数量\r\n   *                  legendColumns     能作为图例的属性列数量（distinct_count < 50 的列）\r\n   *                  dateColumns       日期列数量\r\n   *                  lonColumns        经度列数量\r\n   *                  latColumns        纬度列数量\r\n   *                  queryResultCount    查询数据结果条目\r\n   *                  regionColumns        地理列数组（1：国家集合；1.5：国家；2：省集合；2.5：省；3：市集合；3.5：市；4：区集合；4.5：区；0：其他地理列）\r\n   *              }\r\n   *          }\r\n   *\r\n   * 判断条件：\r\n   * 1. xAxis不允许为空\r\n   * 2. yAxis不允许为空\r\n   * 3. 主Y轴不允许为空\r\n   * 4. legend只允许一个\r\n   * 5. legend存在时Y轴只允许一个\r\n   * 6. legend不允许与xAxis重复\r\n   *\r\n   * @return [String]errorKey -   错误提示对应的key;\r\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let theErrorMsgKey = '';\n    theAxisConfig = theAxisConfig || {};\n    // 行数据与值数据不能为空\n    if (!theAxisConfig.rows || !theAxisConfig.rows.length) {\n      theErrorMsgKey = \"chart-row-value-axis-null\";\n    }\n    if (!theAxisConfig.values || !theAxisConfig.values.length) {\n      theErrorMsgKey = \"chart-row-value-axis-null\";\n    }\n\n    // 当前图形需要将所有属性列利用起来\n    let searchResultStatistic = theAxisConfig.searchResultStatistic || {};\n    let usedAttributeNum = (theAxisConfig.rows && theAxisConfig.rows.length || 0) + (theAxisConfig.columns && theAxisConfig.columns.length || 0);\n    let dataAttributeNum = searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.length || 0;\n    if (usedAttributeNum < dataAttributeNum) {\n      theErrorMsgKey = \"chart-need-all-attribute-columns\";\n    }\n    return theErrorMsgKey;\n  },\n  // 当前图形的配置项[ *新增图形必填项 ]\n  chartConfigureList: [\n  //通用\n  {\n    key: \"category_common\",\n    title: \"category_common\",\n    options: [\n    //字体大小\n    {\n      key: \"style_cell_font_size\",\n      title: \"option_style_cell_font_size\",\n      description: \"option_style_cell_font_size_desc\",\n      type: \"input\",\n      defaultNumber: 12,\n      min: 10,\n      max: 48,\n      withoutSlider: true\n    },\n    //边框宽度\n    {\n      key: \"all_border_width\",\n      title: \"option_all_border_width\",\n      description: \"option_all_border_width_desc\",\n      type: \"input\",\n      min: 0,\n      max: 2,\n      defaultNumber: 1\n    },\n    // 表格对齐\n    {\n      key: \"table_text_align_label\",\n      title: \"option_table_text_align_label\",\n      description: \"option_table_text_align_label_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"text_align_center\", \"text_align_left\", \"text_align_right\"]\n    },\n    //搜索记录\n    {\n      key: \"chart_page_size\",\n      title: \"option_chart_page_size\",\n      description: \"option_chart_page_size_desc\",\n      onlyConfigFlag: true,\n      type: \"input\",\n      defaultNumber: 1000,\n      withoutSlider: true\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      title: \"option_chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //单元格\n  {\n    key: \"category_cell\",\n    title: \"category_chart_cell\",\n    options: [\n    //单元格颜色\n    {\n      key: \"style_node_body_color\",\n      title: \"option_style_node_body_color\",\n      description: \"option_style_node_body_color_desc\",\n      type: \"color\"\n    },\n    //单元格边框颜色\n    {\n      key: \"style_node_border_color\",\n      title: \"option_style_node_border_color\",\n      description: \"option_style_node_border_color_desc\",\n      type: \"color\"\n    },\n    //自定义单元格宽度\n    {\n      key: \"cell_width_text\",\n      title: \"option_cell_width_text\",\n      description: \"option_cell_width_text_desc\",\n      type: \"text\"\n    },\n    //单元格宽度\n    {\n      key: \"style_cell_width\",\n      title: \"option_style_cell_width\",\n      description: \"option_style_cell_width_desc\",\n      type: \"input\",\n      min: 60,\n      max: 1000,\n      defaultNumber: 80,\n      withoutSlider: true\n    },\n    //单元格高度\n    {\n      key: \"style_cell_height\",\n      title: \"option_style_cell_height\",\n      description: \"option_style_cell_height_desc\",\n      type: \"input\",\n      min: 20,\n      max: 1000,\n      defaultNumber: 30,\n      withoutSlider: true\n    },\n    //单元格字体颜色\n    {\n      key: \"style_cell_font_color\",\n      title: \"option_style_cell_font_color\",\n      description: \"option_style_cell_font_color_desc\",\n      type: \"color\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      title: \"option_chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //综合表头\n  {\n    key: \"category_syn\",\n    title: \"category_chart_syn\",\n    options: [\n    //综合表头内容\n    {\n      key: \"syn_content_text\",\n      title: \"option_syn_content_text\",\n      description: \"option_syn_content_text_desc\",\n      type: \"text\"\n    },\n    //分隔方式\n    {\n      key: \"syn_split_type\",\n      title: \"option_syn_split_type\",\n      description: \"option_syn_split_type_desc\",\n      type: \"select\",\n      selection: [\"option_syn_split_top\", \"option_syn_split_bottom\"]\n    },\n    //综合表头颜色\n    {\n      key: \"style_syn_color\",\n      title: \"option_style_syn_color\",\n      description: \"option_style_syn_color_desc\",\n      type: \"color\"\n    },\n    //综合表头边框颜色\n    {\n      key: \"style_syn_border_color\",\n      title: \"option_style_syn_border_color\",\n      description: \"option_style_syn_border_color_desc\",\n      type: \"color\"\n    },\n    /*//停用宽高自适应\r\n    {\r\n        key: \"stop_adapt_width_height\",\r\n        title: \"option_stop_adapt_width_height\",\r\n        description: \"option_stop_adapt_width_height_desc\",\r\n        type:\"checkbox\"\r\n    },*/\n    //综合表头宽度\n    {\n      key: \"syn_header_width\",\n      title: \"option_syn_header_width\",\n      description: \"option_syn_header_width_desc\",\n      type: \"input\",\n      //require:\"stop_adapt_width_height\",\n      min: 60,\n      max: 1000,\n      defaultNumber: 80,\n      withoutSlider: true\n    },\n    //综合表头高度\n    {\n      key: \"syn_header_height\",\n      title: \"option_syn_header_height\",\n      description: \"option_syn_header_height_desc\",\n      type: \"input\",\n      //require:\"stop_adapt_width_height\",\n      min: 20,\n      max: 1000,\n      defaultNumber: 30,\n      withoutSlider: true\n    },\n    //综合表头字体大小\n    {\n      key: \"syn_font_size\",\n      title: \"option_syn_font_size\",\n      description: \"option_syn_font_size_desc\",\n      type: \"input\",\n      defaultNumber: 10,\n      min: 10,\n      max: 48,\n      withoutSlider: true\n    },\n    //综合表头字体颜色\n    {\n      key: \"syn_font_color\",\n      title: \"option_syn_font_color\",\n      description: \"option_syn_font_color_desc\",\n      type: \"color\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      title: \"option_chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //顶部表头\n  {\n    key: \"category_top\",\n    title: \"category_chart_top\",\n    options: [\n    //顶部表头颜色\n    {\n      key: \"style_top_header_color\",\n      title: \"option_style_top_header_color\",\n      description: \"option_style_top_header_color_desc\",\n      type: \"color\"\n    },\n    //顶部表头边框颜色\n    {\n      key: \"style_top_header_border_color\",\n      title: \"option_style_top_header_border_color\",\n      description: \"option_style_top_header_border_color_desc\",\n      type: \"color\"\n    },\n    //顶部表头字体大小\n    {\n      key: \"top_header_font_size\",\n      title: \"option_top_header_font_size\",\n      description: \"option_top_header_font_size_desc\",\n      type: \"input\",\n      defaultNumber: 14,\n      min: 10,\n      max: 48,\n      withoutSlider: true\n    },\n    //顶部表头字体颜色\n    {\n      key: \"top_header_font_color\",\n      title: \"option_top_header_font_color\",\n      description: \"option_top_header_font_color_desc\",\n      type: \"color\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      title: \"option_chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //左侧表头\n  {\n    key: \"category_left\",\n    title: \"category_chart_left\",\n    options: [\n    //左侧表头颜色\n    {\n      key: \"style_left_header_color\",\n      title: \"option_style_left_header_color\",\n      description: \"option_style_left_header_color_desc\",\n      type: \"color\"\n    },\n    //左侧表头边框颜色\n    {\n      key: \"style_left_header_border_color\",\n      title: \"option_style_left_header_border_color\",\n      description: \"option_style_left_header_border_color_desc\",\n      type: \"color\"\n    },\n    //左侧表头字体大小\n    {\n      key: \"left_header_font_size\",\n      title: \"option_left_header_font_size\",\n      description: \"option_left_header_font_size_desc\",\n      type: \"input\",\n      defaultNumber: 14,\n      min: 10,\n      max: 48,\n      withoutSlider: true\n    },\n    //左侧表头字体颜色\n    {\n      key: \"left_header_font_color\",\n      title: \"option_left_header_font_color\",\n      description: \"option_left_header_font_color_desc\",\n      type: \"color\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      title: \"option_chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //冻结行列\n  {\n    key: \"category_freeze\",\n    title: \"category_chart_freeze\",\n    options: [\n    //设置冻结行\n    {\n      key: \"freeze_row_content\",\n      title: \"option_freeze_row_content\",\n      description: \"option_freeze_row_content_desc\",\n      type: \"text\"\n    },\n    //设置冻结列\n    {\n      key: \"freeze_column_content\",\n      title: \"option_freeze_column_content\",\n      description: \"option_freeze_column_content_desc\",\n      type: \"text\"\n    },\n    //冻结行背景颜色\n    {\n      key: \"freeze_row_color\",\n      title: \"option_style_freeze_row_color\",\n      description: \"option_style_freeze_row_color_desc\",\n      type: \"color\"\n    },\n    //冻结行边框颜色\n    {\n      key: \"freeze_row_border_color\",\n      title: \"option_style_freeze_row_border_color\",\n      description: \"option_style_freeze_row_border_color_desc\",\n      type: \"color\"\n    },\n    //冻结行字体大小\n    {\n      key: \"freeze_row_font_size\",\n      title: \"option_freeze_row_font_size\",\n      description: \"option_freeze_row_font_size_desc\",\n      type: \"input\",\n      defaultNumber: 14,\n      min: 10,\n      max: 48,\n      withoutSlider: true\n    },\n    //冻结行字体颜色\n    {\n      key: \"freeze_row_font_color\",\n      title: \"option_freeze_row_font_color\",\n      description: \"option_freeze_row_font_color_desc\",\n      type: \"color\"\n    },\n    // //冻结列颜色\n    // {\n    //     key: \"freeze_column_color\",\n    //     title: \"option_style_freeze_column_color\",\n    //     description: \"option_style_freeze_column_color_desc\",\n    //     type: \"color\"\n    // },\n    // //冻结列边框颜色\n    // {\n    //     key: \"freeze_column_border_color\",\n    //     title: \"option_style_freeze_column_border_color\",\n    //     description: \"option_style_freeze_column_border_color_desc\",\n    //     type: \"color\"\n    // },\n    // //冻结列字体大小\n    // {\n    //     key: \"freeze_column_font_size\",\n    //     title: \"option_freeze_column_font_size\",\n    //     description: \"option_freeze_column_font_size_desc\",\n    //     type: \"input\",\n    //     defaultNumber:14,\n    //     min:10,\n    //     max:48,\n    //     withoutSlider:true,\n    // },\n    // //冻结列字体颜色\n    // {\n    //     key: \"freeze_column_font_color\",\n    //     title: \"option_freeze_column_font_color\",\n    //     description: \"option_freeze_column_font_color_desc\",\n    //     type: \"color\"\n    // },\n\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      title: \"option_chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 总计行\n  {\n    key: \"category_total\",\n    title: \"category_chart_total\",\n    options: [\n    // 显示总计行\n    {\n      key: \"show_total_row\",\n      title: \"option_show_total_row\",\n      description: \"option_show_total_row_desc\",\n      type: \"checkbox\"\n    },\n    //总计行位置\n    {\n      key: \"total_row_position\",\n      title: \"option_total_row_position\",\n      description: \"option_option_total_row_position_desc\",\n      require: \"show_total_row\",\n      type: \"select\",\n      selection: [\"option_total_row_position_first\", \"option_total_row_position_last\"]\n    },\n    // 合计行的显示标签\n    {\n      key: \"total_row_label\",\n      title: \"option_total_row_label\",\n      description: \"option_total_row_label_desc\",\n      type: \"text\"\n    },\n    // 显示总计列\n    {\n      key: \"show_total_column\",\n      title: \"option_show_total_column\",\n      description: \"option_show_total_column_desc\",\n      type: \"checkbox\"\n    },\n    //总计行位置\n    {\n      key: \"total_column_position\",\n      title: \"option_total_column_position\",\n      description: \"option_option_total_column_position_desc\",\n      require: \"show_total_row\",\n      type: \"select\",\n      selection: [\"option_total_column_position_first\", \"option_total_column_position_last\"]\n    }]\n  }],\n  /**\r\n   * 使用个人画图方法画图形 [*必填项]\r\n   * @params [Object]options  -   当前图形的配置\r\n   *              {\r\n   *                  container       -   当前画图的DOM元素\r\n   *                  chartAxis       -   当前图形的Axis配置\r\n   *                  datas           -   当前画图数据\r\n   *                  isResize        -   是否是窗口变化引起的画图\r\n   *                  chartConfigures -   图形配置\r\n   *                  plugins         -   DataFocus提供的第三方画图库\r\n   *                      {\r\n   *                          d3  -   d3的v3版本\r\n   *                          echarts -   echarts的\r\n   *                      }\r\n   *              }\r\n   * **/\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n    let startTime = new Date().getTime();\n    let currentChart = options.currentChart,\n      conf = currentChart.defaultConf || {},\n      container = options.container,\n      chartAxis = options.chartAxis;\n    //系统配置\n    let d3 = options.plugins.d3v7;\n    let fontSize = conf.fontSize || 14;\n    //获取配置信息\n    let nodeBodyColor = \"#fff\"; //  单元格背景颜色\n    let nodeBorderColor = \"#f5f5f5\"; //  单元格边框颜色\n    let styleCellWidth = 80; //  单元格宽度\n    let styleCellHeight = 30; //  单元格高度\n    let styleSynWidth = 80; //  综合表头即左上角表头单元格宽度\n    let styleSynHeight = 30; //  综合表头即左上角表头单元格高度\n    let styleTopHeaderColor = \"#647588\"; //  顶部表头的背景颜色\n    let styleTopHeaderBorderColor = \"#7c8a9a\"; //  顶部表头的边框颜色\n    let styleLeftHeaderColor = \"#fff\"; //  左侧表头背景颜色\n    let styleLeftHeaderBorderColor = \"#f0f0f0\"; //  左侧表头的边框颜色\n    let styleSynHeaderColor; //  综合表头的背景颜色\n    let styleSynHeaderBorderColor; //  综合表头的边框颜色\n    let freezeRowColor = \"#eee\"; //  固定行背景颜色\n    let freezeRowBorderColor; //  固定行边框颜色\n    let cellFontSize = 12; //  单元格字体大小\n    let cellFontColor; //  单元格字体颜色\n    let synFontSize = 10; //  综合表头字体大小\n    let synFontColor; //  综合表头字体颜色\n    let topHeaderFontSize; //  顶部表头的字体大小\n    let topHeaderFontColor = \"#fff\"; //  顶部表头字体颜色\n    let leftHeaderFontSize; //  左侧表头字体大小\n    let leftHeaderFontColor; //  左侧表头字体颜色\n    let freezeRowFontSize; //  固定行字体大小\n    let freezeRowFontColor; //  固定行字体颜色\n    let defaultFontColor = \"\"; //  默认字体颜色   -   默认继承使用系统颜色\n    let synContentText; //  自定义表头内容\n    let synContentRadius = 50;\n    let freezeRowCount = 0; //  冻结行数\n    let freezeColumnCount = 0; //  冻结列数\n    let cellWidthText; //  自定义列宽， 例： 12:124 代表的是第12列的单元格宽度为124px\n    let allBorderWidth = 1; //  边框宽度\n    let synSplitType = \"top\"; //  综合表头的分割方式，左上或右上\n    let showTotalColumnFlag = false; //    显示总计列的标志\n    let showSubTotalColumnFlag = false; //    显示组内合计列的标志\n    let totalColumnPosition = 'before'; //    合计列的位置，在左before 或 在右after\n\n    let showTotalRowFlag = false; //  显示总计行标志\n    let showSubTotalRowFlag = false; //  显示组内合计行的标志\n    let totalRowPosition = 'before'; //  合计列的位置， 在上before 或 在下after\n    let theTotalText = '总计'; //    总计行左侧表头现实的内容\n    let textAlign = 'center'; //  对齐方式\n\n    let chartConfig = conf.chartConfigures;\n    if (chartConfig) {\n      //字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.font_size_label)) {\n        fontSize = parseInt(chartConfig.font_size_label);\n      }\n      //对齐方式\n      if (conf.chartConfigures.table_text_align_label) {\n        let tempTextAlign = \"center\";\n        switch (conf.chartConfigures.table_text_align_label) {\n          case \"text_align_center\":\n            tempTextAlign = \"center\";\n            break;\n          case \"text_align_left\":\n            tempTextAlign = \"left\";\n            break;\n          case \"text_align_right\":\n            tempTextAlign = \"right\";\n            break;\n        }\n        textAlign = tempTextAlign;\n      }\n      //节点颜色\n      if (chartConfig.style_node_body_color) {\n        nodeBodyColor = chartConfig.style_node_body_color;\n      }\n      //节点描边颜色\n      if (chartConfig.style_node_border_color) {\n        nodeBorderColor = chartConfig.style_node_border_color;\n      }\n      //自定义列宽度\n      if (chartConfig.cell_width_text) {\n        cellWidthText = chartConfig.cell_width_text;\n      }\n      //单元格宽度\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_cell_width)) {\n        styleCellWidth = parseInt(chartConfig.style_cell_width);\n      }\n      //单元格高度\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_cell_height)) {\n        styleCellHeight = parseInt(chartConfig.style_cell_height);\n      }\n      //单元格字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.style_cell_font_size)) {\n        cellFontSize = parseInt(chartConfig.style_cell_font_size);\n      }\n      //单元格字体颜色\n      if (chartConfig.style_cell_font_color) {\n        cellFontColor = chartConfig.style_cell_font_color;\n      }\n      //自定义综合表头\n      if (chartConfig.syn_content_text) {\n        synContentText = chartConfig.syn_content_text;\n      }\n      if (chartConfig.syn_split_type) {\n        switch (chartConfig.syn_split_type) {\n          case \"option_syn_split_top\":\n            synSplitType = \"top\";\n            break;\n          case \"option_syn_split_bottom\":\n            synSplitType = \"bottom\";\n            break;\n        }\n      }\n      //综合表头宽度\n      if (_DataFocusMethod.isPureNumber(chartConfig.syn_header_width)) {\n        styleSynWidth = parseInt(chartConfig.syn_header_width);\n      }\n      //综合表头高度\n      if (_DataFocusMethod.isPureNumber(chartConfig.syn_header_height)) {\n        styleSynHeight = parseInt(chartConfig.syn_header_height);\n      }\n      //综合表头字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.syn_font_size)) {\n        synFontSize = parseInt(chartConfig.syn_font_size);\n      }\n      //综合表头字体颜色\n      if (chartConfig.syn_font_color) {\n        synFontColor = chartConfig.syn_font_color;\n      }\n      //综合表头颜色\n      if (chartConfig.style_syn_color) {\n        styleSynHeaderColor = chartConfig.style_syn_color;\n      }\n      //综合表头边框颜色\n      if (chartConfig.style_syn_border_color) {\n        styleSynHeaderBorderColor = chartConfig.style_syn_border_color;\n      }\n      //顶部表头颜色\n      if (chartConfig.style_top_header_color) {\n        styleTopHeaderColor = chartConfig.style_top_header_color;\n      }\n      //顶部表头边框颜色\n      if (chartConfig.style_top_header_border_color) {\n        styleTopHeaderBorderColor = chartConfig.style_top_header_border_color;\n      }\n      //顶部表头字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.top_header_font_size)) {\n        topHeaderFontSize = parseInt(chartConfig.top_header_font_size);\n      }\n      //顶部表头字体颜色\n      if (chartConfig.top_header_font_color) {\n        topHeaderFontColor = chartConfig.top_header_font_color;\n      }\n      //左侧表头颜色\n      if (chartConfig.style_left_header_color) {\n        styleLeftHeaderColor = chartConfig.style_left_header_color;\n      }\n      //左侧表头边框颜色\n      if (chartConfig.style_left_header_border_color) {\n        styleLeftHeaderBorderColor = chartConfig.style_left_header_border_color;\n      }\n      //左侧表头字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.left_header_font_size)) {\n        leftHeaderFontSize = parseInt(chartConfig.left_header_font_size);\n      }\n      //左侧表头字体颜色\n      if (chartConfig.left_header_font_color) {\n        leftHeaderFontColor = chartConfig.left_header_font_color;\n      }\n      //边框宽度\n      if (_DataFocusMethod.isPureNumber(chartConfig.all_border_width)) {\n        allBorderWidth = parseInt(chartConfig.all_border_width);\n      }\n      //设置冻结行\n      if (_DataFocusMethod.isPureNumber(chartConfig.freeze_row_content)) {\n        freezeRowCount = parseInt(chartConfig.freeze_row_content);\n      }\n      //设置冻结列\n      if (_DataFocusMethod.isPureNumber(chartConfig.freeze_column_content)) {\n        freezeColumnCount = parseInt(chartConfig.freeze_column_content);\n      }\n      //冻结行颜色\n      if (chartConfig.freeze_row_color) {\n        freezeRowColor = chartConfig.freeze_row_color;\n      }\n      //冻结行列边框颜色\n      if (chartConfig.freeze_row_border_color) {\n        freezeRowBorderColor = chartConfig.freeze_row_border_color;\n      }\n      //冻结行列字体大小\n      if (_DataFocusMethod.isPureNumber(chartConfig.freeze_row_font_size)) {\n        freezeRowFontSize = parseInt(chartConfig.freeze_row_font_size);\n      }\n      //冻结行列字体颜色\n      if (chartConfig.freeze_row_font_color) {\n        freezeRowFontColor = chartConfig.freeze_row_font_color;\n      }\n\n      //显示总计行\n      if (chartConfig.show_total_row) {\n        showTotalRowFlag = true;\n        showSubTotalRowFlag = true;\n      }\n      //总计行位置\n      if (chartConfig.total_row_position) {\n        switch (chartConfig.total_row_position) {\n          case \"option_total_row_position_first\":\n            totalRowPosition = \"before\";\n            break;\n          case \"option_total_row_position_last\":\n            totalRowPosition = \"after\";\n            break;\n        }\n      }\n      if (chartConfig.total_row_label) {\n        theTotalText = chartConfig.total_row_label;\n      }\n\n      //显示总计列\n      if (chartConfig.show_total_column) {\n        showTotalColumnFlag = true;\n        showSubTotalColumnFlag = true;\n      }\n      //总计列位置\n      if (chartConfig.total_column_position) {\n        switch (chartConfig.total_column_position) {\n          case \"option_total_column_position_first\":\n            totalColumnPosition = \"before\";\n            break;\n          case \"option_total_column_position_last\":\n            totalColumnPosition = \"after\";\n            break;\n        }\n      }\n    }\n\n    // 清除画图容器\n    $(container).empty();\n    if (!options.datas.columns || !options.datas.columns.length) {\n      console.log('当前图形没有合法的画图数据');\n      return false;\n    }\n    let drawWidth, drawHeight;\n    $(container).css({\n      \"position\": \"relative\",\n      \"text-align\": textAlign\n    });\n    drawWidth = $(container).width();\n    drawHeight = $(container).height();\n    // 准备画图容器 ， 绘制标题元素等\n    let containerResult = _charts_plugin_animationTimeSequenceFrame__WEBPACK_IMPORTED_MODULE_0__[\"default\"].containerOp.executeContainer({\n      hideTimeBarFlag: true,\n      drawWidth: drawWidth,\n      drawHeight: drawHeight,\n      isLegendFlag: false,\n      hideAxisYTitleFlag: true,\n      axisYTitlePosition: 'bottom',\n      hideAxisXTitleFlag: true,\n      axisXTitlePosition: 'bottom',\n      container: container,\n      currentChart: currentChart,\n      chartAxis: chartAxis,\n      fontSize: fontSize\n    });\n    // // 由于ATSF.containerOp.executeContainer计算的画图高度和宽度不准确，所以不采用\n    // drawWidth = containerResult.drawWidth;\n    // drawHeight = containerResult.drawHeight;\n    // console.info('second drawHeight = ' ,  drawHeight);\n    let svgDiv = containerResult.svgDiv;\n    // 交叉表四周没有偏置\n    let topOffset = 0,\n      leftOffset = 0;\n\n    //整理行列值表头数据\n    let rowList = [],\n      columnList = [],\n      valueList = [];\n    let rowIdxList = [],\n      columnIdxList = [],\n      valueIdxList = [];\n    if (chartAxis.curRows) {\n      for (let i = 0; i < chartAxis.curRows.length; i++) {\n        let row = chartAxis.curRows[i];\n        rowList.push({\n          header: row,\n          idx: row.idx,\n          distincts: row.distincts,\n          isHiddenFlag: row.headerSetting && row.headerSetting.hiddenSubTotalFlag\n        });\n        rowIdxList.push(row.idx);\n      }\n    }\n    if (chartAxis.curColumns) {\n      for (let i = 0; i < chartAxis.curColumns.length; i++) {\n        let column = chartAxis.curColumns[i];\n        columnList.push({\n          header: column,\n          idx: column.idx,\n          distincts: column.distincts\n        });\n        columnIdxList.push(column.idx);\n      }\n    }\n    if (chartAxis.curValues) {\n      for (let i = 0; i < chartAxis.curValues.length; i++) {\n        let value = chartAxis.curValues[i];\n        valueList.push({\n          header: value,\n          isHiddenFlag: value.headerSetting && value.headerSetting.totalOperator1 === 'hidden'\n        });\n        valueIdxList.push(value.idx);\n      }\n    }\n\n    //构造列表头平铺数据 , 如果是没有列数据列的配置  或  数值列超过一个 ，则说明是需要数值列表头的\n    let isValueHeaderFlag = false; //  当前是否需要数值列表头\n    let isValueHeaderFlagInDeepSearch = false; //  数值列表头是否在嵌套处理流程中的标志\n    if (columnList.length === 0 || valueList.length > 1) {\n      isValueHeaderFlag = true;\n      isValueHeaderFlagInDeepSearch = true;\n    }\n\n    /**\r\n     * 生成curNodeList字符串数组，保存所有层级的表头的数据 例： [20220101|华东|销售数量 ， 20220101|华东|销售金额 ， 20220101|华南|销售数量 ， 20220101|华东|销售金额]\r\n     * 如果增加总结列进去,则生成类似数据, 总计列在前的阳样例 例： [总计:销售数量 ，总计:销售金额 ，总计:20220101|销售数量 ，总计:20220101|销售金额 ，20220101|华东|销售数量 ， 20220101|华东|销售金额 ， 20220101|华南|销售数量 ， 20220101|华东|销售金额 ]\r\n     * */\n    let curNodeList = [];\n    /***\r\n     * @param   deep                -   嵌套层级\r\n     * @param   parentContent       -   父节点内容\r\n     * @param   isValueLayerFlag    -   是否是数值列层级\r\n     * @param   finalCount          -   列配置最后一级的index, 如果isValueLayerFlag是true的情况下，则无需使用\r\n     * */\n    function deepSearchLeaves(deep, parentContent, isValueLayerFlag, finalCount) {\n      let isOverFlag = false; //  是否是到了最后一级的标志\n\n      // 如果deep属性列到了最后一级，且 没有多个数值列，则最后一级属性列就是最后一级表头\n      if (deep === finalCount && !isValueHeaderFlagInDeepSearch) {\n        isOverFlag = true;\n      }\n      // 如果到了数值列的层级，则一定是最后一级表头\n      if (isValueLayerFlag) isOverFlag = true;\n      if (isOverFlag) {\n        // 到了最后一级表头，往curNodeList中装表头单元\n        if (isValueLayerFlag) {\n          for (let i = 0; i < valueList.length; i++) {\n            let ans;\n            let theValueHeader = valueList[i] && valueList[i].header || {};\n            if (deep === 0) {\n              // 如果层级是0 ， 且是数值层级，说明parentContent为空\n              ans = parentContent + (theValueHeader.displayName || theValueHeader.col_name);\n            } else {\n              // 如果层级不是0 ，说明前面parentContent是父级元素 ， 通过 | 隔开\n              ans = parentContent + \"|\" + (theValueHeader.displayName || theValueHeader.col_name);\n            }\n            curNodeList.push(ans);\n          }\n        } else {\n          let theColumnHeader = columnList[deep] || {};\n          for (let i = 0; theColumnHeader.distincts && i < theColumnHeader.distincts.length; i++) {\n            let ans;\n            let theColumnValue = theColumnHeader.distincts[i];\n            if (deep === 0) {\n              ans = parentContent + theColumnValue;\n            } else {\n              ans = parentContent + \"|\" + theColumnValue;\n            }\n            curNodeList.push(ans);\n          }\n        }\n      } else {\n        let theColumnHeader = columnList[deep] || {};\n        for (let i = 0; theColumnHeader.distincts && i < theColumnHeader.distincts.length; i++) {\n          let ans;\n          let theColumnValue = theColumnHeader.distincts[i];\n          if (deep === 0) {\n            ans = parentContent + theColumnValue;\n          } else {\n            ans = parentContent + \"|\" + theColumnValue;\n          }\n          if (deep === finalCount) {\n            deepSearchLeaves(deep + 1, ans, true);\n          } else {\n            deepSearchLeaves(deep + 1, ans, false, finalCount);\n          }\n        }\n      }\n    }\n    if (columnList.length === 0) {\n      // 没有列属性数据配置的情况下 ，\n      deepSearchLeaves(0, \"\", true);\n    } else {\n      // 有列属性数据配置的情况下\n      deepSearchLeaves(0, \"\", false, columnList.length - 1);\n    }\n\n    //获取每一行表头所占单元格的数量[ 通过distinct.length * columnList.length粗略计算 ]\n    let columnDistinctNumberList = []; //  每行顶部表头所占单元格数量 例：上面数据生成的[4,2,1]\n    let columnDistinctMaps = []; //  获取每行顶部表头每个值所在的位置  [{20220101：0} , {华东：0 , 华南：1}]\n    let columnMultipleSum = valueList.length; //  顶部表头中不包含数值列的总列数\n    for (let i = columnList.length - 1; i >= 0; i--) {\n      columnDistinctNumberList[i] = columnMultipleSum;\n      columnMultipleSum *= columnList[i].distincts.length;\n    }\n    //如果数值也参与表头，则增加一层表头\n    if (isValueHeaderFlag) {\n      columnDistinctNumberList.push(1);\n    }\n    for (let i = 0; i < columnList.length; i++) {\n      let theColumnHeader = columnList[i] || {};\n      columnDistinctMaps[i] = {};\n      for (let j = 0; theColumnHeader.distincts && j < theColumnHeader.distincts.length; j++) {\n        let theDistinctValue = theColumnHeader.distincts[j];\n        columnDistinctMaps[i][theDistinctValue] = j;\n      }\n    }\n\n    //构造每一行表头所占单元格的数量 [ 通过distinct.length * rowList.length粗略计算 ]\n    let rowDistinctNumberList = []; //  左侧表头通过distinct计算的理论上每个单元格，占据的下一列的单元格的数量 例：[6，1] 仅供计算理论行号使用\n    let rowDistinctMaps = []; //  获取每行顶部表头每个值所在的位置  [{特惠炒货：0 , 磕磕坚果：1，果果仁仁：2} , {炒米：0 , 开心果：1，东北红松：2 ....}]\n    let rowMultipleSum = 1; //  临时变量，为rowDistinctNumberList服务\n    for (let i = rowList.length - 1; i >= 0; i--) {\n      rowDistinctNumberList[i] = rowMultipleSum;\n      rowMultipleSum *= rowList[i].distincts.length;\n    }\n    for (let i = 0; i < rowList.length; i++) {\n      let theRowHeader = rowList[i] || {};\n      rowDistinctMaps[i] = {};\n      for (let j = 0; theRowHeader.distincts && j < theRowHeader.distincts.length; j++) {\n        let theRowValue = theRowHeader.distincts[j];\n        rowDistinctMaps[i][theRowValue] = j;\n      }\n    }\n    // console.log(rowDistinctNumberList);\n    // console.log(rowDistinctMaps);\n    // console.log('左侧表头的distincts count');\n\n    /**\r\n     * 遍历数据columns, 构造行列表体的数据，通过每个column中各列单元格数据在distinct中的位置\r\n     * 通过 position * distinct.length 的方式生成所有单元格的理论行号rowPosition与理论列号columnPosition\r\n     * -    curObj.columnIndexList     该单元格使用的行数据在各列distinct中的位置\r\n     * -    curObj.rowIndexList        该单元格使用的列数据在各列distinct中的位置\r\n     * **/\n    let rowObjArray = []; //  每行数据的对象数组\n    options.datas.columns.forEach(function (row, index) {\n      let rowData = row;\n      let rowPosition = 0,\n        columnPosition = 0;\n      let curRowDistinctIndexList = []; //  该列数据的各个行属性在列distinct中的位置\n      let curColumnDistinctIndexList = []; //  该行数据的各个列属性在列distinct中的位置\n      // 计算行位置的起点rowPosition\n      for (let i = 0; i < rowDistinctMaps.length; i++) {\n        if (!rowList[i]) continue;\n        let theRowHeaderIdx = rowList[i].idx;\n        let theRowDistinctValueMap = rowDistinctMaps[i];\n        // 当前行数据中，该row的数据值\n        let theRowValue = rowData[theRowHeaderIdx];\n        rowPosition += rowDistinctMaps[i][theRowValue] * rowDistinctNumberList[i];\n        curRowDistinctIndexList.push(theRowDistinctValueMap[theRowValue]);\n      }\n      // 计算列位置的起点columnPosition\n      for (let i = 0; i < columnDistinctMaps.length; i++) {\n        if (!columnList[i]) continue;\n        let theColumnHeaderIdx = columnList[i].idx;\n        let theColumnDistinctValueMap = columnDistinctMaps[i];\n\n        // 当前行数据中，该column的数据值\n        let theColumnValue = rowData[theColumnHeaderIdx];\n        columnPosition += theColumnDistinctValueMap[theColumnValue] * columnDistinctNumberList[i];\n        curColumnDistinctIndexList.push(theColumnDistinctValueMap[theColumnValue]);\n      }\n      for (let i = 0; i < valueList.length; i++) {\n        let curObj = {};\n        let tempCp = columnPosition + i;\n        curObj.rowIndexList = curRowDistinctIndexList; //  当前行数据表头各个列的值在各个列distincts中的索引位置 ， -2代表总计行\n        if (isValueHeaderFlag && valueList.length > 1) {\n          // 如果有多个数值列，则columnIndexList需要将在value中的位置也加入\n          curObj.columnIndexList = [].concat(curColumnDistinctIndexList, [i]);\n        } else {\n          // 如果没有多个数值列，则columnIndexList只到最后一层属性位置\n          curObj.columnIndexList = curColumnDistinctIndexList;\n        }\n        curObj.rp = rowPosition; //  此处的行数是通过左侧表头交叉出来的行序号\n        curObj.cp = tempCp;\n        curObj.value = row[valueList[i].header.idx];\n        curObj.header = valueList[i].header;\n        curObj.valueIndex = i - 0;\n        curObj.rowData = row;\n        curObj.rowIndex = index;\n        rowObjArray.push(curObj);\n      }\n    });\n\n    // ----------------------将单元格数据按列号排号，清除无效列号--------------------------------------------------------------------\n    // 清除rowObjArray中没有任何单元格的列数据，将理论列号重新整理为真实列序号 ； 并增加合计列 ;\n    rowObjArray = rowObjArray.sort(function (a, b) {\n      return a.cp - b.cp;\n    });\n    let columnNumberObjMap = {};\n    let columnNumberCount = -1; //  所有列的数量\n    let totalColumnNumberCount = -1; //  总计列的数量\n    let totalBatchLength = 0; //  显示合计列的列数\n    // 如果显示总计列并且在前，则 rowNumberCount行号+1\n    let totalColumnCountMap = {};\n    for (let val = 0; val < valueList.length; val++) {\n      // if(valueList[val] && valueList[val].isHiddenFlag) continue ;\n      totalBatchLength++;\n      totalColumnCountMap['totalV' + val + '_'] = {\n        'header': {}\n      };\n    }\n    //  总计列，总计列的列数数据为0\n    if (showTotalColumnFlag && totalColumnPosition === 'before') {\n      for (let val = 0; val < valueList.length; val++) {\n        // if(valueList[val] && valueList[val].isHiddenFlag) continue ;\n        columnNumberCount++;\n        totalColumnNumberCount++;\n        totalColumnCountMap['totalV' + val + '_']['cp'] = columnNumberCount;\n      }\n    }\n    // 遍历通过行号排序的所有单元格数据， 根据真实行数据更新行号，加入总计行与合计行\n    let prevColumnNb = -1;\n    let prevColumnObj;\n    for (let i = 0; i < rowObjArray.length; i++) {\n      let curObj = rowObjArray[i];\n\n      // 如果是最后一行数据，也需要更新当前总计列\n      if (curObj.cp !== prevColumnNb) {\n        // 进入新的一列时，如果合计列在前，则需要将新一列的合计列列数加上\n        if (showSubTotalColumnFlag && curObj.columnIndexList.length > 1) {\n          if (totalColumnPosition === 'before') {\n            // 如果合计行在前, 计算统计当前行的数据\n            let prevColumnIndexStr = '';\n            for (let k = 0; k < columnList.length - 1; k++) {\n              prevColumnIndexStr += curObj.columnIndexList[k] + '_';\n              for (let val = 0; val < valueList.length; val++) {\n                if (!totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]) {\n                  columnNumberCount++;\n                  totalColumnNumberCount++;\n                  if (!totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]) totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr] = {};\n                  totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['cp'] = columnNumberCount;\n                  totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['header'] = {};\n                  totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['columnIndexList'] = curObj.columnIndexList.slice(0, k + 1);\n                }\n              }\n            }\n          } else if (prevColumnObj) {\n            // 如果当前列的某一行与前一列的某一行不一致，则说明此处需要增加合计列\n            let addTotalColumnFlag = false;\n            let prevColumnIndexStr = '';\n            let numberSubCount = 0;\n            for (let k = 0; k < columnList.length - 1; k++) {\n              let curColumnIndex = curObj.columnIndexList[k],\n                preColumnIndex = prevColumnObj.columnIndexList[k];\n              prevColumnIndexStr += prevColumnObj.columnIndexList[k] + '_';\n              // 如果当前列不一致，给列增加合计行，k越大的合计行，cp越小\n              for (let val = 0; val < valueList.length; val++) {\n                // if(valueList[val] && valueList[val].isHiddenFlag) continue ;\n                if (addTotalColumnFlag || curColumnIndex !== preColumnIndex) {\n                  addTotalColumnFlag = true;\n                  numberSubCount++;\n                  if (!totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]) {\n                    totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr] = {};\n                    totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['header'] = {};\n                    totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['columnIndexList'] = prevColumnObj.columnIndexList.slice(0, k + 1);\n                  }\n                  totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['cp'] = columnNumberCount + val + columnList.length - 1 - k;\n                }\n              }\n            }\n            columnNumberCount += numberSubCount;\n            totalColumnNumberCount += numberSubCount;\n          }\n        }\n        columnNumberCount++;\n        prevColumnNb = curObj.cp;\n        curObj.cp = columnNumberCount;\n        columnNumberObjMap[columnNumberCount + \"\"] = curObj;\n      } else {\n        curObj.cp = columnNumberCount;\n      }\n\n      // 前一个节点的信息\n      prevColumnObj = curObj;\n    }\n\n    // ----------------------将单元格数据按行号排号，清除无效行号--------------------------------------------------------------------\n    // 清除rowObjArray中没有任何单元格的行数据，将理论行序号重新整理为真实行序号 ； 并且增加合计行\n    rowObjArray = rowObjArray.sort(function (a, b) {\n      return a.rp - b.rp;\n    });\n    let positionValueMap = {};\n    let rowNumberObjMap = {};\n    let rowNumberCount = -1;\n    let totalRowBatchLength = 0; //  显示合计列的列数\n    // 如果显示总计行并且在前，则rowNumberCount行号+1\n    let totalRowCountMap = {\n      'total_': {\n        'header': {}\n      }\n    };\n    // 总计行，总计行的行数数据为0\n    if (showTotalRowFlag && totalRowPosition === 'before') {\n      rowNumberCount++;\n      totalRowCountMap['total_']['rp'] = rowNumberCount;\n      totalRowCountMap['total_']['cp'] = [];\n    }\n\n    // 统计需要显示总计的行数据\n    for (let k = 0; k < rowList.length; k++) {\n      if (rowList[k] && rowList[k].isHiddenFlag) continue;\n      totalRowBatchLength++;\n    }\n\n    // 遍历通过行号排序的所有单元格数据， 根据真实行数据更新行号，加入总计行与合计行\n    let prevRowObj;\n    let prevRowNb = -1;\n    let maxColumnNumber = columnNumberCount;\n    for (let i = 0; i < rowObjArray.length; i++) {\n      let curObj = rowObjArray[i];\n      // 如果是最后一行数据，也需要更新当前总计行\n      if (curObj.rp !== prevRowNb) {\n        // 进入新的一行时，如果合计行在前，则需要将新一行的合计行行数加上；\n        if (showSubTotalRowFlag && curObj.rowIndexList.length > 1) {\n          if (totalRowPosition === 'before') {\n            // 如果合计行在前, 计算统计当前行的数据\n            let prevRowIndex = '';\n            for (let k = 0; k < rowList.length - 1; k++) {\n              prevRowIndex += curObj.rowIndexList[k] + '_';\n              if (rowList[k] && rowList[k].isHiddenFlag) continue;\n              if (!totalRowCountMap['total_' + prevRowIndex]) {\n                rowNumberCount++;\n                if (!totalRowCountMap['total_' + prevRowIndex]) totalRowCountMap['total_' + prevRowIndex] = {};\n                totalRowCountMap['total_' + prevRowIndex]['rp'] = rowNumberCount;\n                totalRowCountMap['total_' + prevRowIndex]['header'] = {};\n                totalRowCountMap['total_' + prevRowIndex]['rowIndexList'] = curObj.rowIndexList.slice(0, k + 1);\n              }\n            }\n          } else if (prevRowObj) {\n            // 如果当前行的某一列与前一行的某一列不一致，则说明此处需要增加合计行\n            let addTotalRowFlag = false;\n            let prevRowIndex = '';\n            let numberSubCount = 0;\n            for (let k = 0, b = 0; k < rowList.length - 1; k++) {\n              let curRowIndex = curObj.rowIndexList[k],\n                preRowIndex = prevRowObj.rowIndexList[k];\n              prevRowIndex += prevRowObj.rowIndexList[k] + '_';\n              if (rowList[k] && rowList[k].isHiddenFlag) continue;\n              b++;\n              // 如果当前列不一致，给列增加合计行，k越大的合计行，rp约小\n              if (addTotalRowFlag || curRowIndex !== preRowIndex) {\n                addTotalRowFlag = true;\n                numberSubCount++;\n                if (!totalRowCountMap['total_' + prevRowIndex]) {\n                  if (!totalRowCountMap['total_' + prevRowIndex]) totalRowCountMap['total_' + prevRowIndex] = {};\n                  totalRowCountMap['total_' + prevRowIndex]['header'] = {};\n                  totalRowCountMap['total_' + prevRowIndex]['rowIndexList'] = prevRowObj.rowIndexList.slice(0, k + 1);\n                }\n                totalRowCountMap['total_' + prevRowIndex]['rp'] = rowNumberCount + totalRowBatchLength - b;\n              }\n            }\n            rowNumberCount += numberSubCount;\n          }\n        }\n        rowNumberCount++;\n        prevRowNb = curObj.rp;\n        curObj.rp = rowNumberCount;\n        rowNumberObjMap[rowNumberCount + \"\"] = curObj;\n      } else {\n        curObj.rp = rowNumberCount;\n      }\n\n      // 前一个节点的信息\n      prevRowObj = curObj;\n\n      // 统计总计行的所有列的值集合\n      if (showTotalRowFlag) {\n        if (!totalRowCountMap['total_'][curObj.cp]) totalRowCountMap['total_'][curObj.cp] = [];\n        totalRowCountMap['total_'][curObj.cp].push(curObj.value);\n        totalRowCountMap['total_']['header'][curObj.cp] = {\n          columnIndexList: curObj.columnIndexList,\n          valueIndex: curObj.valueIndex\n        };\n      }\n      // 统计合计行中所有没有引起换行的单元格的数据\n      if (showSubTotalRowFlag) {\n        let prevRowIndex = '';\n        let numberSubCount = 0;\n        for (let k = 0, b = 0; k < rowList.length - 1; k++) {\n          prevRowIndex += curObj.rowIndexList[k] + '_';\n          if (rowList[k] && rowList[k].isHiddenFlag) continue;\n          b++;\n          if (!totalRowCountMap['total_' + prevRowIndex]) {\n            if (!totalRowCountMap['total_' + prevRowIndex]) totalRowCountMap['total_' + prevRowIndex] = {};\n            totalRowCountMap['total_' + prevRowIndex]['rowIndexList'] = curObj.rowIndexList.slice(0, k + 1);\n            totalRowCountMap['total_' + prevRowIndex]['header'] = {};\n          }\n          // 如果是总计行在前，则总计行的所在行数不需要调整 ； 总计行在后，才需要被前面的元素改变\n          if (totalRowPosition !== 'before') {\n            // 如果是最后一行需要增加合计行，k越大的合计行，rp约小\n            if (i === rowObjArray.length - 1) {\n              numberSubCount++;\n              totalRowCountMap['total_' + prevRowIndex]['rp'] = rowNumberCount + totalRowBatchLength - b;\n            } else {\n              totalRowCountMap['total_' + prevRowIndex]['rp'] = rowNumberCount;\n            }\n          }\n          if (!totalRowCountMap['total_' + prevRowIndex][curObj.cp]) totalRowCountMap['total_' + prevRowIndex][curObj.cp] = [];\n          totalRowCountMap['total_' + prevRowIndex][curObj.cp].push(curObj.value);\n          totalRowCountMap['total_' + prevRowIndex]['header'][curObj.cp] = {\n            columnIndexList: curObj.columnIndexList,\n            valueIndex: curObj.valueIndex\n          };\n          // console.log('为‘' + rowList[k].distincts[curObj.rowIndexList[k]] + '’增加第' + curObj.cp + '列的总计值：' + curObj.value);\n        }\n        // 如果合计行在后面，则需要增加最后一个单元的合计行\n        if (totalRowPosition !== 'before' && i === rowObjArray.length - 1) {\n          rowNumberCount += numberSubCount;\n        }\n      }\n\n      // 在原始数据中统计总计列的所有原始列的值集合\n      if (showTotalColumnFlag) {\n        for (let val = 0; val < valueList.length; val++) {\n          // if(valueList[val] && valueList[val].isHiddenFlag) continue ;\n          if (curObj.valueIndex === val) {\n            if (!totalColumnCountMap['totalV' + val + '_'][curObj.rp]) totalColumnCountMap['totalV' + val + '_'][curObj.rp] = [];\n            totalColumnCountMap['totalV' + val + '_'][curObj.rp].push(curObj.value);\n            totalColumnCountMap['totalV' + val + '_']['header'][curObj.rp] = val;\n            if (totalColumnPosition !== 'before') {\n              // 如果是最后一行需要增加合计行，k越大的合计行，rp约小\n              let thePrevCp = totalColumnCountMap['totalV' + val + '_']['cp'] || 0;\n              let theMaxLength = Math.min(columnList.length, curObj.columnIndexList.length - 1);\n              let theCpOffset = valueList.length * theMaxLength;\n              totalColumnCountMap['totalV' + val + '_']['cp'] = Math.max(curObj.cp + theCpOffset, thePrevCp);\n              maxColumnNumber = Math.max(curObj.cp + theCpOffset, maxColumnNumber);\n\n              // console.log('totalV' + curObj.valueIndex + '_' + '\\'s cp = ' + Math.max(curObj.cp + theCpOffset , thePrevCp) + ', prev cp = ' + thePrevCp + ' , the obj cp = ' + curObj.cp);\n            }\n          }\n        }\n      }\n      // 在原始数据中统计合计列中所有原始列的值的集合\n      if (showSubTotalColumnFlag) {\n        let prevColumnIndexStr = '';\n        for (let k = 0; k < columnList.length - 1; k++) {\n          prevColumnIndexStr += curObj.columnIndexList[k] + '_';\n          for (let val = 0; val < valueList.length; val++) {\n            // if(valueList[val] && valueList[val].isHiddenFlag) continue ;\n            if (curObj.valueIndex === val) {\n              if (!totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr]) {\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr] = {};\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr]['rowIndexList'] = curObj.rowIndexList;\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr]['columnIndexList'] = curObj.columnIndexList.slice(0, k + 1);\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr]['header'] = {};\n              }\n              // 如果是总计行在前，则总计行的所在行数不需要调整 ； 总计行在后，才需要被前面的元素改变\n              if (totalColumnPosition !== 'before') {\n                // 如果是最后一行需要增加合计行，k越大的合计行，rp约小\n                let thePrevCp = totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['cp'] || 0;\n                let theMaxLength = Math.min(columnList.length, curObj.columnIndexList.length - 1);\n                let theCpOffset = valueList.length * (theMaxLength - 1 - k);\n                totalColumnCountMap['totalV' + val + '_' + prevColumnIndexStr]['cp'] = Math.max(curObj.cp + theCpOffset, thePrevCp);\n                maxColumnNumber = Math.max(curObj.cp + theCpOffset, maxColumnNumber);\n              }\n              if (!totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr][curObj.rp]) totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr][curObj.rp] = [];\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr][curObj.rp].push(curObj.value);\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_' + prevColumnIndexStr]['header'][curObj.rp] = curObj.valueIndex;\n              // console.log('为‘' + columnList[k].distincts[curObj.columnIndexList[k]] + '’增加第' + curObj.rp + '行的总计值：' + curObj.value);\n            }\n          }\n        }\n      }\n      positionValueMap[curObj.rp + \"-\" + curObj.cp] = curObj;\n    }\n    // 总计在后时，总计行的行数为最后一行\n    if (showTotalRowFlag && totalRowPosition !== 'before') {\n      rowNumberCount++;\n      totalRowCountMap['total_']['rp'] = rowNumberCount;\n    }\n    // 总计在后时，总计列的列数为最后一列\n    columnNumberCount = maxColumnNumber; //  因为将总计行的单元格加入总计列时，对应的cp是使用单元格cp+value.length计算出来的，所以columnNumberCount没有跟踪所有的值\n    // if(showTotalColumnFlag && totalColumnPosition !== 'before'){\n    //     for(let val = 0 ; val < valueList.length ; val++){\n    //         // if(valueList[val] && valueList[val].isHiddenFlag) continue ;\n    //         columnNumberCount ++ ;\n    //         totalColumnNumberCount ++ ;\n    //         totalColumnCountMap['totalV' + val + '_']['cp'] = columnNumberCount ;\n    //     }\n    // }\n\n    // 将总计与合计行的数据加入positionValueMap中\n    let totalRowCount = rowNumberCount + 1;\n    for (let totalKey in totalRowCountMap) {\n      let theTotalValue = totalRowCountMap[totalKey];\n      let theKeyArray = totalKey.split('_'),\n        rowIndexList = theKeyArray.slice(1, theKeyArray.length - 1);\n      for (let cpKey in theTotalValue) {\n        if (_DataFocusMethod.isPureNumber(cpKey)) {\n          let theCpValueList = theTotalValue[cpKey];\n          let theCpValueHeader = theTotalValue.header && theTotalValue.header[cpKey];\n          let curObj = {};\n          curObj.isTotal = true; //  是否是总计行或合计行\n          curObj.isSubTotal = !!rowIndexList.length; //  是否是合计行\n          curObj.cellNumber = rowList.length - rowIndexList.length;\n          curObj.rp = theTotalValue.rp;\n          curObj.cp = parseInt(cpKey);\n          curObj.valueIndex = theCpValueHeader && theCpValueHeader.valueIndex;\n          curObj.header = valueList[curObj.valueIndex] && valueList[curObj.valueIndex].header;\n          curObj.value = generateTotal(theCpValueList, curObj.header);\n          curObj.rowIndexList = rowIndexList && rowIndexList.map(function (v) {\n            return parseInt(v);\n          });\n          curObj.columnIndexList = theCpValueHeader && theCpValueHeader.columnIndexList;\n          if (!rowNumberObjMap[curObj.rp]) rowNumberObjMap[curObj.rp] = curObj;\n\n          // 在总计行与合计行中总计列及合计列\n          if (showTotalColumnFlag) {\n            // 所有单元格均加入总计列\n            if (!totalColumnCountMap['totalV' + curObj.valueIndex + '_']) {\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_'] = {};\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_']['cp'] = curObj.cp;\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_']['columnIndexList'] = [];\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_']['header'] = {};\n            }\n            if (!totalColumnCountMap['totalV' + curObj.valueIndex + '_'][curObj.rp]) totalColumnCountMap['totalV' + curObj.valueIndex + '_'][curObj.rp] = [];\n            totalColumnCountMap['totalV' + curObj.valueIndex + '_'][curObj.rp].push(curObj.value);\n            totalColumnCountMap['totalV' + curObj.valueIndex + '_']['header'][curObj.rp] = curObj.valueIndex;\n\n            // 将合计行单元格加入合计列\n            let preColumnIndexStr = '';\n            for (let cIndex = 0; curObj.columnIndexList && cIndex < columnList.length && cIndex < curObj.columnIndexList.length - 1; cIndex++) {\n              preColumnIndexStr += curObj.columnIndexList[cIndex] + '_';\n              if (!totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]) {\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr] = {};\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]['cp'] = curObj.cp;\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]['columnIndexList'] = curObj.columnIndexList.slice(0, cIndex + 1);\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]['header'] = {};\n              }\n              if (totalColumnPosition !== 'before') {\n                let thePrevCp = totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]['cp'] || 0;\n                let theMaxLength = Math.min(columnList.length, curObj.columnIndexList.length - 1);\n                let theCpOffset = valueList.length * (theMaxLength - 1 - cIndex);\n                // console.log('totalV' + curObj.valueIndex + '_'+preColumnIndexStr + '\\'s cp = ' + Math.max(curObj.cp + theCpOffset , thePrevCp) + ', prev cp = ' + thePrevCp + ' , the obj cp = ' + curObj.cp);\n                totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]['cp'] = Math.max(curObj.cp + theCpOffset, thePrevCp);\n              }\n              if (!totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr][curObj.rp]) totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr][curObj.rp] = [];\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr][curObj.rp].push(curObj.value);\n              totalColumnCountMap['totalV' + curObj.valueIndex + '_' + preColumnIndexStr]['header'][curObj.rp] = curObj.valueIndex;\n            }\n          }\n          positionValueMap[curObj.rp + \"-\" + curObj.cp] = curObj;\n        }\n      }\n    }\n    // console.log('左侧表头真实的总行数=' + totalRowCount);\n\n    // 将总计与合计列的数据加入positionValueMap中\n    let totalColumnCount = columnNumberCount + 1; //  所有列的数量\n    let subTotalColumnCount = totalColumnNumberCount + 1; //  所有合计列及总计列的数量\n    for (let totalColumnKey in totalColumnCountMap) {\n      let theTotalValue = totalColumnCountMap[totalColumnKey];\n      let theKeyArray = totalColumnKey.split('_'),\n        columnIndexList = theKeyArray.slice(1, theKeyArray.length);\n      for (let rpKey in theTotalValue) {\n        if (_DataFocusMethod.isPureNumber(rpKey)) {\n          let theRpValueList = theTotalValue[rpKey];\n          let curObj = {};\n          curObj.isTotal = true; //  是否是总计行或合计行\n          curObj.isSubTotal = !!columnIndexList.length; //  是否是合计行\n          curObj.cellNumber = columnDistinctNumberList.length - columnIndexList.length + 1;\n          curObj.cp = theTotalValue.cp;\n          curObj.rp = parseInt(rpKey);\n          curObj.valueIndex = theTotalValue.header && theTotalValue.header[rpKey];\n          curObj.header = valueList[curObj.valueIndex] && valueList[curObj.valueIndex].header;\n          curObj.value = generateTotal(theRpValueList, curObj.header);\n          curObj.columnIndexList = theTotalValue.columnIndexList;\n          curObj.rowIndexList = theTotalValue.rowIndexList;\n          if (!columnNumberObjMap[curObj.cp]) columnNumberObjMap[curObj.cp] = curObj;\n          positionValueMap[curObj.rp + \"-\" + curObj.cp] = curObj;\n          theTotalValue.isUsedFlag = true;\n        }\n      }\n    }\n\n    // console.log('顶部表头真实的总列数=' + totalColumnCount);\n    // console.log('总计列与合计列的列数=' + subTotalColumnCount);\n\n    //构建默认左上综合表头标题 , 如果用户配置了，则使用用户配置的数据 ； 否则默认依据行列值配置来构建\n    let defaultHeaderTitles = \"\";\n    if (!synContentText) {\n      for (let i = 0; i < columnList.length; i++) {\n        let theColumnHeader = columnList[i] && columnList[i].header || {};\n        if (defaultHeaderTitles === \"\") {\n          defaultHeaderTitles += theColumnHeader.displayName || theColumnHeader.col_name;\n        } else {\n          defaultHeaderTitles += \"|\" + (theColumnHeader.displayName || theColumnHeader.col_name);\n        }\n      }\n      for (let i = valueList.length - 1; i >= 0; i--) {\n        let theValueHeader = valueList[i] && valueList[i].header || {};\n        if (defaultHeaderTitles === \"\") {\n          defaultHeaderTitles += theValueHeader.displayName || theValueHeader.col_name;\n        } else {\n          defaultHeaderTitles += \"|\" + (theValueHeader.displayName || valueList[i].header.col_name);\n        }\n      }\n      for (let i = rowList.length - 1; i >= 0; i--) {\n        let theRowHeader = rowList[i] && rowList[i].header || {};\n        if (defaultHeaderTitles === \"\") {\n          defaultHeaderTitles += theRowHeader.displayName || theRowHeader.col_name;\n        } else {\n          defaultHeaderTitles += \"|\" + (theRowHeader.displayName || theRowHeader.col_name);\n        }\n      }\n    } else {\n      defaultHeaderTitles = synContentText;\n    }\n    let minWidth = 60;\n    let minHeight = 20;\n    let cellWidth = styleCellWidth || 80; //  单元格宽度\n    let cellHeight = styleCellHeight || 30; //  单元格高度\n    let leftHeaderWidth = styleSynWidth || 80; //  左侧表头宽度使用综合表头宽度\n    let leftHeaderHeight = styleCellHeight || 30; //  左侧表头高度使用单元格高度\n    let topHeaderWidth = styleCellWidth || 80; //  顶部表头宽度使用单元格宽度\n    let topHeaderHeight = styleSynHeight || 30; //  顶部表头高度使用综合表头高度\n    //初始化绘制控制\n    let topLayerCount = columnList.length + (isValueHeaderFlag ? 1 : 0); //  顶部表头的行数\n    let leftLayerCount = rowList.length; //  左侧表头的列数\n    let matrixRowCount = totalRowCount; //  数据表总行数\n    let matrixColumnCount = totalColumnCount; //  数据表总列数\n\n    // 计算拖拽后生成列宽 及 各个组的总列宽 { 0: 110 , 1: 220 , groupTotalWidth: 330 }\n    let cellWidthMap = {};\n    let computeCellWidthMap = function () {\n      cellWidthMap = {}; //  记录各个数值列配置的宽度\n      let definedColumnNum = 0,\n        //  被配置列宽的数量\n        definedTotalColumnNum = 0,\n        //  被配置的合计列列宽的数量\n        undefinedColumnNum = 0,\n        //  没有被配置列宽度的数量\n        undefinedTotalColumnNum = 0,\n        //  没有被配置的合计列列宽度的数量\n        definedTotalWidth = 0,\n        //  被用户配置的列宽和\n        definedSubTotalWidth = 0,\n        //  被用户配置的合计列的宽度和\n        subGroupTotalWidth = 0,\n        //  合计列中显示的数值列的宽度和 【因为合计列可以配置隐藏】\n        groupTotalWidth = 0; //  每组所有数值列的宽度和\n      if (cellWidthText) {\n        let tempStr = cellWidthText.split(\"|\");\n        for (let i = 0; i < tempStr.length; i++) {\n          let strList = tempStr[i].split(\":\");\n          if (!_DataFocusMethod.isPureNumber(strList[0]) || !_DataFocusMethod.isPureNumber(strList[1])) continue;\n          let theIndexNum = parseInt(strList[0]),\n            theCellWidth = parseInt(strList[1]);\n          if (theIndexNum >= 0 && theIndexNum < valueIdxList.length && theCellWidth > 0) {\n            cellWidthMap[theIndexNum] = theCellWidth;\n            definedTotalWidth += theCellWidth;\n            definedSubTotalWidth += theCellWidth;\n            definedColumnNum++;\n            definedTotalColumnNum++;\n          }\n        }\n      }\n      for (let i = 0; i < valueIdxList.length; i++) {\n        if (!cellWidthMap[i]) {\n          cellWidthMap[i] = cellWidth;\n          undefinedColumnNum++;\n          if (valueList[i] && !valueList[i].isHiddenFlag) undefinedTotalColumnNum++;\n        }\n\n        // 所有数值列的宽度和\n        groupTotalWidth += cellWidthMap[i];\n        // 合计列的宽度和\n        if (valueList[i] && !valueList[i].isHiddenFlag) subGroupTotalWidth += cellWidthMap[i];\n      }\n      cellWidthMap.groupTotalWidth = groupTotalWidth;\n      cellWidthMap.subGroupTotalWidth = subGroupTotalWidth;\n      cellWidthMap.definedTotalWidth = definedTotalWidth;\n      cellWidthMap.definedSubTotalWidth = definedSubTotalWidth;\n      cellWidthMap.definedColumnNum = definedColumnNum;\n      cellWidthMap.undefinedColumnNum = undefinedColumnNum;\n      cellWidthMap.definedTotalColumnNum = definedTotalColumnNum;\n      cellWidthMap.undefinedTotalColumnNum = undefinedTotalColumnNum;\n    };\n    computeCellWidthMap();\n\n    /**\r\n     * 计算拖拽显示区域的尺寸\r\n     * 向drawControl中输出以下参数：\r\n     *  -    displayTop             //  顶部表头+固定行高的高度\r\n     *  -    displayLeft            //  左侧表头+固定列宽的宽度\r\n     *  -    displayWidth           //  可滚动的区域宽度[ 即去除左侧表头宽度和固定列宽后剩下的宽度 ]\r\n     *  -    displayHeight          //  可滚动的区域高度[ 即去除顶部表头高度和固定行高后剩下的高度 ]\r\n     *  -    synBoxTop              //  综合表头的高度[即顶部表头的高度]\r\n     *  -    synBoxLeft             //  综合表头的宽度[即左侧表头的宽度]\r\n     *  -    measureWidth           //  去掉固定单元格宽度的真实单元格需要的显示宽度\r\n     *  -    measureHeight          //  去掉固定单元格高度的真实单元格需要的显示高度\r\n     *  -    realDrawWidth          //  去除左侧表头宽度的单元格宽度区域\r\n     *  -    realDrawHeight         //  去除顶部表头高度的单元格高度区域\r\n     *  -    freezeColumnWidth      //  固定列宽度\r\n     *  -    freezeColumnHeight     //  固定行高度\r\n     * */\n    let drawControl = {};\n    drawControl.left = 0;\n    drawControl.top = 0;\n    drawControl.extraLoadCount = 1; //  额外需要多加载的单元格数量，以作容错\n    let computeDragControl = function () {\n      drawControl.displayTop = topLayerCount * topHeaderHeight;\n      drawControl.synBoxTop = topLayerCount * topHeaderHeight;\n      if (freezeRowCount > 0) {\n        drawControl.displayTop += freezeRowCount * cellHeight;\n      }\n      drawControl.displayLeft = leftLayerCount * leftHeaderWidth;\n\n      // 计算冻结列的宽度  123列总和 *  groupTotalWidth + 1列宽 + 2列宽 [ 因为各个数值列可以配置单独配置宽度 ]\n      let freezeColumnWidth = 0;\n      if (freezeColumnCount > 0) {\n        freezeColumnWidth += Math.floor(freezeColumnCount / valueIdxList.length) * cellWidthMap.groupTotalWidth;\n        for (let i = 0; i < freezeColumnCount % valueIdxList.length; i++) {\n          if (cellWidthMap[i]) freezeColumnWidth += cellWidthMap[i];\n        }\n      }\n      drawControl.freezeColumnWidth = freezeColumnWidth;\n      drawControl.freezeColumnHeight = freezeRowCount * cellHeight;\n      drawControl.displayLeft += freezeColumnWidth;\n      drawControl.synBoxLeft = leftLayerCount * leftHeaderWidth;\n      drawControl.measureHeight = (matrixRowCount - freezeRowCount) * cellHeight;\n      drawControl.measureWidth = Math.floor(matrixColumnCount / valueIdxList.length) * cellWidthMap.groupTotalWidth - freezeColumnWidth;\n      drawControl.displayHeight = drawHeight - drawControl.displayTop;\n      drawControl.displayWidth = drawWidth - drawControl.displayLeft;\n      drawControl.realDrawWidth = drawWidth - drawControl.synBoxLeft - leftOffset || 1;\n      drawControl.realDrawHeight = drawHeight - drawControl.synBoxTop - topOffset || 1;\n    };\n    computeDragControl();\n\n    // 根据顶部表头的真实列数totalColumnCount , 自适应各个列的宽度\n    // 当默认单元格列宽占不满显示区域时，将没有定义宽度的单元格宽度调整为自适应的宽度值\n    let adjustCellWidth = function () {\n      let unitColumnWidth = cellWidthMap.groupTotalWidth; //  数值列组单元格宽度总和\n      let definitelyWidth = cellWidthMap.definedTotalWidth; //  数值列中被用户明确定义的列宽总和\n      let restCount = cellWidthMap.undefinedColumnNum; //  未被定义的列宽的数量\n\n      let batchCount = Math.floor(totalColumnCount / valueList.length);\n      if (totalColumnCount && unitColumnWidth * batchCount < drawControl.realDrawWidth) {\n        let perBatchWidth = Math.floor(drawControl.realDrawWidth / batchCount);\n        cellWidth = topHeaderWidth = perBatchWidth - definitelyWidth;\n        if (restCount) {\n          cellWidth = cellWidth / restCount;\n          topHeaderWidth = cellWidth;\n        }\n        computeCellWidthMap();\n        // 计算拖拽区域尺寸依赖单元格的宽度，所以必须在计算单元格宽度以后操作\n        computeDragControl();\n      }\n\n      // let unitColumnWidth = cellWidthMap.groupTotalWidth;      //  数值列组单元格宽度总和\n      // let totalUnitColumnWidth = cellWidthMap.subGroupTotalWidth; //  合计列组单元格宽度总和\n      // let withoutTotalColumnCount = totalColumnCount - subTotalColumnCount ;\n      // let batchCount = Math.floor(withoutTotalColumnCount / valueList.length);\n      // let totalBatchCount = Math.floor(subTotalColumnCount / totalBatchLength);\n      // let scrollColumnWidth = unitColumnWidth * batchCount + totalUnitColumnWidth * totalBatchCount ;  //  所有单元格的滚动宽度\n      // if (totalColumnCount && scrollColumnWidth < drawControl.realDrawWidth) {\n      //     let undefinedColumnCount = batchCount * cellWidthMap.undefinedColumnNum + totalBatchCount * cellWidthMap.undefinedTotalColumnNum ;\n      //     if(undefinedColumnCount){\n      //         //  说明有未分配宽度的单元格\n      //         cellWidth = (drawControl.realDrawWidth - batchCount*cellWidthMap.definedTotalWidth - totalBatchCount*cellWidthMap.definedSubTotalWidth)/undefinedColumnCount ;\n      //     }else{\n      //         // // 说明所有单元格均被分配了宽度，但是没有占满整个宽度，则将所有单元格宽度等比例拉大\n      //         // let theScale = scrollColumnWidth / drawControl.realDrawWidth ;\n      //     }\n      //\n      //     topHeaderWidth = cellWidth ;\n      //     computeCellWidthMap();\n      //     // 计算拖拽区域尺寸依赖单元格的宽度，所以必须在计算单元格宽度以后操作\n      //     computeDragControl();\n      // }\n    };\n    adjustCellWidth();\n\n    // 交叉表中的单元格元素从SVG元素调整为DIV元素，用于显示图片，颜色规则形状等元素\n    let svgParent = d3.select(svgDiv.find(\"svg\")[0]);\n\n    /**\r\n     * 在svg中填充对应区域的单元格内容\r\n     * @param   left    -   单元格的左侧起点\r\n     * @param   top     -   单元格的顶部起点\r\n     *\r\n     * 使用外部定义一下变量\r\n     *      -   drawControl         交叉表布局宽度\r\n     *      -   cellWidthMap        单元格宽度\r\n     *      -   freezeRowCount      冻结行数\r\n     *      -   freezeColumnCount   冻结列数\r\n     *      -   rowNumberObjMap     画左侧表头时使用的数据\r\n     *      -   matrixColumnCount   总行数\r\n     *\r\n     *      -   valueList           配置的数值\r\n     *      -   rowList             配置的行数据\r\n     *      -   columnList          配置的列数据\r\n     *\r\n     * */\n    function drawDetail(left, top) {\n      svgDiv.find(\">div\").remove();\n      //计算纵向需要显示的区间\n      let topStart = Math.floor(top / cellHeight) - drawControl.extraLoadCount;\n      let topEnd = Math.ceil((top + drawControl.displayHeight) / cellHeight) + drawControl.extraLoadCount;\n      topStart = Math.max(0, topStart);\n      topEnd = Math.min(totalRowCount - freezeRowCount, topEnd);\n\n      //计算横向需要显示的区间\n      let leftStart;\n      let leftEnd;\n      //若自定义了列宽，使用特别的定位方法 todo - 计算左侧序号\n      let minUnitColumnWidth = cellWidthMap.groupTotalWidth;\n      leftStart = Math.floor(left / minUnitColumnWidth) * valueList.length - drawControl.extraLoadCount;\n      leftEnd = Math.ceil((left + drawControl.displayWidth) / minUnitColumnWidth) * valueList.length + drawControl.extraLoadCount;\n      leftStart = Math.max(0, leftStart);\n      leftEnd = Math.min(matrixColumnCount - freezeColumnCount, leftEnd);\n\n      //绘制表格主体，均受影响 [ 排除冻结行列的数据单元格 ]\n      let divContainer = document.createElement('div');\n      divContainer.className = 'rect-cell-container';\n      let theDivStyle = 'position:absolute;display:block;';\n      theDivStyle += 'top:' + drawControl.displayTop + 'px;';\n      theDivStyle += 'left:' + drawControl.displayLeft + 'px;';\n      theDivStyle += 'width:' + drawControl.displayWidth + 'px;';\n      theDivStyle += 'height:' + drawControl.displayHeight + 'px;';\n      theDivStyle += 'overflow:hidden;';\n      divContainer.style = theDivStyle;\n      svgDiv.append(divContainer);\n      for (let i = topStart + freezeRowCount; i < topEnd + freezeRowCount; i++) {\n        for (let j = leftStart + freezeColumnCount; j < leftEnd + freezeColumnCount; j++) {\n          let curObj = positionValueMap[i + \"-\" + j] || {};\n          let cx,\n            cy,\n            cw = cellWidth,\n            ch = cellHeight;\n          if (cellWidthText) {\n            let curWidth = cellWidthMap[j % valueList.length];\n\n            // 计算当前单元格在所在数值组中的左侧单元格的宽度和\n            let theOffsetValueWidth = 0;\n            if (isValueHeaderFlag) {\n              let locateNumber = j % valueList.length; //  当前单元格在数值组中的位置\n              for (let k = 0; k < locateNumber; k++) {\n                theOffsetValueWidth += cellWidthMap[k];\n              }\n            }\n            cx = leftOffset + drawControl.displayLeft + Math.floor(j / valueList.length) * minUnitColumnWidth + theOffsetValueWidth - drawControl.freezeColumnWidth;\n            cy = topOffset + drawControl.displayTop + (i - freezeRowCount) * cellHeight - top;\n            cw = curWidth;\n          } else {\n            cx = leftOffset + drawControl.displayLeft + (j - freezeColumnCount) * cellWidth;\n            cy = topOffset + drawControl.displayTop + (i - freezeRowCount) * cellHeight - top;\n          }\n          let curRect = generateDivCellDom({\n            className: \"rect-cell-item\",\n            cx: cx - drawControl.displayLeft - leftOffset,\n            cy: cy - drawControl.displayTop - topOffset,\n            cw: cw,\n            ch: ch,\n            backgroundColor: nodeBodyColor,\n            borderWidth: allBorderWidth,\n            borderColor: nodeBorderColor,\n            color: cellFontColor ? cellFontColor : defaultFontColor,\n            marginLeft: -left,\n            fontSize: cellFontSize,\n            originalValue: curObj.value,\n            header: curObj.header\n          });\n          divContainer.appendChild(curRect);\n        }\n      }\n\n      //左侧表头 及 左侧行号容器 [ 不包含固定行 ]\n      let leftHeaderContainer = document.createElement('div');\n      leftHeaderContainer.className = 'rect-left-header-container';\n      let theLeftHeaderStyle = 'position:absolute;display:block;';\n      theLeftHeaderStyle += 'top:' + (drawControl.synBoxTop + topOffset + drawControl.freezeColumnHeight) + 'px;';\n      theLeftHeaderStyle += 'left:' + leftOffset + 'px;';\n      theLeftHeaderStyle += 'width:' + drawControl.synBoxLeft + 'px;';\n      theLeftHeaderStyle += 'height:' + drawControl.displayHeight + 'px;';\n      theLeftHeaderStyle += 'overflow:hidden;';\n      leftHeaderContainer.style = theLeftHeaderStyle;\n      svgDiv.append(leftHeaderContainer);\n      //绘制左侧表头，仅受left影响\n      /**\r\n       * 因为画左侧表头的逻辑是，行数据多列N > 1的情况下，针对前N-1个列的单元格，相同的值需要合并\r\n       *\r\n       * 遍历每行的数据，每列遇到与上一行单元格内容不一致的情况下，画上一行该列的单元格的内容\r\n       * 所以最后一行数据的前N-1个列的单元格 由于没有下一行的比对，导致没有画出来，需要补充\r\n       */\n      let prevRowNumberList = [];\n      let prevRowIndexList = [];\n      let prevRowNumberCountList = [];\n      let prevDrawTextList = [];\n      let horizonDragLines = [];\n      let prevRowObj;\n      for (let i = 0; i < rowList.length - 1; i++) {\n        prevRowNumberList[i] = -1;\n        prevRowNumberCountList[i] = 1;\n        prevRowIndexList[i] = -1;\n      }\n      // 画没有被固定行列的左侧表头N-1列的单元格\n      for (let i = topStart + freezeRowCount; i < topEnd + freezeRowCount; i++) {\n        let curObj = rowNumberObjMap[i + \"\"];\n        if (!curObj || curObj.isTotal && !curObj.isSubTotal) continue; //  总计行不参与\n        let cx = leftOffset + (rowList.length - 1) * leftHeaderWidth;\n        let cy = topOffset + drawControl.displayTop + (i - freezeRowCount) * leftHeaderHeight - top;\n        let cw = leftHeaderWidth;\n        let ch = leftHeaderHeight;\n        let originalCy = cy;\n\n        // 画左侧表头非最后一列的数据\n        let clearSubRowFlag = false; //  是否需要清空绘制完所有列\n        // console.log('当前列到的位置=' + (curObj.rowIndexList && curObj.rowIndexList.join(',')));\n        for (let j = 0; j < rowList.length - 1; j++) {\n          let originalValue = '',\n            theHeader,\n            needCellFlag = false;\n          // 非最后一列的左侧表头\n          if (curObj.rowIndexList && curObj.rowIndexList.length) {\n            let theRowIndex = curObj.rowIndexList[j];\n            let thePrevIndex = prevRowObj && prevRowObj.rowIndexList && prevRowObj.rowIndexList[j];\n            if (prevRowNumberList[j] === -1) {\n              prevRowNumberList[j] = theRowIndex;\n              prevRowNumberCountList[j] = 1;\n              prevDrawTextList[j] = rowList[j].distincts[theRowIndex];\n              prevRowIndexList[j] = i;\n            } else if (clearSubRowFlag || theRowIndex !== thePrevIndex) {\n              clearSubRowFlag = true;\n              originalValue = prevDrawTextList[j];\n              theHeader = rowList[j];\n              needCellFlag = true;\n              cx = leftOffset + j * leftHeaderWidth;\n              ch = leftHeaderHeight * prevRowNumberCountList[j];\n              cy = originalCy - ch;\n              // console.log('绘制左侧单元格‘'+originalValue+'’ ，在第'+ i +'行'+'绘制了第'+ prevRowObj.rp +'行第'+ j +'列的数据');\n              // console.log(j);\n              // 如果当前列是undefined，说明遇到了合计行，需要将对应的后面的单元格全部画出来\n              if (theRowIndex !== undefined) {\n                prevRowNumberList[j] = theRowIndex;\n                prevDrawTextList[j] = rowList[j].distincts[theRowIndex];\n              }\n              prevRowNumberCountList[j] = 1;\n              prevRowIndexList[j] = i;\n\n              // 绘制完当前行的所有列再替换prevRowObj\n              if (j === rowList.length - 2) prevRowObj = curObj;\n            } else if (theRowIndex === prevRowNumberList[j]) {\n              prevRowNumberCountList[j]++;\n              prevRowIndexList[j] = i;\n            }\n          }\n\n          // 如果需要显示单元格的情况下\n          if (needCellFlag && originalValue !== undefined) {\n            let curRect = generateDivCellDom({\n              className: \"rect-left-header-cell-item\",\n              cx: cx - leftOffset,\n              cy: cy - drawControl.displayTop,\n              cw: cw,\n              ch: ch,\n              backgroundColor: styleLeftHeaderColor,\n              borderWidth: allBorderWidth,\n              borderColor: styleLeftHeaderBorderColor,\n              color: leftHeaderFontColor || defaultFontColor,\n              fontSize: leftHeaderFontSize || cellFontSize,\n              originalValue: originalValue,\n              header: theHeader\n            });\n            leftHeaderContainer.appendChild(curRect);\n          }\n        }\n\n        // console.log('各列到的位置=' + prevRowNumberList.join(','));\n        // console.log('各列占据的高度=' + prevRowNumberCountList.join(','));\n        // console.log('各列的值=' + prevDrawTextList.join(','));\n        prevRowObj = curObj;\n      }\n      // 绘制左侧表头最后一行的前N-1列左侧单元格\n      for (let j = 0; j < rowList.length - 1; j++) {\n        // 如果显示总计行，总计行在最后，则计算最后一个单元格的cy时，需要将总计行的高度去除\n        let theRowIndex = prevRowIndexList[j];\n        if (theRowIndex < 0) continue;\n        let cx = leftOffset + (rowList.length - 1) * leftHeaderWidth;\n        let cy = topOffset + drawControl.displayTop + (theRowIndex + 1) * leftHeaderHeight - drawControl.freezeColumnHeight - top;\n        let cw = leftHeaderWidth;\n        let ch = leftHeaderHeight;\n        let drawText = prevDrawTextList[j];\n        cx = leftOffset + j * leftHeaderWidth;\n        ch = leftHeaderHeight * prevRowNumberCountList[j];\n        cy -= ch;\n        let curRect = generateDivCellDom({\n          className: \"rect-left-header-cell-item 11 \",\n          cx: cx - leftOffset,\n          cy: cy - drawControl.displayTop,\n          cw: cw,\n          ch: ch,\n          backgroundColor: styleLeftHeaderColor,\n          borderWidth: allBorderWidth,\n          borderColor: styleLeftHeaderBorderColor,\n          color: leftHeaderFontColor || defaultFontColor,\n          fontSize: leftHeaderFontSize || cellFontSize,\n          originalValue: drawText,\n          header: rowList[j]\n        });\n        leftHeaderContainer.appendChild(curRect);\n      }\n      // 绘制左侧表头最后一列的数据及每个总计行，带横向拖拽线\n      for (let i = topStart + freezeRowCount; i < topEnd + freezeRowCount; i++) {\n        let curObj = rowNumberObjMap[i + \"\"];\n        if (!curObj) continue;\n        let index = i;\n        let cx = leftOffset + (rowList.length - 1) * leftHeaderWidth;\n        let cy = topOffset + drawControl.displayTop + index * leftHeaderHeight - drawControl.freezeColumnHeight - top;\n        let cw = leftHeaderWidth;\n        let ch = leftHeaderHeight;\n        let drawText = '',\n          originalValue = '',\n          theHeader = rowList[rowList.length - 1];\n        // 所有的总计行都在最后画\n        if (curObj.isTotal) {\n          drawText = theTotalText;\n          cx = leftOffset + Math.max(rowList.length - curObj.cellNumber, 0) * leftHeaderWidth;\n          cw = leftHeaderWidth * curObj.cellNumber;\n        } else if (curObj.rowIndexList) {\n          originalValue = theHeader.distincts[curObj.rowIndexList[rowList.length - 1]];\n        }\n        let curRect = generateDivCellDom({\n          className: \"rect-left-header-cell-item\",\n          cx: cx - leftOffset,\n          cy: cy - drawControl.displayTop,\n          cw: cw,\n          ch: ch,\n          backgroundColor: styleLeftHeaderColor,\n          borderWidth: allBorderWidth,\n          borderColor: styleLeftHeaderBorderColor,\n          color: leftHeaderFontColor || defaultFontColor,\n          fontSize: leftHeaderFontSize || cellFontSize,\n          drawText: drawText,\n          originalValue: originalValue,\n          header: theHeader\n        });\n        leftHeaderContainer.appendChild(curRect);\n        let theDragLine = generateDragLineDom({\n          className: 'rect-left-header-drag-line',\n          cw: cw + drawControl.realDrawWidth,\n          ch: 6,\n          cx: cx - leftOffset,\n          cy: cy + ch - topOffset - 4 - drawControl.displayTop,\n          cursor: 'ns-resize'\n        });\n        leftHeaderContainer.appendChild(theDragLine);\n        horizonDragLines.push(theDragLine);\n      }\n\n      //顶部表头容器 [ 不包含固定列 ]\n      let topHeaderContainer = document.createElement('div');\n      topHeaderContainer.className = 'rect-top-header-container';\n      let theTopHeaderStyle = 'position:absolute;display:block;';\n      theTopHeaderStyle += 'top:' + topOffset + 'px;';\n      theTopHeaderStyle += 'left:' + (drawControl.displayLeft + leftOffset) + 'px;';\n      theTopHeaderStyle += 'width:' + drawControl.displayWidth + 'px;';\n      theTopHeaderStyle += 'height:' + drawControl.synBoxTop + 'px;';\n      theTopHeaderStyle += 'overflow:hidden;';\n      topHeaderContainer.style = theTopHeaderStyle;\n      svgDiv.append(topHeaderContainer);\n      //绘制顶部表头,仅受Top影响\n      /**\r\n       * 因为画顶部表头的逻辑是，列数据多列N > 1的情况下，针对前N-1个行的单元格，相同的值需要合并\r\n       *\r\n       * 遍历每列的数据，每列遇到与上一列单元格内容不一致的情况下，画上一列该行的单元格的内容\r\n       * 所以最后一列数据的前N-1个行的单元格 由于没有下一列的比对，导致没有画出来，需要补充\r\n       */\n      let prevColumnNumberList = []; //  各行表头画到第N个列中值在distinct中的顺粗\n      let prevColumnIndexList = [];\n      let prevColumnWidthCountList = []; //  各行累计的宽度\n      let prevColumnNumberCountList = []; //  各行累积的单元格数量\n      prevDrawTextList = []; //  隔行待画的值\n      prevColumnObj = null;\n      for (let i = 0; i < columnDistinctNumberList.length - 1; i++) {\n        prevColumnNumberList[i] = -1;\n        prevColumnWidthCountList[i] = 0;\n        prevColumnNumberCountList[i] = 1;\n        prevColumnIndexList[i] = -1;\n      }\n      // 画没有被固定列的顶部表头第N-1行前的单元格\n      for (let i = leftStart + freezeColumnCount; i < leftEnd + freezeColumnCount; i++) {\n        let curColumnObj = columnNumberObjMap[i + \"\"];\n        if (!curColumnObj) continue;\n        let cx, cy, cw, ch;\n        cw = cellWidthMap[curColumnObj.valueIndex];\n        ch = topHeaderHeight;\n        cx = leftOffset + drawControl.displayLeft + Math.floor(i / valueList.length) * cellWidthMap.groupTotalWidth - drawControl.freezeColumnWidth;\n        for (let k = 0; k < i % valueList.length; k++) {\n          cx += cellWidthMap[k];\n        }\n        let originalCx = cx;\n        let originalCw = cw;\n\n        // 画顶部表头非最后一行的数据\n        let clearSubColumnFlag = false; //  是否需要清空绘制完所有行\n        for (let j = 0; j < columnDistinctNumberList.length - 1; j++) {\n          let originalValue = '',\n            theHeader,\n            needCellFlag = false;\n          // 非最后一行的顶部侧表头\n          if (curColumnObj.columnIndexList && curColumnObj.columnIndexList.length) {\n            let theColumnIndex = curColumnObj.columnIndexList[j];\n            let thePrevIndex = prevColumnObj && prevColumnObj.columnIndexList && prevColumnObj.columnIndexList[j];\n            if (prevColumnNumberList[j] === -1) {\n              prevColumnNumberList[j] = theColumnIndex;\n              prevColumnNumberCountList[j] = 1;\n              prevColumnWidthCountList[j] = originalCw;\n              prevDrawTextList[j] = columnList[j].distincts[theColumnIndex];\n              prevColumnIndexList[j] = i;\n            } else if (clearSubColumnFlag || theColumnIndex !== thePrevIndex) {\n              clearSubColumnFlag = true;\n              originalValue = prevDrawTextList[j];\n              theHeader = columnList[j];\n              needCellFlag = true;\n              cy = topOffset + j * topHeaderHeight;\n              cw = prevColumnWidthCountList[j];\n              cx = originalCx - cw;\n\n              // console.log(j + '-' + i);\n              // console.log('绘制顶部侧单元格‘'+originalValue+'’ ，在第'+ i +'列'+'绘制了第'+ prevRowObj.cp +'列第'+ j +'行的数据');\n              // 如果当前列是undefined，说明遇到了合计列，需要将对应的后面的单元格全部画出来\n              if (theColumnIndex !== undefined) {\n                prevColumnNumberList[j] = theColumnIndex;\n                prevDrawTextList[j] = columnList[j].distincts[theColumnIndex];\n              }\n              prevColumnWidthCountList[j] = originalCw;\n              prevColumnNumberCountList[j] = 1;\n              prevColumnIndexList[j] = i;\n            } else if (theColumnIndex === prevColumnNumberList[j]) {\n              prevColumnNumberCountList[j]++;\n              prevColumnWidthCountList[j] += originalCw;\n              prevColumnIndexList[j] = i;\n            }\n          }\n          if (needCellFlag && originalValue !== undefined) {\n            let curRect = generateDivCellDom({\n              className: \"rect-top-header-cell-item\",\n              cx: cx - leftOffset - drawControl.displayLeft,\n              cy: cy - topOffset,\n              cw: cw,\n              ch: ch,\n              backgroundColor: styleTopHeaderColor,\n              borderWidth: allBorderWidth,\n              borderColor: styleTopHeaderBorderColor,\n              color: topHeaderFontColor,\n              fontSize: topHeaderFontSize || cellFontSize,\n              marginLeft: -left,\n              originalValue: originalValue,\n              header: theHeader\n            });\n            topHeaderContainer.appendChild(curRect);\n          }\n        }\n        prevColumnObj = curColumnObj;\n      }\n      // 绘制顶部表头最后一列的前N-1行顶部单元格 例：如果有3行表头，画前两行表头的最后一列\n      for (let j = 0; j < columnDistinctNumberList.length - 1; j++) {\n        // 需要画单元格\n        let i = prevColumnIndexList[j];\n        if (i < 0) continue;\n        let cx, cy, cw, ch;\n        // 计算单元格cx的方法一 : 通过计算下一个单元格的cx , 然后减去前一个单元格的宽度，即使前一个单元格的cx\n        let prevCx = Math.floor((i + 1) / valueList.length) * cellWidthMap.groupTotalWidth - drawControl.freezeColumnWidth;\n        for (let k = 0; k < (i + 1) % valueList.length; k++) {\n          prevCx += cellWidthMap[k];\n        }\n\n        // 计算方法二： 需要计算当前单元格的前一个不同的单元格cx ，prevColumnNumberCountList[j] 保存的是使用当前单元格内容的单元格数量\n        let thePrevIndex = i + 1 - prevColumnNumberCountList[j];\n        cx = Math.floor(thePrevIndex / valueList.length) * cellWidthMap.groupTotalWidth - drawControl.freezeColumnWidth;\n        for (let k = 0; k < thePrevIndex % valueList.length; k++) {\n          cx += cellWidthMap[k];\n        }\n        cw = prevColumnWidthCountList[j];\n        ch = topHeaderHeight;\n\n        // console.log('prevCx = ' + (prevCx - cw) + ' ; cx = ' + cx); //   preCx计算的下一个单元格的cx , 将当前单元格宽度减掉就是当前单元格的cx\n        let drawText = prevDrawTextList[j] || \"\";\n        cy = topOffset + j * topHeaderHeight;\n        let curRect = generateDivCellDom({\n          className: \"rect-top-header-cell-item\",\n          cx: cx,\n          cy: cy - topOffset,\n          cw: cw,\n          ch: ch,\n          backgroundColor: styleTopHeaderColor,\n          borderWidth: allBorderWidth,\n          borderColor: styleTopHeaderBorderColor,\n          color: topHeaderFontColor,\n          fontSize: topHeaderFontSize || cellFontSize,\n          marginLeft: -left,\n          originalValue: drawText,\n          header: columnList[j]\n        });\n        topHeaderContainer.appendChild(curRect);\n      }\n      // 画最后一行的表头的所有列 及 纵向拖拽线\n      let verticalDragLines = []; //纵向拖拽线\n      for (let i = leftStart + freezeColumnCount; i < leftEnd + freezeColumnCount; i++) {\n        let curColumnObj = columnNumberObjMap[i + \"\"];\n        if (!curColumnObj) continue;\n        let drawText, originalValue, theHeader;\n        // 总计列或者当前是多个数值列的情况下，表头的最后一行全部是valueList.name\n        if (curColumnObj.isTotal || isValueHeaderFlag) {\n          let theValueHeader = valueList[curColumnObj.valueIndex] && valueList[curColumnObj.valueIndex].header || {};\n          drawText = theValueHeader.displayName || theValueHeader.col_name;\n\n          // 总计列，如果显示的聚合值不是总和\n          if (curColumnObj.isTotal && theValueHeader.headerSetting && theValueHeader.headerSetting.totalOperator1) {\n            let theAggregate = _DataFocusMethod.addAggregates[theValueHeader.headerSetting.totalOperator1];\n            drawText = (theAggregate && theAggregate[conf.language + '_value'] ? theAggregate[conf.language + '_value'] + ':' : '') + drawText;\n          }\n        } else {\n          theHeader = columnList[columnList.length - 1];\n          originalValue = theHeader.distincts[curColumnObj.columnIndexList[columnList.length - 1]];\n        }\n        let cx, cy, cw, ch;\n        let curWidth = cellWidthMap[curColumnObj.valueIndex];\n        let theOffsetValueWidth = 0;\n        if (isValueHeaderFlag) {\n          for (let k = 0; k < curColumnObj.valueIndex; k++) {\n            theOffsetValueWidth += cellWidthMap[k];\n          }\n        }\n        // i前面N个数值组的宽度和 + i在当前组的前面的数值单元格的宽度和 - 固定列的宽度和\n        cx = leftOffset + drawControl.displayLeft + Math.floor(i / valueList.length) * minUnitColumnWidth + theOffsetValueWidth - drawControl.freezeColumnWidth;\n        cy = topOffset + (columnList.length - 1 + (isValueHeaderFlag ? 1 : 0)) * topHeaderHeight;\n        cw = curWidth;\n        ch = topHeaderHeight;\n\n        // 所有的总计行都在最后画\n        if (curColumnObj.isTotal) {\n          ch = topHeaderHeight * curColumnObj.cellNumber;\n          cy = cy + topHeaderHeight - ch;\n        }\n        let curRect = generateDivCellDom({\n          className: \"rect-top-header-cell-item\",\n          cx: cx - leftOffset - drawControl.displayLeft,\n          cy: cy - topOffset,\n          cw: cw,\n          ch: ch,\n          backgroundColor: styleTopHeaderColor,\n          borderWidth: allBorderWidth,\n          borderColor: styleTopHeaderBorderColor,\n          color: topHeaderFontColor,\n          fontSize: topHeaderFontSize || cellFontSize,\n          marginLeft: -left,\n          drawText: drawText,\n          originalValue: originalValue,\n          header: theHeader\n        });\n        topHeaderContainer.appendChild(curRect);\n        let theDragLine = generateDragLineDom({\n          className: 'rect-top-header-drag-line',\n          cw: 6,\n          ch: cw + drawControl.realDrawHeight,\n          cx: cx - leftOffset - 4 - drawControl.displayLeft,\n          cy: cy - topOffset,\n          cursor: 'ew-resize'\n        });\n        theDragLine.setAttribute('valueIdx', (i + 1) % valueList.length);\n        topHeaderContainer.appendChild(theDragLine);\n        verticalDragLines.push(theDragLine);\n      }\n\n      //综合表头容器\n      let MultiHeaderContainer = document.createElement('div');\n      MultiHeaderContainer.className = 'rect-multi-header-container';\n      let theMultiHeaderStyle = 'position:absolute;display:block;';\n      theMultiHeaderStyle += 'top:' + topOffset + 'px;';\n      theMultiHeaderStyle += 'left:' + leftOffset + 'px;';\n      theMultiHeaderStyle += 'width:' + drawControl.synBoxLeft + 'px;';\n      theMultiHeaderStyle += 'height:' + drawControl.synBoxTop + 'px;';\n      theMultiHeaderStyle += 'overflow:hidden;';\n      MultiHeaderContainer.style = theMultiHeaderStyle;\n      MultiHeaderContainer.innerHTML = '<svg><g></g></svg>';\n      svgDiv.append(MultiHeaderContainer);\n      let multiHeaderSvg = d3.select($(MultiHeaderContainer).find('svg')[0]);\n      //绘制综合表头\n      let lTRect = multiHeaderSvg.append(\"rect\");\n      lTRect.attr(\"x\", leftOffset).attr(\"y\", topOffset).attr(\"width\", drawControl.synBoxLeft).attr(\"height\", drawControl.synBoxTop).attr(\"fill\", styleSynHeaderColor || styleTopHeaderColor).attr(\"stroke\", styleSynHeaderBorderColor || styleTopHeaderBorderColor).attr(\"stroke-width\", allBorderWidth);\n      //创建左上表头的裁剪区域\n      let lTRectClipPathID = options.chartUUID + 'lTRect' + drawControl.synBoxLeft + drawControl.synBoxTop;\n      let curClipPath = svgParent.append(\"defs\").append(\"clipPath\").attr('id', lTRectClipPathID);\n      let curClipRect = curClipPath.append(\"rect\");\n      curClipRect.attr(\"x\", leftOffset).attr(\"y\", topOffset).attr(\"width\", drawControl.synBoxLeft).attr(\"height\", drawControl.synBoxTop);\n      if (synSplitType === \"top\") {\n        //绘制左上表头的分割线\n        let tempSplitStr = defaultHeaderTitles.split(\"|\");\n        let partAngle = 90 / tempSplitStr.length - 1;\n        let radius = Math.sqrt(drawControl.synBoxLeft * drawControl.synBoxLeft + drawControl.synBoxTop * drawControl.synBoxTop);\n        let textRadius = synContentRadius;\n        let linePoints = [{\n          x: textRadius,\n          y: 0\n        }];\n        for (let i = 1; i < tempSplitStr.length; i++) {\n          let cx = radius * Math.cos(partAngle * i / 180 * Math.PI);\n          let cy = radius * Math.sin(partAngle * i / 180 * Math.PI);\n          let tx = textRadius * Math.cos(partAngle * i / 180 * Math.PI);\n          let ty = textRadius * Math.sin(partAngle * i / 180 * Math.PI);\n          linePoints.push({\n            x: tx,\n            y: ty\n          });\n          let curLine = multiHeaderSvg.append(\"line\");\n          curLine.attr(\"x1\", leftOffset).attr(\"y1\", topOffset).attr(\"x2\", leftOffset + cx).attr(\"y2\", topOffset + cy).attr(\"stroke\", styleSynHeaderBorderColor || styleTopHeaderBorderColor).attr(\"stroke-width\", \"2\").attr(\"clip-path\", \"url(#\" + lTRectClipPathID + \")\");\n        }\n        linePoints.push({\n          x: 0,\n          y: textRadius\n        });\n        //绘制左上表头的内容\n        for (let i = 0; i < tempSplitStr.length; i++) {\n          let cx = linePoints[i].x * 0.3 + linePoints[i + 1].x * 0.7;\n          let cy = linePoints[i].y * 0.3 + linePoints[i + 1].y * 0.7;\n          let textG = multiHeaderSvg.append(\"g\");\n          textG.attr(\"clip-path\", \"url(#\" + lTRectClipPathID + \")\");\n          let curText = textG.append(\"text\");\n          curText.attr(\"class\", 'labels').style(\"stroke-width\", \"0\").style(\"font-weight\", \"400\").style(\"font-size\", synFontSize || topHeaderFontSize || cellFontSize).style(\"fill\", synFontColor || topHeaderFontColor).text(tempSplitStr[i]).attr('text-anchor', \"middle\").attr('transform', function () {\n            return 'translate(' + parseInt(leftOffset * 1 + cx * 1) + ',' + parseInt(topOffset * 1 + cy * 1) + ') ' + 'rotate(' + parseInt(partAngle * 0.5 + partAngle * i) + ')';\n          });\n        }\n      } else {\n        //绘制左上表头的分割线\n        let tempSplitStr = defaultHeaderTitles.split(\"|\").reverse();\n        let partAngle = 90 / tempSplitStr.length - 1;\n        let radius = Math.sqrt(drawControl.synBoxLeft * drawControl.synBoxLeft + drawControl.synBoxTop * drawControl.synBoxTop);\n        let textRadius = synContentRadius;\n        let linePoints = [{\n          x: textRadius,\n          y: drawControl.synBoxTop\n        }];\n        for (let i = 1; i < tempSplitStr.length; i++) {\n          let cx = radius * Math.cos((360 - 1 * (partAngle * i)) / 180 * Math.PI);\n          let cy = radius * Math.sin((360 - 1 * (partAngle * i)) / 180 * Math.PI) + drawControl.synBoxTop;\n          let tx = textRadius * Math.cos((360 - 1 * (partAngle * i)) / 180 * Math.PI);\n          let ty = textRadius * Math.sin((360 - 1 * (partAngle * i)) / 180 * Math.PI) + drawControl.synBoxTop;\n          linePoints.push({\n            x: tx,\n            y: ty\n          });\n          let curLine = multiHeaderSvg.append(\"line\");\n          curLine.attr(\"x1\", leftOffset).attr(\"y1\", topOffset + drawControl.synBoxTop).attr(\"x2\", leftOffset + cx).attr(\"y2\", topOffset + cy).attr(\"stroke\", styleSynHeaderBorderColor || styleTopHeaderBorderColor).attr(\"stroke-width\", \"2\").attr(\"clip-path\", \"url(#\" + lTRectClipPathID + \")\");\n        }\n        linePoints.push({\n          x: 0,\n          y: drawControl.synBoxTop - textRadius\n        });\n        //绘制左上表头的内容\n        for (let i = 0; i < tempSplitStr.length; i++) {\n          let cx = linePoints[i].x * 0.7 + linePoints[i + 1].x * 0.3;\n          let cy = linePoints[i].y * 0.7 + linePoints[i + 1].y * 0.3;\n          let textG = multiHeaderSvg.append(\"g\");\n          textG.attr(\"clip-path\", \"url(#\" + lTRectClipPathID + \")\");\n          let curText = textG.append(\"text\");\n          curText.attr(\"class\", 'labels').style(\"stroke-width\", \"0\").style(\"font-weight\", \"400\").style(\"font-size\", synFontSize || topHeaderFontSize || cellFontSize).style(\"fill\", synFontColor || topHeaderFontColor).text(tempSplitStr[i]).attr('text-anchor', \"middle\").attr('transform', function () {\n            return 'translate(' + parseInt(leftOffset * 1 + cx * 1) + ',' + parseInt(topOffset * 1 + cy * 1) + ') ' + 'rotate(' + parseInt(-partAngle * 0.5 - partAngle * i) + ')';\n          });\n        }\n      }\n\n      // 单独的冻结行单元格容器 [ 不包含与冻结列的交叉单元格部分 ]\n      let freezeRowContainer = document.createElement('div');\n      freezeRowContainer.className = 'rect-freeze-row-container';\n      let theFreezeRowStyle = 'position:absolute;display:block;';\n      theFreezeRowStyle += 'top:' + (drawControl.synBoxTop + topOffset) + 'px;';\n      theFreezeRowStyle += 'left:' + leftOffset + 'px;';\n      theFreezeRowStyle += 'width: 100%;';\n      theFreezeRowStyle += 'height:' + drawControl.freezeColumnHeight + 'px;';\n      theFreezeRowStyle += 'font-size: ' + freezeRowFontColor + ';';\n      freezeRowContainer.style = theFreezeRowStyle;\n      svgDiv.append(freezeRowContainer);\n      //绘制冻结行中的滚动单元格部分\n      for (let i = 0; i < freezeRowCount; i++) {\n        // 冻结行中的滚动区域\n        for (let j = leftStart + freezeColumnCount; j < leftEnd + freezeColumnCount; j++) {\n          let curObj = positionValueMap[i + \"-\" + j] || {};\n          let cx, cy, cw, ch;\n          if (cellWidthText) {\n            let curWidth = cellWidthMap[j % valueList.length];\n\n            // 计算当前单元格在所在数值组中的左侧单元格的宽度和\n            let theOffsetValueWidth = 0;\n            if (isValueHeaderFlag) {\n              let locateNumber = j % valueList.length; //  当前单元格在数值组中的位置\n              for (let k = 0; k < locateNumber; k++) {\n                theOffsetValueWidth += cellWidthMap[k];\n              }\n            }\n            cx = leftOffset + drawControl.displayLeft + Math.floor(j / valueList.length) * minUnitColumnWidth + theOffsetValueWidth - drawControl.freezeColumnWidth;\n            cy = topOffset + drawControl.synBoxTop + i * cellHeight;\n            cw = curWidth;\n            ch = cellHeight;\n          } else {\n            cx = leftOffset + drawControl.displayLeft + j * cellWidth - drawControl.freezeColumnWidth;\n            cy = topOffset + drawControl.synBoxTop + i * cellHeight;\n            cw = cellWidth;\n            ch = cellHeight;\n          }\n\n          // 冻结行的值\n          let curRect = generateDivCellDom({\n            className: \"rect-freeze-cell-item-item\",\n            cx: cx - leftOffset,\n            cy: cy - topOffset - drawControl.synBoxTop,\n            cw: cw,\n            ch: ch,\n            backgroundColor: freezeRowColor,\n            borderWidth: allBorderWidth,\n            borderColor: freezeRowBorderColor,\n            color: freezeRowFontColor || defaultFontColor,\n            fontSize: freezeRowFontSize || cellFontSize,\n            marginLeft: -left,\n            originalValue: curObj.value,\n            header: curObj.header\n          });\n          freezeRowContainer.appendChild(curRect);\n        }\n      }\n\n      // 绘制冻结行中的左侧表头\n      let tempFreezeRowDragLineParameters = [];\n      if (freezeRowCount) {\n        prevRowNumberList = [];\n        prevRowNumberCountList = [];\n        prevDrawTextList = [];\n        prevRowObj = null;\n        for (let i = 0; i < rowList.length - 1; i++) {\n          prevRowNumberList[i] = -1;\n          prevRowNumberCountList[i] = 1;\n        }\n        for (let i = 0; i < freezeRowCount; i++) {\n          let curObj = rowNumberObjMap[i + \"\"];\n          if (!curObj || curObj.isTotal && !curObj.isSubTotal) continue; //  总计行不参与\n          let cx = leftOffset + (rowList.length - 1) * leftHeaderWidth;\n          let cy = topOffset + drawControl.synBoxTop + i * leftHeaderHeight;\n          let cw = leftHeaderWidth;\n          let ch = leftHeaderHeight;\n          let originalCy = cy;\n\n          // 画左侧表头非最后一列的数据\n          let clearSubRowFlag = false; //  是否需要清空绘制完所有列\n          for (let j = 0; j < rowList.length - 1; j++) {\n            let originalValue = '',\n              theHeader,\n              needCellFlag = false;\n            // 非最后一列的左侧表头\n            if (curObj.rowIndexList && curObj.rowIndexList.length) {\n              let theRowIndex = curObj.rowIndexList[j];\n              let thePrevIndex = prevRowObj && prevRowObj.rowIndexList && prevRowObj.rowIndexList[j];\n              if (prevRowNumberList[j] === -1) {\n                prevRowNumberList[j] = theRowIndex;\n                prevRowNumberCountList[j] = 1;\n                prevDrawTextList[j] = rowList[j].distincts[theRowIndex];\n              } else if (clearSubRowFlag || theRowIndex !== thePrevIndex) {\n                clearSubRowFlag = true;\n                originalValue = prevDrawTextList[j];\n                theHeader = rowList[j];\n                needCellFlag = true;\n                cx = leftOffset + j * leftHeaderWidth;\n                ch = leftHeaderHeight * prevRowNumberCountList[j];\n                cy = originalCy - ch;\n                // console.log('绘制左侧单元格‘'+originalValue+'’ ，在第'+ i +'行'+'绘制了第'+ prevRowObj.rp +'行第'+ j +'列的数据');\n                // console.log(j);\n                // 如果当前列是undefined，说明遇到了合计行，需要将对应的后面的单元格全部画出来\n                if (theRowIndex !== undefined) {\n                  prevRowNumberList[j] = theRowIndex;\n                  prevDrawTextList[j] = rowList[j].distincts[theRowIndex];\n                }\n                prevRowNumberCountList[j] = 1;\n\n                // 绘制完当前行的所有列再替换prevRowObj\n                if (j === rowList.length - 2) prevRowObj = curObj;\n              } else if (theRowIndex === prevRowNumberList[j]) {\n                prevRowNumberCountList[j]++;\n              }\n            }\n\n            // 如果需要显示单元格的情况下\n            if (needCellFlag && originalValue !== undefined) {\n              let curRect = generateDivCellDom({\n                className: \"rect-left-freeze-header-cell-item\",\n                cx: cx - leftOffset,\n                cy: cy - drawControl.synBoxTop,\n                cw: cw,\n                ch: ch,\n                backgroundColor: freezeRowColor,\n                borderWidth: allBorderWidth,\n                borderColor: freezeRowBorderColor,\n                color: freezeRowFontColor || defaultFontColor,\n                fontSize: freezeRowFontSize || cellFontSize,\n                originalValue: originalValue,\n                header: theHeader\n              });\n              freezeRowContainer.appendChild(curRect);\n            }\n          }\n          prevRowObj = curObj;\n        }\n        // 绘制左侧表头最后一行的前N-1列左侧单元格\n        for (let j = 0; j < rowList.length - 1; j++) {\n          // 如果显示总计行，总计行在最后，则计算最后一个单元格的cy时，需要将总计行的高度去除\n          let theRowIndex = freezeRowCount;\n          if (showTotalRowFlag && theRowIndex === totalRowCount) theRowIndex = theRowIndex - 1;\n          let cx = leftOffset + (rowList.length - 1) * leftHeaderWidth;\n          let cy = topOffset + drawControl.synBoxTop + theRowIndex * leftHeaderHeight;\n          let cw = leftHeaderWidth;\n          let ch = leftHeaderHeight;\n          let drawText = prevDrawTextList[j];\n          cx = leftOffset + j * leftHeaderWidth;\n          ch = leftHeaderHeight * prevRowNumberCountList[j];\n          cy -= ch;\n          let curRect = generateDivCellDom({\n            className: \"rect-left-freeze-header-cell-item\",\n            cx: cx - leftOffset,\n            cy: cy - drawControl.synBoxTop,\n            cw: cw,\n            ch: ch,\n            backgroundColor: freezeRowColor,\n            borderWidth: allBorderWidth,\n            borderColor: freezeRowBorderColor,\n            color: freezeRowFontColor || defaultFontColor,\n            fontSize: freezeRowFontSize || cellFontSize,\n            originalValue: drawText,\n            header: rowList[j]\n          });\n          freezeRowContainer.appendChild(curRect);\n        }\n        for (let i = 0; i < freezeRowCount; i++) {\n          let curObj = rowNumberObjMap[i + \"\"];\n          if (!curObj) continue;\n          let index = i;\n          let cx = leftOffset + (rowList.length - 1) * leftHeaderWidth;\n          let cy = topOffset + drawControl.synBoxTop + index * leftHeaderHeight;\n          let cw = leftHeaderWidth;\n          let ch = leftHeaderHeight;\n          let drawText = '',\n            originalValue = '',\n            theHeader = rowList[rowList.length - 1];\n          // 所有的总计行都在最后画\n          if (curObj.isTotal) {\n            drawText = theTotalText;\n            cx = leftOffset + Math.max(rowList.length - curObj.cellNumber, 0) * leftHeaderWidth;\n            cw = leftHeaderWidth * curObj.cellNumber;\n          } else if (curObj.rowIndexList) {\n            originalValue = theHeader.distincts[curObj.rowIndexList[rowList.length - 1]];\n          }\n          let curRect = generateDivCellDom({\n            className: \"rect-left-freeze-header-cell-item\",\n            cx: cx - leftOffset,\n            cy: cy - drawControl.synBoxTop,\n            cw: cw,\n            ch: ch,\n            backgroundColor: freezeRowColor,\n            borderWidth: allBorderWidth,\n            borderColor: freezeRowBorderColor,\n            color: freezeRowFontColor || defaultFontColor,\n            fontSize: freezeRowFontSize || cellFontSize,\n            drawText: drawText,\n            originalValue: originalValue,\n            header: theHeader\n          });\n          freezeRowContainer.appendChild(curRect);\n          tempFreezeRowDragLineParameters.push({\n            x: cx,\n            y: cy - drawControl.synBoxTop + ch,\n            w: cw + drawControl.realDrawWidth,\n            h: 6\n          });\n        }\n      }\n\n      // 单独的冻结列单元格容器 [ 不包含与冻结行的交叉单元格部分 ]\n      let freezeColumnContainer = document.createElement('div');\n      freezeColumnContainer.className = 'rect-freeze-column-container';\n      let theFreezeColumnStyle = 'position:absolute;display:block;';\n      theFreezeColumnStyle += 'top:' + topOffset + 'px;';\n      theFreezeColumnStyle += 'left:' + (drawControl.synBoxLeft + leftOffset) + 'px;';\n      theFreezeColumnStyle += 'width: ' + drawControl.freezeColumnWidth + 'px ;';\n      theFreezeColumnStyle += 'height: 100%;';\n      freezeColumnContainer.style = theFreezeColumnStyle;\n      svgDiv.append(freezeColumnContainer);\n      //绘制冻结列滚动区域部分\n      for (let i = topStart + freezeRowCount; i < topEnd + freezeRowCount; i++) {\n        for (let j = 0; j < freezeColumnCount; j++) {\n          let curObj = positionValueMap[i + \"-\" + j] || {};\n          let cx, cy, cw, ch;\n          if (cellWidthText) {\n            let curWidth = cellWidthMap[j % valueList.length];\n\n            // 计算当前单元格在所在数值组中的左侧单元格的宽度和\n            let theOffsetValueWidth = 0;\n            if (isValueHeaderFlag) {\n              let locateNumber = j % valueList.length; //  当前单元格在数值组中的位置\n              for (let k = 0; k < locateNumber; k++) {\n                theOffsetValueWidth += cellWidthMap[k];\n              }\n            }\n            cx = leftOffset + drawControl.synBoxLeft + Math.floor(j / valueList.length) * minUnitColumnWidth + theOffsetValueWidth;\n            cy = topOffset + drawControl.displayTop + (i - freezeRowCount) * cellHeight - top;\n            cw = curWidth;\n            ch = cellHeight;\n          } else {\n            cx = leftOffset + drawControl.synBoxLeft + j * cellWidth;\n            cy = topOffset + drawControl.displayTop + (i - freezeRowCount) * cellHeight - top;\n            cw = cellWidth;\n            ch = cellHeight;\n          }\n          let curRect = generateDivCellDom({\n            className: \"rect-freeze-cell-item\",\n            cx: cx - leftOffset - drawControl.synBoxLeft,\n            cy: cy - topOffset,\n            cw: cw,\n            ch: ch,\n            backgroundColor: freezeRowColor,\n            borderWidth: allBorderWidth,\n            borderColor: freezeRowBorderColor,\n            color: freezeRowFontColor || defaultFontColor,\n            fontSize: freezeRowFontSize || cellFontSize,\n            originalValue: curObj.value,\n            header: curObj.header\n          });\n          freezeColumnContainer.appendChild(curRect);\n        }\n      }\n      //绘制冻结列的顶部表头\n      let tempFreezeColumnDragLineParameters = []; //  冻结列的拖拽线\n      if (freezeColumnCount) {\n        prevColumnObj = null;\n        prevDrawTextList = [];\n        prevColumnNumberList = [];\n        prevColumnWidthCountList = [];\n        prevColumnNumberCountList = [];\n        for (let i = 0; i < columnDistinctNumberList.length - 1; i++) {\n          prevColumnNumberList[i] = -1;\n          prevColumnWidthCountList[i] = 0;\n          prevColumnNumberCountList[i] = 1;\n        }\n        // 画冻结列中每一行中非最后一列的数据\n        for (let i = 0; i < freezeColumnCount; i++) {\n          let curColumnObj = columnNumberObjMap[i + \"\"];\n          if (!curColumnObj) continue;\n          let cx, cy, cw, ch;\n          cw = cellWidthMap[curColumnObj.valueIndex];\n          ch = topHeaderHeight;\n          cx = leftOffset + drawControl.synBoxLeft + Math.floor(i / valueList.length) * cellWidthMap.groupTotalWidth;\n          for (let k = 0; k < i % valueList.length; k++) {\n            cx += cellWidthMap[k];\n          }\n          let originalCx = cx;\n          let originalCw = cw;\n\n          // 画顶部表头非最后一行的数据\n          let clearSubColumnFlag = false; //  是否需要清空绘制完所有行\n          for (let j = 0; j < columnDistinctNumberList.length - 1; j++) {\n            let originalValue = '',\n              theHeader,\n              needCellFlag = false;\n            // 非最后一行的顶部侧表头\n            if (curColumnObj.columnIndexList && curColumnObj.columnIndexList.length) {\n              let theColumnIndex = curColumnObj.columnIndexList[j];\n              let thePrevIndex = prevColumnObj && prevColumnObj.columnIndexList && prevColumnObj.columnIndexList[j];\n              if (prevColumnNumberList[j] === -1) {\n                prevColumnNumberList[j] = theColumnIndex;\n                prevColumnNumberCountList[j] = 1;\n                prevColumnWidthCountList[j] = originalCw;\n                prevDrawTextList[j] = columnList[j].distincts[theColumnIndex];\n              } else if (clearSubColumnFlag || theColumnIndex !== thePrevIndex) {\n                clearSubColumnFlag = true;\n                originalValue = prevDrawTextList[j];\n                theHeader = columnList[j];\n                needCellFlag = true;\n                cy = topOffset + j * topHeaderHeight;\n                cw = prevColumnWidthCountList[j];\n                cx = originalCx - cw;\n\n                // console.log(j + '-' + i);\n                // console.log('绘制顶部侧单元格‘'+originalValue+'’ ，在第'+ i +'列'+'绘制了第'+ prevRowObj.cp +'列第'+ j +'行的数据');\n                // 如果当前列是undefined，说明遇到了合计列，需要将对应的后面的单元格全部画出来\n                if (theColumnIndex !== undefined) {\n                  prevColumnNumberList[j] = theColumnIndex;\n                  prevDrawTextList[j] = columnList[j].distincts[theColumnIndex];\n                }\n                prevColumnWidthCountList[j] = originalCw;\n                prevColumnNumberCountList[j] = 1;\n              } else if (theColumnIndex === prevColumnNumberList[j]) {\n                prevColumnNumberCountList[j]++;\n                prevColumnWidthCountList[j] += originalCw;\n              }\n            }\n            if (needCellFlag && originalValue !== undefined) {\n              let curRect = generateDivCellDom({\n                className: \"rect-top-freeze-header-cell-item\",\n                cx: cx - leftOffset - drawControl.synBoxLeft,\n                cy: cy - topOffset,\n                cw: cw,\n                ch: ch,\n                backgroundColor: styleTopHeaderColor,\n                borderWidth: allBorderWidth,\n                borderColor: styleTopHeaderBorderColor,\n                color: topHeaderFontColor,\n                fontSize: topHeaderFontSize || cellFontSize,\n                originalValue: originalValue,\n                header: theHeader\n              });\n              freezeColumnContainer.appendChild(curRect);\n            }\n          }\n          prevColumnObj = curColumnObj;\n        }\n        // 绘制冻结列顶部表头最后一列的前N-1行顶部单元格 例：如果有3行表头，画前两行表头的最后一列\n        for (let j = 0; j < columnDistinctNumberList.length - 1; j++) {\n          let i = freezeColumnCount;\n          let cx, cy, cw, ch;\n          if (!prevColumnWidthCountList[j]) continue;\n          cx = leftOffset + drawControl.synBoxLeft + Math.floor(i / valueList.length) * cellWidthMap.groupTotalWidth;\n          for (let k = 0; k < i % valueList.length; k++) {\n            cx += cellWidthMap[k];\n          }\n          cw = prevColumnWidthCountList[j];\n          ch = topHeaderHeight;\n          let drawText = prevDrawTextList[j] || \"\";\n          cy = topOffset + j * topHeaderHeight;\n          cx = cx - cw;\n          let curRect = generateDivCellDom({\n            className: \"rect-top-freeze-header-cell-item\",\n            cx: cx - leftOffset - drawControl.synBoxLeft,\n            cy: cy - topOffset,\n            cw: cw,\n            ch: ch,\n            backgroundColor: styleTopHeaderColor,\n            borderWidth: allBorderWidth,\n            borderColor: styleTopHeaderBorderColor,\n            color: topHeaderFontColor,\n            fontSize: topHeaderFontSize || cellFontSize,\n            originalValue: drawText,\n            header: columnList[j]\n          });\n          freezeColumnContainer.appendChild(curRect);\n        }\n        // 画冻结列表头最后一行单元格\n        for (let i = 0; i < freezeColumnCount; i++) {\n          let curColumnObj = columnNumberObjMap[i + \"\"];\n          if (!curColumnObj) continue;\n          let drawText, originalValue, theHeader;\n          // 总计列或者当前是多个数值列的情况下，表头的最后一行全部是valueList.name\n          if (curColumnObj.isTotal || isValueHeaderFlag) {\n            let theValueHeader = valueList[curColumnObj.valueIndex] && valueList[curColumnObj.valueIndex].header || {};\n            drawText = theValueHeader.displayName || theValueHeader.col_name;\n          } else {\n            theHeader = columnList[columnList.length - 1];\n            originalValue = theHeader.distincts[curColumnObj.columnIndexList[columnList.length - 1]];\n          }\n          let cx, cy, cw, ch;\n          let curWidth = cellWidthMap[curColumnObj.valueIndex];\n          let theOffsetValueWidth = 0;\n          if (isValueHeaderFlag) {\n            for (let k = 0; k < curColumnObj.valueIndex; k++) {\n              theOffsetValueWidth += cellWidthMap[k];\n            }\n          }\n          // i前面N个数值组的宽度和 + i在当前组的前面的数值单元格的宽度和 - 固定列的宽度和\n          cx = leftOffset + drawControl.synBoxLeft + Math.floor(i / valueList.length) * minUnitColumnWidth + theOffsetValueWidth;\n          cy = topOffset + (columnList.length - 1 + (isValueHeaderFlag ? 1 : 0)) * topHeaderHeight;\n          cw = curWidth;\n          ch = topHeaderHeight;\n\n          // 所有的总计列都在最后画\n          if (curColumnObj.isTotal) {\n            ch = topHeaderHeight * curColumnObj.cellNumber;\n            cy = cy + topHeaderHeight - ch;\n          }\n          let curRect = generateDivCellDom({\n            className: \"rect-top-freeze-header-cell-item\",\n            cx: cx - leftOffset - drawControl.synBoxLeft,\n            cy: cy - topOffset,\n            cw: cw,\n            ch: ch,\n            backgroundColor: styleTopHeaderColor,\n            borderWidth: allBorderWidth,\n            borderColor: styleTopHeaderBorderColor,\n            color: topHeaderFontColor,\n            fontSize: topHeaderFontSize || cellFontSize,\n            drawText: drawText,\n            originalValue: originalValue,\n            header: theHeader\n          });\n          freezeColumnContainer.appendChild(curRect);\n          tempFreezeColumnDragLineParameters.push({\n            vIdx: i % valueList.length,\n            x: cx - leftOffset - drawControl.synBoxLeft + cw,\n            y: cy - topOffset,\n            w: 6,\n            h: cw + drawControl.realDrawHeight\n          });\n        }\n      }\n\n      //绘制冻结行列的交叉部分\n      if (freezeColumnCount && freezeRowCount) {\n        // 冻结行列交叉单元格的容器\n        let freezeCrossContainer = document.createElement('div');\n        freezeCrossContainer.className = 'rect-freeze-cross-container';\n        let theFreezeCrossStyle = 'position:absolute;display:block;';\n        theFreezeCrossStyle += 'top:' + (drawControl.synBoxTop + topOffset) + 'px;';\n        theFreezeCrossStyle += 'left:' + (drawControl.synBoxLeft + leftOffset) + 'px;';\n        theFreezeCrossStyle += 'width: ' + drawControl.freezeColumnWidth + 'px ;';\n        theFreezeCrossStyle += 'height: 100%;';\n        freezeCrossContainer.style = theFreezeCrossStyle;\n        svgDiv.append(freezeCrossContainer);\n        for (let i = 0; i < freezeRowCount; i++) {\n          for (let j = 0; j < freezeColumnCount; j++) {\n            let curObj = positionValueMap[i + \"-\" + j] || {};\n            let cx, cy, cw, ch;\n            if (cellWidthText) {\n              let curWidth = cellWidthMap[j % valueList.length];\n\n              // 计算当前单元格在所在数值组中的左侧单元格的宽度和\n              let theOffsetValueWidth = 0;\n              if (isValueHeaderFlag) {\n                let locateNumber = j % valueList.length; //  当前单元格在数值组中的位置\n                for (let k = 0; k < locateNumber; k++) {\n                  theOffsetValueWidth += cellWidthMap[k];\n                }\n              }\n              cx = leftOffset + drawControl.synBoxLeft + Math.floor(j / valueList.length) * minUnitColumnWidth + theOffsetValueWidth;\n              cy = topOffset + drawControl.synBoxTop + i * cellHeight;\n              cw = curWidth;\n              ch = cellHeight;\n            } else {\n              cx = leftOffset + drawControl.synBoxLeft + j * cellWidth;\n              cy = topOffset + drawControl.synBoxTop + i * cellHeight;\n              cw = cellWidth;\n              ch = cellHeight;\n            }\n            let curRect = generateDivCellDom({\n              className: \"rect-freeze-cross-cell-item\",\n              cx: cx - leftOffset - drawControl.synBoxLeft,\n              cy: cy - topOffset - drawControl.synBoxTop,\n              cw: cw,\n              ch: ch,\n              backgroundColor: freezeRowColor,\n              borderWidth: allBorderWidth,\n              borderColor: freezeRowBorderColor,\n              color: freezeRowFontColor || defaultFontColor,\n              fontSize: freezeRowFontSize || cellFontSize,\n              originalValue: curObj.value,\n              header: curObj.header\n            });\n            freezeCrossContainer.appendChild(curRect);\n          }\n        }\n      }\n\n      // 冻结行的拖拽元素\n      tempFreezeRowDragLineParameters.forEach(function (parameter) {\n        let theDragLine = generateDragLineDom({\n          cw: parameter.w,\n          ch: parameter.h,\n          cx: parameter.x,\n          cy: parameter.y,\n          cursor: 'ns-resize',\n          className: 'freeze-rect-left-drag-line'\n        });\n        freezeRowContainer.appendChild(theDragLine);\n        horizonDragLines.push(theDragLine);\n      });\n\n      // 冻结列的拖拽元素\n      tempFreezeColumnDragLineParameters.forEach(function (parameter) {\n        let theDragLine = generateDragLineDom({\n          cw: parameter.w,\n          ch: parameter.h,\n          cx: parameter.x,\n          cy: parameter.y,\n          cursor: 'ew-resize',\n          className: 'freeze-rect-top-drag-line'\n        });\n        theDragLine.setAttribute('valueIdx', parameter.vIdx);\n        freezeColumnContainer.appendChild(theDragLine);\n        verticalDragLines.push(theDragLine);\n      });\n\n      //顶部表头高度拖拽线\n      let topHeaderDragLine = generateDragLineDom({\n        cw: drawControl.synBoxLeft + drawControl.realDrawWidth,\n        ch: 6,\n        cx: leftOffset,\n        cy: topOffset + drawControl.synBoxTop - 1,\n        cursor: 'ns-resize',\n        className: 'header-top-drag-line'\n      });\n      svgDiv.append(topHeaderDragLine);\n\n      //左侧表头宽度拖拽线\n      let leftHeaderDragLine = generateDragLineDom({\n        cw: 6,\n        ch: drawControl.synBoxTop + drawControl.realDrawHeight,\n        cx: leftOffset + drawControl.synBoxLeft - 1,\n        cy: topOffset,\n        cursor: 'ew-resize',\n        className: 'header-left-drag-line'\n      });\n      svgDiv.append(leftHeaderDragLine);\n\n      //绑定横线的拖拽事件\n      horizonDragLines.forEach(function (line) {\n        let lineJq = $(line);\n        lineJq.unbind(\"mousedown\");\n        lineJq.bind(\"mousedown\", function (e) {\n          e.stopPropagation();\n          let startY = e.clientY;\n          let originalCellHeight = cellHeight;\n          $(document).bind(\"mousemove\", function (e) {\n            let moveHeight = e.clientY - startY;\n            leftHeaderHeight = cellHeight = Math.max(originalCellHeight + moveHeight, minHeight);\n            if (!avoidShakeTimerHandleVertical) {\n              drawControl.displayTop = topLayerCount * topHeaderHeight;\n              if (freezeRowCount > 0) {\n                drawControl.displayTop += freezeRowCount * cellHeight;\n              }\n              drawDetail(drawControl.left, drawControl.top);\n              avoidShakeTimerHandleVertical = true;\n              setTimeout(function () {\n                avoidShakeTimerHandleVertical = false;\n              }, 50);\n            }\n          });\n          $(options.container).one(\"mouseup\", function (e) {\n            $(document).unbind(\"mousemove\");\n            options.currentChart.requireSetConfig({\n              key: \"style_cell_height\",\n              value: cellHeight,\n              isResize: true\n            });\n          });\n        });\n      });\n      //绑定纵向的拖拽事件\n      verticalDragLines.forEach(function (line) {\n        let lineJq = $(line);\n        lineJq.unbind(\"mousedown\");\n        lineJq.bind(\"mousedown\", function (e) {\n          e.stopPropagation();\n          let startX = e.clientX;\n          let valueIdx = parseInt(line.getAttribute(\"valueIdx\"));\n          let originalCellWidth = cellWidthMap[valueIdx] ? cellWidthMap[valueIdx] : cellWidth;\n          $(document).bind(\"mousemove\", function (e) {\n            let moveWidth = e.clientX - startX;\n            let tempWidth = Math.max(originalCellWidth + moveWidth, minWidth);\n            if (!avoidShakeTimerHandleVertical) {\n              cellWidthMap[valueIdx + \"\"] = tempWidth;\n              cellWidthText = \"\";\n              let isFirst = true;\n              for (let i = 0; i < valueList.length; i++) {\n                if (cellWidthMap[i]) {\n                  if (isFirst) {\n                    isFirst = false;\n                    cellWidthText += i + \":\" + parseInt(cellWidthMap[i]);\n                  } else {\n                    cellWidthText += \"|\" + i + \":\" + parseInt(cellWidthMap[i]);\n                  }\n                }\n              }\n              computeDragControl();\n              adjustCellWidth();\n              drawDetail(drawControl.left, drawControl.top);\n              avoidShakeTimerHandleVertical = true;\n              setTimeout(function () {\n                avoidShakeTimerHandleVertical = false;\n              }, 50);\n            }\n          });\n          $(options.container).one(\"mouseup\", function (e) {\n            $(document).unbind(\"mousemove\");\n            options.currentChart.requireSetConfig({\n              key: \"cell_width_text\",\n              value: cellWidthText,\n              isResize: true\n            });\n          });\n        });\n      });\n      //绑定顶部表头高度拖拽线的拖拽事件\n      let topHeaderDragLineJq = $(topHeaderDragLine);\n      topHeaderDragLineJq.unbind(\"mousedown\");\n      topHeaderDragLineJq.bind(\"mousedown\", function (e) {\n        e.stopPropagation();\n        let startY = e.clientY;\n        let originalCellHeight = topHeaderHeight;\n        $(document).bind(\"mousemove\", function (e) {\n          let moveHeight = (e.clientY - startY) / columnDistinctNumberList.length;\n          topHeaderHeight = Math.max(originalCellHeight + moveHeight, minHeight);\n          if (!avoidShakeTimerHandleVertical) {\n            computeDragControl();\n            drawDetail(drawControl.left, drawControl.top);\n            avoidShakeTimerHandleVertical = true;\n            setTimeout(function () {\n              avoidShakeTimerHandleVertical = false;\n            }, 50);\n          }\n        });\n        $(options.container).one(\"mouseup\", function (e) {\n          $(document).unbind(\"mousemove\");\n          options.currentChart.requireSetConfig({\n            key: \"syn_header_height\",\n            value: topHeaderHeight,\n            isResize: true\n          });\n        });\n      });\n      //绑定左侧表头高度拖拽线的拖拽事件\n      let leftHeaderDragLineJq = $(leftHeaderDragLine);\n      leftHeaderDragLineJq.unbind(\"mousedown\");\n      leftHeaderDragLineJq.bind(\"mousedown\", function (e) {\n        e.stopPropagation();\n        let startX = e.clientX;\n        let originalCellWidth = leftHeaderWidth;\n        $(document).bind(\"mousemove\", function (e) {\n          let moveWidth = (e.clientX - startX) / rowList.length;\n          leftHeaderWidth = Math.max(originalCellWidth + moveWidth, minWidth);\n          if (!avoidShakeTimerHandleVertical) {\n            computeDragControl();\n            drawDetail(drawControl.left, drawControl.top);\n            avoidShakeTimerHandleVertical = true;\n            setTimeout(function () {\n              avoidShakeTimerHandleVertical = false;\n            }, 50);\n          }\n        });\n        $(options.container).one(\"mouseup\", function (e) {\n          $(document).unbind(\"mousemove\");\n          options.currentChart.requireSetConfig({\n            key: \"syn_header_width\",\n            value: leftHeaderWidth,\n            isResize: true\n          });\n        });\n      });\n    }\n    drawDetail(0, 0);\n\n    //当数据的总体高度超过了显示高度时，绘制纵向滚动条\n    let isVerticalScrollFlag = false;\n    let avoidShakeTimerHandleVertical = false;\n    let percentVertical;\n    let verticalScrollDom;\n    let currentVerticalScrollPosition = 0;\n    if (drawControl.measureHeight > drawControl.displayHeight) {\n      isVerticalScrollFlag = true;\n      percentVertical = drawControl.displayHeight / drawControl.measureHeight;\n      verticalScrollDom = generateDivCellDom({\n        tagName: 'span',\n        className: 'vertical-scroll-container hover-display-dom scroll',\n        cx: drawWidth - 5,\n        cy: drawControl.displayTop + topOffset,\n        cw: 7,\n        ch: drawControl.displayHeight * percentVertical,\n        backgroundColor: \"#ddd\",\n        zIndex: 1\n      });\n      svgDiv.append(verticalScrollDom);\n      let verticalScrollJq = $(verticalScrollDom);\n      verticalScrollJq.unbind(\"mousedown\");\n      verticalScrollJq.bind(\"mousedown\", function (e) {\n        e.stopPropagation();\n        let startY = e.clientY;\n        let tempPosition = currentVerticalScrollPosition;\n        let topAbsolute, topMoveOffset;\n        $(document).bind(\"mousemove\", function (e) {\n          let moveHeight = e.clientY - startY;\n          tempPosition = currentVerticalScrollPosition + moveHeight;\n          tempPosition = Math.min(Math.max(0, tempPosition), drawControl.displayHeight * (1 - percentVertical));\n          $(verticalScrollDom).css(\"top\", drawControl.displayTop + topOffset + tempPosition);\n          topAbsolute = (currentVerticalScrollPosition + moveHeight) / drawControl.realDrawHeight * drawControl.measureHeight;\n          topAbsolute = Math.min(Math.max(0, topAbsolute), drawControl.measureHeight - drawControl.displayHeight);\n          topMoveOffset = topAbsolute - drawControl.top;\n          drawControl.top = topAbsolute;\n          if (!avoidShakeTimerHandleVertical) {\n            drawDetail(drawControl.left, drawControl.top);\n            avoidShakeTimerHandleVertical = true;\n            setTimeout(function () {\n              avoidShakeTimerHandleVertical = false;\n            }, 50);\n          }\n        });\n        $(options.container).one(\"mouseup\", function (e) {\n          $(document).unbind(\"mousemove\");\n          currentVerticalScrollPosition = tempPosition;\n        });\n      });\n    } else {\n      svgDiv.find(\".vertical-scroll-container\").remove();\n      verticalScrollDom = undefined;\n    }\n\n    //当数据的总体宽度超过了显示宽度时，绘制横向滚动条\n    let isOrientationScrollFlag = false;\n    let avoidShakeTimerHandleOrientation = false;\n    let percentOrientation;\n    let orientationScrollDom;\n    let currentOrientationScrollPosition = 0;\n    if (drawControl.measureWidth > drawControl.displayWidth) {\n      isOrientationScrollFlag = true;\n      percentOrientation = drawControl.displayWidth / drawControl.measureWidth;\n      orientationScrollDom = generateDivCellDom({\n        tagName: 'span',\n        className: 'horizontal-scroll-container hover-display-dom scroll',\n        cx: drawControl.displayLeft + leftOffset,\n        cy: drawHeight - 7,\n        cw: drawControl.displayWidth * percentOrientation,\n        ch: 7,\n        backgroundColor: \"#ddd\",\n        zIndex: 1\n      });\n      svgDiv.append(orientationScrollDom);\n      let orientationScrollJq = $(orientationScrollDom);\n      orientationScrollJq.unbind(\"mousedown\");\n      orientationScrollJq.bind(\"mousedown\", function (e) {\n        e.stopPropagation();\n        let startX = e.clientX;\n        let tempPosition = currentOrientationScrollPosition;\n        let leftAbsolute, leftMoveOffset;\n        $(document).bind(\"mousemove\", function (e) {\n          let moveWidth = e.clientX - startX;\n          tempPosition = currentOrientationScrollPosition + moveWidth;\n          tempPosition = Math.min(Math.max(0, tempPosition), drawControl.displayWidth * (1 - percentOrientation));\n          $(orientationScrollDom).css(\"left\", drawControl.displayLeft + leftOffset + tempPosition);\n          leftAbsolute = (currentOrientationScrollPosition + moveWidth) / drawControl.displayWidth * drawControl.measureWidth;\n          leftAbsolute = Math.min(Math.max(0, leftAbsolute), drawControl.measureWidth - drawControl.displayWidth);\n          leftMoveOffset = leftAbsolute - drawControl.left;\n          drawControl.left = leftAbsolute;\n          if (!avoidShakeTimerHandleOrientation) {\n            drawDetail(drawControl.left, drawControl.top);\n            avoidShakeTimerHandleOrientation = true;\n            setTimeout(function () {\n              avoidShakeTimerHandleOrientation = false;\n            }, 30);\n          }\n        });\n        $(options.container).one(\"mouseup\", function (e) {\n          $(document).unbind(\"mousemove\");\n          currentOrientationScrollPosition = tempPosition;\n        });\n      });\n    } else {\n      svgDiv.find(\".horizontal-scroll-container\").remove();\n      orientationScrollDom = undefined;\n    }\n\n    //当存在纵向滚动条时，绑定鼠标滚轮纵向事件，若不存在纵向只存在横向，则绑定鼠标滚轮横向事件\n    if (isVerticalScrollFlag) {\n      let wheelTimer = null;\n      let mouseWheelHandler = function (event) {\n        /**\r\n         * IE Chorme等浏览器下使用onmousewheel事件 , 使用wheelDelta判断滚动方向,向下滚时wheelDelta为-120\r\n         *\r\n         * FireFox下不存在mousewheel事件 ,滚动时会触发DOMMouseScroll事件,通过event.detail判断滚动方向,如果event.detail>0为往下滚\r\n         *\r\n         * **/\n        var wheelDirective = event.wheelDelta || -event.detail || -event.deltaY;\n        if (wheelDirective < 0) {\n          let topAbsolute = drawControl.top;\n          topAbsolute += 2 * cellHeight;\n          let tempPosition = topAbsolute / drawControl.measureHeight * drawControl.displayHeight;\n          tempPosition = Math.min(Math.max(0, tempPosition), drawControl.displayHeight * (1 - percentVertical));\n          $(verticalScrollDom).css(\"top\", drawControl.displayTop + topOffset + tempPosition);\n          currentVerticalScrollPosition = tempPosition;\n          topAbsolute = Math.min(Math.max(0, topAbsolute), drawControl.measureHeight - drawControl.displayHeight);\n          drawControl.top = topAbsolute;\n          drawDetail(drawControl.left, drawControl.top);\n        } else {\n          let topAbsolute = drawControl.top;\n          topAbsolute -= 2 * cellHeight;\n          let tempPosition = topAbsolute / drawControl.measureHeight * drawControl.displayHeight;\n          tempPosition = Math.min(Math.max(0, tempPosition), drawControl.displayHeight * (1 - percentVertical));\n          $(verticalScrollDom).css(\"top\", drawControl.displayTop + topOffset + tempPosition);\n          currentVerticalScrollPosition = tempPosition;\n          topAbsolute = Math.min(Math.max(0, topAbsolute), drawControl.measureHeight - drawControl.displayHeight);\n          drawControl.top = topAbsolute;\n          drawDetail(drawControl.left, drawControl.top);\n        }\n      };\n      $(options.container)[0].onwheel = $(options.container)[0].onmousewheel = function (event) {\n        _DataFocusMethod.stopEventDefault(event);\n        // wheelDelta < 0 时 表明是往下滚 ; >=0 时是往上滚\n        if (wheelTimer) {\n          clearTimeout(wheelTimer);\n          wheelTimer = null;\n        }\n        wheelTimer = setTimeout(function () {\n          mouseWheelHandler(event);\n        }, 10);\n        return false;\n      };\n      /**\r\n       * Firefox\r\n       * */\n      $(options.container)[0].addEventListener(\"DOMMouseScroll\", function (event) {\n        _DataFocusMethod.stopEventDefault(event);\n        // wheelDelta < 0 时 表明是往下滚 ; >=0 时是往上滚\n        if (wheelTimer) {\n          clearTimeout(wheelTimer);\n          wheelTimer = null;\n        }\n        wheelTimer = setTimeout(function () {\n          mouseWheelHandler(event);\n        }, 10);\n        return false;\n      });\n    } else if (isOrientationScrollFlag) {\n      let wheelTimer = null;\n      let mouseWheelHandler = function (event) {\n        /**\r\n         * IE Chorme等浏览器下使用onmousewheel事件 , 使用wheelDelta判断滚动方向,向下滚时wheelDelta为-120\r\n         *\r\n         * FireFox下不存在mousewheel事件 ,滚动时会触发DOMMouseScroll事件,通过event.detail判断滚动方向,如果event.detail>0为往下滚\r\n         *\r\n         * **/\n        var wheelDirective = event.wheelDelta || -event.detail || -event.deltaY;\n        if (wheelDirective < 0) {\n          let leftAbsolute = drawControl.left;\n          leftAbsolute += 2 * cellWidth;\n          let tempPosition = leftAbsolute / drawControl.measureWidth * drawControl.displayWidth;\n          tempPosition = Math.min(Math.max(0, tempPosition), drawControl.displayWidth * (1 - percentOrientation));\n          $(orientationScrollDom).css(\"left\", drawControl.displayLeft + leftOffset + tempPosition);\n          currentOrientationScrollPosition = tempPosition;\n          leftAbsolute = Math.min(Math.max(0, leftAbsolute), drawControl.measureWidth - drawControl.displayWidth);\n          drawControl.left = leftAbsolute;\n          drawDetail(drawControl.left, drawControl.top);\n        } else {\n          let leftAbsolute = drawControl.left;\n          leftAbsolute -= 2 * cellWidth;\n          let tempPosition = leftAbsolute / drawControl.measureWidth * drawControl.displayWidth;\n          tempPosition = Math.min(Math.max(0, tempPosition), drawControl.displayWidth * (1 - percentOrientation));\n          $(orientationScrollDom).css(\"left\", drawControl.displayLeft + leftOffset + tempPosition);\n          currentOrientationScrollPosition = tempPosition;\n          leftAbsolute = Math.min(Math.max(0, leftAbsolute), drawControl.measureWidth - drawControl.displayWidth);\n          drawControl.left = leftAbsolute;\n          drawDetail(drawControl.left, drawControl.top);\n        }\n      };\n      $(options.container)[0].onwheel = $(options.container)[0].onmousewheel = function (event) {\n        _DataFocusMethod.stopEventDefault(event);\n        // wheelDelta < 0 时 表明是往下滚 ; >=0 时是往上滚\n        if (wheelTimer) {\n          clearTimeout(wheelTimer);\n          wheelTimer = null;\n        }\n        wheelTimer = setTimeout(function () {\n          mouseWheelHandler(event);\n        }, 10);\n        return false;\n      };\n      /**\r\n       * Firefox\r\n       * */\n      $(options.container)[0].addEventListener(\"DOMMouseScroll\", function (event) {\n        _DataFocusMethod.stopEventDefault(event);\n        // wheelDelta < 0 时 表明是往下滚 ; >=0 时是往上滚\n        if (wheelTimer) {\n          clearTimeout(wheelTimer);\n          wheelTimer = null;\n        }\n        wheelTimer = setTimeout(function () {\n          mouseWheelHandler(event);\n        }, 10);\n        return false;\n      });\n    }\n\n    /**\r\n     * 生成DIV元素的单元格DOM  , 居中显示且显示数据格式及对应颜色规则或图片\r\n     * @param   options     -   生成单元格的位置信息\r\n     *          {\r\n     *              cx                  -   在svgDiv中的left的绝对位置\r\n     *              cy                  -   在svgDiv中的top的绝对位置\r\n     *              cw                  -   宽度\r\n     *              ch                  -   高度\r\n     *              className           -   类名\r\n     *              drawText            -   需要画出的内容\r\n     *              originalValue       -   单元格原始值\r\n     *              header              -   单元格表头\r\n     *              backgroundColor     -   背景色\r\n     *              borderWidth         -   边框宽度\r\n     *              borderColor         -   边框颜色\r\n     *              color               -   字体颜色\r\n     *              zIndex              -   zIndex的属性，\r\n     *              marginLeft          -   margin-left的值\r\n     *          }\r\n     * @return DIV DOM元素\r\n     * */\n    function generateDivCellDom(options) {\n      options = options || {};\n      let cw = options.cw;\n      let ch = options.ch;\n      let cx = options.cx;\n      let cy = options.cy;\n      let cellClassName = options.className;\n      let drawText = options.drawText;\n      let backgroundColor = options.backgroundColor;\n      let borderWidth = options.borderWidth;\n      let borderColor = options.borderColor;\n      let fontSize = options.fontSize;\n      let color = options.color;\n      let curRect = document.createElement(options.tagName || 'div');\n      curRect.className = cellClassName;\n      let theCellStyle = 'position:absolute;display:flex;justify-content:center;align-items:center;cursor:pointer;';\n      theCellStyle += 'left:' + cx + 'px; ';\n      theCellStyle += 'top:' + cy + 'px; ';\n      theCellStyle += 'width:' + cw + 'px; ';\n      theCellStyle += 'height:' + ch + 'px; ';\n      theCellStyle += 'background-color:' + (backgroundColor || \"#fff\") + '; ';\n      theCellStyle += 'border:1px solid transparent ;';\n      theCellStyle += 'border-width:' + borderWidth + 'px; ';\n      theCellStyle += 'border-color:' + (borderColor || \"#f5f5f5\") + '; ';\n      theCellStyle += 'font-size:' + (fontSize || 14) + 'px; ';\n      if (options.zIndex && options.zIndex > 0) theCellStyle += 'z-index:' + options.zIndex + '; ';\n      if (options.marginLeft - 0 === options.marginLeft) theCellStyle += 'margin-left:' + options.marginLeft + 'px; ';\n      curRect.title = _DataFocusMethod.translateIllegalStr(options.originalValue || drawText, {\n        showUnicodeFlag: true,\n        showNullValueFlag: true\n      });\n      let theCellColor = color || defaultFontColor;\n      let theInnerHTML = '<div class=\"text-clip\" style=\"min-width: calc(100% - 5px);width:auto;\">';\n      let theInnerText = '';\n      if (drawText) {\n        theInnerText += drawText;\n      } else if (options.header) {\n        let originalValue = options.originalValue,\n          theHeader = options.header || {},\n          originalHeader = theHeader.header;\n        let columnValue = originalValue,\n          isNullFlag = false;\n        if (columnValue == null || columnValue === undefined) {\n          isNullFlag = true;\n          columnValue = \"\";\n        }\n        let formatValue = '';\n        if (originalHeader.columnClassify === \"number\") {\n          formatValue = _DataFocusMethod.formatData(columnValue, originalHeader);\n        } else {\n          formatValue = _DataFocusMethod.formatTextData(columnValue, originalHeader);\n        }\n\n        // 计算单元格颜色规则\n        let showSignalLight = \"\",\n          showSignalLightColor = \"\";\n        if (originalHeader.colorFormattings && originalHeader.colorFormattings.length > 0) {\n          originalHeader.entireShape = originalHeader.colorFormattings[0].entireShape || 'default';\n          if (originalHeader.columnClassify === 'number') {\n            if (_DataFocusMethod.isPureNumber(columnValue)) {\n              originalHeader.colorFormattings.forEach(function (d) {\n                if (_DataFocusMethod.isNumber(d.start) && _DataFocusMethod.isNumber(d.end)) {\n                  if (d.start <= columnValue && d.end >= columnValue) {\n                    if (!d.shape || d.shape === \"default\") {\n                      showSignalLight = originalHeader.entireShape;\n                    } else {\n                      showSignalLight = d.shape;\n                    }\n                    showSignalLightColor = d.color;\n                    theCellColor = d.color;\n                  }\n                } else if (_DataFocusMethod.isNumber(d.start)) {\n                  if (d.start <= columnValue) {\n                    if (!d.shape || d.shape === \"default\") {\n                      showSignalLight = originalHeader.entireShape;\n                    } else {\n                      showSignalLight = d.shape;\n                    }\n                    showSignalLightColor = d.color;\n                    theCellColor = d.color;\n                  }\n                } else if (_DataFocusMethod.isNumber(d.end)) {\n                  if (columnValue <= d.end) {\n                    if (!d.shape || d.shape === \"default\") {\n                      showSignalLight = originalHeader.entireShape;\n                    } else {\n                      showSignalLight = d.shape;\n                    }\n                    showSignalLightColor = d.color;\n                    theCellColor = d.color;\n                  }\n                }\n              });\n            }\n          } else {\n            originalHeader.colorFormattings.forEach(function (d) {\n              if (d.text) {\n                if (!d.reverse && columnValue.toLowerCase().indexOf(d.text.toLowerCase()) > -1 || d.reverse && columnValue.toLowerCase().indexOf(d.text.toLowerCase()) === -1) {\n                  if (!d.shape || d.shape === \"default\") {\n                    showSignalLight = originalHeader.entireShape;\n                  } else {\n                    showSignalLight = d.shape;\n                  }\n                  showSignalLightColor = d.color;\n                  theCellColor = d.color;\n                }\n              }\n            });\n          }\n          if (showSignalLightColor === \"red\") {\n            showSignalLightColor = \"#FF4040\";\n          }\n        }\n\n        // 通过计算的颜色规则参数，获取单元格内容\n        let theCellText = '',\n          theCellIcon = '';\n        // 单元格内容\n        if (!showSignalLight || showSignalLight === \"text\" || showSignalLight === \"default\") {\n          theCellText += !isNullFlag ? _DataFocusMethod.translateIllegalStr(formatValue, {\n            showUnicodeFlag: true\n          }) : '';\n        } else {\n          let transformStyle = \"transform: scale(2);transform-origin: 50% 50%;margin:5px;\";\n          let shapeText = \"\";\n          // // 如果需要显示图文结合的内容，才给shapeText赋值\n          // if(chartConfig.signalLightTempRomove){\n          //     transformStyle=\"margin-left:5px;transform: scale(1.5);transform-origin: 50% 50%;\";\n          //     shapeText=!isNullFlag?_DataFocusMethod.translateIllegalStr(formatValue , {showUnicodeFlag: true}):'';\n          // }\n          if (showSignalLight === \"circle\") {\n            theCellText += shapeText;\n            theCellIcon += '<span style=\"display: inline-block;margin-left:2px;' + transformStyle + '\"> ●</span>';\n            // theCellIcon += ' ●';\n          } else if (showSignalLight === \"square\") {\n            theCellText += shapeText;\n            theCellIcon += '<span style=\"display: inline-block;margin-left:2px;' + transformStyle + '\"> ■</span>';\n            // theCellIcon += ' ■';\n          } else if (showSignalLight === \"tangle\") {\n            transformStyle = \"transform: scale(1.3);transform-origin: 50% 50%;\";\n            theCellText += shapeText;\n            theCellIcon += '<span style=\"display: inline-block;' + transformStyle + '\"> ▲</span>';\n            // theCellIcon += ' ▲';\n          } else if (showSignalLight === \"up_arrow\") {\n            theCellText += shapeText;\n            theCellIcon += \" ↑\";\n          } else if (showSignalLight === \"low_arrow\") {\n            theCellText += shapeText;\n            theCellIcon += \" ↓\";\n          }\n        }\n        if (originalHeader.headerSetting && originalHeader.headerSetting.displayType === 'image') {\n          let theCellUniqueId = 'table-cell-' + originalHeader.idx + _DataFocusMethod.getUUID();\n          let theWidthScale = parseInt(originalHeader.headerSetting.widthScale) || 1;\n          let theHeightScale = parseInt(originalHeader.headerSetting.heightScale) || 1;\n          let theHeightPercent = parseInt(originalHeader.headerSetting.heightPercent) || 90;\n          let theImageContainer = document.createElement('div');\n          theImageContainer.style = 'display:flex;justify-content:center;align-items:center;margin:auto;';\n          theImageContainer.className = 'table-image-cell disabled ' + theCellUniqueId;\n          if (/^http[s]?:\\/\\/\\w*/.test(columnValue)) {\n            // 如果图片地址是外部地址，则加载完成后显示\n            let theRealImage = new Image();\n            theRealImage.src = columnValue;\n            theRealImage.width = cellHeight * (theHeightPercent / 100) * (theWidthScale / theHeightScale);\n            theRealImage.height = cellHeight * (theHeightPercent / 100);\n            theRealImage.onload = function (data) {\n              svgDiv.find(\".\" + theCellUniqueId).attr('class', '').html('').append(theRealImage);\n            };\n            theRealImage.onerror = function (error) {\n              svgDiv.find(\".\" + theCellUniqueId).attr('class', '').html('<div class=\"focus-icon icon-picture\" style=\"opacity:0.4;font-size: ' + (ch * 0.6 + 'px') + '\"></div>' + theCellIcon);\n            };\n            theInnerText += theImageContainer.outerHTML + theCellIcon;\n          } else if (/^data:image\\/\\w*/.test(columnValue)) {\n            let theImage = new Image();\n            theImage.src = columnValue;\n            theImage.width = cellHeight * (theHeightPercent / 100) * (theWidthScale / theHeightScale);\n            theImage.height = cellHeight * (theHeightPercent / 100);\n            theImageContainer.className = '';\n            theImageContainer.appendChild(theImage);\n            theInnerText += theImageContainer.outerHTML + theCellIcon;\n          } else {\n            theInnerText += '<div class=\"focus-icon icon-picture\" style=\"opacity:0.4;font-size: ' + (cellHeight * 0.6 + 'px') + '\"></div>' + theCellIcon;\n          }\n        } else {\n          theInnerText += theCellText + theCellIcon;\n        }\n      }\n      theInnerHTML += (theInnerText ? theInnerText : '-') + '</div>';\n      curRect.innerHTML = theInnerHTML;\n      theCellStyle += 'color:' + theCellColor + '; ';\n      curRect.style = theCellStyle;\n      return curRect;\n    }\n\n    /**\r\n     * 生成DIV元素的拖拽线\r\n     * @param   options     -   生成拖拽先的位置信息\r\n     *          {\r\n     *              cx          -   在svgDiv中的left的绝对位置\r\n     *              cy          -   在svgDiv中的top的绝对位置\r\n     *              cw          -   宽度\r\n     *              ch          -   高度\r\n     *              className   -   类名\r\n     *              cursor      -   鼠标移入的手势\r\n     *          }\r\n     * @return DIV DOM元素\r\n     * **/\n    function generateDragLineDom(options) {\n      let cw = options.cw;\n      let ch = options.ch;\n      let cx = options.cx;\n      let cy = options.cy;\n      let cursor = options.cursor;\n      let className = options.className;\n      let theDragLine = document.createElement('div');\n      theDragLine.className = className;\n      let theLineStyle = 'position:absolute;display:block;';\n      theLineStyle += 'left:' + cx + 'px; ';\n      theLineStyle += 'top:' + cy + 'px; ';\n      theLineStyle += 'width:' + cw + 'px; ';\n      theLineStyle += 'height:' + ch + 'px; ';\n      theLineStyle += 'cursor:' + cursor + ';';\n      theDragLine.style = theLineStyle;\n      return theDragLine;\n    }\n\n    // 生成不同类型的数值 总和，最大值，最小值，平均值 ...\n    function generateTotal(valueList, header) {\n      if (!valueList) return false;\n      let theHeaderSetting = header && header.headerSetting;\n      let theOperate = theHeaderSetting && theHeaderSetting.totalOperator1 || 'sum';\n      let theReturnValue = '';\n      switch (theOperate) {\n        case 'sum':\n          theReturnValue = _DataFocusMethod.calcSum(valueList);\n          break;\n        case 'min':\n          theReturnValue = _DataFocusMethod.calcMin(valueList);\n          break;\n        case 'max':\n          theReturnValue = _DataFocusMethod.calcMax(valueList);\n          break;\n        case 'average':\n          theReturnValue = _DataFocusMethod.calcAverage(valueList);\n          break;\n        case 'std_deviation':\n          theReturnValue = _DataFocusMethod.calcStd(valueList);\n          break;\n        case 'variance':\n          theReturnValue = _DataFocusMethod.calcVariance(valueList);\n          break;\n      }\n      return theReturnValue;\n    }\n    let endTime = new Date().getTime();\n    console.log('画当前交叉表需要的时间是' + (endTime - startTime) + 'ms');\n  },\n  getTemplateData: function () {\n    let theTemplateData = {\n      headers: [{\n        idx: 0,\n        col_id: '10001',\n        col_uuid: '10001',\n        col_name: '样例行数据',\n        data_type: 'string',\n        operator: '',\n        geo_type: '',\n        col_type: 'ATTRIBUTE',\n        distincts: [\"样例列数据1\", \"样例列数据2\", \"样例列数据3\"]\n      }, {\n        idx: 1,\n        col_id: '10002',\n        col_uuid: '10002',\n        col_name: '样例列数据',\n        data_type: 'string',\n        operator: '',\n        geo_type: '',\n        col_type: 'ATTRIBUTE',\n        distincts: [\"行数据1\", \"行数据2\", \"行数据3\", \"行数据4\", \"行数据5\", \"行数据6\", \"行数据7\", \"行数据8\", \"行数据9\", \"行数据10\", \"行数据11\", \"行数据12\", \"行数据13\"]\n      }, {\n        idx: 2,\n        col_id: '10003',\n        col_uuid: '10003',\n        col_name: '样例值',\n        data_type: 'MEASURE',\n        operator: 'SUM',\n        geo_type: '',\n        col_type: 'double'\n      }],\n      columns: [[\"样例列数据1\", \"行数据1\", 125], [\"样例列数据2\", \"行数据2\", 125], [\"样例列数据3\", \"行数据3\", 125], [\"样例列数据1\", \"行数据4\", 125], [\"样例列数据2\", \"行数据5\", 125], [\"样例列数据3\", \"行数据6\", 125], [\"样例列数据2\", \"行数据7\", 125], [\"样例列数据1\", \"行数据8\", 125], [\"样例列数据2\", \"行数据9\", 125], [\"样例列数据3\", \"行数据10\", 125], [\"样例列数据1\", \"行数据11\", 125], [\"样例列数据2\", \"行数据12\", 125], [\"样例列数据3\", \"行数据13\", 125]],\n      default_chart: {\n        type: 'crossTable',\n        rows: [0, 1],\n        columns: [0, 1],\n        values: [2]\n      },\n      charts: [{\n        type: 'crossTable',\n        rows: [0, 1],\n        columns: [0, 1],\n        values: [2]\n      }]\n    };\n    return theTemplateData;\n  },\n  // 当前图形定制的中英文[ 配置XY轴，图表配置 ] [ *新增图形必填项 ]\n  i18nObj: {\n    chinese: {\n      \"chart-name-title\": \"交叉表\",\n      \"chart-description-title\": \"至少一个属性列，至少一个数值列\",\n      \"chart-column-axis-title\": \"列数据\",\n      \"chart-row-axis-title\": \"行数据\",\n      \"chart-row-value-axis-null\": \"行数据和值不能为空\",\n      \"chart-need-all-attribute-columns\": \"当前图形需要将所有的属性列利用起来\",\n      \"category_common\": \"通用\",\n      \"category_chart_style\": \"样式\",\n      \"category_chart_cell\": \"单元格\",\n      \"category_chart_syn\": \"综合表头\",\n      \"category_chart_top\": \"顶部表头\",\n      \"category_chart_left\": \"左侧表头\",\n      \"category_chart_freeze\": \"冻结行列\",\n      \"category_chart_total\": \"总计行列\",\n      \"option_style_node_body_color\": '背景颜色',\n      \"option_style_node_body_color_desc\": \"设置单元格的背景颜色,默认是白色\",\n      \"option_style_node_border_color\": \"边框颜色\",\n      \"option_style_node_border_color_desc\": \"设置单元格的边框颜色，默认是#f5f5f5\",\n      \"option_cell_width_text\": \"自定义列宽度\",\n      \"option_cell_width_text_desc\": \"设置各个数值列的宽度 , 格式为（数值列序号：单元格宽度），例：0:120|1:60 表示第一个数值列宽度是120px , 第二个数值列宽度是60px \",\n      \"option_style_cell_width\": \"宽度\",\n      \"option_style_cell_width_desc\": \"设置单元格宽度，当单元格宽度占不满画图区域时，会等比例放大各列的宽度\",\n      \"option_style_cell_height\": \"高度\",\n      \"option_style_cell_height_desc\": \"设置单元格高度\",\n      \"option_style_cell_font_size\": \"字体大小\",\n      \"option_style_cell_font_size_desc\": \"设置单元格字体大小\",\n      \"option_style_cell_font_color\": \"字体颜色\",\n      \"option_style_cell_font_color_desc\": \"设置单元格字体颜色\",\n      \"option_syn_content_text\": \"自定义综合表头\",\n      \"option_syn_content_text_desc\": \"设置左上角表头的分割线内容，默认是将所有行列内容全部显示，例: 顶部|中间值|左侧\",\n      \"option_syn_split_type\": \"分隔方式\",\n      \"option_syn_split_type_desc\": \"设置综合表头的分割方式\",\n      \"option_syn_split_top\": \"从左上到右下发散\",\n      \"option_syn_split_bottom\": \"从左下到右上发散\",\n      \"option_style_syn_color\": \"背景颜色\",\n      \"option_style_syn_color_desc\": \"设置综合表头背景颜色\",\n      \"option_style_syn_border_color\": \"边框颜色\",\n      \"option_style_syn_border_color_desc\": \"设置综合表头边框颜色\",\n      \"option_syn_header_width\": \"宽度单元\",\n      \"option_syn_header_width_desc\": \"设置左侧表头内单元格的宽度，其和为综合表格的宽度\",\n      \"option_syn_header_height\": \"高度单元\",\n      \"option_syn_header_height_desc\": \"设置顶部表头内单元格的高度，其和为综合表头的高度\",\n      \"option_syn_font_size\": \"字体大小\",\n      \"option_syn_font_size_desc\": \"设置综合表头字体大小\",\n      \"option_syn_font_color\": \"字体颜色\",\n      \"option_syn_font_color_desc\": \"设置综合表头字体颜色\",\n      \"option_style_top_header_color\": \"背景颜色\",\n      \"option_style_top_header_color_desc\": \"设置顶部表头背景颜色\",\n      \"option_style_top_header_border_color\": \"边框颜色\",\n      \"option_style_top_header_border_color_desc\": \"设置顶部表头边框颜色\",\n      \"option_top_header_font_size\": \"字体大小\",\n      \"option_top_header_font_size_desc\": \"设置顶部表头字体大小\",\n      \"option_top_header_font_color\": \"字体颜色\",\n      \"option_top_header_font_color_desc\": \"设置顶部表头字体颜色\",\n      \"option_style_left_header_color\": \"背景颜色\",\n      \"option_style_left_header_color_desc\": '设置左侧表头颜色',\n      \"option_style_left_header_border_color\": \"边框颜色\",\n      \"option_style_left_header_border_color_desc\": \"设置左侧表头边框颜色\",\n      \"option_left_header_font_size\": \"字体大小\",\n      \"option_left_header_font_size_desc\": \"设置左侧表头字体大小\",\n      \"option_left_header_font_color\": \"字体颜色\",\n      \"option_left_header_font_color_desc\": \"设置左侧表头字体颜色\",\n      \"option_all_border_width\": \"边框宽度\",\n      \"option_all_border_width_desc\": \"边框宽度\",\n      \"option_show_row_number\": \"显示行号\",\n      \"option_show_row_number_desc\": \"显示行号\",\n      \"option_show_column_number\": \"显示列号\",\n      \"option_show_column_number_desc\": \"显示列号\",\n      \"option_freeze_row_content\": \"冻结行数\",\n      \"option_freeze_row_content_desc\": \"设置需要冻结的前N行\",\n      \"option_freeze_column_content\": \"冻结列数\",\n      \"option_freeze_column_content_desc\": \"设置需要冻结的前N列\",\n      \"option_style_freeze_row_color\": \"背景颜色\",\n      \"option_style_freeze_row_color_desc\": \"设置冻结行列的背景颜色\",\n      \"option_style_freeze_row_border_color\": \"边框颜色\",\n      \"option_style_freeze_row_border_color_desc\": \"设置冻结行列的边框颜色\",\n      \"option_freeze_row_font_size\": \"字体大小\",\n      \"option_freeze_row_font_size_desc\": \"设置冻结行列的字体大小\",\n      \"option_freeze_row_font_color\": \"字体颜色\",\n      \"option_freeze_row_font_color_desc\": \"设置冻结行列的字体颜色\",\n      \"option_show_total_row\": \"显示总计行\",\n      \"option_show_total_row_desc\": \"配置显示总计行及合计行，默认为不显示\",\n      \"option_total_row_position\": \"总计行位置\",\n      \"option_option_total_row_position_desc\": \"总计行位置\",\n      \"option_total_row_position_first\": \"首行\",\n      \"option_total_row_position_last\": \"尾行\",\n      \"option_total_row_label\": \"合计行内容\",\n      \"option_total_row_label_desc\": \"设置合计行的显示内容，默认为总计\",\n      \"option_show_total_column\": \"显示总计列\",\n      \"option_show_total_column_desc\": \"配置显示总计列及和合计列，默认为不显示\",\n      \"option_total_column_position\": \"总计列位置\",\n      \"option_option_total_column_position_desc\": \"总计列位置\",\n      \"option_total_column_position_first\": \"左侧\",\n      \"option_total_column_position_last\": \"右侧\",\n      \"option_chart_config_restart\": \"恢复默认配置\"\n    },\n    english: {\n      \"chart-name-title\": \"Cross Table\",\n      \"chart-description-title\": \"at least one attribute column and one measure column \",\n      \"chart-column-axis-title\": \"Column data\",\n      \"chart-row-axis-title\": \"Row data\",\n      \"chart-row-value-axis-null\": \"Row data and value cannot be empty\",\n      \"chart-need-all-attribute-columns\": \"The current chart needs to make use of all attribute columns\",\n      \"category_common\": \"General\",\n      \"category_chart_style\": \"Style\",\n      \"category_chart_cell\": \"Cell\",\n      \"category_chart_syn\": \"Top Left Header\",\n      \"category_chart_top\": \"Top Header\",\n      \"category_chart_left\": \"Left Header\",\n      \"category_chart_freeze\": \"Freeze columns & rows\",\n      \"category_chart_total\": \"Total columns & rows\",\n      \"option_style_node_body_color\": 'Cell background',\n      \"option_style_node_body_color_desc\": \"Set the background of scrolling cell\",\n      \"option_style_node_border_color\": \"Border color\",\n      \"option_style_node_border_color_desc\": \"Set the color of the border color\",\n      \"option_cell_width_text\": \"Cell Width\",\n      \"option_cell_width_text_desc\": \"Set the width of each numerical column in the format (numerical column serial number: cell width). For example, 0:120 × 1:60 means that the width of the first numerical column is 120px and the width of the second numerical column is 60px\",\n      \"option_style_cell_width\": \"Cell Width\",\n      \"option_style_cell_width_desc\": \"Set the cell width. When the cell width does not occupy the drawing area, the width of each column will be enlarged in equal proportion\",\n      \"option_style_cell_height\": \"Cell Height\",\n      \"option_style_cell_height_desc\": \"Set the cell height\",\n      \"option_style_cell_font_size\": \"Font Size\",\n      \"option_style_cell_font_size_desc\": \"Set the font size in cross table\",\n      \"option_style_cell_font_color\": \"Font color\",\n      \"option_style_cell_font_color_desc\": \"Set the font color in cross table\",\n      \"option_syn_content_text\": \"Define comprehensive header\",\n      \"option_syn_content_text_desc\": \"Set the content of the dividing line in the header at the upper left corner. By default, all the contents of all rows and columns are displayed, for example: top | content | left\",\n      \"option_syn_split_type\": \"Display type\",\n      \"option_syn_split_type_desc\": \"Set the display mode of comprehensive header\",\n      \"option_syn_split_top\": \"From left top to right bottom\",\n      \"option_syn_split_bottom\": \"From left bottom to right top\",\n      \"option_style_syn_color\": \"Comprehensive background\",\n      \"option_style_syn_color_desc\": \"Set the background color of comprehensive header\",\n      \"option_style_syn_border_color\": \"Comprehensive border background\",\n      \"option_style_syn_border_color_desc\": \"Set the border color of comprehensive header\",\n      \"option_syn_header_width\": \"Comprehensive width unit\",\n      \"option_syn_header_width_desc\": \"Set the width of each left header, and its sum is the comprehensive width\",\n      \"option_syn_header_height\": \"Comprehensive height unit\",\n      \"option_syn_header_height_desc\": \"Set the height of each top header, and its sum is the comprehensive height\",\n      \"option_syn_font_size\": \"Comprehensive font size\",\n      \"option_syn_font_size_desc\": \"Set the font size of comprehensive header\",\n      \"option_syn_font_color\": \"Comprehensive font color\",\n      \"option_syn_font_color_desc\": \"Set the font color of comprehensive header\",\n      \"option_style_top_header_color\": \"Top header background\",\n      \"option_style_top_header_color_desc\": \"Set the background color of the top right header\",\n      \"option_style_top_header_border_color\": \"Top header border\",\n      \"option_style_top_header_border_color_desc\": \"Set the border color of the top right header\",\n      \"option_top_header_font_size\": \"Top header font size\",\n      \"option_top_header_font_size_desc\": \"Set the font size of the top header cell\",\n      \"option_top_header_font_color\": \"Top header color\",\n      \"option_top_header_font_color_desc\": \"Set the font color of the top header cell\",\n      \"option_style_left_header_color\": \"Left header background\",\n      \"option_style_left_header_color_desc\": 'Set the background color of the left header cell',\n      \"option_style_left_header_border_color\": \"Left header border\",\n      \"option_style_left_header_border_color_desc\": \"Set the border color of the left header cell\",\n      \"option_left_header_font_size\": \"Left header font size\",\n      \"option_left_header_font_size_desc\": \"Set the font size of the left header cell\",\n      \"option_left_header_font_color\": \"Left header color\",\n      \"option_left_header_font_color_desc\": \"Set the font color of the left header cell\",\n      \"option_all_border_width\": \"Border width\",\n      \"option_all_border_width_desc\": \"Set the border width of the cross table cell\",\n      \"option_show_row_number\": \"显示行号\",\n      \"option_show_row_number_desc\": \"显示行号\",\n      \"option_show_column_number\": \"显示列号\",\n      \"option_show_column_number_desc\": \"显示列号\",\n      \"option_freeze_row_content\": \"Freeze row\",\n      \"option_freeze_row_content_desc\": \"Set the number of frozen rows\",\n      \"option_freeze_column_content\": \"Freeze column\",\n      \"option_freeze_column_content_desc\": \"Set the number of frozen columns\",\n      \"option_style_freeze_row_color\": \"Freeze row background\",\n      \"option_style_freeze_row_color_desc\": \"Set the background color of freeze row cell \",\n      \"option_style_freeze_row_border_color\": \"Freeze row border\",\n      \"option_style_freeze_row_border_color_desc\": \"Set the border color of freeze row cell \",\n      \"option_freeze_row_font_size\": \"Freeze font size\",\n      \"option_freeze_row_font_size_desc\": \"Set the font size of freeze row cell\",\n      \"option_freeze_row_font_color\": \"Freeze font color\",\n      \"option_freeze_row_font_color_desc\": \"Set the font color of freeze row cell\",\n      // \"option_style_freeze_column_color\": \"冻结列背景颜色\",\n      // \"option_style_freeze_column_color_desc\": '设置冻结列颜色',\n      //\n      // \"option_style_freeze_column_border_color\": \"冻结列边框颜色\",\n      // \"option_style_freeze_column_border_color_desc\": \"设置冻结列边框颜色\",\n      //\n      // \"option_freeze_column_font_size\": \"冻结列字体大小\",\n      // \"option_freeze_column_font_size_desc\": \"设置冻结列字体大小\",\n      //\n      // \"option_freeze_column_font_color\": \"冻结列字体颜色\",\n      // \"option_freeze_column_font_color_desc\": \"设置冻结列字体颜色\",\n\n      \"option_show_total_row\": \"Show total row\",\n      \"option_show_total_row_desc\": \"show the total row of the table \",\n      \"option_total_row_position\": \"total row position\",\n      \"option_option_total_row_position_desc\": \"set the total row position of the cross table , default id before\",\n      \"option_total_row_position_first\": \"Before\",\n      \"option_total_row_position_last\": \"After\",\n      // \"option_style_bubble_radius_max\": \"节点最大半径\",\n      // \"option_style_bubble_radius_max_desc\": \"节点最大半径\",\n      // \"option_style_bubble_radius_min\": \"节点最小半径\",\n      // \"option_style_bubble_radius_min_desc\": \"节点最小半径\",\n\n      \"option_chart_config_restart\": \"Reset default\"\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.senior/crossTable.js?");

/***/ })

}]);