(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[21],{

/***/ "../src-v5/assets/js/charts.system.basic/line/LineChartComponent.js":
/*!**************************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/line/LineChartComponent.js ***!
  \**************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/* harmony import */ var _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n// 辅助折线图画图的组件\n\n\n\n\n// 通用的动画化函数\n/**\r\n *\r\n * @param timing - 动画曲线函数\r\n * @param draw - 绘制一帧（接收progress,0-1之间）\r\n * @param duration - 动画持续的时间\r\n */\nfunction animate({\n  timing,\n  draw,\n  duration\n}) {\n  let start = performance.now();\n  requestAnimationFrame(function animate(time) {\n    // timeFraction 从 0 增加到 1\n    let timeFraction = (time - start) / duration;\n    if (timeFraction > 1) timeFraction = 1;\n\n    // 计算当前动画状态\n    let progress = timing(timeFraction);\n    draw(progress); // 绘制当前帧\n\n    if (timeFraction < 1) {\n      requestAnimationFrame(animate);\n    }\n  });\n}\nfunction colorRgb(str, transparent = 1) {\n  // 16进制颜色值的正则\n  var reg = /^#([0-9a-fA-f]{3}|[0-9a-fA-f]{6})$/;\n  // 把颜色值变成小写\n  var color = str;\n  if (reg.test(color)) {\n    // 如果只有三位的值，需变成六位，如：#fff => #ffffff\n    if (color.length === 4) {\n      var colorNew = \"#\";\n      for (var i = 1; i < 4; i += 1) {\n        colorNew += color.slice(i, i + 1).concat(color.slice(i, i + 1));\n      }\n      color = colorNew;\n    }\n    // 处理六位的颜色值，转为RGB\n    var colorChange = [];\n    for (var i = 1; i < 7; i += 2) {\n      colorChange.push(parseInt(\"0x\" + color.slice(i, i + 2)));\n    }\n    return \"rgba(\" + colorChange.join(\",\") + \",\" + transparent + \")\";\n  } else {\n    return color;\n  }\n}\nconst LineChartComponent = {\n  // 获取折线上的点数据\n  getLineDataSet: function (chartSetData, options = {}) {\n    if (!chartSetData || !chartSetData.length) return false;\n    if (!options.attributeXAxis || !options.attributeXAxis.scale || !options.measureYAxis || !options.measureYAxis.firstMeasureScaleFunc || !options.curYAxis) return false;\n    let measureYScaleFunc = options.curYAxis.direction === 'right' ? options.measureYAxis.secondMeasureScaleFunc : options.measureYAxis.firstMeasureScaleFunc;\n    let attributeXScaleFunc = options.attributeXAxis.scale,\n      rangeBand = options.attributeXAxis.rangeBand || 0,\n      legendConfig = options.legendConfig || {},\n      scatterRadius = parseFloat(options.scatterRadius) || 5;\n    let theMax = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].max(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      }),\n      theMin = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].min(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      });\n    let linePath = [];\n    chartSetData.forEach(function (curData) {\n      if (!curData) return false;\n      let theXValue = curData.x0,\n        theYValue = curData['y' + options.yIndex];\n      if (_DataFocusMethod.isPureNumber(theYValue)) {\n        let theOX = attributeXScaleFunc(curData.x0) + rangeBand / 2,\n          theOY = measureYScaleFunc(curData['y' + options.yIndex]);\n        let theColor = legendConfig.color;\n        // Y轴的颜色规则\n        if (options.curYAxis.header && options.curYAxis.header.colorFormattings) {\n          let theYColorFormats = options.curYAxis.header.colorFormattings;\n          let curColor = _DataFocusMethod.calcTheColor(theYValue, theYColorFormats, {\n            rowData: curData.rowData\n          });\n          if (curColor) theColor = curColor;\n        }\n\n        // 当前点是警告点的情况下 , 则需要使用svg画该点，加上闪烁效果\n        if (curData[\"alarm\" + options.yIndex] || curData[\"alarm_x_0\"]) {\n          theColor = 'transparent';\n        }\n        const point = {\n          ox: theOX,\n          oy: theOY,\n          zeroY: measureYScaleFunc(0),\n          color: theColor,\n          radius: scatterRadius,\n          yIndex: options.yIndex,\n          x0: curData.x0,\n          [`y${options.yIndex}`]: curData['y' + options.yIndex],\n          legendType: options.legendType,\n          legendValue: options.legendValue,\n          legendIndex: options.legendIndex,\n          legendConfig: options.legendConfig,\n          legendId: options.legendId,\n          legendTotal: chartSetData.total,\n          rowData: curData.rowData,\n          rowIndex: curData.rowIndex,\n          isForecastFlag: curData.isForecastFlag,\n          isAlarmFlag: curData[\"alarm\" + options.yIndex],\n          isMaxFlag: curData['y' + options.yIndex] === theMax,\n          isMinFlag: curData['y' + options.yIndex] === theMin\n        };\n        linePath.push(point);\n      }\n    });\n\n    // 对点按X轴从小到大排序\n    linePath.sort(function (a, b) {\n      return a.ox - b.ox;\n    });\n    return {\n      points: linePath,\n      yIndex: options.yIndex,\n      legendType: options.legendType,\n      legendValue: options.legendValue,\n      legendIndex: options.legendIndex,\n      legendConfig: options.legendConfig,\n      legendId: options.legendId,\n      legendTotal: chartSetData.total,\n      dashedFlag: options.dashedFlag,\n      // 当前图例是否开启dashFlag\n      showShadowFlag: options.showShadowFlag // 线条是否开启阴影\n    };\n  },\n  /**\r\n   * 在Canvas中画散点，无需分页，直接画所有数据【主要应对散点数据过多的情况，在svg中数据过多会导致标签过多从而导致浏览器崩溃】\r\n   * @param chartSetData  -   所有三点数据\r\n   * @param options\r\n   *          {\r\n   *              canvasContext   -  当前的canvas画图上下文\r\n   *              d3SvgContainer  -  当前的 d3 svg-dom 容器，用来绘制线条\r\n   *              pathGroup   -  线条和阴影群组\r\n   *\r\n   *              canvasZoom      -   当前canvas的缩放大小\r\n   *\r\n   *              animateFlag             -   是否需要动画\r\n   *\r\n   *              mouseoverCallback           -    鼠标移入事件的响应方法\r\n   *              mouseoutCallback            -    鼠标移出事件的响应方法\r\n   *              mousedownCallback           -    鼠标点击事件的响应方法\r\n   *          }\r\n   * */\n  drawLine: function (scatterDataSet, options) {\n    if (!scatterDataSet || !scatterDataSet.length) return false;\n    options = options || {};\n\n    // canvas 容器\n    if (!options.canvasContext) return false;\n    // svg 容器\n    if (!options.d3SvgContainer) return false;\n    // 线条和阴影的 group\n    if (!options.pathGroup) return false;\n    const chartUUID = options.chartUUID;\n    const duration = options.duration;\n    let canvasContext = options.canvasContext,\n      canvasZoom = parseFloat(options.canvasZoom) || 2,\n      animateFlag = !!options.animateFlag && !options.currentLegendValue && !options.currentLegendId,\n      // 不是高亮图例才绘制动画\n      currentLegendValue = options.currentLegendValue,\n      currentLegendId = options.currentLegendId,\n      selectedScatterIndex = parseInt(options.selectedScatterIndex),\n      //  当前鼠标移入的高亮点，在没有节点的情况下，显示节点处的原点\n      alarmContainer = options.alarmContainer,\n      alarmXOffset = options.alarmXOffset,\n      translateLeft = options.alarmXOffset || 0,\n      isCanvasExisted = options.isCanvasExisted;\n    const d3SvgContainer = options.d3SvgContainer;\n    const pathGroup = options.pathGroup;\n    const realCanvasWidth = options.canvasWidth * canvasZoom;\n    const realCanvasHeight = options.canvasHeight * canvasZoom;\n    if (currentLegendId !== undefined && currentLegendId !== null) {\n      // console.info('高亮图例：' , currentLegendId);\n      scatterDataSet.sort((legendData1, legendData2) => {\n        if (legendData1.legendId === currentLegendId && legendData2.legendId !== currentLegendId) {\n          return 1;\n        }\n        if (legendData1.legendId !== currentLegendId && legendData2.legendId === currentLegendId) {\n          return -1;\n        }\n      });\n    }\n    const pointPositionAccessorForSvg = {\n      x: d => d.ox,\n      y: d => d.oy\n    };\n    const pointPositionAccessorForCanvas = {\n      x: d => d.ox * canvasZoom,\n      y: d => (d.oy + 10) * canvasZoom // 画布上间距10像素\n    };\n\n    // 计算线条，统计线条长度\n    for (const legendData of scatterDataSet) {\n      const pointsOfCurLegend = legendData.points; // 当前图例的所有点\n      // 常规点\n      let theNormalPointsOfCurLegend = pointsOfCurLegend.filter(point => !point.isForecastFlag);\n      // 预测点\n      let theForecastPointsOfCurLegend = [],\n        prevPoint = null;\n      for (let i = 0; i < pointsOfCurLegend.length; i++) {\n        let thePoint = pointsOfCurLegend[i];\n        // 将预测点的前一个点也加入到预测点，用于连线\n        if (thePoint.isForecastFlag) {\n          if (!theForecastPointsOfCurLegend.length && prevPoint) theForecastPointsOfCurLegend.push(prevPoint);\n          theForecastPointsOfCurLegend.push(thePoint);\n        }\n        prevPoint = thePoint;\n      }\n      const lineGenerator = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].line().x(pointPositionAccessorForSvg.x).y(pointPositionAccessorForSvg.y);\n      const areaGenerator = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].area().x(pointPositionAccessorForSvg.x).y0(d => d.zeroY).y1(pointPositionAccessorForSvg.y);\n      // 设置线条生成器\n      const curveGeneratorMap = {\n        'step': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveStep,\n        'step-before': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveStepBefore,\n        'step-after': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveStepAfter,\n        'curve-basis': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveBasis,\n        'curve-natural': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveNatural,\n        'curve-monotone-x': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveMonotoneX,\n        // 两点间基于Y的曲线拥有单调性，极值只会出现在起始点或结束点\n        'curve-monotone-y': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveMonotoneY,\n        // 两点间基于X的曲线拥有单调性，极值只会出现在起始点或结束点\n        'curve-bump-x': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].curveBumpX\n      };\n      if (curveGeneratorMap[options.lineStyle]) {\n        lineGenerator.curve(curveGeneratorMap[options.lineStyle]);\n        areaGenerator.curve(curveGeneratorMap[options.lineStyle]);\n      }\n\n      // ===============================  计算常规点的线条的path数据  ===============================\n      // 常规点的线条path数据\n      const pathData = lineGenerator(theNormalPointsOfCurLegend);\n      // 常规点的线条area数据\n      const areaData = areaGenerator(theNormalPointsOfCurLegend);\n\n      // ===============================  计算预测点的线条的path数据  ===============================\n      // 预测点的线条path数据\n      const forecastPathData = lineGenerator(theForecastPointsOfCurLegend);\n      // 预测点的线条area数据\n      const forecastAreaData = areaGenerator(theForecastPointsOfCurLegend);\n\n      // 常规点的canvas 中检测的 pathData： 将theNormalPointsOfCurLegend折线有一个结束点\n      lineGenerator.x(pointPositionAccessorForCanvas.x);\n      lineGenerator.y(pointPositionAccessorForCanvas.y);\n      const canvasPathData = lineGenerator(theNormalPointsOfCurLegend);\n      const forecastCanvasPathData = lineGenerator(theForecastPointsOfCurLegend);\n      legendData.path = {\n        pathData: pathData,\n        areaData: areaData,\n        canvasPathData: canvasPathData\n      };\n      legendData.forecastPath = {\n        pathData: forecastPathData,\n        areaData: forecastAreaData,\n        canvasPathData: forecastCanvasPathData\n      };\n    }\n\n    // 绘制svg线条\n    function drawSvg() {\n      // 为线条设置样式\n      function setStyleForLinePath(selection) {\n        selection.attr('d', legendData => {\n          const {\n            pathData\n          } = legendData.path;\n          return pathData || '';\n        }).attr('stroke', legendData => {\n          let colorOfCurLegend = legendData.legendConfig.color; // 当前图例的颜色\n          if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n            colorOfCurLegend = '#eeeeee';\n            colorOfCurLegend = 'transparent';\n          }\n          return colorOfCurLegend;\n        }).attr('data-line-path', 'true').attr('data-legend-value', legendData => {\n          return legendData.legendValue;\n        }).attr('stroke-width', options.lineWidth || 1).attr('fill', 'transparent').attr('stroke-dasharray', legendData => {\n          const dashOfCurLegend = legendData.legendConfig.dash; // 当前图例线条的虚实\n          if (dashOfCurLegend !== undefined) {\n            if (dashOfCurLegend === 'option_dashed_solid_of_line_dashed') {\n              return '10 5';\n            } else if (dashOfCurLegend === 'option_dashed_solid_of_line_solid') {\n              return '';\n            }\n          }\n          return options.lineDashedFlag ? '10 5' : '';\n        }).attr('stroke-linejoin', 'round')\n        // .raise();\n        ;\n      }\n      function setClipPathForPath(path) {\n        path.each(function () {\n          const uuid = _DataFocusMethod.getUUID();\n          const clipPathId = `line-clip-path-${uuid}`;\n          const defsId = `defs-${uuid}`;\n          const scaleMeasureHeight = realCanvasHeight;\n          const scaleAttributeWidth = realCanvasWidth;\n          d3SvgContainer.append('defs').attr('id', defsId).append('clipPath').attr('id', clipPathId).append('path').attr('d', () => {\n            return `M${0} 0L0 0L0 ${scaleMeasureHeight}L0 ${scaleMeasureHeight}Z`;\n          }).transition().duration(duration.pathEnter).ease(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].easeLinear).attr('d', () => {\n            return `M${0} 0L${realCanvasWidth / 2} 0L${realCanvasWidth / 2} ${scaleMeasureHeight}L0 ${scaleMeasureHeight}Z`;\n          }).on('end', function () {\n            // 移除当前 clip-path 的 defs\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].select(`#${defsId}`).remove();\n          });\n\n          // 为当前线条设置clip-path 开启动画\n          _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].select(this).attr('clip-path', `url(#${clipPathId})`);\n        });\n      }\n\n      // 绘制阴影\n      (() => {\n        function setStyleForAreaPath(selection) {\n          selection.attr('d', legendData => {\n            const {\n              areaData\n            } = legendData.path;\n            return areaData || '';\n          }).attr('stroke', 'transparent').attr('data-area-path', 'true').attr('stroke-linejoin', 'round').attr('fill', (legendData, index) => {\n            return `url('#shadow-gradient-${chartUUID}-${legendData.legendValue}')`;\n          });\n        }\n        const scatterDataSetWithShadow = scatterDataSet.filter(legendData => {\n          const shadowOfCurLegend = legendData.legendConfig.shadow; // 当前图例线条的阴影\n\n          if (shadowOfCurLegend !== undefined) {\n            return shadowOfCurLegend;\n          } else {\n            return options.drawShadowFlag;\n          }\n        });\n\n        // defs container\n        const gradientShadowDefs = d3SvgContainer.selectAll('defs.gradient-defs').data(scatterDataSetWithShadow.length ? [true] : [], legendData => legendData.legendId).join(enter => enter.append('defs').classed('gradient-defs', true), update => update, exit => exit.remove());\n\n        // 构造阴影渐变的定义\n        function setStopColorForGradient(gradient) {\n          gradient.each(function (legendData) {\n            // 当前图例的颜色\n            let colorOfCurLegend = legendData.legendConfig.color; // 当前图例的颜色\n            if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n              colorOfCurLegend = '#eeeeee';\n              colorOfCurLegend = 'transparent';\n            }\n            let rgbColor = _DataFocusMethod.formatRgbColor(colorOfCurLegend);\n\n            // 设置起始渐变\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].select(this).selectAll('stop').data([0, 1]).join(enter => enter.append('stop').attr('offset', (_, index) => {\n              return index === 0 ? '5%' : '95%';\n            }).attr('stop-color', (_, index) => {\n              return index === 0 ? colorRgb(rgbColor, 0.9) : colorRgb(rgbColor, 0.15);\n            }), update => update.transition().duration(duration.update).attr('stop-color', (_, index) => {\n              return index === 0 ? colorRgb(rgbColor, 0.9) : colorRgb(rgbColor, 0.15);\n            }), exit => exit.remove());\n          });\n        }\n        const gradientsDefs = gradientShadowDefs.selectAll('linearGradient.gradient').data(scatterDataSetWithShadow, legendData => legendData.legendId).join(enter => {\n          const gradient = enter.append('linearGradient').attr('class', legendData => `gradient ${legendData.legendId}`).attr('gradientTransform', 'rotate(90)').attr('id', (legendData, index) => {\n            return `shadow-gradient-${chartUUID}-${legendData.legendValue}`;\n          }).call(setStopColorForGradient);\n          return gradient;\n        }, update => {\n          const gradient = update.call(setStopColorForGradient);\n          return update;\n        }, exit => exit.remove());\n        const areaPaths = pathGroup.selectAll('path.area-path').data(scatterDataSetWithShadow, legendData => legendData.legendId).join(enter => {\n          // 构造渐变色\n          return enter.append('path').classed('area-path', true).attr('opacity', 0).transition().duration(duration.enter).attr('opacity', 1).call(setStyleForAreaPath).call(setClipPathForPath);\n        }, update => update.transition().duration(duration.update).call(setStyleForAreaPath), exit => exit.transition().duration(duration.exit).attr('opacity', 0).remove());\n      })();\n\n      // 绘制线条\n      (() => {\n        const linePaths = pathGroup.selectAll('path.line-path').data(scatterDataSet, legendData => legendData.legendId).join(enter => {\n          return enter.append('path').classed('line-path', true).call(setStyleForLinePath).call(setClipPathForPath);\n        }, update => update.transition().duration(duration.update).call(setStyleForLinePath), exit => exit.transition().duration(duration.exit).attr('opacity', 0).remove());\n      })();\n    }\n    // 绘制预测的svg线条\n    function drawForecastSvg() {\n      // 为线条设置样式\n      function setStyleForLinePath(selection) {\n        selection.attr('d', legendData => {\n          const {\n            pathData\n          } = legendData.forecastPath;\n          return pathData || '';\n        }).attr('stroke', legendData => {\n          let colorOfCurLegend = options.forecastLineColor || legendData.legendConfig.color; // 当前图例的颜色\n          if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n            colorOfCurLegend = '#eeeeee';\n            colorOfCurLegend = 'transparent';\n          }\n          return colorOfCurLegend;\n        }).attr('data-line-path', 'true').attr('data-legend-value', legendData => {\n          return legendData.legendValue;\n        }).attr('stroke-width', (options.lineWidth || 1) + 1.5).attr('fill', 'transparent').attr('stroke-dasharray', legendData => {\n          const dashOfCurLegend = legendData.legendConfig.dash; // 当前图例线条的虚实\n          if (dashOfCurLegend !== undefined) {\n            if (dashOfCurLegend === 'option_dashed_solid_of_line_dashed') {\n              return '';\n            } else if (dashOfCurLegend === 'option_dashed_solid_of_line_solid') {\n              return '10 5';\n            }\n          }\n          return options.lineDashedFlag ? '' : '10 5';\n        }).attr('stroke-linejoin', 'round');\n      }\n      function setClipPathForPath(path) {\n        path.each(function () {\n          const uuid = _DataFocusMethod.getUUID();\n          const clipPathId = `forecast-line-clip-path-${uuid}`;\n          const defsId = `defs-${uuid}`;\n          const scaleMeasureHeight = realCanvasHeight;\n          const scaleAttributeWidth = realCanvasWidth;\n          d3SvgContainer.append('defs').attr('id', defsId).append('clipPath').attr('id', clipPathId).append('path').attr('d', () => {\n            return `M${0} 0L0 0L0 ${scaleMeasureHeight}L0 ${scaleMeasureHeight}Z`;\n          }).transition().duration(duration.pathEnter).ease(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].easeLinear).attr('d', () => {\n            return `M${0} 0L${realCanvasWidth / 2} 0L${realCanvasWidth / 2} ${scaleMeasureHeight}L0 ${scaleMeasureHeight}Z`;\n          }).on('end', function () {\n            // 移除当前 clip-path 的 defs\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].select(`#${defsId}`).remove();\n          });\n\n          // 为当前线条设置clip-path 开启动画\n          _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_2__[\"default\"].select(this).attr('clip-path', `url(#${clipPathId})`);\n        });\n      }\n\n      // 绘制线条\n      (() => {\n        const linePaths = pathGroup.selectAll('path.forecast-line-path').data(scatterDataSet, legendData => legendData.legendId).join(enter => {\n          return enter.append('path').classed('forecast-line-path', true).call(setStyleForLinePath).call(setClipPathForPath);\n        }, update => update.transition().duration(duration.update).call(setStyleForLinePath), exit => exit.transition().duration(duration.exit).attr('opacity', 0).remove());\n      })();\n    }\n\n    // 1. 绘制svg线条\n    drawSvg();\n    // 1.5. 绘制预测线条\n    drawForecastSvg();\n\n    // 2. 绘制canvas节点 并 画每个节点的数据标签\n    drawCanvasNode(1);\n\n    /** @param progress - 当前绘图的进度。 0-1 之间*/\n    function drawCanvasNode(progress) {\n      canvasContext.clearRect(0, 0, realCanvasWidth, realCanvasHeight);\n      alarmContainer.html(null);\n      canvasContext.lineWidth = options.lineWidth ? Math.max(1, options.lineWidth) * canvasZoom : 1 * canvasZoom; // 判断鼠标是否处于线条内所用的线宽\n      const currentClipWidth = realCanvasWidth * progress;\n      const clipPath = `M0,0L${currentClipWidth},0L${currentClipWidth},${realCanvasHeight}L0,${realCanvasHeight}L0,0`;\n      canvasContext.save();\n      canvasContext.clip(new Path2D(clipPath));\n      const loopSymbolArray = ['circle', 'three', 'four', 'rect', 'diamond', 'five'];\n      let loopSymbolTypeIndex = 0;\n      for (const legendData of scatterDataSet) {\n        // 当前图例的符号\n        let lineSymbolType;\n        if (options.lineSymbolType !== 'loop') {\n          lineSymbolType = options.lineSymbolType;\n        } else {\n          lineSymbolType = loopSymbolArray[loopSymbolTypeIndex % loopSymbolArray.length];\n          loopSymbolTypeIndex++;\n        }\n        let colorOfCurLegend = legendData.legendConfig.color; // 当前图例的颜色\n        const shadowOfCurLegend = legendData.legendConfig.shadow; // 当前图例线条的阴影\n        const shapeOfCurLegend = legendData.legendConfig.shape;\n        if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n          colorOfCurLegend = '#eeeeee';\n          colorOfCurLegend = 'transparent';\n        }\n        const pointsOfCurLegend = legendData.points; // 当前图例的所有点\n        canvasContext.strokeStyle = colorOfCurLegend; // 线条颜色\n\n        // 绘制点\n        const circleRadius = options.circleRadius || 5;\n        for (const point of pointsOfCurLegend) {\n          let drawCircleFlag = false;\n          // 如果当前是告警点，则绘制点\n          if (point.isAlarmFlag) {\n            drawCircleFlag = true;\n          }\n          // 是否画当前点\n          if (!drawCircleFlag && selectedScatterIndex !== point.rowIndex && !options.showPoint && pointsOfCurLegend.length !== 1) continue;\n          canvasContext.beginPath();\n          const pointPosition = {\n            x: pointPositionAccessorForCanvas.x(point),\n            y: pointPositionAccessorForCanvas.y(point)\n          };\n          if (point.isAlarmFlag) {\n            // 警告点\n            alarmContainer.append('circle').attr(\"class\", \"circles\").style('pointer-events', 'none').attr(\"alarm-status\", 'true').attr(\"cx\", point.ox + alarmXOffset).attr(\"cy\", point.oy).attr(\"r\", circleRadius * canvasZoom);\n            continue;\n          }\n          if (!point.isAlarmFlag) {\n            if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n              canvasContext.fillStyle = '#eeeeee';\n              canvasContext.fillStyle = 'transparent';\n            } else {\n              canvasContext.fillStyle = point.color || colorOfCurLegend;\n            }\n          } else {\n            canvasContext.fillStyle = 'transparent';\n          }\n          canvasContext.setLineDash([]);\n          // 开启符号描边\n          if (options.enablePointStroke) {\n            canvasContext.lineWidth = options.pointStrokeStyle && options.pointStrokeStyle.lineWidth || '1';\n            canvasContext.strokeStyle = options.pointStrokeStyle && options.pointStrokeStyle.lineColor || '#fff';\n            if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n              canvasContext.strokeStyle = '#eeeeee';\n              canvasContext.strokeStyle = 'transparent';\n            }\n            canvasContext.lineJoin = 'miter';\n          }\n          const shape = shapeOfCurLegend || lineSymbolType;\n          if (shape === 'three' || shape === 'option_legend_shape_type_three') {\n            const scale = 1.5;\n            canvasContext.moveTo(pointPosition.x, pointPosition.y - circleRadius * scale * canvasZoom);\n            canvasContext.lineTo(pointPosition.x + Math.cos(Math.PI / 6) * circleRadius * scale * canvasZoom, pointPosition.y + Math.cos(Math.PI / 3) * circleRadius * scale * canvasZoom);\n            canvasContext.lineTo(pointPosition.x - Math.cos(Math.PI / 6) * circleRadius * scale * canvasZoom, pointPosition.y + Math.cos(Math.PI / 3) * circleRadius * scale * canvasZoom);\n          } else if (shape === 'four' || shape === 'option_legend_shape_type_four') {\n            canvasContext.moveTo(pointPosition.x - circleRadius * canvasZoom, pointPosition.y - circleRadius * canvasZoom);\n            canvasContext.lineTo(pointPosition.x + circleRadius * canvasZoom, pointPosition.y - circleRadius * canvasZoom);\n            canvasContext.lineTo(pointPosition.x + circleRadius * canvasZoom, pointPosition.y + circleRadius * canvasZoom);\n            canvasContext.lineTo(pointPosition.x - circleRadius * canvasZoom, pointPosition.y + circleRadius * canvasZoom);\n          } else if (shape === 'rect' || shape === 'option_legend_shape_type_rect') {\n            canvasContext.moveTo(pointPosition.x - circleRadius * canvasZoom, pointPosition.y - circleRadius * canvasZoom * 0.5);\n            canvasContext.lineTo(pointPosition.x + circleRadius * canvasZoom, pointPosition.y - circleRadius * canvasZoom * 0.5);\n            canvasContext.lineTo(pointPosition.x + circleRadius * canvasZoom, pointPosition.y + circleRadius * canvasZoom * 0.5);\n            canvasContext.lineTo(pointPosition.x - circleRadius * canvasZoom, pointPosition.y + circleRadius * canvasZoom * 0.5);\n          } else if (shape === 'diamond' || shape === 'option_legend_shape_type_diamond') {\n            canvasContext.moveTo(pointPosition.x, pointPosition.y - circleRadius * canvasZoom * 1.3);\n            canvasContext.lineTo(pointPosition.x + circleRadius * canvasZoom, pointPosition.y);\n            canvasContext.lineTo(pointPosition.x, pointPosition.y + circleRadius * canvasZoom * 1.3);\n            canvasContext.lineTo(pointPosition.x - circleRadius * canvasZoom, pointPosition.y);\n          } else if (shape === 'five' || shape === 'option_legend_shape_type_five') {\n            let theArc = Math.PI / 5,\n              theRadius = circleRadius * 0.7,\n              theScale = 3;\n            // 1\n            canvasContext.moveTo(pointPosition.x, pointPosition.y - Math.cos(theArc) * theRadius * canvasZoom * theScale);\n            // 2\n            canvasContext.lineTo(pointPosition.x + Math.sin(theArc) * theRadius * canvasZoom, pointPosition.y - Math.cos(theArc) * theRadius * canvasZoom); // 2\n            // 3\n            canvasContext.lineTo(pointPosition.x + Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.cos(Math.PI / 2 - theArc * 2), pointPosition.y - Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.sin(Math.PI / 2 - theArc * 2)); // 3\n            //4\n            canvasContext.lineTo(pointPosition.x + Math.cos(Math.PI / 2 - theArc * 2) * theRadius * canvasZoom, pointPosition.y + Math.sin(Math.PI / 2 - theArc * 2) * theRadius * canvasZoom);\n            // 5\n            canvasContext.lineTo(pointPosition.x + Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.sin(theArc), pointPosition.y + Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.cos(theArc));\n            // 6\n            canvasContext.lineTo(pointPosition.x, pointPosition.y + theRadius * canvasZoom);\n            // 7\n            canvasContext.lineTo(pointPosition.x - Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.sin(theArc), pointPosition.y + Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.cos(theArc));\n            // 8\n            canvasContext.lineTo(pointPosition.x - Math.cos(Math.PI / 2 - theArc * 2) * theRadius * canvasZoom, pointPosition.y + Math.sin(Math.PI / 2 - theArc * 2) * theRadius * canvasZoom);\n            // 9\n            canvasContext.lineTo(pointPosition.x - Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.cos(Math.PI / 2 - theArc * 2), pointPosition.y - Math.cos(theArc) * theRadius * canvasZoom * theScale * Math.sin(Math.PI / 2 - theArc * 2)); // 3\n            // 10\n            canvasContext.lineTo(pointPosition.x - Math.sin(theArc) * theRadius * canvasZoom, pointPosition.y - Math.cos(theArc) * theRadius * canvasZoom); // 2\n          } else {\n            // 圆形\n            canvasContext.arc(pointPosition.x, pointPosition.y, circleRadius * canvasZoom, 0, Math.PI * 2);\n          }\n          canvasContext.closePath();\n          canvasContext.stroke();\n          canvasContext.fill();\n        }\n      }\n      canvasContext.restore();\n\n      // 进度到最后再显示标签\n      if (progress >= 1) {\n        drawTextLabel();\n      }\n    }\n\n    // 画节点上的文本标签\n    function drawTextLabel() {\n      if (!options.showLabelFlag) return;\n      // 绘制数据标签\n      let labelFontSize = options.labelFontSize || 10,\n        labelFontColor = options.labelFontColor === undefined ? '#333' : options.labelFontColor,\n        labelFontBold = options.labelFontBold === undefined ? '500' : options.labelFontBold ? 'bold' : '500',\n        labelFontItalic = options.labelFontItalic === undefined ? 'normal' : options.labelFontItalic ? 'italic' : 'normal',\n        labelPosition = options.labelPosition || \"default\",\n        labelChartSpace = 3,\n        //  标签局内局外时，与散点的距离\n        labelRotation = options.labelRotation || 0,\n        labelVisibleMap = options.labelVisibleMap || 'all',\n        labelAllowOverlap = !!options.labelAllowOverlap;\n      let drewScatterArray = [];\n      for (const legendData of scatterDataSet) {\n        let theLegendConfig = legendData.legendConfig || {};\n        let colorOfCurLegend = theLegendConfig.color; // 当前图例的颜色\n        if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== legendData.legendId) {\n          colorOfCurLegend = '#eeeeee';\n          colorOfCurLegend = 'transparent';\n        }\n        const pointsOfCurLegend = legendData.points; // 当前图例的所有点\n        canvasContext.globalAlpha = 1;\n        for (const point of pointsOfCurLegend) {\n          if (!point || !point.labelText) {\n            continue;\n          }\n          if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== point.legendId) {\n            continue;\n          }\n\n          // 只显示最大最小值的情况下\n          if (labelVisibleMap !== 'all' && !point.isMaxFlag && !point.isMinFlag) continue;\n          let theTextArray = point.labelText.split('\\n'),\n            maxLabelWidth = 0,\n            perHeight = 0,\n            maxLabelHeight = 0;\n          theTextArray && theTextArray.forEach(function (theText) {\n            if (theText) {\n              let theTextStrSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', theText, {\n                fontSize: labelFontSize\n              });\n              maxLabelWidth = Math.max(maxLabelWidth, theTextStrSize.width);\n              maxLabelHeight += theTextStrSize.height;\n              perHeight = theTextStrSize.height;\n            }\n          });\n          let theOy = point.oy;\n          let theTextPosition = {\n            ox: point.ox,\n            oy: theOy,\n            x: point.ox - maxLabelWidth / 2,\n            y: theOy - maxLabelHeight / 2,\n            width: maxLabelWidth,\n            perHeight: perHeight,\n            height: maxLabelHeight\n          };\n          if (labelPosition === 'in') {\n            // 如果设置居点内\n            theTextPosition.y = theOy - maxLabelHeight / 2;\n          } else if (labelPosition === 'out') {\n            // 设置居点外\n            theTextPosition.y = theOy - point.radius - maxLabelHeight;\n          } else {\n            // 默认情况下居点外\n            theTextPosition.y = theOy - point.radius - maxLabelHeight;\n          }\n\n          // 居外标签旋转，是网上旋转； 居内标签旋转是居中旋转\n          if (labelRotation > 0) {\n            if (labelPosition === 'in') {\n              // 中心点不变，中心点旋转\n              theTextPosition.x = point.ox - maxLabelHeight / 2;\n              theTextPosition.y = theOy - maxLabelWidth / 2;\n              theTextPosition.width = maxLabelHeight;\n              theTextPosition.height = maxLabelWidth;\n            } else {\n              // 往上旋转\n              theTextPosition.ox = point.ox;\n              theTextPosition.oy = theOy - point.radius - maxLabelWidth / 2;\n              theTextPosition.x = point.ox - maxLabelHeight / 2;\n              theTextPosition.y = theOy - point.radius - maxLabelWidth;\n              theTextPosition.width = maxLabelHeight;\n              theTextPosition.height = maxLabelWidth;\n            }\n          }\n\n          // 如果与图形之间有间隔 , 只有居外时需要有间隔\n          if (labelChartSpace && labelPosition !== 'in') {\n            theTextPosition.y = theTextPosition.y - labelChartSpace;\n          }\n\n          // 如果左侧超出图形，则往右移动 ； 超出右侧往左移\n          if (theTextPosition.x < 0) theTextPosition.x = 0;else if (theTextPosition.x + theTextPosition.width > options.canvasWidth) theTextPosition.x = options.canvasWidth - theTextPosition.width;\n          // 如果上侧超出图形，则往下移动；超出下侧，往上移动\n          if (theTextPosition.y < 0) theTextPosition.y = 0;else if (theTextPosition.y + theTextPosition.height > options.canvasHeight) theTextPosition.y = options.canvasHeight - theTextPosition.height;\n\n          // 当前文字标签是否会与其他值重叠碰撞\n          let isCurrentLabelOverlap = false;\n\n          // 不允许重叠的情况下，判断是否重叠\n          if (!labelAllowOverlap) {\n            isCurrentLabelOverlap = drewScatterArray.some(existedRect => {\n              return _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isOverlap(theTextPosition, existedRect);\n            });\n          }\n\n          // 1. 允许重叠的情况下，永远绘制所有标签;  2. 不允许重叠的情况下，只绘制非重叠的标签\n          if (labelAllowOverlap || !isCurrentLabelOverlap) {\n            canvasContext.save();\n            canvasContext.beginPath();\n            canvasContext.rect(theTextPosition.x * canvasZoom, theTextPosition.y * canvasZoom, theTextPosition.width * canvasZoom, theTextPosition.height * canvasZoom);\n            canvasContext.fillStyle = 'rgba(28,28,28,0)';\n            canvasContext.fill();\n            canvasContext.closePath();\n            canvasContext.translate(theTextPosition.x * canvasZoom, theTextPosition.y * canvasZoom);\n            canvasContext.rotate(labelRotation * Math.PI / 180);\n            canvasContext.fillStyle = labelFontColor;\n            canvasContext.font = labelFontBold + ' ' + labelFontItalic + ' ' + labelFontSize * canvasZoom + 'px 微软雅黑,Helvetica,Arial,sans-serif';\n            canvasContext.textBaseline = 'hanging';\n            let drawIndex = 0;\n            theTextArray && theTextArray.forEach(function (theText) {\n              if (labelRotation === 90) {\n                canvasContext.fillText(theText, 0, -(theTextPosition.width - theTextPosition.perHeight * drawIndex) * canvasZoom);\n              } else if (labelRotation === 270) {\n                canvasContext.fillText(theText, -theTextPosition.height * canvasZoom, theTextPosition.perHeight * drawIndex * canvasZoom);\n              } else {\n                canvasContext.fillText(theText, 0, theTextPosition.perHeight * drawIndex * canvasZoom);\n              }\n              drawIndex++;\n            });\n            canvasContext.restore();\n\n            // 当前已经绘制过的文字标签加入碰撞区域\n            drewScatterArray.push(theTextPosition);\n          }\n        }\n      }\n    }\n  },\n  /**\r\n   * 为折线图绑定事件，包括canvas上的点和svg上的线条\r\n   * @param options\r\n   *      {\r\n   *          canvasDom\r\n   *          scatterRadius\r\n   *          mouseoverCallback\r\n   *          mouseoutCallback\r\n   *          mousedownCallback\r\n   *      }\r\n   * **/\n  appendScatterCanvasEvent: function (options) {\n    options = options || {};\n    if (!options.canvasDom) return false;\n    if (!options.pointsArr || !options.pointsArr.length) return false;\n    const canvasZoom = options.canvasZoom;\n    const canvasContext = options.canvasContext;\n    canvasContext.lineWidth = options.lineWidth ? Math.max(1, options.lineWidth) * canvasZoom : 1 * canvasZoom; // 判断鼠标是否处于线条内所用的线宽\n    let theCanvasDom = options.canvasDom,\n      theScatterDataSet = options.pointsArr;\n    if (typeof options.mousedownCallback !== 'function') return;\n\n    // 鼠标在canvas上移动时，处理canvas内圆圈的移入移出\n    theCanvasDom.onmousemove = function (event) {\n      let mouseX = event.offsetX,\n        mouseY = event.offsetY;\n\n      // 移入canvas点上面\n      if (typeof options.mouseoverCircleCallback === 'function') {\n        const circleRadius = options.circleRadius || 5;\n        for (const legendData of theScatterDataSet) {\n          const pointsOfCurLegend = legendData.points; // 当前图例的所有点\n          for (const point of pointsOfCurLegend) {\n            const circle = new Path2D();\n            circle.arc(point.ox * canvasZoom, (point.oy + 10) * canvasZoom, circleRadius * canvasZoom, 0, 2 * Math.PI);\n            if (canvasContext.isPointInPath(circle, mouseX * canvasZoom, mouseY * canvasZoom)) {\n              options.mouseoverCircleCallback(event, {\n                scatterData: point\n              });\n              return;\n            }\n          }\n        }\n      }\n      // 移入线条上面\n      if (typeof options.mouseoverPathCallback === 'function') {\n        for (const legendData of theScatterDataSet) {\n          const canvasPathData = new Path2D(legendData.path.canvasPathData);\n          if (canvasContext.isPointInStroke(canvasPathData, mouseX * canvasZoom, mouseY * canvasZoom)) {\n            options.mouseoverPathCallback(event, {\n              scatterData: legendData,\n              xLabelIndex: options.hoverWidth ? Math.floor(mouseX / options.hoverWidth) : -1\n            });\n            return;\n          }\n        }\n      }\n      // 未移入任何元素\n      typeof options.mouseoutPathCallback === 'function' && options.mouseoutPathCallback();\n\n      // 如果没有在圆圈里 且 需要显示X轴刻度的区域 , 则显示当前X轴刻度的区域元素\n      if (typeof options.mousemoverXLabelCallback === 'function') {\n        options.mousemoverXLabelCallback({\n          event: event,\n          xLabelIndex: options.hoverWidth ? Math.floor(mouseX / options.hoverWidth) : -1\n        });\n        return;\n      }\n      typeof options.mouseoutXLabelCallback === 'function' && options.mouseoutXLabelCallback();\n    };\n\n    // 鼠标移出canvas\n    theCanvasDom.onmouseout = function () {\n      //  移出canvas时，直接执行mouseoutCallback\n      typeof options.mouseoutCircleCallback === 'function' && options.mouseoutCircleCallback();\n      typeof options.mouseoutPathCallback === 'function' && options.mouseoutPathCallback();\n      typeof options.mouseoutXLabelCallback === 'function' && options.mouseoutXLabelCallback();\n    };\n\n    // 鼠标在canvas进行点击操作\n    theCanvasDom.onmousedown = function (event) {\n      let mouseX = event.offsetX,\n        mouseY = event.offsetY;\n      if (typeof options.mousedownCallback === 'function') {\n        const circleRadius = options.circleRadius || 5;\n\n        // 判断是否点击节点\n        for (const legendData of theScatterDataSet) {\n          const pointsOfCurLegend = legendData.points; // 当前图例的所有点\n          for (const point of pointsOfCurLegend) {\n            const circle = new Path2D();\n            circle.arc(point.ox * canvasZoom, (point.oy + 10) * canvasZoom, circleRadius * canvasZoom, 0, 2 * Math.PI);\n            if (canvasContext.isPointInPath(circle, mouseX * canvasZoom, mouseY * canvasZoom)) {\n              options.mousedownCallback(event, point);\n              return;\n            }\n          }\n        }\n      }\n    };\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (LineChartComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/line/LineChartComponent.js?");

/***/ }),

/***/ "../src-v5/assets/js/charts.system.basic/line/systemLineChart.js":
/*!***********************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/line/systemLineChart.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ContainerComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pc/assets/js/charts.components/ContainerComponent */ \"../src-v5/assets/js/charts.components/ContainerComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_TranslateDataComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pc/assets/js/charts.components/TranslateDataComponent */ \"../src-v5/assets/js/charts.components/TranslateDataComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pc/assets/js/charts.components/LegendComponent */ \"../src-v5/assets/js/charts.components/LegendComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pc/assets/js/charts.components/TitleComponent */ \"../src-v5/assets/js/charts.components/TitleComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pc/assets/js/charts.components/MeasureAxisComponent */ \"../src-v5/assets/js/charts.components/MeasureAxisComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_AttributeAxisComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pc/assets/js/charts.components/AttributeAxisComponent */ \"../src-v5/assets/js/charts.components/AttributeAxisComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @pc/assets/js/charts.components/MarkerComponent */ \"../src-v5/assets/js/charts.components/MarkerComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_SvgClipPathComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pc/assets/js/charts.components/SvgClipPathComponent */ \"../src-v5/assets/js/charts.components/SvgClipPathComponent.js\");\n/* harmony import */ var _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./LineChartComponent.js */ \"../src-v5/assets/js/charts.system.basic/line/LineChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @pc/assets/js/charts.components/ReferenceLineComponent */ \"../src-v5/assets/js/charts.components/ReferenceLineComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_PaginationChartComponent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @pc/assets/js/charts.components/PaginationChartComponent */ \"../src-v5/assets/js/charts.components/PaginationChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_SelectChartComponent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @pc/assets/js/charts.components/SelectChartComponent */ \"../src-v5/assets/js/charts.components/SelectChartComponent.js\");\n/**\r\n * 系统散点图画图组件\r\n *\r\n * 从系统中剥离的目的\r\n * 1. 为了减轻图形打包文件的大小【20230301时最大的打包文件是10M左右】\r\n * 2. 各个图形控制各自的图表配置\r\n * 3. 支持图形的延迟分批加载\r\n * **/\n\n\n// 通用组件[ 获取字符串长度之类 ...  ]\n\n// 画图容器组件[ 主要区分svg部分与图例部分 ]\n\n// 数据处理组件[ 解析XY轴配置组的数据 ]\n\n// 画图例列表的组件\n\n// 画标题组件\n\n// 解析数值刻度 及  画数值刻度的组件\n\n// 画属性刻度轴\n\n// 画标准线[ 最大/最小/平均值 ]\n\n// 画图形区域的截取元素\n\n// 画图形中的散点元素\n\n\n// 画标度线\n\n// 画分页组件\n\n// 区域选择组件\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // [*必填项] 图姓唯一标识\n  chartType: \"line\",\n  // [*必填项] 图形名称中英文Key\n  chartDisplayNameKey: \"chart_line\",\n  // [*必填项] 图形描述中英文Key\n  chartDescriptionKey: \"chart_line_tooltip\",\n  // [*必填项] 图轴配置元素 ( X轴 ，Y轴（允许右Y轴），图例 )\n  needAxis: {\n    xAxis: {},\n    yAxis: {\n      defaultYAxisNumber: -1,\n      allowMultiYAxis: true\n    },\n    legend: {}\n  },\n  // [*必填项] 搜索数据是否支持该图形 ( 至少一个属性列，一个数值列，允许图例 )\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n\n    // if (!searchResultStatistic || !searchResultStatistic.aggregatedFlag) return false;\n    // @20230721 非聚合数据也可以画折线图\n    if (!searchResultStatistic) return false;\n    if (searchResultStatistic.measureColumns.length > 0 && searchResultStatistic.attributeColumns.length > 0) {\n      satisfiedFlag = true;\n    }\n    return satisfiedFlag;\n  },\n  /**\r\n   * [选填] 获取当前图形各个needAxis中可选择的配置列\r\n   * @return\r\n   *      {\r\n   *          // 依据needAxis结构返回各个可选列的index\r\n   *          xAxis: [1,2,3] ,\r\n   *          yAxis: [4,5] ,\r\n   *          legend: [1,2,3] ,\r\n   *          size: [4,5] ,\r\n   *          time: [1,2]\r\n   *      }\r\n   * */\n  getSatisfiedChartAxis: function (searchResultStatistic) {\n    let self = this; //  是当前_DataFocusChartTypes中的对象\n\n    const needAxis = self.needAxis || {};\n    if (!needAxis || !searchResultStatistic) return false;\n    let theAxisObj = {};\n    // Time / legend / xAxis / yAxis / size\n    // X轴的可选项\n    if (needAxis.xAxis) {\n      theAxisObj.xAxis = searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    // Y轴的可选项\n    if (needAxis.yAxis) {\n      theAxisObj.yAxis = searchResultStatistic.measureColumns && searchResultStatistic.measureColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n\n    // 图例列的可选项\n    // 有XAxis时，图例则必须在有X轴的情况下才可以有，所以在只有一个属性列时，不允许存在图例列\n    if (needAxis.legend) {\n      if (needAxis.xAxis && searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.length <= 1) {\n        theAxisObj.legend = [];\n      } else {\n        theAxisObj.legend = searchResultStatistic.legendColumns && searchResultStatistic.legendColumns.map(function (h) {\n          return h.idx;\n        });\n      }\n    }\n    if (_DataFocusMethod.isObjEmpty(theAxisObj)) {\n      return false;\n    } else {\n      theAxisObj.name = self.name;\n      theAxisObj.type = self.name;\n      return theAxisObj;\n    }\n  },\n  /**\r\n   * [选填] 在图形没有图轴配置的情况下，从getSatisfiedChartAxis中图轴可选项中初始化画图配置\r\n   *\r\n   * 初始化规则：\r\n   * 1. 如果当前数据中有两个以上数值列，则默认X轴是数值列，Y轴是一个数值列\r\n   * 2. 如果当前数据只有一个数值列，则默认X轴是属性列，Y轴是数值列\r\n   *\r\n   * // 依据needAxis生成初始的图轴配置值，及各个轴的配置可选项\r\n   *    返回对象名字规则: 可选项是needAxis中各项名字 + Area ； 当前配置项是 cur + needAxis中各项名字\r\n   * @return chartAxis\r\n   *          {\r\n   *              xAxisArea: [  {col_id , index ...} , {} ] ,\r\n   *              curXAxis: [ {col_id , index ...} ]\r\n   *              yAxisArea: [ {col_id , index , min , max ...} , {} ] ,\r\n   *              curYAxis: [ {col_id , index , min , max ...} ] ,\r\n   *              legendArea: [ {col_id , index ...} ],\r\n   *              curLegend: {col_id , index ...} ,\r\n   *              sizeArea: [{col_id , index ...}] ,\r\n   *              curSize: {col_id , index ...} ,\r\n   *              timeArea: [ {col_id , index ...} ] ,\r\n   *              curTime: {col_id , index ...}\r\n   *          }\r\n   *\r\n   * */\n  initChartAxisConfig: function (options) {\n    options = options || {};\n    if (!options.tableData || !options.tableData.headers) return false;\n    let self = this,\n      //  是当前_DataFocusChartTypes中的对象\n      tableData = options.tableData,\n      headers = tableData.headers,\n      columns = tableData.columns;\n\n    // charts是依据各个图形中的getSatisfiedChartAxis生成的\n    let theMatchedChart = tableData.charts && tableData.charts.find(function (chart) {\n        return (chart.name || chart.type) === self.name;\n      }),\n      chartAxis = {};\n    if (!theMatchedChart) {\n      console.log(\"当前数据不适合折线图\");\n      return chartAxis;\n    }\n    let getIdIndexInHeader = function (colIdx, headers) {\n      // 目前charts返回的都是索引\n      if (colIdx < headers.length) return colIdx;\n      for (let i = 0; i < headers.length; i++) {\n        if (headers[i].col_id === colIdx) return i;\n      }\n      return -1;\n    };\n\n    // 百分比增长的列。放在左Y轴\n    const percentGrowthCategorySet = new Set(['growth_rate', 'growth_interval_rate',\n    // 同期增长率\n    'percentage_attr_measure' // 百分比\n    ]);\n\n    // 数量增长的列。放入右Y轴\n    const amountGrowthCategorySet = new Set(['growth_amount', 'growth_interval_amount' // 同期增长量\n    ]);\n\n    // 增长前后相关值的 category：划入未可视化列中\n    const amountCategorySet = new Set(['growth_previous', 'growth_current']);\n    const growthCategorySet = new Set([...percentGrowthCategorySet, ...amountGrowthCategorySet, ...amountCategorySet]);\n\n    // 是否是增长量、增长率相关的搜索语句。如果是，则采用专门的方案区分左右轴。\n    const isGrowthSearch = theMatchedChart && theMatchedChart.yAxis.some((c, index) => {\n      let curColumnIndex = getIdIndexInHeader(c, headers);\n      const headerCategories = headers[curColumnIndex] && headers[curColumnIndex].categories || [];\n      return headerCategories.some(categoryItem => growthCategorySet.has(categoryItem));\n    });\n\n    // 获取图例列及可选数组 [ 默认legend不允许与时间列相同 ]\n    if (self.needAxis && self.needAxis.legend) {\n      chartAxis.legendArea = [];\n      let theLegendArea = [];\n      theMatchedChart.legend && theMatchedChart.legend.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        chartAxis.legendArea.push(obj);\n        theLegendArea.push(obj);\n      });\n\n      // 默认使用值distinct count最小的作为图例\n      theLegendArea.sort(function (a, b) {\n        return a.statistics && b.statistics && a.statistics['unique count'] - b.statistics['unique count'];\n      });\n      chartAxis.curLegend = theLegendArea[0];\n    }\n\n    // 获取XAxis列及可选数组\n    if (self.needAxis && self.needAxis.xAxis) {\n      chartAxis.xAxisArea = [];\n      theMatchedChart.xAxis && theMatchedChart.xAxis.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        chartAxis.xAxisArea.push(obj);\n      });\n\n      // 赋值默认的X轴，默认X轴与图例列不能重叠\n      let xAxisArea = chartAxis.xAxisArea.filter(function (xAxis) {\n        return !(chartAxis.curLegend && xAxis.index === chartAxis.curLegend.index);\n      });\n      // 如果指令了属性列的数量\n      let defaultXAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.xAxis.defaultXAxisNumber) ? self.needAxis.xAxis.defaultXAxisNumber : -1;\n      let withoutSortX = xAxisArea && xAxisArea.filter(function (head) {\n        return !head.isSortNoFlag;\n      });\n      // 如果没有排序列的属性列足够分配需要的X轴，则优先使用非排序列的属性列\n      if (defaultXAxisNumber < 0) {\n        chartAxis.curXAxis = withoutSortX.length ? withoutSortX : xAxisArea;\n      } else {\n        if (withoutSortX.length >= defaultXAxisNumber) {\n          chartAxis.curXAxis = withoutSortX.slice(0, defaultXAxisNumber);\n        } else {\n          chartAxis.curXAxis = xAxisArea.slice(0, defaultXAxisNumber);\n        }\n      }\n    }\n\n    // 获取YAxis列及可选数组 [ 必须计算yAxis的最大值与最小值，计算刻度使用 ]\n    if (self.needAxis && self.needAxis.yAxis) {\n      chartAxis.yAxisArea = [];\n      theMatchedChart.yAxis && theMatchedChart.yAxis.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        obj.direction = \"left\";\n        let min = obj.statistics && obj.statistics.min,\n          max = obj.statistics && obj.statistics.max;\n        // 如果min/max中存在Infinity这类的无穷数据 或者 存在非法数字时，需要从原始数据中重新获取合法数值\n        if (!isFinite(min + max) || !_DataFocusMethod.isPureNumber(min) || !_DataFocusMethod.isPureNumber(max)) {\n          let theMin = Infinity,\n            theMax = -Infinity;\n          columns && columns.forEach(function (d) {\n            if (_DataFocusMethod.isPureNumber(d[curColumnIndex]) && isFinite(d[curColumnIndex])) {\n              theMin = Math.min(theMin, d[curColumnIndex]);\n              theMax = Math.max(theMax, d[curColumnIndex]);\n            }\n          });\n          min = theMin;\n          max = theMax;\n          // 如果theMin是Infinity, 说明数据表中没有合法的数值，则将其设置成0\n          if (Math.abs(theMin) === Infinity) {\n            min = 0;\n            max = 0;\n          }\n        }\n        // 如果min是undefined 说明，数据表头中没有统计 且 返回数据中没有合法的数值，则默认设置为0\n        if (min === undefined) {\n          min = 0;\n          max = 0;\n        }\n        obj.min = min;\n        obj.max = min === max && max === 0 && min === 0 ? 1 : max;\n        chartAxis.yAxisArea.push(obj);\n      });\n      if (chartAxis.curLegend) {\n        let theYAxis = chartAxis.yAxisArea.find(function (yAxis) {\n          return true;\n        });\n        if (theYAxis) chartAxis.curYAxis = [theYAxis];\n      } else {\n        // 没有图例的情况，使用配置中默认的Y轴数量\n        let yAxisArea = chartAxis.yAxisArea;\n        if (isGrowthSearch) {\n          // 判断是否同时具有增长率和增长量\n          let hasAmountAxis = false,\n            hasPercentAxis = false;\n          for (const yAxis of yAxisArea) {\n            const categories = yAxis.categories || [];\n            if (!hasAmountAxis && categories.some(categoryItem => amountGrowthCategorySet.has(categoryItem))) {\n              hasAmountAxis = true;\n            } else if (!hasPercentAxis && categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n              hasPercentAxis = true;\n            }\n          }\n          const resYAxis = [];\n          if (hasAmountAxis && hasPercentAxis) {\n            // 同时具有增长量和增长率。增长量放左边，增长率放右边\n            for (const yAxis of yAxisArea) {\n              const categories = yAxis.categories || [];\n              if (categories.some(categoryItem => amountGrowthCategorySet.has(categoryItem))) {\n                yAxis.direction = 'left';\n                resYAxis.push(yAxis);\n              } else if (categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n                yAxis.direction = 'right';\n                resYAxis.push(yAxis);\n              }\n            }\n          } else {\n            // 否则统一放左边\n            for (const yAxis of yAxisArea) {\n              const categories = yAxis.categories || [];\n              if (categories.some(categoryItem => amountGrowthCategorySet.has(categoryItem))) {\n                yAxis.direction = 'left';\n                resYAxis.push(yAxis);\n              } else if (categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n                yAxis.direction = 'left';\n                resYAxis.push(yAxis);\n              }\n            }\n          }\n          if (!resYAxis.length && yAxisArea[0]) {\n            resYAxis.push(yAxisArea[0]);\n          }\n          chartAxis.curYAxis = resYAxis;\n        } else {\n          let defaultYAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.yAxis.defaultYAxisNumber) ? self.needAxis.yAxis.defaultYAxisNumber : 1;\n          // 如果默认Y轴< 0 ， 说明剩下所有可用Y轴全部是默认Y轴\n          if (defaultYAxisNumber < 0) {\n            chartAxis.curYAxis = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].sortYAxisAreaByMagnitude(yAxisArea);\n          } else {\n            chartAxis.curYAxis = yAxisArea.slice(0, defaultYAxisNumber);\n            let defaultRightYAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.yAxis.defaultRightYAxisNumber) ? self.needAxis.yAxis.defaultRightYAxisNumber : 0;\n            let rightYAxis = yAxisArea.slice(defaultYAxisNumber, defaultYAxisNumber + defaultRightYAxisNumber);\n            if (rightYAxis && rightYAxis.length) {\n              rightYAxis && rightYAxis.forEach(function (yAxis) {\n                yAxis.direction = 'right';\n              });\n              chartAxis.curYAxis = chartAxis.curYAxis.concat(rightYAxis);\n            }\n          }\n        }\n      }\n\n      // conf.multiYFlag = false ;\n      // chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis) { if (yAxis.direction === \"right\") conf.multiYFlag = true; });\n      // // 将right轴往后排\n      // chartAxis.curYAxis && chartAxis.curYAxis.sort(function(axis1,axis2){ return axis2.direction === \"right\"?-1:0;});\n    }\n\n    // 因为Legend与Time将属性列全部使用完了，这种时候默认不需要legend , 将Legend分配给XAxis\n    if (self.needAxis && self.needAxis.xAxis) {\n      if (chartAxis.curLegend && !chartAxis.curXAxis.length) {\n        chartAxis.curXAxis = chartAxis.xAxisArea.filter(function (xAxis) {\n          return xAxis.index === chartAxis.curLegend.index;\n        });\n        chartAxis.curLegend = undefined;\n      }\n    }\n    return chartAxis;\n  },\n  /***\r\n   * [*必填项] 图轴配置是否合法\r\n   *\r\n   * 1. X轴是Measure列时的限制条件\r\n   *\r\n   *     - X轴不允许为空\r\n   *     - Y轴不允许为空\r\n   *     - Y轴不允许超过两个\r\n   *     - X轴不允许超过两个\r\n   *     - X轴不允许与Y轴一致\r\n   *     - X轴中不允许属性列与数值列一起\r\n   *\r\n   * 2. X轴是Attribute列时的限制条件\r\n   *\r\n   *      - X轴不允许为空\r\n   *      - Y轴不允许为空\r\n   *      - 左Y轴不允许为空\r\n   *      - Y轴不允许重复\r\n   *      - 有legend时，Y轴不允许超过1个\r\n   *      - 有legend时，不允许与X轴中的项重复\r\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let chartErrorMsg = '',\n      i,\n      yyids;\n    if (!theAxisConfig) return chartErrorMsg;\n\n    // X轴为必填选项\n    if (!theAxisConfig.xAxis || !theAxisConfig.xAxis.length) {\n      chartErrorMsg = 'chart_modify_x_not_null';\n      return chartErrorMsg;\n    }\n\n    // Y轴不允许为空\n    if (!theAxisConfig.yAxis || !theAxisConfig.yAxis.length) {\n      chartErrorMsg = 'chart_modify_y_not_null';\n      return chartErrorMsg;\n    }\n\n    // 左Y轴不允许为空\n    let leftYIds = theAxisConfig.yAxis && theAxisConfig.yAxis.filter(function (axis) {\n      return axis.direction === 'left';\n    });\n    if (!leftYIds || !leftYIds.length) {\n      chartErrorMsg = 'chart_modify_y_left_not_null';\n      return chartErrorMsg;\n    }\n\n    // Y轴不允许重复\n    for (i = 0, yyids = []; theAxisConfig.yAxis && i < theAxisConfig.yAxis.length; i++) {\n      let theAxis = theAxisConfig.yAxis[i];\n      if (yyids.indexOf(theAxis.index) > -1) {\n        chartErrorMsg = 'chart_modify_y_not_repeat';\n        yyids.push(theAxis.index);\n        return chartErrorMsg;\n      }\n    }\n\n    // 有legend时，Y轴不允许超过1个\n    if (theAxisConfig.legend && theAxisConfig.yAxis && theAxisConfig.yAxis.length > 1) {\n      chartErrorMsg = 'chart_modify_y_only_one';\n      return chartErrorMsg;\n    }\n\n    // 有legend时，不允许与X轴中的项重复\n    if (theAxisConfig.legend && theAxisConfig.xAxis && theAxisConfig.xAxis.find(function (axis) {\n      return axis.index === theAxisConfig.legend.index;\n    })) {\n      chartErrorMsg = 'chart_modify_x_legend_not_equal';\n      return chartErrorMsg;\n    }\n    return chartErrorMsg;\n  },\n  // [* 必填项]画图方法\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n    const headers = options.datas.headers;\n    const currentPaginationInfo = {\n      start: 0,\n      steps: 0,\n      end: 0\n    };\n    let self = this,\n      container = options.container,\n      chartAxis = options.chartAxis,\n      currentChart = options.currentChart,\n      conf = currentChart.defaultConf || {},\n      chartUUID = conf.chartUUID,\n      systemLanguage = conf.systemLanguage || 'chinese',\n      chartConfigures = options.chartConfigures || {},\n      hasLegendFlag = !!(chartAxis.curLegend || chartAxis.curYAxis && chartAxis.curYAxis.length > 1),\n      aChartFrameReturn,\n      hideCategories = conf.hideCategories;\n\n    // 获取图例的位置，默认在右侧\n    let legendPosition = hasLegendFlag ? 'right' : '';\n    if (legendPosition) {\n      legendPosition = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].translateLegendConfigure(chartConfigures.legend_position);\n    }\n    const isCanvasExisted = !!container.querySelector('canvas.canvas-dom');\n    // 给柱状图初始化画图容器  SVG图形部分(X轴Y轴图形) / X轴标题(位置) / Y轴标题(位置) / 图例(位置)\n    const containerResult = _pc_assets_js_charts_components_ContainerComponent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].drawCommonContainer({\n      container: container,\n      legendPosition: !!(chartConfigures.show_legend === undefined || chartConfigures.show_legend) ? legendPosition : '',\n      needCanvasFlag: true\n    });\n    if (!containerResult.svgJqDom) {\n      container.innerHTML = '';\n      return false;\n    }\n    // 为了防止图形先画了图例，导致没有数据时有图例的区域在\n    if (!options.datas.columns || !options.datas.columns.length) {\n      container.innerHTML = '';\n      console.log('当前图形没有合法的画图数据');\n      return false;\n    }\n\n    // 获取图形的整体宽度和高度\n    let chartWidth = container.offsetWidth,\n      chartHeight = container.offsetHeight;\n    // 当前画图区域的缩放比例【会影响到获取字体高度的计算】\n    if (_DataFocusMethod.isPureNumber(chartConfigures._DF_SYS_TRANSFORM_SCALE)) {\n      _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].transformScale = chartConfigures._DF_SYS_TRANSFORM_SCALE;\n    }\n    // 获取当前图形的配置颜色主题方法\n    let colorFunc = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].translateColorThemeConfigure(chartConfigures.chart_color_theme, {\n      chart_custom_theme: chartConfigures.chart_custom_theme\n    });\n    // 获取隐藏聚合方式的标志配置, 即所有属性列的聚合方式不显示在标签内\n    let hideOperatorFlag = false;\n    if (chartConfigures.hide_operator_label) hideOperatorFlag = true;\n    // 获取图形的字体大小配置\n    let chartFontSize = chartConfigures.font_size_label && parseInt(chartConfigures.font_size_label.fontSize) || 10,\n      chartFontColor = chartConfigures.font_size_label && chartConfigures.font_size_label.fontColor,\n      chartFontBold = chartConfigures.font_size_label && chartConfigures.font_size_label.fontBold,\n      chartFontItalic = chartConfigures.font_size_label && chartConfigures.font_size_label.fontItalic;\n    chartFontSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].translateFontSizeConfigure(chartFontSize) || 10;\n    if (chartFontColor) {\n      container.style.color = chartFontColor || 'inherit';\n      container.style.fill = chartFontColor || 'inherit';\n      containerResult.svgJqDom.style.color = chartFontColor;\n      containerResult.svgJqDom.style.fill = chartFontColor;\n    }\n    if (chartFontBold) {\n      container.style.fontWeight = 'bold';\n    } else {\n      container.style.fontWeight = 'normal';\n    }\n    if (chartFontItalic) {\n      container.style.fontStyle = 'italic';\n    } else {\n      container.style.fontStyle = 'normal';\n    }\n    let theXTitleFontSize = chartConfigures.x_axis_title_style && parseInt(chartConfigures.x_axis_title_style.fontSize) || chartFontSize || 10,\n      //  X轴标题字体大小\n      theXAxisFontSize = chartConfigures.x_axis_label_style && parseInt(chartConfigures.x_axis_label_style.fontSize) || chartFontSize || 10,\n      //  X轴刻度字体大小， 默认使用图形统一的字体大小\n      theYTitleFontSize = chartConfigures.y_axis_title_style && parseInt(chartConfigures.y_axis_title_style.fontSize) || chartFontSize || 10,\n      //  Y轴标题字体大小\n      theYAxisFontSize = chartConfigures.y_axis_label_style && parseInt(chartConfigures.y_axis_label_style.fontSize) || chartFontSize || 10,\n      //  Y轴刻度字体大小， 默认使用图形统一的字体大小\n      theLegendFontSize = chartConfigures.legend_font_style && parseInt(chartConfigures.legend_font_style.fontSize) || chartFontSize || 10;\n\n    // 先填充图例区域 [ 绘制图例列表，翻页 ，宽度高度限制 ]\n    // 计算图例列表\n    let showLegendLength = 0,\n      legendValueList = [],\n      defaultLegendList = [];\n    let savedLegendColorConfig = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].translateLegendColor({\n      // legendColors: conf.legendColors ,\n      // yAxisColors: conf.yAxisColors ,\n      curYAxis: chartAxis.curYAxis,\n      configureLegendList: chartConfigures.chart_legend_list\n    });\n    if (chartAxis.curLegend) {\n      chartAxis.curLegend.distincts && chartAxis.curLegend.distincts.forEach(function (legendName, index) {\n        let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId('legendAxis', legendName); // \"column-value-\" + legendName ,\n        let theConfigLegend = savedLegendColorConfig && savedLegendColorConfig.find(function (theConfig) {\n          return theConfig.id === theLegendId;\n        });\n        legendValueList.push({\n          type: 'columnValue',\n          legend: legendName,\n          legendTranslateName: _DataFocusMethod.formatTextData(legendName, chartAxis.curLegend),\n          id: theLegendId,\n          index: index,\n          shape: theConfigLegend && theConfigLegend.shape,\n          dash: theConfigLegend && theConfigLegend.dash,\n          shadow: theConfigLegend && theConfigLegend.shadow,\n          color: theConfigLegend && theConfigLegend.color || colorFunc(index),\n          show: !theConfigLegend || theConfigLegend.show === undefined ? true : !!theConfigLegend.show\n        });\n        defaultLegendList.push({\n          type: 'columnValue',\n          legend: legendName,\n          legendTranslateName: _DataFocusMethod.formatTextData(legendName, chartAxis.curLegend),\n          id: theLegendId,\n          index: index,\n          shape: chartConfigures.legend_shape_type,\n          dash: chartConfigures.dashed_solid_of_line,\n          shadow: chartConfigures.show_line_shadow,\n          color: colorFunc(index),\n          show: true\n        });\n      });\n    } else if (chartAxis.curYAxis) {\n      chartAxis.curYAxis.forEach(function (yAxis, index) {\n        let theYLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId('yAxis', yAxis.idx); //  \"measure-column-id-\" + yAxis.col_id ,\n        let theConfigLegend = savedLegendColorConfig && savedLegendColorConfig.find(function (theConfig) {\n          return theConfig.id === theYLegendId;\n        });\n        legendValueList.push({\n          type: 'measureColumn',\n          legend: _DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n            hideOperator: hideOperatorFlag\n          }),\n          id: theYLegendId,\n          index: index,\n          shape: theConfigLegend && theConfigLegend.shape,\n          dash: theConfigLegend && theConfigLegend.dash,\n          shadow: theConfigLegend && theConfigLegend.shadow,\n          color: theConfigLegend && theConfigLegend.color || colorFunc(index),\n          show: !theConfigLegend || theConfigLegend.show === undefined ? true : !!theConfigLegend.show\n        });\n        defaultLegendList.push({\n          type: 'measureColumn',\n          legend: _DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n            hideOperator: hideOperatorFlag\n          }),\n          id: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId('yAxis', yAxis.idx),\n          //  \"measure-column-id-\" + yAxis.col_id ,\n          index: index,\n          color: colorFunc(index),\n          shape: chartConfigures.legend_shape_type,\n          dash: chartConfigures.dashed_solid_of_line,\n          shadow: chartConfigures.show_line_shadow,\n          show: true\n        });\n      });\n    }\n    legendValueList && legendValueList.forEach(function (theLegend) {\n      if (theLegend.show) showLegendLength++;\n    });\n    // 如果没有显示的图例，则至少保证显示一个\n    if (!showLegendLength) {\n      showLegendLength = 1;\n      legendValueList[0] && (legendValueList[0].show = true);\n    }\n    // 画图例元素,先将图例元素画完成后，才可以计算SVG的宽度与高度\n    if (hasLegendFlag && containerResult.legendContainer) {\n      // 画图例元素\n      let drawLegendFlag = !!(chartConfigures.show_legend === undefined || chartConfigures.show_legend);\n      if (drawLegendFlag) {\n        _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAttributeLegend({\n          container: containerResult.legendContainer,\n          chartWidth: chartWidth,\n          chartHeight: chartHeight,\n          legendPosition: legendPosition,\n          legendMaxWidthInVertical: chartConfigures.legend_position_width,\n          legendValueList: legendValueList,\n          legendFontSize: theLegendFontSize,\n          legendFontColor: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontColor,\n          legendBoldStyle: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontBold,\n          legendItalicStyle: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontItalic,\n          legendOffsetSpace: chartConfigures.legend_position_offset,\n          legendIntervalSpace: chartConfigures.legend_position_interval,\n          legendShapeType: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].translateLegendShapeConfigure(chartConfigures && chartConfigures.legend_shape_type),\n          changeLegendColorFlag: !!(conf.action && !conf.wxFlag) && !conf.inPinboard,\n          chooseButtonText: self.getPluginKeyText(),\n          changeLegendColorCallback: function (options) {\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              // 修改图形中的图例配置，并将其传给配置组件，然后由配置组件触发画图， 而不是在此处直接画图\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend) {\n                let theMatchedConfigure = chartConfigures.chart_legend_list && chartConfigures.chart_legend_list.find(function (configure) {\n                  return configure.id === theMatchedLegend.id || configure.legend === theMatchedLegend.legend;\n                });\n                if (theMatchedConfigure) {\n                  theMatchedConfigure.color = options.color || undefined;\n                } else {\n                  chartConfigures.chart_legend_list = chartConfigures.chart_legend_list || [];\n                  chartConfigures.chart_legend_list.push({\n                    id: theMatchedLegend.id,\n                    legend: theMatchedLegend.legend,\n                    color: options.color || undefined\n                  });\n                }\n                // 修改图形配置\n                currentChart.requireSetConfig({\n                  key: \"chart_legend_list\",\n                  value: chartConfigures.chart_legend_list\n                });\n              }\n            }\n          },\n          // 点击 显示/隐藏 图例\n          mousedownEventCallback: function (options) {\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              // 修改图形中的图例配置，并将其传给配置组件，然后由配置组件触发画图， 而不是在此处直接画图\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend) {\n                let theMatchedConfigure = chartConfigures.chart_legend_list && chartConfigures.chart_legend_list.find(function (configure) {\n                  return configure.id === theMatchedLegend.id || configure.legend === theMatchedLegend.legend;\n                });\n                let theShownLegendLength = legendValueList.filter(function (legend) {\n                  return legend.show;\n                }).length;\n                // 如果只有一个图例显示，则不再隐藏最后一个了\n                if (theShownLegendLength === 1 && !!theMatchedLegend.show) return false;\n                if (theMatchedConfigure) {\n                  theMatchedConfigure.show = !theMatchedLegend.show;\n                } else {\n                  chartConfigures.chart_legend_list = chartConfigures.chart_legend_list || [];\n                  chartConfigures.chart_legend_list.push({\n                    id: theMatchedLegend.id,\n                    legend: theMatchedLegend.legend,\n                    show: !theMatchedLegend.show\n                  });\n                }\n                // 修改图形配置\n                currentChart.requireSetConfig({\n                  key: \"chart_legend_list\",\n                  value: chartConfigures.chart_legend_list\n                });\n              }\n            }\n          },\n          // 鼠标移入图例，高亮对应图例\n          mouseoverEventCallback: function (options) {\n            // 高亮当前图例所在的图形元素，置灰其他元素\n\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend && theMatchedLegend.id && theMatchedLegend.show) {\n                drawAChartFrame({\n                  start: currentPaginationInfo.start,\n                  steps: currentPaginationInfo.steps,\n                  end: currentPaginationInfo.end,\n                  currentLegend: theMatchedLegend\n                });\n                if (options.legendDom) {\n                  $(options.legendDom).find(\"svg\").removeClass(\"fill-grey\");\n                  $(options.legendDom).siblings().find(\"svg\").addClass(\"fill-grey\");\n                }\n              }\n            }\n          },\n          mouseoutEventCallback: function (options) {\n            options = options || {};\n            // // 恢复高亮所有图例的图形元素\n            drawAChartFrame({\n              start: currentPaginationInfo.start,\n              steps: currentPaginationInfo.steps,\n              end: currentPaginationInfo.end,\n              animateFlag: false\n            });\n            if (options.legendDom) $(options.legendDom).parent().find(\"svg\").removeClass(\"fill-grey\");\n          }\n        });\n      }\n    }\n\n    // 再填充画图区域\n    // 0. 先计算Y轴刻度比例尺[ 左Y轴比例尺 及 右Y轴比例尺 及 左右Y轴宽度 ]\n    if (!chartAxis.curYAxis || !chartAxis.curYAxis.length) {\n      container.innerHTML = '';\n      console.log('当前图形Y轴配置异常');\n      return false;\n    }\n    let svgDrawWidth = $(containerResult.svgJqDom).width(),\n      svgDrawHeight = $(containerResult.svgJqDom).height();\n    let showYTitleFlag = !conf.inPinboard;\n    if (!chartConfigures.y_axis_title_visible || chartConfigures.y_axis_title_visible === 'system_auto_default') {\n      showYTitleFlag = !conf.inPinboard;\n    } else {\n      showYTitleFlag = !!(chartConfigures.y_axis_title_visible === \"option_title_visible_show\");\n    }\n    let yAxisBasicMessage = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].calcMeasureAxisBasicMessage({\n      direction: 'vertical',\n      language: systemLanguage,\n      axisFontSize: theYAxisFontSize,\n      drawWidth: svgDrawWidth,\n      drawHeight: svgDrawHeight,\n      firstMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n        return axis.direction !== 'right';\n      }), {\n        axisType: 'normal',\n        tableData: conf.datas,\n        scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].translateScaleType(chartConfigures.measure_scale_type),\n        min: chartConfigures.measure_scale_min,\n        max: chartConfigures.measure_scale_max,\n        definedMin: chartConfigures.measure_scale_defined_min || 0,\n        definedSeparate: chartConfigures.measure_scale_step,\n        definedStep: chartConfigures.measure_scale_step_number,\n        definedScaleFormat: chartConfigures.measure_left_y_configure\n      }),\n      secondMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n        return axis.direction === 'right';\n      }), {\n        axisType: 'normal',\n        tableData: conf.datas,\n        scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].translateScaleType(chartConfigures.measure_scale_type_right),\n        min: chartConfigures.measure_scale_min_right,\n        max: chartConfigures.measure_scale_max_right,\n        definedMin: chartConfigures.measure_scale_defined_min_right || 0,\n        definedSeparate: chartConfigures.measure_scale_step_right,\n        definedStep: chartConfigures.measure_scale_step_number_right,\n        definedScaleFormat: chartConfigures.measure_right_y_configure\n      }),\n      showAxisTitleFlag: showYTitleFlag,\n      measureAxisVisible: chartConfigures.y_axis_label_visible === undefined ? true : chartConfigures.y_axis_label_visible,\n      titleFontSize: theYTitleFontSize,\n      maxLabelWidthPercent: chartConfigures.y_axis_label_max_width_percent,\n      alignZeroFlag: chartConfigures.measure_scale_parallel\n    });\n    if (!yAxisBasicMessage || !yAxisBasicMessage.firstMeasure) return false;\n\n    // 1. 解析数据为当前画图数据: 如果有预测数据，则将其加入到画图数据中，增加标志识别\n    let translateData = _pc_assets_js_charts_components_TranslateDataComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateXYLegendBasicData({\n      tableData: conf.datas,\n      chartAxis: chartAxis,\n      xLabelType: chartConfigures.x_axis_draw_type === 'option_select_x_axis_dot_line' ? 'dotLine' : 'auto',\n      language: systemLanguage,\n      hideCategories\n    });\n    if (!translateData || !translateData.datas) {\n      console.log('当前图形没有合法的画图数据');\n      return false;\n    }\n\n    // 2. 计算是否有标准线及 标准线的宽度\n    let hasMarkerFlag = !hasLegendFlag && chartAxis.curYAxis.length === 1; //  没有图例的情况下[只有一个yAxis时]就有可以有标准线\n    hasMarkerFlag = hasMarkerFlag && !chartConfigures.grid_remove_standard_line; //  是否配置了移除标准线\n    hasMarkerFlag = hasMarkerFlag && translateData.xLabelType !== 'scaleLine'; //  X轴得是属性轴的情况下才有标准线\n    let theMarkerBasicMessage;\n    if (hasMarkerFlag) {\n      theMarkerBasicMessage = _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_9__[\"default\"].calcMeasureMarkerMessage({\n        direction: 'vertical',\n        measureAxis: chartAxis.curYAxis,\n        markerFontSize: chartFontSize,\n        drawWidth: svgDrawWidth,\n        drawHeight: svgDrawHeight,\n        scaleFormat: yAxisBasicMessage.firstMeasure.measureAxis && yAxisBasicMessage.firstMeasure.measureAxis.yScaleFormat,\n        getI18nKey: conf.curLanguage\n      });\n      if (!theMarkerBasicMessage || !theMarkerBasicMessage.hasMarkerFlag) hasMarkerFlag = false;\n    }\n\n    // 翻页时需要重新画以下图形部分 / 缩放时也需要重新画以下图形部分 ---------------------------------------------------------- //\n\n    // 3. 计算X轴刻度值 [ 先通过Y轴刻度宽度值 及 标准线宽度值，计算X轴刻度的宽度 ， 画完X轴刻度后才可以确认X轴刻度的高度]\n    let measureSeparate = 5,\n      //  刻度值与轴之间的间隔[ Y轴刻度与Y轴线之间的间隔 ]\n      attributeSeparate = 2,\n      //  X轴刻度与轴之间的间隔 [ X轴刻度与Y轴最小的一条线的间隔 ]\n      titleSeparate = 5,\n      //  轴标题与轴刻度之间的间隔 [ X轴标题与X轴刻度的间隔 ； Y轴标题与Y轴刻度的间隔 ]\n      firstTitleWidth = yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag ? (yAxisBasicMessage.firstMeasure.measureTitleSize || 0) + titleSeparate : 0,\n      firstMeasureWidth = (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.measureTickWidth || 0) + measureSeparate,\n      secondTitleWidth = yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag ? (yAxisBasicMessage.secondMeasure.measureTitleSize || 0) + titleSeparate : 0,\n      secondMeasureWidth = yAxisBasicMessage.secondMeasure ? yAxisBasicMessage.secondMeasure.measureTickWidth + measureSeparate : 0,\n      markerMessageWidth = theMarkerBasicMessage && theMarkerBasicMessage.markerMaxWidth || 0,\n      scaleAttributeWidth = svgDrawWidth - firstMeasureWidth - firstTitleWidth - secondMeasureWidth - secondTitleWidth - markerMessageWidth;\n\n    // 获取数据标签的配置(最小字体是10)\n    let labelFontSize = chartConfigures.label_text_font_style && parseInt(chartConfigures.label_text_font_style.fontSize) || Math.max(chartFontSize - 2, 10) || 10,\n      showLabelFlag = false,\n      labelPosition = 'default',\n      labelRotation = 0,\n      labelVisibleMap = 'all',\n      allowOverlap = false;\n    if (chartConfigures.label_text_visible) {\n      showLabelFlag = true;\n    }\n    if (chartConfigures.label_text_column_position) {\n      switch (conf.chartConfigures.label_text_column_position) {\n        case 'option_label_position_in':\n          labelPosition = 'in';\n          break;\n        case 'option_label_position_out':\n          labelPosition = 'out';\n          break;\n        default:\n          labelPosition = 'default';\n          break;\n      }\n    }\n    if (chartConfigures.label_text_rotation_angle) {\n      switch (chartConfigures.label_text_rotation_angle) {\n        case 'option_label_rotation_90':\n          labelRotation = 90;\n          break;\n        case 'option_label_rotation_270':\n          labelRotation = 270;\n          break;\n        default:\n          labelRotation = 0;\n          break;\n      }\n    }\n    if (chartConfigures.label_text_visible_items) {\n      switch (chartConfigures.label_text_visible_items) {\n        case 'option_label_visible_all':\n          labelVisibleMap = 'all';\n          break;\n        case 'option_label_visible_standard':\n          labelVisibleMap = 'standard';\n          break;\n        default:\n          labelVisibleMap = 'all';\n          break;\n      }\n    }\n    if (chartConfigures.label_text_allow_overlap) {\n      allowOverlap = true;\n    }\n\n    // 是否显示X轴标题的配置\n    let showXTitleFlag = !conf.inPinboard; //  用户没有配置X轴或配置为自动的情况下，系统按是否是看板自动分配\n    if (!chartConfigures.x_axis_title_visible || chartConfigures.x_axis_title_visible === 'system_auto_default') {\n      showXTitleFlag = !conf.inPinboard;\n    } else {\n      showXTitleFlag = !!(chartConfigures.x_axis_title_visible === \"option_title_visible_show\");\n    }\n    let animateFlag = !chartConfigures.animation_forbidden,\n      //  是否禁止动画的标志\n      colorAssignedToScaleFlag = !!chartConfigures.chart_color_assigned_to_x_scale,\n      //  在没有图例且单个Y轴的情况下，将颜色按X轴刻度分配的标志\n      chartCustomLegend = chartConfigures.chart_custom_label_color;\n    let theXLabelColorList = [],\n      defaultXLabelColorList = [];\n    const duration = {\n      enter: animateFlag ? 300 : 0,\n      update: animateFlag ? 300 : 0,\n      exit: animateFlag ? 300 : 0,\n      pathEnter: animateFlag ? 1200 : 0 // 线条显示的动画\n    };\n    if (!hasLegendFlag) {\n      let theLabelColorConfig = chartConfigures.chart_custom_label_color;\n      translateData.xLabelDistinct && translateData.xLabelDistinct.forEach(function (xLabel, index) {\n        let theMatchedColorConfig = theLabelColorConfig && theLabelColorConfig.find(function (theConfig) {\n          return theConfig.legend === xLabel;\n        });\n        theXLabelColorList.push({\n          id: xLabel,\n          legend: xLabel,\n          //  因为使用的legendList组件，所以显示名命名都是legend\n          color: theMatchedColorConfig && theMatchedColorConfig.color || colorFunc(index)\n        });\n        defaultXLabelColorList.push({\n          id: xLabel,\n          legend: xLabel,\n          color: colorFunc(index)\n        });\n      });\n    }\n\n    // 解析画布中元素的配置\n    let lineStyle,\n      lineWidth = 1,\n      lineSymbolType = 'circle',\n      lineDashedFlag = false,\n      theAnalysisColor = 'red',\n      theAnalysisWidth = 1,\n      circleRadius = 5,\n      // 曲线上的symbol尺寸\n      showPoint = false;\n    let drawShadowFlag = chartConfigures.show_line_shadow;\n    const lineStyleMap = {\n      option_default_value: 'linear',\n      option_line_style_linear: 'linear',\n      option_line_style_step: 'step',\n      option_line_style_step_after: 'step-after',\n      option_line_style_step_before: 'step-before',\n      option_line_style_curve_natural: 'curve-natural',\n      option_line_style_curve_bump_x: 'curve-bump-x',\n      option_line_style_curve_monotone_x: 'curve-monotone-x',\n      option_line_style_curve_monotone_y: 'curve-monotone-y',\n      option_line_style_curve_basis: 'curve-basis'\n    };\n    lineStyle = lineStyleMap[chartConfigures.style_of_line] || lineStyleMap['option_default_value'];\n    if (chartConfigures.show_point !== undefined) {\n      showPoint = !!chartConfigures.show_point;\n    }\n    const lineSymbolMap = {\n      option_legend_shape_type_default: 'circle',\n      option_legend_shape_type_circle: 'circle',\n      // option_legend_shape_type_rect: 'rect',\n      option_legend_shape_type_four: 'four',\n      option_legend_shape_type_diamond: 'diamond',\n      option_legend_shape_type_three: 'three',\n      option_legend_shape_type_five: 'five',\n      option_legend_shape_type_loop: 'loop'\n    };\n    circleRadius = parseInt(chartConfigures.symbol_size_of_line) || 5;\n    if (_DataFocusMethod.isPureNumber(chartConfigures.thickness_of_line)) {\n      lineWidth = parseInt(chartConfigures.thickness_of_line) || 1;\n    }\n    // 折线上的符号与图例符号保持一致\n    lineSymbolType = lineSymbolMap[chartConfigures.legend_shape_type] || lineSymbolMap['option_legend_shape_type_default'];\n    lineDashedFlag = chartConfigures.dashed_solid_of_line === 'option_dashed_solid_of_line_dashed';\n    // todo : columnTextArrays未赋值\n    theAnalysisColor = chartConfigures.outlier_correlation_line_color;\n    if (_DataFocusMethod.isPureNumber(chartConfigures.outlier_correlation_line_width)) {\n      theAnalysisWidth = parseInt(chartConfigures.outlier_correlation_line_width);\n      theAnalysisWidth = Math.max(theAnalysisWidth, 0);\n    }\n\n    /**\r\n     * frameOptions 主要用于翻页 及 缩放时的参数传递\r\n     * @param frameOptions\r\n     *      {\r\n     *          type    -   操作类型    page: 翻页； zoom: 缩放 ； select: 区域选择 ； 无：是初始化\r\n     *          start   -   X刻度开始的索引\r\n     *          steps   -   X轴可以放的X刻度数量\r\n     *      }\r\n     * */\n    let drawAChartFrame = function (frameOptions) {\n      frameOptions = frameOptions || {};\n      let scalePaddingTop = 10; //  垂直方向的刻度轴顶部需要预留10px空白\n\n      let pointsArr = []; // 所有点的数组\n\n      // 清空canvas画布\n      if (!containerResult.canvasJqDom) return false;\n      let theCanvasContext = containerResult.canvasJqDom.getContext('2d');\n      let theCanvasWidth = 0,\n        theCanvasHeight = 0,\n        theCanvasZoom = 2,\n        xLabelStart = 0,\n        //  X轴是属性轴的情况下, X轴刻度的起始位置索引[ 主要给图例高亮使用 ]\n        xLabelEnd = 0,\n        //  X轴是属性轴的情况下, X轴刻度的结束位置索引[ 主要给图例高亮使用 ]\n        xLabelDatas = {},\n        //  X轴是属性轴的情况下, 各个X轴刻度的数据\n        xLabelWidth = 0,\n        //  X轴是属性轴的情况下, 各个X轴刻度的宽度\n        hoverRangeHeight = 0; //  X轴是属性轴的情况下，鼠标移入各个X轴度区域需要显示该区域数据\n      switch (translateData.xLabelType) {\n        // 如果当前图形是属性轴，则按照X轴是属性轴的方式画散点图\n        // X轴是属性轴时，移入该X刻度区域，显示该区域下的所有数据信息 ， 移入单个点高亮放大该点，高亮同图例的数据，置灰其他图例数据\n        case \"timeLine\":\n        case \"levelLine\":\n        case \"dotLine\":\n        default:\n          // X轴是属性时，直接显示所有的X轴刻度及所有的点，无需翻页\n          frameOptions = frameOptions || {};\n          let start = parseInt(frameOptions.start) || 0;\n          let steps = parseInt(frameOptions.steps) || 0;\n          let end = 0;\n          steps = Math.min(steps, translateData.xLabelDistinct.length);\n          steps = Math.max(steps, 1);\n          end = start + steps;\n          if (end > translateData.xLabelDistinct.length) {\n            end = translateData.xLabelDistinct.length;\n            start = end - steps;\n          }\n\n          // 清空SVG的区域\n          xLabelStart = start;\n          xLabelEnd = end;\n          currentPaginationInfo.start = xLabelStart;\n          currentPaginationInfo.end = xLabelEnd;\n          currentPaginationInfo.steps = xLabelEnd - xLabelStart;\n\n          // 画X轴标题[ 如果看板中显示 或者 强制显示的情况 ]\n          let attributeTitleHeight = 0; //  X轴横向摆放的高度\n          const xTitleContainer = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom).select('g.title.horizontal-title');\n          if (xTitleContainer) {\n            xTitleContainer.remove();\n          }\n          if (showXTitleFlag) {\n            let theSettingXTitleText = chartConfigures.x_axis_title_content,\n              theDefaultXTitleText = [];\n            chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n              theDefaultXTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, xAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theXTitleSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', \"KKK\", {\n              fontSize: theXTitleFontSize\n            });\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawAxisTitle({\n              svgContainer: containerResult.svgJqDom,\n              direction: 'horizontal',\n              titleText: theSettingXTitleText || theDefaultXTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.x_axis_title_alignment || 'center',\n              titleFontSize: theXTitleFontSize,\n              titleFontColor: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontItalic,\n              translateTop: svgDrawHeight - theXTitleSize.height,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              titleHeight: theXTitleSize.height,\n              titleWidth: scaleAttributeWidth,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? chartAxis.curXAxis : null\n            });\n            attributeTitleHeight = theXTitleSize.height;\n          }\n\n          // 画X轴刻度\n          let attributeAxis = _pc_assets_js_charts_components_AttributeAxisComponent__WEBPACK_IMPORTED_MODULE_8__[\"default\"].drawHorizontalAttributeAxis({\n            axisType: translateData.xLabelType,\n            axisTimeType: translateData.xAxisTimeType,\n            svgContainer: containerResult.svgJqDom,\n            attributeAxisVisible: chartConfigures.x_axis_label_visible === undefined ? true : chartConfigures.x_axis_label_visible,\n            drawWidth: svgDrawWidth - firstTitleWidth - secondTitleWidth,\n            drawHeight: svgDrawHeight - attributeTitleHeight,\n            axisFontSize: theXAxisFontSize,\n            axisFontColor: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontColor,\n            axisFontBold: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontBold,\n            axisFontItalic: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontItalic,\n            position: 'bottom',\n            attributeValueList: translateData.xLabelDistinct,\n            attributeValueMap: translateData.xLabelDistinctMapping,\n            start: start,\n            end: end,\n            hoverTranslateLeft: firstTitleWidth + firstMeasureWidth,\n            hoverTranslateTop: scalePaddingTop,\n            hoverTopSeparate: attributeSeparate,\n            scaleWidth: scaleAttributeWidth,\n            maxLabelHeightPercent: chartConfigures.x_axis_label_max_height_percent,\n            rotate: chartConfigures.x_axis_label_dot_line_rotation_value,\n            labelStepWidth: chartConfigures.x_axis_label_dot_line_space_width\n          });\n          if (!attributeAxis || !attributeAxis.attributeContainer) {\n            console.log('画点X属性轴异常');\n            return false;\n          }\n          if (attributeAxis.attributeContainer) {\n            attributeAxis.attributeContainer.attr(\"transform\", \"translate(\" + (firstTitleWidth + firstMeasureWidth) + \" , \" + (svgDrawHeight - (attributeAxis.maxLabelHeight || 0) - attributeTitleHeight) + \")\");\n          }\n\n          // 4. 填充Y轴标题 及 刻度 [ 通过X轴刻度高度确定Y轴比例尺的高度，画Y轴刻度，返回Y轴刻度比例尺 ]\n          let scaleMeasureHeight = svgDrawHeight - (attributeAxis.maxLabelHeight || 0) - attributeTitleHeight - attributeSeparate - scalePaddingTop;\n          // 画第一个Y轴标题\n          const firstYTitleContainer = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom).select('g.title.vertical-title.first-y-title');\n          if (firstYTitleContainer) {\n            firstYTitleContainer.remove();\n          }\n          if (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag) {\n            let theDefaultTitleText = [];\n            let theMeasureAxis = yAxisBasicMessage.firstMeasure.measureAxis;\n            theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n              theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theSettingTitleText = chartConfigures.y_axis_title_content;\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawAxisTitle({\n              verticalTitleClass: 'first-y-title',\n              svgContainer: containerResult.svgJqDom,\n              direction: 'vertical',\n              titleText: theSettingTitleText || theDefaultTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n              titleFontSize: theYTitleFontSize,\n              titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n              translateLeft: 0,\n              translateTop: scalePaddingTop,\n              titleHeight: scaleMeasureHeight,\n              titleWidth: yAxisBasicMessage.firstMeasure.measureTitleSize,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n            });\n          }\n\n          // 画第二个Y轴标题\n          const secondYTitleContainer = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom).select('g.title.vertical-title.second-y-title');\n          if (secondYTitleContainer) {\n            secondYTitleContainer.remove();\n          }\n          if (yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag) {\n            let theDefaultTitleText = [];\n            let theMeasureAxis = yAxisBasicMessage.secondMeasure.measureAxis;\n            theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n              theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theSettingTitleText = chartConfigures.right_y_axis_title_content;\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawAxisTitle({\n              verticalTitleClass: 'second-y-title',\n              svgContainer: containerResult.svgJqDom,\n              direction: 'vertical',\n              titleText: theSettingTitleText || theDefaultTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n              //  标题内容\n              titleFontSize: theYTitleFontSize,\n              titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n              translateLeft: firstMeasureWidth + firstTitleWidth + scaleAttributeWidth + secondMeasureWidth + titleSeparate,\n              translateTop: scalePaddingTop,\n              titleHeight: scaleMeasureHeight,\n              titleWidth: yAxisBasicMessage.secondMeasure.measureTitleSize,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n            });\n          }\n\n          // 画Y轴刻度\n          let measureAxis = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].drawMeasureAxis({\n            svgContainer: containerResult.svgJqDom,\n            drawWidth: svgDrawWidth,\n            drawHeight: svgDrawHeight,\n            axisFontSize: theYAxisFontSize,\n            axisFontColor: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontColor,\n            axisFontBold: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontBold,\n            axisFontItalic: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontItalic,\n            direction: 'vertical',\n            separate: measureSeparate,\n            scaleHeight: scaleMeasureHeight,\n            scaleLineWidth: scaleAttributeWidth,\n            firstMeasure: yAxisBasicMessage.firstMeasure,\n            secondMeasure: yAxisBasicMessage.secondMeasure,\n            // 默认显示网格线\n            showAxisLineFlag: chartConfigures.grid_show_all_line === undefined ? true : chartConfigures.grid_show_all_line,\n            // 网格线样式\n            strokeLineStyle: chartConfigures.grid_line_style,\n            // 只显示零线\n            showOnlyZeroLineFlag: !!chartConfigures.grid_show_only_zero_line,\n            // 零线样式\n            zeroStrokeLineStyle: chartConfigures.grid_zero_line_style\n          });\n          measureAxis.measureContainer.attr(\"transform\", \"translate( \" + firstTitleWidth + \" , \" + scalePaddingTop + \")\");\n\n          // 画标准线\n          const existedMarkerLine = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom).selectAll('g.marker-line');\n          if (!existedMarkerLine.empty()) {\n            existedMarkerLine.remove();\n          }\n          if (hasMarkerFlag && theMarkerBasicMessage) {\n            _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawHorizontalMarkerLine({\n              svgContainer: containerResult.svgJqDom,\n              markerTextList: theMarkerBasicMessage.markerTextList,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              markerFontSize: chartFontSize,\n              maxWidth: theMarkerBasicMessage.markerMaxWidth,\n              lineWidth: scaleAttributeWidth,\n              scaleHeight: scaleMeasureHeight,\n              scaleFunc: measureAxis.firstMeasureScaleFunc,\n              markerLineColor: conf.colors(0)\n            });\n          }\n          const existedGoalLine = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom).selectAll('g.goal-line');\n          if (!existedGoalLine.empty()) {\n            existedGoalLine.remove();\n          }\n          // 画目标线\n          chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis) {\n            if (!_DataFocusMethod.isPureNumber(yAxis.goal)) return;\n            // 设置目标值后，需要画目标线\n            if (yAxis.direction !== 'right') {\n              let theScaleFunc = measureAxis.firstMeasureScaleFunc,\n                yScaleFormat = measureAxis.firstMeasure && measureAxis.firstMeasure.yScaleFormat;\n              _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_12__[\"default\"].drawHorizontalGoalLine({\n                svgContainer: containerResult.svgJqDom,\n                position: \"left\",\n                translateLeft: firstTitleWidth + firstMeasureWidth,\n                translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n                lineWidth: scaleAttributeWidth,\n                hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n              });\n            } else {\n              let theScaleFunc = measureAxis.secondMeasureScaleFunc,\n                yScaleFormat = measureAxis.secondMeasure && measureAxis.secondMeasure.yScaleFormat;\n              _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_12__[\"default\"].drawHorizontalGoalLine({\n                svgContainer: containerResult.svgJqDom,\n                position: \"right\",\n                translateLeft: firstTitleWidth + firstMeasureWidth,\n                translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n                lineWidth: scaleAttributeWidth,\n                hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n              });\n            }\n          });\n\n          // 画标度[参考]线 及 区域\n          // 先前的参考线\n          const previousDivisionRange = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom).select('g.reference-container');\n          if (!previousDivisionRange.empty()) previousDivisionRange.remove();\n          if (chartConfigures.scale_y_visible && chartConfigures.scale_y_range) {\n            _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_12__[\"default\"].drawHorizontalDivisionRange({\n              language: systemLanguage,\n              referenceConfigure: chartConfigures.scale_y_range,\n              svgContainer: containerResult.svgJqDom,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              measureAxis: measureAxis,\n              rangeWidth: scaleAttributeWidth,\n              defaultTitleText: conf.curLanguage(\"option_scale_config_text_default\")\n            });\n          }\n          theCanvasWidth = scaleAttributeWidth;\n          theCanvasHeight = scaleMeasureHeight + scalePaddingTop;\n          hoverRangeHeight = scaleMeasureHeight;\n          xLabelWidth = attributeAxis.rangeBand;\n\n          // 有图例的情况， 获取所有散点数据\n          if (translateData.datasType === 'legend') {\n            let thePrevColumnIndex = -1;\n            translateData.legendDistinct && translateData.legendDistinct.forEach(function (theLegendStr, legendIndex) {\n              let theLegendData = translateData.datas[theLegendStr];\n              let theLegendConfig = legendValueList[legendIndex];\n              if (!theLegendConfig.show) return false;\n              thePrevColumnIndex++;\n              if (!theLegendData) return false;\n              let currentPageLegendData = theLegendData && theLegendData.filter(function (data) {\n                let theMappingObj = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[data.x0];\n                let theIndex = theMappingObj && theMappingObj.index || 0;\n                if (theIndex >= start && theIndex < end) {\n                  return true;\n                }\n              });\n              // 有图例的情况Y轴只允许一个\n              const thePointArr = _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].getLineDataSet(currentPageLegendData, {\n                attributeXAxis: attributeAxis,\n                measureYAxis: measureAxis,\n                curYAxis: chartAxis.curYAxis && chartAxis.curYAxis[0],\n                yIndex: 0,\n                yLength: translateData.yLength,\n                legendType: \"legendAxis\",\n                legendId: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId('legendAxis', theLegendStr),\n                legendValue: theLegendStr,\n                legendIndex: legendIndex,\n                legendConfig: theLegendConfig,\n                animateFlag: animateFlag\n              });\n              if (thePointArr) {\n                thePointArr && thePointArr.points.forEach(function (data) {\n                  if (!xLabelDatas[data.x0]) xLabelDatas[data.x0] = [];\n                  xLabelDatas[data.x0].push(data);\n                });\n                pointsArr = pointsArr.concat(thePointArr);\n              }\n            });\n          }\n          // 无图例的情况， 获取所有散点数据\n          else {\n            let theLegendData = translateData.datas;\n            let thePrevColumnIndex = -1;\n            let currentPageLegendData = theLegendData && theLegendData.filter(function (data) {\n              let theMappingObj = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[data.x0];\n              let theIndex = theMappingObj && theMappingObj.index || 0;\n              if (theIndex >= start && theIndex < end) {\n                return true;\n              }\n            });\n            chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis, yIndex) {\n              let theLegendConfig = legendValueList[yIndex];\n              if (!theLegendConfig.show) return false;\n              thePrevColumnIndex++;\n              // 当前页下每条Y轴的线条数据\n              const thePointArr = _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].getLineDataSet(currentPageLegendData, {\n                attributeXAxis: attributeAxis,\n                measureYAxis: measureAxis,\n                curYAxis: yAxis,\n                yIndex: yIndex,\n                yLength: translateData.yLength,\n                legendType: \"YAxis\",\n                legendId: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId('yAxis', yAxis.idx),\n                legendValue: yAxis.col_id,\n                legendIndex: yIndex,\n                legendConfig: theLegendConfig,\n                animateFlag: animateFlag\n              });\n              if (thePointArr) {\n                thePointArr && thePointArr.points.forEach(function (data) {\n                  if (!xLabelDatas[data.x0]) xLabelDatas[data.x0] = [];\n                  xLabelDatas[data.x0].push(data);\n                });\n                pointsArr = pointsArr.concat(thePointArr);\n              }\n            });\n          }\n\n          // 计算所有数据的标签\n          if (showLabelFlag) {\n            pointsArr && pointsArr.forEach(function (pointArr) {\n              const points = pointArr.points;\n              for (const point of points) {\n                let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[point.x0];\n                const xValue = point.x0;\n                // yIndex 是 y轴在Y轴列表中的index, 不是rowData中的index。\n                const yValue = point[`y${point.yIndex}`];\n                let thePointLabelText = (theXLabelMapping && theXLabelMapping.text || xValue) + ':' + yValue;\n                if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n                  let theSuspendTextConfig = chartConfigures.label_text_regex || '';\n                  if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_Y_VALUE\";\n                  thePointLabelText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n                    type: \"label\",\n                    xLabel: theXLabelMapping && theXLabelMapping.text || xValue,\n                    yValue: yValue,\n                    yAxis: chartAxis.curYAxis[point.yIndex],\n                    legend: point.legendValue,\n                    legendIndex: point.legendIndex + 1,\n                    legendTotal: point.total,\n                    rowData: point.rowData,\n                    headers: headers\n                  });\n                }\n                point.labelText = thePointLabelText;\n              }\n            });\n          }\n\n          // 画翻页的元素 [ 翻页也是临时的，不保存在配置中的 ]\n          _pc_assets_js_charts_components_PaginationChartComponent__WEBPACK_IMPORTED_MODULE_13__[\"default\"].drawHorizontalPagination({\n            chartContainer: containerResult.svgContainer,\n            translateLeft: firstTitleWidth,\n            translateTop: scalePaddingTop,\n            height: scaleMeasureHeight,\n            width: scaleAttributeWidth + firstMeasureWidth + secondMeasureWidth + markerMessageWidth,\n            start: start,\n            pageSize: steps,\n            totalNumber: translateData.xLabelDistinct.length,\n            pagingFunc: drawAChartFrame\n          });\n\n          // 区域选择事件\n          _pc_assets_js_charts_components_SelectChartComponent__WEBPACK_IMPORTED_MODULE_14__[\"default\"].selectHorizontalSvgColumnChart({\n            svgContainer: containerResult.svgContainer,\n            translateLeft: firstTitleWidth + firstMeasureWidth,\n            translateTop: scalePaddingTop,\n            width: scaleAttributeWidth,\n            height: scaleMeasureHeight,\n            rangeBand: attributeAxis.rangeBand,\n            prevStart: start,\n            prevSteps: steps,\n            selectFunc: drawAChartFrame,\n            transformScale: conf.inPinboard ? _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].transformScale || 1 : 1\n          });\n          break;\n      }\n\n      // 初始化散点区域的数据\n      $(containerResult.canvasJqDom).css({\n        width: theCanvasWidth,\n        height: theCanvasHeight,\n        left: firstTitleWidth + firstMeasureWidth,\n        top: 0\n      });\n      containerResult.canvasJqDom.width = theCanvasWidth * theCanvasZoom;\n      containerResult.canvasJqDom.height = theCanvasHeight * theCanvasZoom;\n      const d3SvgContainer = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom);\n      const alarmContainer = d3SvgContainer.selectAll('g.alarm-group').data([true]).join(enter => enter.append('g').classed('alarm-group', true), update => update, exit => exit.remove());\n      let chartClipDefId = _pc_assets_js_charts_components_SvgClipPathComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawClipPath({\n        svgContainer: containerResult.svgJqDom,\n        chartUUID: chartUUID,\n        width: scaleAttributeWidth,\n        height: theCanvasHeight,\n        x: firstTitleWidth + firstMeasureWidth,\n        y: 0\n      });\n      const clipPathContainer = d3SvgContainer.selectAll('g.chart-clip-path').data([true]).join(enter => enter.append('g').classed('chart-clip-path', true), update => update, exit => exit.remove()).attr('clip-path', \"url(#\" + chartClipDefId + \")\");\n      const pathGroup = clipPathContainer.selectAll('g.path-group').data([true]).join(enter => enter.append('g').attr('class', 'path-group'), update => update, exit => exit.remove()).attr('transform', `translate(${firstTitleWidth + firstMeasureWidth} ${scalePaddingTop})`);\n\n      // 画出当前散点数据所对应的线条和节点。\n      _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawLine(pointsArr, {\n        alarmXOffset: firstTitleWidth + firstMeasureWidth,\n        alarmContainer: alarmContainer,\n        d3SvgContainer: d3SvgContainer,\n        pathGroup: pathGroup,\n        duration: duration,\n        isCanvasExisted: isCanvasExisted,\n        chartUUID: chartUUID,\n        canvasContext: theCanvasContext,\n        canvasZoom: theCanvasZoom,\n        canvasHeight: theCanvasHeight,\n        canvasWidth: theCanvasWidth,\n        currentLegendValue: frameOptions.currentLegend && frameOptions.currentLegend.legend,\n        currentLegendId: frameOptions.currentLegend && frameOptions.currentLegend.id,\n        // 线条配置\n        lineWidth: lineWidth,\n        lineDashedFlag: lineDashedFlag,\n        drawShadowFlag: drawShadowFlag,\n        lineStyle: lineStyle,\n        showPoint: showPoint,\n        lineSymbolType: lineSymbolType,\n        // 符号样式\n        circleRadius: circleRadius,\n        // 符号的大小\n        enablePointStroke: chartConfigures.point_stroke,\n        // 是否开启符号描边\n        pointStrokeStyle: chartConfigures.point_stroke_style,\n        // 符号描边的样式\n        forecastLineColor: chartConfigures.analysis_forecast_line_color || 'red',\n        // 预测线的颜色\n\n        showLabelFlag: showLabelFlag,\n        // 标签字体大小\n        labelFontSize: labelFontSize,\n        labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor || chartFontColor || \"#333\",\n        labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold || chartFontBold,\n        labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic || chartFontItalic,\n        // 标签位置\n        labelPosition: labelPosition,\n        // 旋转方向\n        labelRotation: labelRotation,\n        // 显示的集合\n        labelVisibleMap: labelVisibleMap,\n        // 标签是否允许重复\n        labelAllowOverlap: allowOverlap,\n        // 是否有动画\n        animateFlag: frameOptions.animateFlag\n      });\n      // Canvas绑定鼠标事件\n      let prevXLabelIndex = -1,\n        theMouseoverHtml,\n        hasMouseOverPathFlag = false; //  是否鼠标移到过线上引起了重新画图\n      _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].appendScatterCanvasEvent({\n        canvasDom: containerResult.canvasJqDom,\n        pointsArr: pointsArr,\n        canvasHeight: theCanvasHeight,\n        canvasWidth: theCanvasWidth,\n        canvasContext: theCanvasContext,\n        canvasZoom: theCanvasZoom,\n        lineWidth: lineWidth,\n        d3SvgContainer: d3SvgContainer,\n        circleRadius: circleRadius,\n        measureXFlag: translateData.xLabelType === 'scaleLine',\n        hoverWidth: xLabelWidth,\n        // 鼠标在当前画布上移动时，显示X轴刻度区域及提示\n        mousemoverXLabelCallback: function (options) {\n          options = options || {};\n          let theXLabelIndex = parseInt(options.xLabelIndex);\n          if (!isNaN(theXLabelIndex) || !options.event) {\n            // 显示当前X刻度的数据信息\n            let theLeftXWidth = theXLabelIndex * xLabelWidth;\n            theXLabelIndex += xLabelStart;\n            if (prevXLabelIndex !== theXLabelIndex && theXLabelIndex >= 0) {\n              prevXLabelIndex = theXLabelIndex;\n              // 显示X刻度 及 各个图例的颜色，图例名称 及 数值\n              let theXLabel = translateData.xLabelDistinct && translateData.xLabelDistinct[theXLabelIndex],\n                theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[theXLabel],\n                theXLabelData = xLabelDatas && xLabelDatas[theXLabel];\n              theMouseoverHtml = (theXLabelMapping && theXLabelMapping.text || theXLabel) + '<br/>';\n              theXLabelData && theXLabelData.forEach(function (data, index) {\n                if (data.legendConfig) {\n                  theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + data.legendConfig.color + ';margin-right:2px;\"></span>';\n                }\n                let theYAxis = chartAxis.curYAxis[data.yIndex];\n                if (chartAxis.curLegend) {\n                  theMouseoverHtml += _DataFocusMethod.formatData(data.legendValue, chartAxis.curLegend) + ':';\n                  theMouseoverHtml += _DataFocusMethod.formatData(data.y0, theYAxis);\n                } else {\n                  theMouseoverHtml += _DataFocusMethod.getDisplayOperateColumn(conf.systemLanguage, theYAxis, {\n                    hideOperator: !conf.aggregationFlag\n                  }) + ':';\n                  theMouseoverHtml += _DataFocusMethod.formatData(data['y' + data.yIndex], theYAxis);\n                }\n                theMouseoverHtml += '<br />';\n              });\n            }\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].positionChartPrompt(options.event, theMouseoverHtml);\n            let theSvgDom = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(containerResult.svgJqDom),\n              theHoverDom = theSvgDom.select(\".hover-area-dom\");\n            function setRectForHoverDom(rect) {\n              rect.style(\"fill\", \"rgba(137,137,137,0.3)\").style(\"stroke\", \"none\").attr(\"x\", \"0\").attr(\"y\", \"0\").attr(\"width\", xLabelWidth).attr(\"height\", theCanvasHeight);\n            }\n            function setLineForHoverDom(line) {\n              line.style(\"stroke\", \"rgba(93 , 25 , 128)\").style(\"stroke-width\", \"1\").attr(\"x1\", \"0\").attr(\"y1\", theCanvasHeight).attr(\"x2\", xLabelWidth).attr(\"y2\", theCanvasHeight);\n            }\n            if (theHoverDom.empty()) {\n              theHoverDom = theSvgDom.append(\"g\").attr(\"class\", \"hover-area-dom\").attr(\"pointer-events\", 'none');\n              theHoverDom.append(\"rect\").call(setRectForHoverDom);\n              theHoverDom.append(\"line\").call(setLineForHoverDom);\n            } else {\n              theHoverDom.select(\"rect\").call(setRectForHoverDom);\n              theHoverDom.select(\"line\").call(setLineForHoverDom);\n            }\n            theHoverDom.attr(\"transform\", \"translate(\" + (firstTitleWidth + firstMeasureWidth + theLeftXWidth) + \", 0)\");\n          }\n        },\n        // 移出整个画布时，清除高亮X轴的区域\n        mouseoutXLabelCallback: function () {\n          let theContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom);\n          theContainer.select(\".hover-area-dom\").remove();\n        },\n        // 鼠标移入当前散点，高亮同图例的散点\n        mouseoverCircleCallback: function (event, options) {\n          let theTranslateSuspendText;\n          options = options || {};\n          let theScatterData = options.scatterData;\n          if (!theScatterData) return false;\n          let theScatterIndex = theScatterData.rowIndex;\n          const yIndex = theScatterData.yIndex;\n          // 高亮当前图例的点\n          if (theScatterData.legendValue) {\n            hasMouseOverPathFlag = true;\n            _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawLine(pointsArr, {\n              alarmXOffset: firstTitleWidth + firstMeasureWidth,\n              alarmContainer: alarmContainer,\n              d3SvgContainer: d3SvgContainer,\n              pathGroup: pathGroup,\n              duration: duration,\n              isCanvasExisted: isCanvasExisted,\n              chartUUID: chartUUID,\n              canvasContext: theCanvasContext,\n              canvasZoom: theCanvasZoom,\n              canvasHeight: theCanvasHeight,\n              canvasWidth: theCanvasWidth,\n              currentLegendValue: theScatterData.legendConfig.legend,\n              currentLegendId: theScatterData.legendId,\n              selectedScatterIndex: theScatterIndex,\n              showLabelFlag: showLabelFlag,\n              // 标签字体大小\n              labelFontSize: labelFontSize,\n              labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n              labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n              labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n              // 标签位置\n              labelPosition: labelPosition,\n              // 旋转方向\n              labelRotation: labelRotation,\n              // 显示的集合\n              labelVisibleMap: labelVisibleMap,\n              // 标签是否允许重复\n              labelAllowOverlap: allowOverlap,\n              // 线条配置\n              lineWidth: lineWidth,\n              lineDashedFlag: lineDashedFlag,\n              drawShadowFlag: drawShadowFlag,\n              lineStyle: lineStyle,\n              showPoint: showPoint,\n              lineSymbolType: lineSymbolType,\n              // 符号样式\n              circleRadius: circleRadius,\n              // 符号的大小\n              enablePointStroke: chartConfigures.point_stroke,\n              // 是否开启符号描边\n              pointStrokeStyle: chartConfigures.point_stroke_style,\n              // 符号描边的样式\n              forecastLineColor: chartConfigures.analysis_forecast_line_color || 'red',\n              // 预测线的颜色\n\n              // 是否有动画\n              animateFlag: animateFlag\n            });\n            let theMatchedLegend = legendValueList.find(function (item) {\n              return item.legend === theScatterData.legendConfig.legend;\n            });\n            if (theMatchedLegend && theMatchedLegend.id && theMatchedLegend.show) {\n              let theLegendItem = $(containerResult.legendContainer).find(\".legend-item[data-legend-id='\" + theMatchedLegend.id + \"']\");\n              theLegendItem.find(\"svg\").removeClass(\"fill-grey\");\n              theLegendItem.siblings().find(\"svg\").addClass(\"fill-grey\");\n            }\n          }\n          if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n            let theSuspendTextConfig = chartConfigures.suspend_text_regex || '';\n            if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_SERIES_NAME %_BR %_NAME %_BR  %_VALUE_NAME : %_VALUE\";\n            let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[theScatterData.x0];\n            theTranslateSuspendText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n              xValue: theXLabelMapping && theXLabelMapping.text || theScatterData.x0,\n              yValue: theScatterData[`y${yIndex}`],\n              yAxis: chartAxis.curYAxis[yIndex],\n              legend: theScatterData.legendConfig.legend,\n              legendIndex: theScatterData.legendIndex + 1,\n              legendTotal: theScatterData.total,\n              rowData: theScatterData.rowData,\n              headers: headers\n            });\n          }\n          _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].positionChartPrompt(event, theTranslateSuspendText || theScatterData.x0 + ':' + theScatterData.y0);\n        },\n        // 鼠标移入线条\n        mouseoverPathCallback: function (event, options) {\n          options = options || {};\n          let theScatterData = options.scatterData;\n          if (!theScatterData) return false;\n\n          // 高亮当前图例的点\n          if (theScatterData.legendValue) {\n            hasMouseOverPathFlag = true;\n            _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawLine(pointsArr, {\n              alarmXOffset: firstTitleWidth + firstMeasureWidth,\n              alarmContainer: alarmContainer,\n              d3SvgContainer: d3SvgContainer,\n              pathGroup: pathGroup,\n              duration: duration,\n              isCanvasExisted: isCanvasExisted,\n              chartUUID: chartUUID,\n              canvasContext: theCanvasContext,\n              canvasZoom: theCanvasZoom,\n              canvasHeight: theCanvasHeight,\n              canvasWidth: theCanvasWidth,\n              currentLegendValue: theScatterData.legendConfig.legend,\n              currentLegendId: theScatterData.legendId,\n              // 线条配置\n              lineWidth: lineWidth,\n              lineDashedFlag: lineDashedFlag,\n              drawShadowFlag: drawShadowFlag,\n              lineStyle: lineStyle,\n              showPoint: showPoint,\n              lineSymbolType: lineSymbolType,\n              // 符号样式\n              circleRadius: circleRadius,\n              // 符号的大小\n              enablePointStroke: chartConfigures.point_stroke,\n              // 是否开启符号描边\n              pointStrokeStyle: chartConfigures.point_stroke_style,\n              // 符号描边的样式\n              forecastLineColor: chartConfigures.analysis_forecast_line_color || 'red',\n              // 预测线的颜色\n\n              showLabelFlag: showLabelFlag,\n              // 标签字体大小\n              labelFontSize: labelFontSize,\n              labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n              labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n              labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n              // 标签位置\n              labelPosition: labelPosition,\n              // 旋转方向\n              labelRotation: labelRotation,\n              // 显示的集合\n              labelVisibleMap: labelVisibleMap,\n              // 标签是否允许重复\n              labelAllowOverlap: allowOverlap,\n              // 是否有动画\n              animateFlag: false\n            });\n            let theMatchedLegend = legendValueList.find(function (item) {\n              return item.legend === theScatterData.legendConfig.legend;\n            });\n            if (theMatchedLegend && theMatchedLegend.id && theMatchedLegend.show) {\n              let theLegendItem = $(containerResult.legendContainer).find(\".legend-item[data-legend-id='\" + theMatchedLegend.id + \"']\");\n              theLegendItem.find(\"svg\").removeClass(\"fill-grey\");\n              theLegendItem.siblings().find(\"svg\").addClass(\"fill-grey\");\n            }\n          }\n        },\n        // 鼠标移出当前散点，高亮所有图例的散点\n        mouseoutPathCallback: function () {\n          _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].clearChartPrompt();\n\n          // 移入线后，移出才需要重新画图\n          if (hasMouseOverPathFlag) {\n            _LineChartComponent_js__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawLine(pointsArr, {\n              alarmXOffset: firstTitleWidth + firstMeasureWidth,\n              alarmContainer: alarmContainer,\n              d3SvgContainer: d3SvgContainer,\n              pathGroup: pathGroup,\n              duration: duration,\n              isCanvasExisted: isCanvasExisted,\n              chartUUID: chartUUID,\n              canvasContext: theCanvasContext,\n              canvasZoom: theCanvasZoom,\n              canvasHeight: theCanvasHeight,\n              canvasWidth: theCanvasWidth,\n              // 线条配置\n              lineWidth: lineWidth,\n              lineDashedFlag: lineDashedFlag,\n              drawShadowFlag: drawShadowFlag,\n              lineStyle: lineStyle,\n              showPoint: showPoint,\n              lineSymbolType: lineSymbolType,\n              // 符号样式\n              circleRadius: circleRadius,\n              // 符号的大小\n              enablePointStroke: chartConfigures.point_stroke,\n              // 是否开启符号描边\n              pointStrokeStyle: chartConfigures.point_stroke_style,\n              // 符号描边的样式\n              forecastLineColor: chartConfigures.analysis_forecast_line_color || 'red',\n              // 预测线的颜色\n\n              showLabelFlag: showLabelFlag,\n              // 标签字体大小\n              labelFontSize: labelFontSize,\n              labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n              labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n              labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n              // 标签位置\n              labelPosition: labelPosition,\n              // 旋转方向\n              labelRotation: labelRotation,\n              // 显示的集合\n              labelVisibleMap: labelVisibleMap,\n              // 标签是否允许重复\n              labelAllowOverlap: allowOverlap,\n              // 是否有动画\n              animateFlag: false\n            });\n            hasMouseOverPathFlag = false;\n          }\n          $(containerResult.legendContainer).find(\".legend-item .fill-grey\").removeClass(\"fill-grey\");\n        },\n        // 鼠标点击当前散点，触发左右击事件\n        mousedownCallback: function (event, d) {\n          // 移动端的mousedown事件不执行\n          if (!!(conf.action && !conf.wxFlag)) {\n            let theDataColumnIdx = [];\n            chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n              theDataColumnIdx.push(xAxis.idx);\n            });\n            if (chartAxis && chartAxis.curLegend) {\n              theDataColumnIdx.push(chartAxis.curLegend.idx);\n            }\n            typeof conf.mousedownCallback === 'function' && conf.mousedownCallback.call(this, event, {\n              dataColumnIndex: theDataColumnIdx,\n              dataRowIndex: d.rowIndex\n            });\n          }\n        }\n      });\n      return {\n        start: xLabelStart,\n        end: xLabelEnd\n      };\n    };\n\n    // 默认画第一页数据\n    aChartFrameReturn = drawAChartFrame({\n      start: 0,\n      steps: translateData.xLabelDistinct.length,\n      end: translateData.xLabelDistinct.length,\n      animateFlag: animateFlag\n    });\n\n    /* *\r\n    * 画完图需要告诉外部的配置组件，当前图形的配置：\r\n    *   X轴类型是单层刻度/多层刻度/时间轴 及 单层刻度列表 ； 或者用户配置的类型 ；\r\n    *   标题是自动显示，还是自动隐藏 ； 或者是用户配置的显示及隐藏\r\n    *   是否有右Y轴\r\n    *   是否有图例，属性列图例；多Y轴图例 ；\r\n    * */\n    let returnConfigureAutoValue = {};\n    // 如果用户配置的X轴类型是自动，则返回给图形配置组件提供当前X轴的自动类型\n    if (chartConfigures.x_axis_draw_type !== 'option_select_x_axis_dot_line') {\n      switch (translateData.autoXLabelType) {\n        case \"dotLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_dot_line';\n          break;\n        case \"timeLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_time_line';\n          break;\n        case \"levelLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_level_line';\n          break;\n        case \"scaleLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_scale_line';\n          break;\n      }\n    }\n    if (translateData.xLabelType === 'scaleLine') {\n      returnConfigureAutoValue.measure_x_flag = true;\n    }\n    // 如果用户配置X轴标题显示自动，则返回给图形配置组件提供当前X轴标题的自动显示类型\n    if (!chartConfigures.x_axis_title_visible || chartConfigures.x_axis_title_visible === 'system_auto_default') {\n      returnConfigureAutoValue.x_axis_title_visible = showXTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n    }\n    // 如果用户配置Y轴标题显示自动，则返回给图形配置组件提供当前Y轴标题的自动显示类型\n    if (!chartConfigures.y_axis_title_visible || chartConfigures.y_axis_title_visible === 'system_auto_default') {\n      returnConfigureAutoValue.y_axis_title_visible = yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n    }\n    // 如果用户配置了右Y轴，则将右Y轴存在的标志传给图形\n    if (yAxisBasicMessage.secondMeasure) {\n      returnConfigureAutoValue.has_right_y_axis = true;\n      // 如果用户配置右Y轴标题显示自动，则返回给图形配置组件提供当前右Y轴标题的自动显示类型\n      if (!chartConfigures.right_y_axis_title_visible || chartConfigures.right_y_axis_title_visible === 'system_auto_default') {\n        returnConfigureAutoValue.right_y_axis_title_visible = yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n      }\n    }\n    // 如果当前图形配置有图例，则将图例配置传给图形\n    if (hasLegendFlag) {\n      returnConfigureAutoValue.has_legend_flag = hasLegendFlag;\n      returnConfigureAutoValue.legendValueList = legendValueList;\n      returnConfigureAutoValue.defaultLegendList = defaultLegendList;\n    } else {\n      returnConfigureAutoValue.xLabelColorList = theXLabelColorList;\n      returnConfigureAutoValue.defaultXLabelColorList = defaultXLabelColorList;\n    }\n    // 如果当前图形可以配置最大最小值标准线，则将该配置传给图形\n    if (!hasLegendFlag && translateData.xLabelType !== 'scaleLine' && chartAxis.curYAxis.length === 1) {\n      returnConfigureAutoValue.allow_marker_flag = true;\n    }\n    return {\n      chartAutoConfigures: returnConfigureAutoValue\n    };\n  },\n  // [*必填项]图表配置列表，其中的require条件不仅可以使用以下配置项的key，也可以使用drawChart中返回的chartAutoConfigures中的值\n  // drawChart返回的chartAutoConfigures是图形返回给图形配置组件的信息，用于开发者可以控制配置的显示与隐藏\n  /**\r\n   * [\r\n   *      key: 'category_name' ,\r\n   *      title: \"category_display_name_key\" ,\r\n   *      require: \"\" ,\r\n   *      options: [\r\n   *          {\r\n   *              key: 'configure_name'\r\n   *              title: 'configure_display_name_key'\r\n   *              description: 'configure_description_key'\r\n   *              require: '' ,\r\n   *              type: 'theme / select / input ... '\r\n   *          }\r\n   *      ]\r\n   *\r\n   * ]\r\n   *\r\n   * */\n  chartConfigureList: [\n  // 通用 ： 字体大小，动画，最小柱宽，\n  {\n    key: \"category_general\",\n    title: \"category_general\",\n    options: [\n    // 图形的颜色主题\n    {\n      key: \"chart_color_theme\",\n      title: \"option_chart_color_theme\",\n      description: \"option_chart_color_theme_desc\",\n      type: \"theme\",\n      selection: [\"option_chart_theme_eight\", \"option_chart_theme_one\", \"option_chart_theme_two\", \"option_chart_theme_three\", \"option_chart_theme_four\", \"option_chart_theme_five\", \"option_chart_theme_six\", \"option_chart_theme_seven\", \"option_chart_theme_custom\"],\n      defaultValue: \"option_chart_theme_one\"\n    },\n    //自定义主题颜色\n    {\n      key: \"chart_custom_theme\",\n      title: \"option_chart_custom_theme\",\n      description: \"option_chart_custom_theme_desc\",\n      type: \"colorList\",\n      require: \"chart_color_theme=option_chart_theme_custom\"\n    },\n    // 图形字体大小\n    {\n      key: \"font_size_label\",\n      title: \"option_font_size_label\",\n      description: \"option_font_size_label_desc\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      }\n    },\n    // 隐藏聚合方式 [ 图例的聚合方式 ]\n    {\n      key: \"hide_operator_label\",\n      title: \"option_hide_operator_label\",\n      description: \"option_hide_operator_label_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 禁止图形动画\n    {\n      key: \"animation_forbidden\",\n      title: \"option_animation_forbidden\",\n      description: \"option_animation_forbidden_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 图例限制条目数，默认为50\n    {\n      key: \"legend_count_limit\",\n      title: \"option_legend_count_limit\",\n      description: \"option_legend_count_limit_desc\",\n      defaultNumber: 50,\n      max: 1000,\n      withoutSlider: true,\n      type: \"input\",\n      reTranslateResult: true\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 线条样式\n  {\n    key: \"category_line_config\",\n    title: \"category_line_config\",\n    options: [\n    // 折线样式配置\n    {\n      key: \"style_of_line\",\n      title: \"option_style_of_line\",\n      description: \"option_style_of_line_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_line_style_linear\", \"option_line_style_step\", \"option_line_style_step_after\", \"option_line_style_step_before\", \"option_line_style_curve_natural\", \"option_line_style_curve_basis\", \"option_line_style_curve_bump_x\", \"option_line_style_curve_monotone_x\", \"option_line_style_curve_monotone_y\"\n      // \"option_style_line_normal_symbol\",\n      // \"option_style_line_curve_symbol\",\n      // \"option_style_line_step_symbol\"\n      ]\n    }, {\n      key: \"thickness_of_line\",\n      title: \"option_thickness_of_line\",\n      description: \"option_thickness_of_line_desc\",\n      type: \"input\",\n      min: 1,\n      defaultNumber: 1\n    },\n    // 显示节点\n    {\n      key: \"show_point\",\n      title: \"option_show_point\",\n      description: \"option_show_point_desc\",\n      type: \"checkbox-prev\",\n      defaultValue: false\n    },\n    // 节点半径\n    {\n      key: \"symbol_size_of_line\",\n      title: \"option_symbol_size_of_line\",\n      description: \"option_symbol_size_of_line_desc\",\n      withoutSlider: true,\n      type: 'input',\n      defaultNumber: 5,\n      require: \"show_point\"\n    },\n    // 节点样式\n    {\n      key: \"legend_shape_type\",\n      title: \"option_legend_shape_type\",\n      description: \"option_legend_shape_type_desc\",\n      type: \"shape-select\",\n      // selection:[\n      //     \"repeat_option_node_shape\",\n      //     \"circle_option_node_shape\",\n      //     \"rect_option_node_shape\",\n      //     \"triangle_option_node_shape\",\n      //     \"diamond_option_node_shape\",\n      //     \"star_option_node_shape\",\n      //     \"fivestar_option_node_shape\",\n      //     \"hexagon_option_node_shape\",\n      //     \"jewel_option_node_shape\",\n      //     \"x_option_node_shape\",\n      // ],\n      selection: [\n      // \"option_default_value\",\n      \"option_legend_shape_type_circle\",\n      // \"option_legend_shape_type_rect\",\n      \"option_legend_shape_type_four\", \"option_legend_shape_type_diamond\", \"option_legend_shape_type_three\", \"option_legend_shape_type_five\", \"option_legend_shape_type_loop\"],\n      require: \"show_point\"\n    },\n    // 显示节点描边\n    {\n      key: \"point_stroke\",\n      title: \"option_point_stroke\",\n      description: \"option_point_stroke_desc\",\n      type: \"checkbox-prev\",\n      defaultValue: false,\n      require: \"show_point\"\n    },\n    // 设置节点描边的宽度、颜色\n    {\n      key: \"point_stroke_style\",\n      title: \"option_point_stroke_style\",\n      description: \"option_point_stroke_style_desc\",\n      type: \"lineStyle\",\n      defaultValue: {\n        lineColor: \"rgba(255, 255, 255 , 1)\",\n        lineWidth: 1\n      },\n      hideLineStyleConfig: true,\n      require: \"point_stroke\"\n    },\n    // 虚实\n    {\n      key: \"dashed_solid_of_line\",\n      title: \"option_dashed_solid_of_line\",\n      description: \"option_dashed_solid_of_line_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_dashed_solid_of_line_solid\", \"option_dashed_solid_of_line_dashed\"]\n    },\n    // 阴影线\n    {\n      key: \"show_line_shadow\",\n      title: \"option_show_line_shadow\",\n      description: \"option_show_line_shadow_desc\",\n      type: \"checkbox\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 颜色：颜色主题，图例形状颜色，单Y轴情况下，将颜色分配给各个X轴刻度，各个刻度的颜色\n  {\n    key: \"category_color\",\n    title: \"category_color\",\n    options: [\n    // 自定义图例颜色[ @20221201 tong - 新的图例颜色样式配置结构  从attrColorArray组件调整为container组件 ]\n    // 仪表图只能通过点击选择图例颜色，无法通过配置设置\n    // 图例类型是单个属性列的情况下，配置各个图例的颜色，虚实....\n    {\n      key: \"chart_legend_list\",\n      // \"chart_custom_legend_new\",\n      type: \"legendList\",\n      legendConfigSet: ['color', 'show', 'shape', 'dash', 'shadow'],\n      //  当前图例可以配置的值 color: 颜色 ； shape:形状 ；dash： 虚实 ； shadow: 阴影\n      legendShapeSelection: [\"option_legend_shape_type_circle\", \"option_legend_shape_type_four\", \"option_legend_shape_type_diamond\", \"option_legend_shape_type_three\", \"option_legend_shape_type_five\"],\n      legendDashSelection: [\"option_dashed_solid_of_line_solid\", \"option_dashed_solid_of_line_dashed\"],\n      legendValueList: \"legendValueList\",\n      //  当前所有图例使用的配置值\n      defaultLegendList: \"defaultLegendList\",\n      //  当前所有图例的默认值\n      require: \"has_legend_flag\",\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }],\n    require: \"has_legend_flag\"\n  },\n  // X轴： X刻度类型[单层/多层/时间]，最高高度，倾斜角度，X轴标题显示，标题自定义，隐藏X轴\n  {\n    key: \"category_x_axis\",\n    title: \"category_x_axis\",\n    options: [\n    // 显示隐藏X轴标签\n    {\n      key: \"x_axis_label_visible\",\n      title: \"option_axis_label_visible\",\n      type: 'checkbox-prev',\n      defaultValue: true\n    },\n    // X轴标签字体样式 [ 显示轴标签才可以配置， 大小 ，颜色，字体，加粗，斜体，下划线 ]\n    {\n      key: \"x_axis_label_style\",\n      title: \"option_font_style\",\n      type: 'fontStyle',\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"x_axis_label_visible\"\n    },\n    // X轴刻度类型[ 单层属性 / 多层属性 / 时间轴 ]\n    // 刻度类型只能在单层与多层之间切换 或者 单层与时间轴之间切换， 所以提供两种选项：自动 ; 单层 ；\n    {\n      key: \"x_axis_draw_type\",\n      title: \"option_x_axis_draw_type\",\n      description: \"option_x_axis_draw_type_desc\",\n      type: 'selectTile',\n      selection: [\"system_auto_default\", \"option_select_x_axis_dot_line\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\",\n      require: \"x_axis_label_visible\"\n    },\n    // X轴单层属性下，旋转角度\n    {\n      // attribute_label_rotate\n      key: \"x_axis_label_dot_line_rotation_value\",\n      title: \"option_x_axis_label_dot_line_rotation_value\",\n      type: 'input',\n      withoutSlider: true,\n      defaultNumber: 30,\n      min: 0,\n      max: 180,\n      // X轴是单层散点模式 且 显示轴标签时，才可以配置旋转角度\n      require: \"x_axis_label_visible;x_axis_draw_type=option_select_x_axis_dot_line\"\n    },\n    // X轴单层属性下，刻度间距\n    {\n      // attribute_label_space_width\n      key: \"x_axis_label_dot_line_space_width\",\n      title: \"option_x_axis_label_dot_line_space_width\",\n      description: \"option_x_axis_label_dot_line_space_width_desc\",\n      type: 'input',\n      withoutSlider: true,\n      min: 1,\n      max: 999,\n      defaultNumber: 50,\n      // X轴是单层散点模式 且 显示轴标签时，才可以配置旋转角度\n      require: \"x_axis_label_visible;x_axis_draw_type=option_select_x_axis_dot_line\"\n    },\n    // X轴最大高度限制\n    {\n      // attribute_label_max_height\n      key: \"x_axis_label_max_height_percent\",\n      title: \"option_x_axis_label_max_height_percent\",\n      description: \"option_x_axis_label_max_height_percent_desc\",\n      type: 'input',\n      min: 0,\n      max: 100,\n      defaultNumber: 30,\n      step: 5,\n      require: \"x_axis_label_visible\"\n    },\n    // X轴标题自动 / 强制显示 / 强制隐藏 [ 平铺选项 ]\n    {\n      key: \"x_axis_title_visible\",\n      title: \"option_axis_title_visible\",\n      description: \"option_axis_title_visible_desc\",\n      type: 'selectTile',\n      prevIcon: \"eye-icon\",\n      openEyeValue: \"option_title_visible_show\",\n      selection: [\"system_auto_default\", \"option_title_visible_show\", \"option_title_visible_hide\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\"\n    },\n    // 自定义的X轴标题内容\n    {\n      key: \"x_axis_title_content\",\n      title: \"option_axis_title_content\",\n      description: \"option_axis_title_content_desc\",\n      type: \"text\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题字体样式\n    {\n      key: \"x_axis_title_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题对齐方式\n    {\n      key: \"x_axis_title_alignment\",\n      title: \"option_font_alignment\",\n      type: \"fontAlign\",\n      defaultValue: \"center\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // Y轴：Y轴刻度最宽宽度，Y轴标尺，Y轴标题\n  {\n    key: \"category_y_axis\",\n    title: \"category_y_axis\",\n    options: [\n    // 显示隐藏Y轴标签\n    {\n      key: \"y_axis_label_visible\",\n      title: \"option_axis_label_visible\",\n      type: 'checkbox-prev',\n      defaultValue: true\n    },\n    // Y轴标签字体样式 [ 显示轴标签才可以配置， 大小 ，颜色，字体，加粗，斜体，下划线 ]\n    {\n      key: \"y_axis_label_style\",\n      title: \"option_font_style\",\n      type: 'fontStyle',\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"y_axis_label_visible\"\n    },\n    // Y轴数据格式\n    {\n      key: \"measure_left_y_configure\",\n      title: \"option_measure_configure\",\n      description: \"option_measure_left_y_configure_desc\",\n      type: \"axisFormat\"\n    },\n    // Y轴最大宽度限制\n    {\n      key: \"y_axis_label_max_width_percent\",\n      title: \"option_y_axis_label_max_width_percent\",\n      type: 'input',\n      min: 0,\n      max: 100,\n      defaultNumber: 30,\n      step: 5,\n      require: \"y_axis_label_visible\"\n    },\n    // Y轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      defaultValue: \"option_default_value\"\n    },\n    // 默认类型下最大值\n    {\n      key: \"measure_scale_min\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_scale_type!=option_measure_scale_type_define'\n    },\n    // 默认类型下最小值\n    {\n      key: \"measure_scale_max\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_scale_type!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // Y轴标题自动 / 强制显示 / 强制隐藏 [ 平铺选项 ]\n    {\n      key: \"y_axis_title_visible\",\n      title: \"option_axis_title_visible\",\n      description: \"option_axis_title_visible_desc\",\n      type: 'selectTile',\n      prevIcon: \"eye-icon\",\n      openEyeValue: \"option_title_visible_show\",\n      selection: [\"system_auto_default\", \"option_title_visible_show\", \"option_title_visible_hide\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\"\n    },\n    // 自定义的Y轴标题内容\n    {\n      key: \"y_axis_title_content\",\n      title: \"option_axis_title_content\",\n      type: \"text\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题字体样式\n    {\n      key: \"y_axis_title_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题对齐方式\n    {\n      key: \"y_axis_title_alignment\",\n      title: \"option_font_alignment\",\n      type: \"fontAlign\",\n      defaultValue: \"center\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 右Y轴[ 有右Y轴的情况下，该信息由画图组件提供出去 ]\n  {\n    key: \"category_right_y_axis\",\n    title: \"category_right_y_axis\",\n    require: \"has_right_y_axis\",\n    options: [\n    // Y轴数据格式\n    {\n      key: \"measure_right_y_configure\",\n      title: \"option_measure_configure\",\n      description: \"option_measure_right_y_configure_desc\",\n      type: \"axisFormat\"\n    },\n    // Y轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type_right\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      defaultValue: \"option_default_value\"\n    },\n    // 默认类型下最大值\n    {\n      key: \"measure_scale_min_right\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right!=option_measure_scale_type_define'\n    },\n    // 默认类型下最小值\n    {\n      key: \"measure_scale_max_right\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min_right\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step_right\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number_right\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义的Y轴标题内容\n    {\n      key: \"right_y_axis_title_content\",\n      title: \"option_axis_title_content\",\n      type: \"text\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 左右Y轴0刻度对齐\n    {\n      key: \"measure_scale_parallel\",\n      title: \"option_measure_scale_parallel\",\n      description: \"option_measure_scale_parallel_desc\",\n      type: \"checkbox-prev\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //图例： 是否隐藏，图例色块形状，图例位置，图例宽度，图例间隔 ， 图例限制条目数\n  {\n    key: \"category_legend_config\",\n    title: \"category_legend_config\",\n    require: \"has_legend_flag\",\n    options: [\n    // 隐藏图例\n    {\n      key: \"show_legend\",\n      title: \"option_map_info_show\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // 字体样式\n    {\n      key: \"legend_font_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"show_legend\"\n    },\n    // 图例位置\n    {\n      key: \"legend_position\",\n      title: \"option_legend_position\",\n      description: \"option_legend_position_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_position_right\", \"option_position_top\", \"option_position_bottom\", \"option_position_right_top\"],\n      require: \"show_legend\"\n    },\n    // 图例宽度\n    {\n      key: \"legend_position_width\",\n      title: \"option_legend_position_width\",\n      description: \"option_legend_position_width_desc\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      max: 200,\n      defaultNumber: 80,\n      require: \"show_legend;legend_position=option_position_top,option_position_bottom\"\n    },\n    // 图例离画图区域的间隔\n    {\n      key: \"legend_position_offset\",\n      title: \"option_legend_position_offset\",\n      description: \"option_legend_position_offset_desc\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      max: 100,\n      defaultNumber: 5,\n      require: \"show_legend\"\n    },\n    // 图例之间的间隔\n    {\n      key: \"legend_position_interval\",\n      title: \"option_legend_position_interval\",\n      description: \"option_legend_position_interval_desc\",\n      type: \"input\",\n      allowNullFlag: true,\n      withoutSlider: true,\n      min: 0,\n      max: 100,\n      require: \"show_legend\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 网格线配置\n  {\n    key: \"category_grid_line\",\n    title: \"category_grid_line\",\n    options: [\n    // 网格线分别可以配置零线显示/样式（虚实粗细颜色） ； 非零线显示/样式（虚实粗细颜色）；\n    // 显示所有的网格线\n    {\n      key: \"grid_show_all_line\",\n      title: \"option_grid_show_all_line\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // 只显示零线\n    {\n      key: \"grid_show_only_zero_line\",\n      title: \"option_grid_show_only_zero_line\",\n      description: \"option_grid_show_only_zero_line_desc\",\n      type: \"checkbox-prev\",\n      require: \"grid_show_all_line\"\n    },\n    // 网格线样式\n    {\n      key: \"grid_line_style\",\n      title: \"option_grid_line_style\",\n      description: \"option_grid_line_style_desc\",\n      type: \"lineStyle\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"grid_show_all_line\"\n    },\n    // 零线样式\n    {\n      key: \"grid_zero_line_style\",\n      title: \"option_grid_zero_line_style\",\n      description: \"option_grid_zero_line_style_desc\",\n      type: \"lineStyle\",\n      defaultValueConfig: \"grid_line_style\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"grid_show_all_line\"\n    },\n    // 隐藏最大值/最小值标准线，在有的情况下显示该配置\n    {\n      key: \"grid_remove_standard_line\",\n      title: \"option_grid_remove_standard_line\",\n      description: \"option_grid_remove_standard_line_desc\",\n      type: \"checkbox-prev\",\n      require: \"allow_marker_flag\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 数据标签格式\n  {\n    key: \"category_label\",\n    title: \"category_label\",\n    options: [\n    // 是否显示数据标签\n    {\n      key: \"label_text_visible\",\n      title: \"option_label_text_visible\",\n      description: \"option_label_text_visible_desc\",\n      type: 'checkbox-prev'\n    },\n    // 字体样式\n    {\n      key: \"label_text_font_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label-2\",\n      require: \"label_text_visible\"\n    },\n    // 数据标签的内容\n    {\n      key: \"label_text_regex\",\n      title: \"option_label_text_regex\",\n      description: \"option_suspend_text_regex_desc\",\n      type: \"chartRichText\",\n      require: 'label_text_visible',\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    // 柱状（居内/居外/居中）\n    {\n      key: \"label_text_column_position\",\n      title: \"option_label_text_position\",\n      description: \"option_label_text_position_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_position_in\", \"option_label_position_out\", \"option_label_position_center\"],\n      require: 'label_text_visible'\n    },\n    // 旋转角度0/90/270\n    {\n      key: \"label_text_rotation_angle\",\n      title: \"option_label_text_rotation_angle\",\n      description: \"option_label_text_rotation_angle_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_rotation_0\", \"option_label_rotation_90\", \"option_label_rotation_270\"],\n      require: 'label_text_visible'\n    },\n    // 标签显示项 [ 全部/标准最大值最小值平均值 ]\n    {\n      key: \"label_text_visible_items\",\n      title: \"option_label_text_visible_items\",\n      description: \"option_label_text_visible_items_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_visible_all\", \"option_label_visible_standard\"],\n      require: 'label_text_visible'\n    },\n    // 标签是否允许重叠\n    {\n      key: \"label_text_allow_overlap\",\n      title: \"option_label_text_allow_overlap\",\n      description: \"option_label_text_allow_overlap_desc\",\n      type: \"checkbox\",\n      require: 'label_text_visible'\n    },\n    // // 使用坐标轴的格式\n    // {\n    //     key: \"label_use_scale_abbreviation\",\n    //     title: \"option_label_use_scale_abbreviation\",\n    //     description: \"option_label_use_scale_abbreviation_desc\",\n    //     type: \"checkbox\",\n    //     require: 'label_text_visible'\n    // }\n\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 悬浮文本设置\n  {\n    key: \"category_suspend_text\",\n    title: \"category_suspend_text\",\n    options: [{\n      key: \"suspend_text_regex\",\n      title: \"option_suspend_text_regex\",\n      description: \"option_suspend_text_regex_desc\",\n      type: \"chartRichText\",\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 标度配置\n  {\n    key: \"category_scale_config\",\n    title: \"category_scale_config\",\n    require: \"!has_right_y_axis\",\n    options: [\n    // 显示/隐藏标度\n    {\n      key: \"scale_y_visible\",\n      title: \"option_scale_y_visible\",\n      type: 'checkbox-prev'\n    },\n    // 其他图形的标度配置全部调整为数组(container)模式  @20221206 by tong\n    {\n      key: \"scale_y_range\",\n      description: \"option_scale_y_range_desc\",\n      type: \"container\",\n      containerClassType: \"borderItem\",\n      options: [\n      // 标度类型 - 直线或区间 [ 默认为直线 ]\n      {\n        type: \"selectTile\",\n        key: \"option_scale_config_type\",\n        title: \"option_scale_config_type\",\n        selection: [\"options_scale_config_type_line\", \"options_scale_config_type_range\"]\n      },\n      // 文本\n      {\n        type: \"text\",\n        title: \"option_scale_config_text\"\n      },\n      // 标度使用列信息\n      {\n        type: \"select\",\n        title: \"option_scale_config_column\",\n        selectType: \"yAxis\",\n        defaultValueKey: 'option_default_value' //  默认显示值的i18n key\n      },\n      // ==== 标度为直线的情况下 start==================================\n      // 标度值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_value_type\",\n        title: \"option_scale_config_value_type\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"],\n        require: \"option_scale_config_type=options_scale_config_type_line\"\n      },\n      // 标度值\n      {\n        type: \"text\",\n        key: \"option_scale_config_value_input\",\n        title: \"option_scale_config_value_input\",\n        require: \"option_scale_config_type=options_scale_config_type_line;option_scale_config_value_type=options_config_value_input\"\n      }, {\n        type: \"color\",\n        title: \"option_scale_config_value_color\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        defaultColor: \"#D62728\"\n      },\n      // 粗细\n      {\n        type: \"select\",\n        title: \"option_scale_config_value_thickness\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        selection: [\"option_default_value\", \"option_thickness_line_thin\", \"option_thickness_line_medium\", \"option_thickness_line_heavy\"]\n      },\n      // 虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_value_style\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        selection: [\"option_default_value\", \"option_line_style_solid_line\", \"option_line_style_dashed\"]\n      },\n      // ==== 标度为直线的情况下 end==================================\n\n      // ==== 标度为区间的情况下 start==================================\n      // 上区间值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_top_range_type\",\n        title: \"option_scale_config_top_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"]\n      },\n      // 上区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_top_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_top_range_type=option_default_value,options_config_value_input\"\n      }, {\n        type: \"select\",\n        key: \"option_scale_config_bottom_range_type\",\n        title: \"option_scale_config_bottom_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"]\n      },\n      // 下区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_bottom_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_bottom_range_type=option_default_value,options_config_value_input\"\n      },\n      // 区间颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        defaultColor: \"#D62728\"\n      },\n      // 区间透明度\n      {\n        type: \"input\",\n        title: \"option_scale_config_range_color_transparent\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        min: 0,\n        max: 100,\n        defaultNumber: 30,\n        unit: \"%\"\n      },\n      // 区间边框颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_edge_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\"\n      },\n      // 区间边框虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_range_edge_style\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"option_line_style_solid_line\", \"option_line_style_dashed\"]\n      }\n      // ==== 标度为区间的情况下 end==================================\n      ],\n      withoutRange: true,\n      rangeInits: [{}],\n      require: \"scale_y_visible\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  }],\n  /**\r\n   * 图形配置的辅助对象：当前图形定义的宏列表 及 宏 解析方法 ； 适配之前图形配置值的方法 ；\r\n   *\r\n   * 当前图形提供的宏列表[ 宏名的命名规则： 开头是%_ 用_连接的大写字符字符串 ]\r\n   * 供自定义数据标签 及 悬浮文本使用，可以让用户配置显示内容\r\n   * 键值对  MacroName : MacroDisplayNameKey\r\n   * {\r\n   *     [Array]chartMacroList: [{key , nameKey , descriptionKey}] ,  供用户配置的自定义宏列表\r\n   *     [Func]translateMacro                                         解析用使用宏配置的字符串\r\n   *     [Func]compatibleHistoryConfigure                             适配之前的配置为最新的配置\r\n   *\r\n   * }\r\n   * */\n  chartConfigureAdvanced: {\n    // 根据宏配置列表，已足够外部组件将 %_NAME:%_VALUE 翻译成 [属性]：[值] 显示给用户\n    // 如果当前图形支持换行的宏，则输入时允许输入换行符 ； 否则编辑时也不支持换行符 ；\n    chartMacroList: [{\n      key: '%_NAME',\n      nameKey: '%_NAME',\n      descriptionKey: '%_NAME_desc'\n    }, {\n      key: '%_CATEGORY_NAME',\n      nameKey: '%_CATEGORY_NAME',\n      descriptionKey: '%_CATEGORY_NAME_desc'\n    }, {\n      key: '%_CATEGORY_NUMBER',\n      nameKey: '%_CATEGORY_NUMBER',\n      descriptionKey: '%_CATEGORY_NUMBER_desc'\n    }, {\n      key: '%_SERIES_NAME',\n      nameKey: '%_SERIES_NAME',\n      descriptionKey: '%_SERIES_NAME_desc'\n    }, {\n      key: '%_SERIES_NUMBER',\n      nameKey: '%_SERIES_NUMBER',\n      descriptionKey: '%_SERIES_NUMBER_desc'\n    }, {\n      key: '%_VALUE_NAME',\n      nameKey: '%_VALUE_NAME',\n      descriptionKey: '%_VALUE_NAME_desc'\n    }, {\n      key: '%_VALUE',\n      nameKey: '%_VALUE',\n      descriptionKey: '%_VALUE_desc'\n    }, {\n      key: '%_CATEGORY_TOTAL',\n      nameKey: '%_CATEGORY_TOTAL',\n      descriptionKey: '%_CATEGORY_TOTAL_desc'\n    }, {\n      key: '%_CATEGORY_AVERAGE',\n      nameKey: '%_CATEGORY_AVERAGE',\n      descriptionKey: '%_CATEGORY_AVERAGE_desc'\n    }, {\n      key: '%_PERCENT_OF_CATEGORY',\n      nameKey: '%_PERCENT_OF_CATEGORY',\n      descriptionKey: '%_PERCENT_OF_CATEGORY_desc'\n    }, {\n      key: '%_PERCENT_OF_TOTAL',\n      nameKey: '%_PERCENT_OF_TOTAL',\n      descriptionKey: '%_PERCENT_OF_TOTAL_desc'\n    }, {\n      key: '%_BR',\n      nameKey: '%_BR',\n      descriptionKey: '%_BR_desc'\n    }],\n    // 依据当前配置，将 %_NAME:%_VALUE 转译成真实值显示\n    /**\r\n     * @param configMacroStr    -   用户配置的带宏的内容\r\n     * @param options\r\n     *          {\r\n     *              type        -\r\n     *\r\n     *              xLabel       -   图形单元对应的属性值 用于实现%_NAME %_CATEGORY_NAME\r\n     *              xLabelIndex  -   图形单元对应的属性索引，用于实现 %_CATEGORY_NUMBER\r\n     *              xLabelTotal  -   图形单元对应的属性上所有值的总和用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              xLabelNumber -   图形单元对应的属性上所有值的个数用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              yValue       -   图形单元对应的值 用于实现 %_VALUE\r\n     *              yAxis        -   图形单元对应的值列 用于实现 %_VALUE_NAME  %_SERIES_NAME\r\n     *              legend       -   图形单元对应的图例名(为空时说明是多Y轴) 用于实现 %_SERIES_NAME\r\n     *              legendIndex  -   图形单元对应的图例索引 用于实现 %_SERIES_NUMBER\r\n     *              legendTotal  -   图形单元对应的图例上所有值的总和,用于实现 %_PERCENT_OF_TOTAL\r\n     *              rowData -  图形单元对应的一整行数据 用于实现%_COLUMN_N的宏\r\n     *          }\r\n     * */\n    translateMacro: function (configMacroStr, options) {\n      options = options || {};\n      if (!configMacroStr) return false;\n      let macroRegex = /%(_[A-Z0-9]*){1,}/g;\n      let theMatchedTextValue = '',\n        matchedIndex = 0;\n      macroRegex.lastIndex = -1;\n      for (let i = 0, execResult; (execResult = macroRegex.exec(configMacroStr)) && i < 100; i++) {\n        if (!execResult || !execResult[0][0]) break;\n        let theMatchStr = execResult[0],\n          theMatchIndex = execResult.index;\n        theMatchedTextValue += configMacroStr.substring(matchedIndex, Math.max(theMatchIndex, matchedIndex));\n        switch (theMatchStr) {\n          case \"%_X_VALUE_NAME\":\n            if (options.xAxis) {\n              theMatchedTextValue += options.xAxis.displayName || options.xAxis.col_name || '';\n            }\n            break;\n          case \"%_X_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.xValue, options.xAxis) || '';\n            break;\n          case \"%_Y_VALUE_NAME\":\n            if (options.yAxis) {\n              theMatchedTextValue += options.yAxis.displayName || options.yAxis.col_name || '';\n            }\n            break;\n          case \"%_Y_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.yValue, options.yAxis) || '';\n            break;\n          case \"%_NAME\":\n          case \"%_CATEGORY_NAME\":\n            theMatchedTextValue += options.xLabel || _DataFocusMethod.formatData(options.xValue, options.xAxis) || '';\n            break;\n          case \"%_SERIES_NAME\":\n            theMatchedTextValue += options.legend || '';\n            break;\n          case \"%_SERIES_NUMBER\":\n            theMatchedTextValue += options.legendIndex || '';\n            break;\n          case \"%_VALUE_NAME\":\n            if (options.yAxis) {\n              theMatchedTextValue += options.yAxis.displayName || options.yAxis.col_name || '';\n            }\n            break;\n          case \"%_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.yValue, options.yAxis) || '';\n            break;\n          case \"%_CATEGORY_TOTAL\":\n            theMatchedTextValue += options.xLabelTotal || '';\n            break;\n          case \"%_CATEGORY_AVERAGE\":\n            let theAverage = options.xLabelTotal / (options.xLabelNumber || 1);\n            if (!isNaN(theAverage)) {\n              theMatchedTextValue += _DataFocusMethod.formatData(_DataFocusMethod.getValidNum(theAverage, 2), options.yAxis);\n            }\n            break;\n          case \"%_PERCENT_OF_CATEGORY\":\n            let theCPercent = options.yValue / (options.xLabelTotal || 1);\n            if (!isNaN(theCPercent)) {\n              theMatchedTextValue += _DataFocusMethod.getValidNum(theCPercent * 100, 2) + '%';\n            }\n            break;\n          case \"%_PERCENT_OF_TOTAL\":\n            let theTPercent = options.yValue / (options.legendTotal || 1);\n            if (!isNaN(theTPercent)) {\n              theMatchedTextValue += _DataFocusMethod.getValidNum(theTPercent * 100, 2) + '%';\n            }\n            break;\n          case \"%_BR\":\n            theMatchedTextValue += options.type === 'label' ? '\\n' : '<br/>';\n            break;\n          default:\n            if (theMatchStr.startsWith(\"%_COLUMN_\")) {\n              let theColumnN = parseInt(theMatchStr.substring(9));\n              const matchedHeader = options.headers[theColumnN - 1];\n              if (!isNaN(theColumnN) && options.rowData && theColumnN > 0 && theColumnN <= options.rowData.length) {\n                theMatchedTextValue += _DataFocusMethod.formatData(options.rowData[theColumnN - 1], matchedHeader) || '';\n              }\n            }\n            break;\n        }\n        matchedIndex = theMatchIndex + theMatchStr.length;\n      }\n      if (matchedIndex < configMacroStr.length) {\n        theMatchedTextValue += configMacroStr.substring(matchedIndex);\n      }\n      return theMatchedTextValue;\n    },\n    // 如果当前图形配置在上线后需要更新配置，需要兼容行为，则在此处处理[ 不同图形兼容方法不一样 ]\n    /**\r\n     * @param   chartConfigure  -   图表配置对象\r\n     * @param   options\r\n     *          {\r\n     *              tableData   -   当前搜索的数据表详情\r\n     *              yAxisColors     -   202306之前保存的问答的y轴配置的颜色(用户通过图形中的图例列表修改颜色，没有统一到配置中导致需要兼容)\r\n     *              legendColors    -   202306之前保存的问答的图例配置的颜色(用户通过图形中的图例列表修改颜色，没有统一到配置中导致需要兼容)\r\n     *          }\r\n     *\r\n     * 将图形中的操作全部作用到图表配置中\r\n     * */\n    compatibleHistoryConfigure: function (chartConfigure, options) {\n      if (!chartConfigure) return false;\n      options = options || {};\n\n      // 将以前的线条类型转换为现在的类型\n      if (chartConfigure.style_of_line) {\n        if (chartConfigure.style_of_line === 'option_style_line_normal') {\n          chartConfigure.style_of_line = 'option_line_style_linear';\n          chartConfigure.show_point = false;\n        }\n        // 原先的带有符号，现在拆成两个配置\n        if (chartConfigure.style_of_line === 'option_style_line_normal_symbol') {\n          chartConfigure.style_of_line = 'option_line_style_linear';\n          chartConfigure.show_point = true;\n        }\n        if (chartConfigure.style_of_line === 'option_style_line_step') {\n          chartConfigure.style_of_line = 'option_line_style_step';\n          chartConfigure.show_point = false;\n        }\n        // 原先的带有符号，现在拆成两个配置\n        if (chartConfigure.style_of_line === 'option_style_line_step_symbol') {\n          chartConfigure.style_of_line = 'option_line_style_step';\n          chartConfigure.show_point = true;\n        }\n        if (chartConfigure.style_of_line === 'option_style_line_curve') {\n          chartConfigure.style_of_line = 'option_line_style_curve_natural';\n          chartConfigure.show_point = false;\n        }\n        // 原先的带有符号，现在拆成两个配置\n        if (chartConfigure.style_of_line === 'option_style_line_curve_symbol') {\n          chartConfigure.style_of_line = 'option_line_style_curve_natural';\n          chartConfigure.show_point = true;\n        }\n      }\n\n      // 将原先的线宽”粗细“变为数值\n      if (chartConfigure.thickness_of_line) {\n        switch (chartConfigure.thickness_of_line) {\n          case \"option_thickness_line_heavy\":\n            chartConfigure.thickness_of_line = \"3\";\n            break;\n          case \"option_thickness_line_medium\":\n            chartConfigure.thickness_of_line = \"2\";\n            break;\n          case \"option_thickness_line_thin\":\n            chartConfigure.thickness_of_line = \"1\";\n            break;\n        }\n      }\n\n      // 节点描边的大小-半径-尺寸\n      if (chartConfigure.symbol_size_of_line) {\n        const symbolSizeOfLineMap = {\n          option_font_size_smaller: 3.5,\n          option_font_size_Minimum: 2,\n          option_font_size_bigger: 6.5,\n          option_font_size_Maximum: 8,\n          option_font_size_super: 10,\n          option_font_size_default: 5\n        };\n        if (symbolSizeOfLineMap[chartConfigure.symbol_size_of_line]) {\n          chartConfigure.symbol_size_of_line = symbolSizeOfLineMap[chartConfigure.symbol_size_of_line];\n        }\n      }\n\n      // 图形字体大小修改了值结构\n      if (_DataFocusMethod.isPureNumber(chartConfigure.font_size_label)) {\n        let theFontSize = parseInt(chartConfigure.font_size_label);\n        chartConfigure.font_size_label = {\n          fontSize: theFontSize\n        };\n      }\n      // 旋转角度 变了名字\n      if (chartConfigure.attribute_label_rotate !== undefined) {\n        chartConfigure.x_axis_label_dot_line_rotation_value = chartConfigure.attribute_label_rotate;\n        chartConfigure.attribute_label_rotate = undefined;\n      }\n      // 刻度间隔 变了名字\n      if (chartConfigure.attribute_label_space_width !== undefined) {\n        chartConfigure.x_axis_label_dot_line_space_width = chartConfigure.attribute_label_space_width;\n        chartConfigure.attribute_label_space_width = undefined;\n      }\n      // 最大高度限制 变了名字\n      if (chartConfigure.attribute_label_max_height !== undefined) {\n        chartConfigure.x_axis_label_max_height_percent = chartConfigure.attribute_label_max_height * 100;\n        chartConfigure.attribute_label_max_height = undefined;\n      }\n\n      // 图形标题隐藏配置调整为两个配置值 [ 新的柱状图 ]\n      if (chartConfigure.hidden_chart_title) {\n        chartConfigure.x_axis_title_visible = \"option_title_visible_hide\";\n        chartConfigure.y_axis_title_visible = \"option_title_visible_hide\";\n        chartConfigure.hidden_chart_title = undefined;\n      }\n\n      // 属性图例颜色 与 Y轴颜色只会存在其中一个\n      // 图例配置列表配置了属性图例的颜色\n      if (!chartConfigure.chart_legend_list) {\n        // 图例配置列表配置了属性图例的颜色\n        if (chartConfigure.chart_custom_legend_new && chartConfigure.chart_custom_legend_new.length || options.legendColors && options.legendColors.length) {\n          let theLegendList = [],\n            theLegendIdObj = {};\n          chartConfigure.chart_custom_legend_new && chartConfigure.chart_custom_legend_new.forEach(function (legend) {\n            if (legend.legend !== undefined && legend.color) {\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId(\"legendAxis\", legend.legend);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: legend.legend,\n                  color: legend.color,\n                  shape: legend.shape,\n                  dash: legend.dash,\n                  shadow: legend.shadow\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_custom_legend_new = undefined;\n\n          // 继承之前保存的legendColors配置\n          options.legendColors && options.legendColors.forEach(function (legend) {\n            if (legend.legend !== undefined && legend.color) {\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId(\"legendAxis\", legend.legend);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: legend.legend,\n                  color: legend.color,\n                  shape: legend.shape,\n                  dash: legend.dash,\n                  shadow: legend.shadow\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_legend_list = theLegendList;\n        }\n        // 图例配置列表配置了Y轴的颜色\n        if (chartConfigure.chart_custom_legend_new_measure && chartConfigure.chart_custom_legend_new_measure.length || options.yAxisColors && options.yAxisColors.length) {\n          let theLegendList = [],\n            theLegendIdObj = {};\n          chartConfigure.chart_custom_legend_new_measure && chartConfigure.chart_custom_legend_new_measure.forEach(function (configLeg) {\n            let theLegendNameObj = configLeg.options && configLeg.options.find(function (obj) {\n                return obj.title === 'option_chart_legend_measure_name';\n              }),\n              theLegendName = theLegendNameObj && theLegendNameObj.value || '',\n              theLegendColorObj = configLeg.options && configLeg.options.find(function (obj) {\n                return obj.title === 'option_chart_legend_color';\n              }),\n              theLegendColor = theLegendColorObj && theLegendColorObj.value || '';\n            theLegendName = theLegendName.replace(\"-y-axis-\", \"\");\n            let theYAxisArray = theLegendName.split('-'),\n              theColIdx = theYAxisArray[0],\n              theColName = theYAxisArray[1],\n              theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId('YAxis', theColIdx);\n            if (theLegendName && theLegendColor) {\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: theColName,\n                  color: theLegendColor\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_custom_legend_new_measure = undefined;\n\n          // 继承之前保存的yAxisColors配置\n          console.log('---------------yAxisColors------------');\n          options.yAxisColors && options.yAxisColors.forEach(function (yAxis) {\n            if (yAxis.col_id !== undefined && yAxis.color) {\n              if (options.tableData && options.tableData.headers) {\n                let theMatchedHeader = options.tableData.headers.find(function (head) {\n                  return yAxis.col_id === head.col_id || head.idx + '' === yAxis.col_id + '';\n                });\n                if (theMatchedHeader) yAxis.col_id = theMatchedHeader.idx;\n              }\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].generateLegendId(\"YAxis\", yAxis.col_id);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: yAxis.name,\n                  color: yAxis.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_legend_list = theLegendList;\n        }\n      }\n\n      // 隐藏网格线调整了显示网格线的名字\n      if (chartConfigure.grid_hide_all_line) {\n        chartConfigure.grid_show_all_line = false;\n        chartConfigure.grid_hide_all_line = undefined;\n      }\n      // 零线颜色及零线粗细调整了配置名\n      if (chartConfigure.grid_zero_color || chartConfigure.grid_zero_width) {\n        chartConfigure.grid_zero_line_style = {\n          lineColor: chartConfigure.grid_zero_color,\n          lineWidth: chartConfigure.grid_zero_width\n        };\n        chartConfigure.grid_zero_color = undefined;\n        chartConfigure.grid_zero_width = undefined;\n      }\n      // 标度增加了显示与隐藏的配置\n      if (chartConfigure.scale_y_visible === undefined && chartConfigure.scale_y_range && chartConfigure.scale_y_range.length) {\n        chartConfigure.scale_y_visible = true;\n        chartConfigure.scale_y_range && chartConfigure.scale_y_range.forEach(function (theScaleYItem) {\n          // 以前标度类型默认值是default, 现在默认的类型是直线，所以得将之前的配置转换为具体值\n          let theTypeOption = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_type\";\n          });\n          if (!theTypeOption) {\n            theScaleYItem.options = theScaleYItem.options || [];\n            theScaleYItem.options.push({\n              title: \"option_scale_config_type\",\n              value: \"option_default_value\"\n            });\n          } else if (theTypeOption && !theTypeOption.value) theTypeOption.value = 'option_default_value';\n\n          // 以前直线的粗细是类型，目前调整为数值\n          let theThickness = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_value_thickness\";\n          });\n          if (theThickness && theThickness.value) {\n            switch (theThickness.value) {\n              case \"option_thickness_line_medium\":\n                theThickness.value = 2;\n                break;\n              case \"option_thickness_line_heavy\":\n                theThickness.value = 3;\n                break;\n            }\n          }\n        });\n      }\n      // 显示图例改了名字\n      if (chartConfigure.hide_legend && chartConfigure.show_legend === undefined) {\n        chartConfigure.show_legend = false;\n        chartConfigure.hide_legend = undefined;\n      }\n    }\n  },\n  // [*必填项]图轴及图表自定义的中英文\n  /**\r\n   * {\r\n   *     chinese: {\"category_x_axis\": \"X轴\" ... } ,\r\n   *     english: {\"category_x_axis\": \"X Axis\" ...}\r\n   * }\r\n   * */\n  i18nObj: {\n    chinese: {\n      \"system_auto_default\": \"自动\",\n      \"user_define_text\": \"自定义\",\n      \"category_x_axis\": \"X轴\",\n      \"option_x_axis_draw_type\": \"X轴类型\",\n      \"option_select_x_axis_dot_line\": \"单层散点\",\n      \"option_select_x_axis_time_line\": \"时间轴\",\n      \"option_select_x_axis_level_line\": \"多层属性\",\n      \"option_x_axis_draw_type_desc\": \"X轴总共有三种类型：\" + \"<br /> 多层属性<span class='color-main-green'>[自动识别]</span>：X轴有2个或3个属性列时，自动会识别使用多层属性展示X轴刻度\" + \"<br /> 时间轴<span class='color-main-green'>[自动识别]</span>：X轴只有1个时间列 且 经过每天/每小时/每分钟聚合时，自动会识别使用时间轴展示X轴刻度\" + \"<br /> 单层散点<span class='color-main-green'>[自动识别]</span>：所有数据均可以强制使用单层三点的模式展示X轴刻度\" + \"<br /> 系统会自动适配合适的X轴，但是您可以强制切换称单层单点模式\",\n      \"option_axis_label_visible\": \"轴标签\",\n      \"option_axis_title_visible\": \"轴标题\",\n      \"option_axis_title_visible_desc\": \"自动情况下，会在详情页面显示标题，看板中隐藏标题\",\n      \"option_title_visible_show\": \"显示\",\n      \"option_title_visible_hide\": \"隐藏\",\n      \"option_axis_title_content\": \"标题内容\",\n      \"option_axis_title_content_desc\": \"默认会使用X轴的列名\",\n      \"option_x_axis_label_dot_line_rotation_value\": \"旋转角度\",\n      \"option_x_axis_label_dot_line_space_width\": \"刻度间距\",\n      \"option_x_axis_label_dot_line_space_width_desc\": \"X轴刻度是单层散点模式下，刻度之间的最小间距，默认是50（即每50px显示一个刻度）\",\n      \"option_x_axis_label_max_height_percent\": \"最大高度(%)\",\n      \"option_x_axis_label_max_height_percent_desc\": \"X轴是单层散点模式下，超出最大高度百分比时，截取字符串显示；其他模式下，超出最大高度时，将不显示X轴刻度\",\n      \"option_font_style\": \"字体\",\n      \"option_font_alignment\": \"对齐方式\",\n      \"category_y_axis\": \"Y轴\",\n      \"option_y_axis_label_max_width_percent\": \"最大宽度(%)\",\n      \"option_measure_configure\": \"格式配置\",\n      \"category_right_y_axis\": \"右Y轴\",\n      \"category_color\": \"颜色/线条\",\n      \"option_chart_column_minimum_width\": \"自适应最小刻度宽\",\n      \"option_chart_column_minimum_width_desc\": \"默认情况下，依据画图区域及画图数据自适应的刻度宽值，默认最小值是5px\",\n      \"option_suspend_text_regex_desc\": \"要显示的文本。有以下替换宏可用：<br /> \" + \"<span class='mr3'>[值]</span> - 对应的Y轴的数值 <br />\" + \"<span class='mr3'>[属性]</span> - 显示的数值标签为对应的X轴的值<br /> \" + \"<span class='mr3'>[刻度]</span> - 显示的数值标签为对应的X轴的值<br /> \" + \"<span class='mr3'>[类别]</span> - 对应的图例的类别值<br /> \" + \"<span class='mr3'>[类别索引]</span> - 对应的图例的类别顺序索引<br /> \" + \"<span class='mr3'>[刻度总和]</span> - 可显示X轴为某个值时所有Y轴的数值之和 <br /> \" + \"<span class='mr3'>[刻度平均值]</span> - 可显示X轴为某个值时所有Y轴的平均值<br /> \" + \"<span class='mr3'>[类别百分比]</span> - X轴的刻度上Y值占所有Y值总和的百分比 <br />\" + \"<span class='mr3'>[刻度百分比]</span> - X轴的刻度上Y值占该X刻度上所有Y值总和的百分比 <br /> \" + \"<span class='mr3'>[(列N)]</span> - 第N列的数值 <br /> \" + \"<span class='mr3'>[换行]</span> - 换行符\",\n      \"%_X_VALUE_NAME\": \"X轴名称\",\n      \"%_X_VALUE\": \"X刻度\",\n      \"%_Y_VALUE_NAME\": \"Y轴名称\",\n      \"%_Y_VALUE\": \"Y刻度\",\n      \"%_LEGEND_VALUE\": \"图例\",\n      \"%_NAME\": \"属性\",\n      \"%_NAME_desc\": \"对应的X轴的刻度值\",\n      \"%_VALUE\": \"值\",\n      \"%_VALUE_desc\": \"对应的Y轴的数值\",\n      \"%_VALUE_NAME\": \"值名称\",\n      \"%_VALUE_NAME_desc\": \"对应的Y轴的名称\",\n      \"%_SERIES_NAME\": \"类别\",\n      \"%_SERIES_NAME_desc\": \"对应的图例的类别值\",\n      \"%_SERIES_NUMBER\": \"类别索引\",\n      \"%_SERIES_NUMBER_desc\": \"对应的图例的类别顺序索引\",\n      \"%_CATEGORY_NAME\": \"刻度\",\n      \"%_CATEGORY_NAME_desc\": \"对应的X轴的刻度值\",\n      \"%_CATEGORY_NUMBER\": \"刻度索引\",\n      \"%_CATEGORY_NUMBER_desc\": \"对应的X轴的刻度顺序索引\",\n      \"%_CATEGORY_TOTAL\": \"刻度总和\",\n      \"%_CATEGORY_TOTAL_desc\": \"各个X轴刻度上所有Y轴值的总和\",\n      \"%_CATEGORY_AVERAGE\": \"刻度平均值\",\n      \"%_CATEGORY_AVERAGE_desc\": \"各个X轴刻度上所有Y轴值的平均值\",\n      \"%_PERCENT_OF_TOTAL\": \"类别百分比\",\n      \"%_PERCENT_OF_TOTAL_desc\": \"X轴的刻度上Y值占所有Y值总和的百分比\",\n      \"%_PERCENT_OF_CATEGORY\": \"刻度百分比\",\n      \"%_PERCENT_OF_CATEGORY_desc\": \"X轴的刻度上Y值占该X刻度上所有Y值总和的百分比\",\n      \"%_BR\": \"换行\",\n      \"option_grid_show_all_line\": \"显示全部网格线\",\n      \"option_grid_line_style\": \"网格线样式\",\n      \"option_grid_line_style_desc\": \"配置所有网格线的样式，包括虚实，颜色及粗细\",\n      \"option_grid_show_only_zero_line\": \"只显示零线\",\n      \"option_grid_show_only_zero_line_desc\": \"配置后，网格线中非零线将全部隐藏，只显示零线 <br /> 如果Y轴最小值大于0，则没有零线，所有网格线均都不显示 \",\n      \"option_grid_zero_line_style\": \"零线样式\",\n      \"option_grid_zero_line_style_desc\": \"配置零线的样式，包括虚实，颜色及粗细\",\n      \"option_scale_y_visible\": \"显示/隐藏\",\n      \"option_line_style_linear\": \"线性\",\n      \"option_line_style_step\": \"阶梯\",\n      \"option_line_style_step_after\": \"阶梯后对齐\",\n      \"option_line_style_step_before\": \"阶梯前对齐\",\n      \"option_line_style_curve_basis\": \"Basis曲线\",\n      \"option_line_style_curve_natural\": \"自然曲线\",\n      \"option_line_style_curve_bump_x\": \"二阶贝塞尔曲线\",\n      \"option_line_style_curve_monotone_x\": \"MonotoneX曲线\",\n      \"option_line_style_curve_monotone_y\": \"MonotoneY曲线\",\n      \"option_thickness_of_line\": \"线宽\",\n      \"option_thickness_of_line_desc\": \"设置图表中线条的宽度\",\n      \"option_show_point\": \"显示节点\",\n      \"option_show_point_desc\": \"设置是否显示节点\",\n      \"option_symbol_size_of_line\": \"节点半径\",\n      \"option_symbol_size_of_line_desc\": \"设置节点的半径\",\n      \"option_legend_shape_type\": \"节点样式\",\n      \"option_legend_shape_type_desc\": \"设置节点显示的符号，默认为小圆圈\",\n      \"option_point_stroke\": \"节点描边\",\n      \"option_point_stroke_desc\": \"是否开启节点描边\",\n      \"option_point_stroke_style\": \"描边样式\",\n      \"option_point_stroke_style_desc\": \"设置节点描边线条的样式\",\n      \"option_show_line_shadow\": '阴影线',\n      \"option_show_line_shadow_desc\": '设置线条是否开启阴影'\n    },\n    english: {\n      \"system_auto_default\": \"Auto\",\n      \"user_define_text\": \"Define\",\n      \"category_x_axis\": \"X Axis\",\n      \"option_x_axis_draw_type\": \"X axis type\",\n      \"option_select_x_axis_dot_line\": \"Single dot\",\n      \"option_select_x_axis_time_line\": \"Time \",\n      \"option_select_x_axis_level_line\": \"Multi level\",\n      \"option_x_axis_draw_type_desc\": \"There are three types of X-axis in total:\" + \"<br /> Multi level<span class='color-main-green'>[Auto]</span>: 2 or 3 attribute columns on the X-axis, it will automatically recognize the multi level \" + \"<br /> Time line<span class='color-main-green'>[Auto]</span>: only one time column on the X-axis and it is aggregated daily / hourly / minutely , it will automatically recognize the time line\" + \"<br /> Single dot<span class='color-main-green'>[Auto]</span>: All data can be forced to display the single level\" + \"<br /> The system will automatically adapt to the appropriate X-axis, but you can forcibly switch to the single level\",\n      \"option_axis_label_visible\": \"Axis Label\",\n      \"option_axis_title_visible\": \"Axis Title\",\n      \"option_axis_title_visible_desc\": \"In automatic mode, the title will be displayed on the answer detail page and hidden in the pinboard\",\n      \"option_title_visible_show\": \"Show\",\n      \"option_title_visible_hide\": \"Hidden\",\n      \"option_axis_title_content\": \"Title Content\",\n      \"option_axis_title_content_desc\": \"By default, column names on the axis will be used\",\n      \"option_x_axis_label_dot_line_rotation_value\": \"Rotate\",\n      \"option_x_axis_label_dot_line_space_width\": \"Label Spacing\",\n      \"option_x_axis_label_dot_line_space_width_desc\": \"The scale is the minimum spacing between labels in single level axis, with a default of 50 (i.e. one scale displayed every 50px)\",\n      \"option_x_axis_label_max_height_percent\": \"Max height(%)\",\n      \"option_x_axis_label_max_height_percent_desc\": \"The axis is in single level, and when the maximum height percentage is exceeded, the string is truncated and displayed; In other modes, when the maximum height is exceeded, the scale will not be displayed\",\n      \"option_font_style\": \"Font\",\n      \"option_font_alignment\": \"Alignment\",\n      \"category_y_axis\": \"Y Axis\",\n      \"option_y_axis_label_max_width_percent\": \"Max Width(%)\",\n      \"option_measure_configure\": \"Data Format\",\n      \"category_right_y_axis\": \"Right Y Axis\",\n      \"category_color\": \"Color/Line\",\n      \"option_chart_column_minimum_width\": \"Adaptive minimum column width\",\n      \"option_chart_column_minimum_width_desc\": \"By default, the column width value is adaptively adjusted based on the drawing area and data. The default minimum value is 5px. After setting the fixed width of the scale, this value is invalid\",\n      \"option_chart_column_width\": \"Fixed column width\",\n      \"option_chart_column_width_desc\": \"By default, the width is adaptive based on the width of the drawing area. After setting a fixed scale width, the scale width is fixed, with a minimum value of 5px\",\n      \"option_suspend_text_regex_desc\": \"The text to be displayed. The following replacement macros are available:<br /> \" + \"<span class='mr3'>[Value]</span> - The corresponding value of the Y-axis <br />\" + \"<span class='mr3'>[Attribute]</span> - The displayed numerical labels are the corresponding X-axis values<br /> \" + \"<span class='mr3'>[Label]</span> - The displayed numerical labels are the corresponding X-axis values<br /> \" + \"<span class='mr3'>[Series]</span> - The series value of the corresponding legend<br /> \" + \"<span class='mr3'>[Series Index]</span> - The series order of the corresponding legend<br /> \" + \"<span class='mr3'>[Label Total]</span> - Can display the sum of all Y-axis values when the X-axis is a certain value <br /> \" + \"<span class='mr3'>[Label AVG]</span> - Can display the average value of all Y-axes when the X-axis is a certain value<br /> \" + \"<span class='mr3'>[Series Percentage]</span> - The percentage of Y values on the scale of the X-axis to the total of all Y values on the legend<br />\" + \"<span class='mr3'>[Label Percentage]</span> - The percentage of Y values on the scale of the X-axis to the total of all Y values on that scale <br /> \" + \"<span class='mr3'>[(ColumnN)]</span> - Value in column N <br /> \" + \"<span class='mr3'>[Wrap]</span> - Line break\",\n      \"%_NAME\": \"Attribute\",\n      \"%_NAME_desc\": \"The displayed numerical labels are the corresponding X-axis values\",\n      \"%_VALUE\": \"Value\",\n      \"%_VALUE_desc\": \"The corresponding value of the Y-axis\",\n      \"%_VALUE_NAME\": \"Value Name\",\n      \"%_VALUE_NAME_desc\": \"The corresponding y-axis column name\",\n      \"%_SERIES_NAME\": \"Series\",\n      \"%_SERIES_NAME_desc\": \"The category value of the corresponding legend\",\n      \"%_SERIES_NUMBER\": \"Series Index\",\n      \"%_SERIES_NUMBER_desc\": \"Category order index of corresponding legend\",\n      \"%_CATEGORY_NAME\": \"Label\",\n      \"%_CATEGORY_NAME_desc\": \"The corresponding X-axis scale value\",\n      \"%_CATEGORY_NUMBER\": \"Label Index\",\n      \"%_CATEGORY_NUMBER_desc\": \"Corresponding X-axis scale sequence index\",\n      \"%_CATEGORY_TOTAL\": \"Label Total\",\n      \"%_CATEGORY_TOTAL_desc\": \"The sum of all Y-axis values on each X-axis scale\",\n      \"%_CATEGORY_AVERAGE\": \"Label AVG\",\n      \"%_CATEGORY_AVERAGE_desc\": \"The average value of all Y-axis values on each X-axis scale\",\n      \"%_PERCENT_OF_TOTAL\": \"Series Percentage\",\n      \"%_PERCENT_OF_TOTAL_desc\": \"The percentage of Y value on the X-axis scale to the total sum of all Y values\",\n      \"%_PERCENT_OF_CATEGORY\": \"Label Percentage\",\n      \"%_PERCENT_OF_CATEGORY_desc\": \"The percentage of Y value on the X-axis scale to the total sum of all Y values on that X-axis scale\",\n      \"%_BR\": \"Wrap\",\n      \"option_grid_show_all_line\": \"Show all grid lines\",\n      \"option_grid_line_style\": \"Line style\",\n      \"option_grid_line_style_desc\": \"Configure the styles of all grid lines, including virtual and solid, color, and thickness\",\n      \"option_grid_show_only_zero_line\": \"Only show the zero line\",\n      \"option_grid_show_only_zero_line_desc\": \"After configuration, all non zero lines in the grid lines will be hidden, and only zero lines will be displayed.<br/>If the minimum value of the Y-axis is greater than 0, there will be no zero lines, and all grid lines will not be displayed\",\n      \"option_grid_zero_line_style\": \"Zero line style\",\n      \"option_grid_zero_line_style_desc\": \"Configure the style of the zero line, including virtual and solid, color, and thickness\",\n      \"option_scale_y_visible\": \"Show/Hide\",\n      \"option_line_style_linear\": \"Linear\",\n      \"option_line_style_step\": \"Step\",\n      \"option_line_style_step_after\": \"StepAfter\",\n      \"option_line_style_step_before\": \"StepBefore\",\n      \"option_line_style_curve_basis\": \"Basis Curve\",\n      \"option_line_style_curve_natural\": \"Natural Curve\",\n      \"option_line_style_curve_bump_x\": \"Bump X Curve\",\n      \"option_line_style_curve_monotone_x\": \"Monotone X Curve\",\n      \"option_line_style_curve_monotone_y\": \"Monotone Y Curve\",\n      \"option_thickness_of_line\": \"Line Width\",\n      \"option_thickness_of_line_desc\": \"Set the width of lines in the chart\",\n      \"option_show_point\": \"Show nodes\",\n      \"option_show_point_desc\": \"Set whether to display nodes\",\n      \"option_symbol_size_of_line\": \"Node radius\",\n      \"option_symbol_size_of_line_desc\": \"Set the radius of the node\",\n      \"option_legend_shape_type\": \"Node Style\",\n      \"option_legend_shape_type_desc\": \"Set the symbol for node display, default to circles\",\n      \"option_point_stroke\": \"Node stroke\",\n      \"option_point_stroke_desc\": \"Whether to enable node tracing\",\n      \"option_point_stroke_style\": \"Stroke Style\",\n      \"option_point_stroke_style_desc\": \"Set the style of node stroke lines\",\n      \"option_show_line_shadow\": 'Shadow',\n      \"option_show_line_shadow_desc\": 'Set whether the line turns on shadows'\n    }\n  },\n  // [*必填项]生成当前图表类型的模板数据\n  getTemplateData: function () {}\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/line/systemLineChart.js?");

/***/ })

}]);