(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[36],{

/***/ "../src-v5/assets/js/charts.system.senior/treeChart.js":
/*!*************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.senior/treeChart.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/** 树形图画图组件 **/\n// 通用组件[ 获取字符串长度之类 ...  ]\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  chartType: 'tree',\n  //  图形名 [ * 必填项 ]\n  chartDisplayNameKey: \"chart-name-title\",\n  chartDescriptionKey: \"chart-description-title\",\n  // 图形配置元素 [ * 必填项 ]\n  needAxis: {\n    // 两个属性列，形成嵌套节点[第一个是源列，第二个是目标列]\n    columns: {\n      i18nKey: \"chart-key-cascade-title\",\n      required: true,\n      defaultAxisNumber: 2\n    },\n    // 一个属性列[ 节点描述列 , 默认只需要一个描述列]\n    rows: {\n      i18nKey: \"chart-key-axis-title\",\n      defaultAxisNumber: 1\n    },\n    // 数值列\n    values: {\n      i18nKey: \"chart-measure-axis-title\",\n      defaultAxisNumber: 1\n    }\n  },\n  /** 至少两个属性列(且两个属性列的列中值是包含与被包含的关系)  */\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n    if (!searchResultStatistic) return false;\n    let attributeNum = searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.length;\n    // 至少有两个属性列，且其中一个属性列的列中值完全包含另外一个属性列的列中值\n    if (attributeNum >= 2) {\n      let theAttributeColumn = [];\n      searchResultStatistic.attributeColumns.forEach(function (attrColumn) {\n        let theValueObj = {};\n        if (attrColumn.distincts && attrColumn.distincts.length < 100 && attrColumn.distincts.length > 1) {\n          attrColumn.distincts.forEach(function (value) {\n            if (value !== null && value !== undefined && value !== '') theValueObj[value] = true;\n          });\n        }\n        theAttributeColumn.push(theValueObj);\n      });\n      for (let i = 0; i < searchResultStatistic.attributeColumns.length; i++) {\n        let theColumn = searchResultStatistic.attributeColumns[i];\n        if (theColumn.distincts && theColumn.distincts.length < 100 && theColumn.distincts.length > 1) {\n          // 如果这个列的列中值被别的列包含，就是可以画图\n          for (let j = 0; j < theAttributeColumn.length; j++) {\n            if (j !== i) {\n              let theMatchedColumn = theAttributeColumn[j];\n              let theContainFlag = true;\n              theColumn.distincts && theColumn.distincts.forEach(function (value) {\n                if (value !== null && value !== undefined && value !== '') {\n                  if (!theMatchedColumn[value]) theContainFlag = false;\n                }\n              });\n              if (theContainFlag) {\n                satisfiedFlag = true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return satisfiedFlag;\n  },\n  /**\r\n   * [选填] 获取当前图形各个needAxis中可选择的配置列\r\n   * @return\r\n   *      {\r\n   *          // 依据needAxis结构返回各个可选列的index\r\n   *          columns: [1,2,3] ,\r\n   *          rows: [4,5] ,\r\n   *          valus: [1,2,3] ,\r\n   *      }\r\n   * */\n  getSatisfiedChartAxis: function (searchResultStatistic) {\n    // console.log('[tree] get satisfied axis');\n    let self = this; //  是当前_DataFocusChartTypes中的对象\n\n    const needAxis = self.needAxis || {};\n    if (!needAxis || !searchResultStatistic) return false;\n    let theAxisObj = {};\n    // column / rows / values\n    let theAttributeColumn = [];\n    searchResultStatistic.attributeColumns.forEach(function (attrColumn) {\n      let theValueObj = {};\n      if (attrColumn.distincts && attrColumn.distincts.length < 100 && attrColumn.distincts.length > 1) {\n        attrColumn.distincts.forEach(function (value) {\n          if (value !== null && value !== undefined && value !== '') theValueObj[value] = true;\n        });\n      }\n      theAttributeColumn.push(theValueObj);\n    });\n\n    // columns的可选项 ： 有嵌套关系的两个列\n    let theColumnIdxObj = {};\n    if (needAxis.columns) {\n      let theColumns = [];\n      for (let i = 0; i < searchResultStatistic.attributeColumns.length; i++) {\n        let theColumn = searchResultStatistic.attributeColumns[i];\n        if (theColumn.distincts && theColumn.distincts.length < 100 && theColumn.distincts.length > 1) {\n          // 如果这个列的列中值被别的列包含，就是可以画图\n          for (let j = 0; j < theAttributeColumn.length; j++) {\n            if (j !== i) {\n              let theMatchedColumn = theAttributeColumn[j];\n              let theContainFlag = true;\n              theColumn.distincts && theColumn.distincts.forEach(function (value) {\n                if (value !== null && value !== undefined && value !== '') {\n                  if (!theMatchedColumn[value]) theContainFlag = false;\n                }\n              });\n\n              // 如果当前列被父列包含，则将两个列加入columns中\n              if (theContainFlag) {\n                // 父元素\n                let theParentColumn = searchResultStatistic.attributeColumns[j];\n                theColumns.push(theParentColumn);\n                theColumns.push(theColumn);\n              }\n            }\n          }\n        }\n      }\n      let theColumnIdx = [];\n      theColumns && theColumns.forEach(function (c) {\n        if (!theColumnIdxObj[c.idx]) {\n          theColumnIdx.push(c.idx);\n          theColumnIdxObj[c.idx] = true;\n        }\n      });\n      theAxisObj.columns = theColumnIdx;\n    }\n\n    // rows的可选项 ： 不在column中其他列作为row\n    if (needAxis.rows) {\n      let theRowIdx = [];\n      searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.forEach(function (c) {\n        theRowIdx.push(c.idx);\n      });\n      theAxisObj.rows = theRowIdx;\n    }\n\n    // values的可选项\n    if (needAxis.values) {\n      theAxisObj.values = searchResultStatistic.measureColumns && searchResultStatistic.measureColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    if (_DataFocusMethod.isObjEmpty(theAxisObj)) {\n      return false;\n    } else {\n      theAxisObj.name = self.name;\n      theAxisObj.type = self.name;\n      return theAxisObj;\n    }\n  },\n  /**\r\n   * 判断条件：\r\n   * 1. 节点列需要两个嵌套的属性列\r\n   * 2. 数值列只允许一个\r\n   *\r\n   * @return [String]errorKey -   错误提示对应的key;\r\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let theErrorMsgKey = '';\n    if (!theAxisConfig) {\n      theErrorMsgKey = 'chart-axis-config-null-error';\n      return theErrorMsgKey;\n    }\n\n    // 1.节点不允许为空\n    if (!theAxisConfig.columns || !theAxisConfig.columns.length) {\n      theErrorMsgKey = 'chart-column-axis-null';\n      return theErrorMsgKey;\n    }\n    // 2.节点需要两个属性列\n    if (theAxisConfig.columns.length !== 2) {\n      theErrorMsgKey = 'chart-column-axis-only-two';\n      return theErrorMsgKey;\n    }\n    // 4.有数值列，只需要一个数值列\n    if (theAxisConfig.values && theAxisConfig.values.length > 1) {\n      theErrorMsgKey = 'chart-values-axis-null';\n      return theErrorMsgKey;\n    }\n    return theErrorMsgKey;\n  },\n  /**\r\n   * 使用个人画图方法画图形\r\n   * @params [Object]options  -   当前图形的配置\r\n   *              {\r\n   *                  container       -   当前画图的DOM元素\r\n   *                  currentChart    -   当前画图对象\r\n   *                  chartAxis       -   当前图形的Axis配置\r\n   *                  datas           -   当前画图数据\r\n   *                  isResize        -   是否是窗口变化引起的画图\r\n   *                  chartConfigures -   图形配置\r\n   *                  plugins         -   DataFocus提供的第三方画图库\r\n   *                      {\r\n   *                          d3  -   d3的v3版本\r\n   *                          echarts -   echarts的\r\n   *                      }\r\n   *              }\r\n   * **/\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n    let htmlString = '';\n    htmlString += '<div class=\"svgDiv\" style=\"width:100%;height: 100%\"> <svg style=\"z-index: 0;\" width=\"100%\" height=\"100%\"></svg> </div>';\n    let svgDiv = $(htmlString);\n    $(options.container).empty();\n    $(options.container).append(svgDiv);\n    let container = options.container;\n    let chartAxis = options.chartAxis;\n    let conf = options.currentChart.defaultConf || {};\n    let getI18nKeyFunc = conf.curLanguage;\n    if (!chartAxis || !chartAxis.curColumns || chartAxis.curColumns.length !== 2) return false;\n    let totalWidth = $(container).width(),\n      totalHeight = $(container).height();\n    let embeddingMap = new Map();\n    let parentIdx, childIdx;\n    let elementaryNodes = [];\n    let root = {\n        children: []\n      },\n      headers = null,\n      columns = null;\n    function translateData(data) {\n      headers = data.headers;\n      columns = data.columns;\n      childIdx = chartAxis.curColumns[0].idx;\n      parentIdx = chartAxis.curColumns[1].idx;\n      let markColumns = [];\n      columns.forEach(function (c, index) {\n        c.rowIndex = index;\n        let markC = {\n          lineValues: c,\n          marked: true\n        };\n        if (!embeddingMap.get(c[childIdx])) {\n          let node = {\n            context: c,\n            children: []\n          };\n          elementaryNodes.push(node);\n          embeddingMap.set(c[childIdx], node);\n        } else {\n          markC.marked = false;\n          let node = embeddingMap.get(c[childIdx]);\n          if (!node.sames) node.sames = [];\n          node.sames.push(c);\n        }\n        markColumns.push(markC);\n      });\n      markColumns.forEach(function (markC) {\n        if (!markC.marked) return;\n        let c = markC.lineValues;\n        let parent = embeddingMap.get(c[parentIdx]);\n        if (!parent || c[parentIdx] === c[childIdx]) {\n          root.children.push(embeddingMap.get(c[childIdx]));\n        } else {\n          parent.children.push(embeddingMap.get(c[childIdx]));\n        }\n      });\n    }\n    translateData(options.datas);\n    //如果根节点的root的child为0，或节点存在不同的父节点，则不符合树的定义\n    let isMultipleParentFlag = false;\n    for (let i = 0; i < elementaryNodes.length; i++) {\n      if (elementaryNodes[i].sames) {\n        let tempNL = elementaryNodes[i].sames;\n        let tempCheckSet = {};\n        for (let j = 0; j < tempNL.length; j++) {\n          if (!tempCheckSet[tempNL[j][parentIdx]]) {\n            tempCheckSet[tempNL[j][parentIdx]] = true;\n          } else {\n            isMultipleParentFlag = true;\n            break;\n          }\n        }\n        if (isMultipleParentFlag) break;\n      }\n    }\n    if (isMultipleParentFlag || root.children.length === 0) {\n      $(options.container).find(\".neg-warning\").remove();\n      let negWarnDom = document.createElement(\"div\"),\n        negTip = getI18nKeyFunc && getI18nKeyFunc(\"option_tree_not_match_tooltip\") || \"Warning: Your data is not proper to the tree structure\",\n        innerTipStr = '<span class=\"error-msg\">' + negTip + '</span>';\n      negWarnDom.className = \"neg-warning\";\n      negWarnDom.innerHTML = innerTipStr;\n      $(options.container).append(negWarnDom);\n      $(options.container).find(\".neg-warning\").css({\n        \"display\": \"flex\",\n        \"width\": \"100%\",\n        \"height\": '100%',\n        'justify-content': 'center',\n        'align-items': 'center'\n      });\n      return false;\n    }\n    let neoColumns = [];\n    let totalNode = [];\n    let fontSize = 14;\n    let lineHeight = 1; //  节点行高\n    let paddingRectSpace = 6; //  节点内边距\n    let orientation = \"horizon\";\n    let contextCompactFlag = false;\n    let fontColor = \"#000\";\n    let lineColor = \"#000\";\n    let arrowColor = \"#000\";\n    let rectFillColor = \"rgba(200,200,200,0.01)\";\n    let rectBoarderColor = \"#000\";\n    let rectBoarderWidth = 2;\n    let boarderDasharray = \"\";\n    let rectRound = 10;\n    let arrowType = \"markerCircle\" + options.chartUUID;\n    let lineType = \"curve\";\n    let arrowOffset = 5;\n    if (options.chartConfigures) {\n      if (options.chartConfigures.chart_tree_orientation === \"option_orientation_vertical\") {\n        orientation = \"vertical\";\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.tree_font_size)) {\n        fontSize = parseInt(options.chartConfigures.tree_font_size);\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.tree_line_height)) {\n        lineHeight = parseInt(options.chartConfigures.tree_line_height);\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.tree_rect_padding)) {\n        paddingRectSpace = Math.max(0, parseInt(options.chartConfigures.tree_rect_padding));\n      }\n      if (options.chartConfigures.tree_compact_context) {\n        contextCompactFlag = true;\n      }\n      if (options.chartConfigures.tree_font_color) {\n        fontColor = options.chartConfigures.tree_font_color;\n      }\n      if (options.chartConfigures.tree_line_color) {\n        lineColor = options.chartConfigures.tree_line_color;\n      }\n      if (options.chartConfigures.tree_arrow_color) {\n        arrowColor = options.chartConfigures.tree_arrow_color;\n      }\n      if (options.chartConfigures.tree_rect_color) {\n        rectFillColor = options.chartConfigures.tree_rect_color;\n      }\n      if (options.chartConfigures.tree_rect_boarder_color) {\n        rectBoarderColor = options.chartConfigures.tree_rect_boarder_color;\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.tree_rect_boarder_width)) {\n        rectBoarderWidth = Math.max(0, parseInt(options.chartConfigures.tree_rect_boarder_width));\n      }\n      if (_DataFocusMethod.isPureNumber(options.chartConfigures.tree_rect_round)) {\n        rectRound = Math.max(0, parseInt(options.chartConfigures.tree_rect_round));\n      }\n      if (options.chartConfigures.tree_rect_boarder) {\n        switch (options.chartConfigures.tree_rect_boarder) {\n          case \"option_rect_boarder_solid\":\n            boarderDasharray = \"\";\n            break;\n          case \"option_rect_boarder_dashed\":\n            boarderDasharray = \"10 6\";\n            break;\n          case \"option_rect_boarder_dotted\":\n            boarderDasharray = \"2 2\";\n            break;\n          case \"option_rect_boarder_none\":\n            boarderDasharray = \"0 1\";\n            break;\n          default:\n            boarderDasharray = \"\";\n            break;\n        }\n      }\n      if (options.chartConfigures.tree_line_style) {\n        switch (options.chartConfigures.tree_line_style) {\n          case \"option_line_style_curve\":\n            lineType = \"curve\";\n            break;\n          case \"option_line_style_fold\":\n            lineType = \"fold\";\n            break;\n          case \"option_line_style_straight\":\n            lineType = \"straight\";\n            break;\n          default:\n            lineType = \"curve\";\n            break;\n        }\n      }\n      if (options.chartConfigures.tree_arrow_style) {\n        switch (options.chartConfigures.tree_arrow_style) {\n          case \"option_arrow_style_circle\":\n            arrowType = \"markerCircle\" + options.chartUUID;\n            arrowOffset = 5;\n            break;\n          case \"option_arrow_style_arrow\":\n            arrowType = \"markerArrow\" + options.chartUUID;\n            arrowOffset = 5;\n            break;\n          case \"option_arrow_style_none\":\n            arrowType = \"none\";\n            arrowOffset = -0;\n            break;\n          default:\n            arrowType = \"markerCircle\" + options.chartUUID;\n            arrowOffset = 5;\n            break;\n        }\n      }\n    }\n    let keyList = [];\n    let curXAxisList = [];\n    for (let tkey in options.chartAxis.curColumns) {\n      if (typeof options.chartAxis.curColumns[tkey] !== \"function\") {\n        curXAxisList.push(options.chartAxis.curColumns[tkey]);\n\n        // 如果没有描述时，使用childIdx显示\n        if (childIdx === options.chartAxis.curColumns[tkey].idx && (!options.chartAxis.curRows || !options.chartAxis.curRows.length)) {\n          keyList.push(options.chartAxis.curColumns[tkey]);\n        }\n      }\n    }\n    for (let tkey in options.chartAxis.curRows) {\n      if (typeof options.chartAxis.curRows[tkey] !== \"function\") {\n        keyList.push(options.chartAxis.curRows[tkey]);\n        curXAxisList.push(options.chartAxis.curRows[tkey]);\n      }\n    }\n    let measureList = [];\n    for (let tkey in options.chartAxis.curValues) {\n      if (typeof options.chartAxis.curValues[tkey] !== \"function\") {\n        measureList.push(options.chartAxis.curValues[tkey]);\n      }\n    }\n    //节点合并\n    function mergeTree(node) {\n      let tempMap = new Map();\n      for (let i = 0; i < node.children.length; i++) {\n        let curNd = node.children[i];\n        if (!tempMap.get(curNd.showContext[0])) {\n          tempMap.set(curNd.showContext[0], curNd);\n        } else {\n          let existNd = tempMap.get(curNd.showContext[0]);\n          curNd.children.forEach(function (nd) {\n            existNd.children.push(nd);\n          });\n        }\n      }\n      node.children = [];\n      tempMap.forEach(function (value) {\n        node.children.push(value);\n      });\n      for (let i = 0; i < node.children.length; i++) {\n        mergeTree(node.children[i]);\n      }\n    }\n    //收缩节点\n    function compactTree(node) {\n      if (node.children.length < 0) return;\n      if (!node.isHolder) {\n        while (true) {\n          if (node.children.length === 1) {\n            //把所有单路径都收缩了\n            node.children[0].showContext.forEach(function (d) {\n              node.showContext.push(d);\n            });\n            node.children = node.children[0].children;\n          } else {\n            break;\n          }\n        }\n      }\n      for (let i = 0; i < node.children.length; i++) {\n        compactTree(node.children[i]);\n      }\n    }\n    //展开树\n    elementaryNodes.forEach(function (node) {\n      let context = node.context;\n      let placeHolder = {\n        isHolder: true,\n        children: []\n      };\n      let preNd = placeHolder;\n      for (let i = 0; i < keyList.length; i++) {\n        let neoNd = {\n          context: node.context,\n          showContext: [context[keyList[i].idx]],\n          children: []\n        };\n        neoNd.measureContext = [];\n        measureList.forEach(function (h) {\n          neoNd.measureContext.push(context[h.idx]);\n        });\n        if (i === keyList.length - 1) {\n          neoNd.isLeaf = true;\n        }\n        preNd.children.push(neoNd);\n        preNd = neoNd;\n      }\n      if (node.sames) {\n        node.sames.forEach(function (s) {\n          let preNd = placeHolder;\n          for (let i = 0; i < keyList.length; i++) {\n            let neoNd = {\n              context: s,\n              showContext: [s[keyList[i].idx]],\n              children: []\n            };\n            neoNd.measureContext = [];\n            measureList.forEach(function (h) {\n              neoNd.measureContext.push(s[h.idx]);\n            });\n            if (i === keyList.length - 1) {\n              neoNd.isLeaf = true;\n            }\n            preNd.children.push(neoNd);\n            preNd = neoNd;\n          }\n        });\n      }\n      mergeTree(placeHolder);\n      if (contextCompactFlag) compactTree(placeHolder);\n      if (placeHolder.children.length > 1) {\n        placeHolder.children.forEach(function (nd) {\n          node.children.push(nd);\n        });\n        node.showContext = null;\n        if (!node.measureContext) node.measureContext = [];\n      } else if (placeHolder.children.length) {\n        placeHolder = placeHolder.children[0];\n        if (placeHolder.children) placeHolder.children.forEach(function (nd) {\n          node.children.push(nd);\n        });\n        node.showContext = placeHolder.showContext;\n        node.measureContext = placeHolder.measureContext;\n      }\n      node.independent = true; //用以区分索引节点和属性节点\n    });\n    //汇总\n    let maxDeep = 0;\n    let tempTotalNodes = [];\n    function summaryTree(node, deep) {\n      node.deep = deep;\n      if (deep > maxDeep) maxDeep = deep;\n      if (node.children.length <= 0) return;\n      for (let i = 0; i < node.children.length; i++) {\n        tempTotalNodes.push(node.children[i]);\n        summaryTree(node.children[i], deep + 1);\n      }\n      if (!node.measureContext) return;\n      if (node.independent) {\n        let isVain = false;\n        let measureOffset = [];\n        for (let i = 0; i < node.measureContext.length; i++) {\n          measureOffset[i] = node.measureContext[i];\n        }\n        node.children.forEach(function (nd) {\n          if (!nd.independent) isVain = true;\n          for (let i = 0; i < node.measureContext.length; i++) {\n            node.measureContext[i] += nd.measureContext[i];\n          }\n        });\n        if (isVain) {\n          for (let i = 0; i < node.measureContext.length; i++) {\n            node.measureContext[i] -= measureOffset[i];\n          }\n        }\n      } else {\n        for (let i = 0; i < node.measureContext.length; i++) {\n          if (node.children.length <= 0) {} else {\n            let sum = 0;\n            node.children.forEach(function (nd) {\n              sum += nd.measureContext[i];\n            });\n            node.measureContext[i] = sum;\n          }\n        }\n      }\n    }\n    summaryTree(root, 0);\n    //用占位符填充树\n    tempTotalNodes.forEach(function (nd) {\n      if (nd.deep < maxDeep) {\n        if (nd.children.length <= 0) {\n          let deep = nd.deep;\n          let preNd = nd;\n          while (true) {\n            deep += 1;\n            let neoNd = {\n              context: preNd.context,\n              holder: true,\n              showContext: preNd.showContext,\n              measureContext: preNd.measureContext,\n              children: []\n            };\n            preNd.children.push(neoNd);\n            preNd = neoNd;\n            if (deep >= maxDeep) break;\n          }\n        }\n      }\n    });\n    let theMetrics = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStrSizeByCanvas('string', \"KKK\", {\n      fontSize: fontSize,\n      lineHeight: lineHeight\n    });\n    let minNodeWidth = 80;\n    let theRowHeight = theMetrics.height,\n      theOriginalHeight = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStrSizeByCanvas('string', \"KKK\", {\n        fontSize: fontSize\n      }).height;\n    let minNodeHeight = theMetrics.height; // Math.max(fontSize+2*lineHeightSpace,2*fontSize);\n    //对树进行分区，并计算每个节点的宽高\n    function analysisTree(node, deep) {\n      if (!node) return;\n      if (deep >= 0) {\n        let showContext = node.showContext;\n        let measureContext = node.measureContext;\n        let maxWidth = 0,\n          maxHeight = 0,\n          elementCount = 0;\n        if (showContext) showContext.forEach(function (c, i) {\n          let showText = \"\";\n          if (headers[i].col_type === \"MEASURE\") {\n            showText += headers[i].col_name + \":\";\n          }\n          showText += c;\n          let theTextMetrics = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStrSizeByCanvas('string', showText, {\n            fontSize: fontSize,\n            lineHeight: lineHeight\n          });\n          let tempWidth = theTextMetrics.width;\n          if (tempWidth > maxWidth) maxWidth = tempWidth;\n          maxHeight += theTextMetrics.height;\n          elementCount++;\n        });\n        if (measureContext) measureContext.forEach(function (m, i) {\n          let showText = \"\";\n          showText += measureList[i].col_name + \":\";\n          showText += m;\n          let theTextMetrics = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getStrSizeByCanvas('string', showText, {\n            fontSize: fontSize,\n            lineHeight: lineHeight\n          });\n          let tempWidth = theTextMetrics.width;\n          if (tempWidth > maxWidth) maxWidth = tempWidth;\n          maxHeight += theTextMetrics.height;\n          elementCount++;\n        });\n        if (maxHeight < minNodeHeight) maxHeight = minNodeHeight;\n        node.width = maxWidth + rectBoarderWidth * 2 + 2 * paddingRectSpace;\n        if (node.width < minNodeWidth) node.width = minNodeWidth;\n        node.height = maxHeight + rectBoarderWidth * 2 + 2 * paddingRectSpace;\n        node.elementNumber = elementCount;\n        //node.deep=deep;\n      }\n      for (let i = 0; i < node.children.length; i++) {\n        if (!neoColumns[deep + 1]) neoColumns[deep + 1] = [];\n        neoColumns[deep + 1].push(node.children[i]);\n        totalNode.push(node.children[i]);\n      }\n      for (let i = 0; i < node.children.length; i++) {\n        analysisTree(node.children[i], deep + 1);\n      }\n    }\n    analysisTree(root, -1);\n    let boarderOffset = 20;\n    let paintParameters = [];\n    let maxWidthIntervalSpace = parseInt(totalWidth * 0.10);\n    let maxHeightIntervalSpace = parseInt(totalHeight * 0.10);\n\n    //计算画布大小\n    let minLayerIntervalSpace = 100;\n    let minItemIntervalSpace = 60;\n    let tempMinWidth = 0,\n      tempMinHeight = 0;\n    if (orientation === \"horizon\") {\n      neoColumns.forEach(function (c) {\n        let maxWidth = 0,\n          tempEntireHeight = 0;\n        c.forEach(function (nd) {\n          tempEntireHeight += nd.height;\n          if (nd.width > maxWidth) maxWidth = nd.width;\n        });\n        tempEntireHeight += (c.length - 1) * minItemIntervalSpace;\n        if (tempEntireHeight > tempMinHeight) tempMinHeight = tempEntireHeight;\n        tempMinWidth += maxWidth;\n      });\n      tempMinWidth += (neoColumns.length - 1) * minLayerIntervalSpace;\n    } else {\n      neoColumns.forEach(function (c) {\n        let maxHeight = 0,\n          tempEntireWidth = 0;\n        c.forEach(function (nd) {\n          tempEntireWidth += nd.width;\n          if (nd.height > maxHeight) maxHeight = nd.height;\n        });\n        tempEntireWidth += (c.length - 1) * minItemIntervalSpace;\n        if (tempEntireWidth > tempMinWidth) tempMinWidth = tempEntireWidth;\n        tempMinHeight += maxHeight;\n      });\n      tempMinHeight += (neoColumns.length - 1) * minLayerIntervalSpace;\n    }\n    tempMinHeight *= 1;\n    tempMinWidth *= 1;\n    let isOverWidth = false,\n      isOverHeigth = false;\n    if (tempMinWidth > totalWidth) {\n      isOverWidth = true;\n      totalWidth = tempMinWidth;\n    }\n    if (tempMinHeight > totalHeight) {\n      isOverHeigth = true;\n      totalHeight = tempMinHeight;\n    }\n    //初始为均分布局\n    if (orientation === \"horizon\") {\n      let entireWidth = 0;\n      neoColumns.forEach(function (c, idx) {\n        let tempEntireHeight = 0,\n          maxWidth = 0;\n        c.forEach(function (nd) {\n          tempEntireHeight += nd.height;\n          if (nd.width > maxWidth) maxWidth = nd.width;\n        });\n        let heightIntervalSpace = c.length > 1 ? parseInt((totalHeight - boarderOffset - tempEntireHeight) / (c.length - 1 || 1)) : 0;\n        if (heightIntervalSpace > maxHeightIntervalSpace) heightIntervalSpace = maxHeightIntervalSpace;\n        let tempPaintHeight = tempEntireHeight + heightIntervalSpace * (c.length - 1);\n        let tempPaintTop = parseInt((totalHeight - tempPaintHeight) / 2);\n        if (isOverHeigth) tempPaintTop = tempPaintTop / 4;\n        if (tempPaintTop < 20) tempPaintTop = 20;\n        paintParameters[idx] = {\n          entireHeight: tempEntireHeight,\n          entireWidth: maxWidth,\n          heightIntervalSpace: heightIntervalSpace,\n          paintTop: tempPaintTop\n        };\n        entireWidth += maxWidth;\n      });\n      let widthIntervalSpace = parseInt((totalWidth - boarderOffset - entireWidth) / (neoColumns.length - 1 || 1));\n      if (widthIntervalSpace > maxWidthIntervalSpace) widthIntervalSpace = maxWidthIntervalSpace;\n      let paintWidth = entireWidth + widthIntervalSpace * (neoColumns.length - 1);\n      let paintLeft = parseInt((totalWidth - paintWidth) / 2) * 2 / 3;\n      if (isOverWidth) paintLeft = parseInt((totalWidth - paintWidth) / 2) * 2 / 9;\n      let leftCumulative = paintLeft;\n      for (let i = 0; i < paintParameters.length; i++) {\n        let tempLeft = leftCumulative;\n        leftCumulative += paintParameters[i].entireWidth + widthIntervalSpace;\n        let topCumulative = paintParameters[i].paintTop;\n        for (let j = 0; j < neoColumns[i].length; j++) {\n          let tempTop = topCumulative;\n          topCumulative += neoColumns[i][j].height + paintParameters[i].heightIntervalSpace;\n          neoColumns[i][j].top = tempTop;\n          neoColumns[i][j].left = tempLeft;\n        }\n      }\n    } else {\n      let entireHeight = 0;\n      neoColumns.forEach(function (c, idx) {\n        let tempEntireWidth = 0,\n          maxHeight = 0;\n        c.forEach(function (nd) {\n          tempEntireWidth += nd.width;\n          if (nd.height > maxHeight) maxHeight = nd.height;\n        });\n        let widthIntervalSpace = c.length > 1 ? parseInt((totalWidth - boarderOffset - tempEntireWidth) / (c.length - 1 || 1)) : 0;\n        if (widthIntervalSpace > maxWidthIntervalSpace) widthIntervalSpace = maxWidthIntervalSpace;\n        let tempPaintWidth = tempEntireWidth + widthIntervalSpace * (c.length - 1);\n        let tempPaintLeft = parseInt((totalWidth - tempPaintWidth) / 2);\n        if (isOverWidth) tempPaintLeft = tempPaintLeft / 4;\n        if (tempPaintLeft < 20) tempPaintLeft = 20;\n        paintParameters[idx] = {\n          entireHeight: maxHeight,\n          entireWidth: tempEntireWidth,\n          widthIntervalSpace: widthIntervalSpace,\n          paintLeft: tempPaintLeft\n        };\n        entireHeight += maxHeight;\n      });\n      let heightIntervalSpace = parseInt((totalHeight - boarderOffset - entireHeight) / (neoColumns.length - 1 || 1));\n      if (heightIntervalSpace > maxHeightIntervalSpace) heightIntervalSpace = maxHeightIntervalSpace;\n      let paintHeight = entireHeight + heightIntervalSpace * (neoColumns.length - 1);\n      let paintTop = parseInt((totalHeight - paintHeight) / 2);\n      if (isOverHeigth) paintTop = parseInt((totalHeight - paintHeight) / 2) / 4;\n      let topCumulative = paintTop;\n      for (let i = 0; i < paintParameters.length; i++) {\n        let tempTop = topCumulative;\n        topCumulative += paintParameters[i].entireHeight + heightIntervalSpace;\n        let leftCumulative = paintParameters[i].paintLeft;\n        for (let j = 0; j < neoColumns[i].length; j++) {\n          let tempLeft = leftCumulative;\n          leftCumulative += neoColumns[i][j].width + paintParameters[i].widthIntervalSpace;\n          neoColumns[i][j].top = tempTop;\n          neoColumns[i][j].left = tempLeft;\n        }\n      }\n    }\n\n    //节点块对齐\n    //向前对齐\n    for (let i = neoColumns.length - 2; i >= 0; i--) {\n      let tempC = neoColumns[i];\n      tempC.forEach(function (nd) {\n        if (orientation === \"horizon\") {\n          let centerTop;\n          if (nd.children.length === 1) {\n            if (nd.height === nd.children[0].height) {\n              nd.top = nd.children[0].top;\n            } else {\n              centerTop = parseInt((nd.children[0].top + nd.children[0].top + nd.children[0].height) / 2);\n            }\n          } else if (nd.children.length > 1) {\n            centerTop = parseInt((nd.children[0].top + nd.children[nd.children.length - 1].top + nd.children[nd.children.length - 1].height) / 2);\n          }\n          if (centerTop) {\n            nd.top = parseInt(centerTop - nd.height / 2);\n          }\n        } else {\n          let centerLeft;\n          if (nd.children.length === 1) {\n            centerLeft = parseInt((nd.children[0].left + nd.children[0].left + nd.children[0].width) / 2);\n          } else if (nd.children.length > 1) {\n            centerLeft = parseInt((nd.children[0].left + nd.children[nd.children.length - 1].left + nd.children[nd.children.length - 1].width) / 2);\n          }\n          if (centerLeft) {\n            nd.left = parseInt(centerLeft - nd.width / 2);\n          }\n        }\n      });\n    }\n    let d3 = options.plugins.d3;\n    let svg = d3.select(svgDiv.find(\"svg\")[0]);\n    svg.style(\"font-size\", fontSize + \"px\");\n    svg.style(\"font-weight\", \"normal\");\n    svg.style(\"cursor\", \"move\");\n    svg.attr(\"fill\", fontColor);\n    svg.append(\"defs\").append(\"marker\").attr(\"id\", \"markerArrow\" + options.chartUUID).attr(\"markerWidth\", 8).attr(\"markerHeight\", 8).attr(\"refX\", 6).attr(\"refY\", 4).attr(\"orient\", \"auto\").attr(\"stroke-width\", \"0\").append(\"path\").attr(\"d\", \"M8,5 L0,0 L0,8\").attr(\"fill-opacity\", \"1\").style(\"fill\", arrowColor);\n    svg.append(\"defs\").append(\"marker\").attr(\"id\", \"markerCircle\" + options.chartUUID).attr(\"markerWidth\", 8).attr(\"markerHeight\", 8).attr(\"refX\", 4).attr(\"refY\", 4).attr(\"orient\", \"auto\").attr(\"stroke-width\", \"0\").append(\"circle\").attr(\"cx\", \"4\").attr(\"cy\", \"4\").attr(\"r\", \"4\").attr(\"fill-opacity\", \"1\").style(\"fill\", arrowColor);\n    let treeContainer = svg.append(\"g\");\n    treeContainer.attr(\"class\", \"tree-container-g\");\n    treeContainer.attr(\"stroke\", lineColor);\n    for (let i = 0; i < totalNode.length; i++) {\n      //绘制连线\n      if (lineType === \"straight\") {\n        totalNode[i].children.forEach(function (nd) {\n          if (totalNode[i].holder || nd.holder) return;\n          if (orientation === \"vertical\") {\n            treeContainer.append(\"line\").attr(\"x1\", totalNode[i].left + totalNode[i].width / 2).attr(\"y1\", totalNode[i].top + totalNode[i].height - fontSize - 3).attr(\"x2\", nd.left + nd.width / 2).attr(\"y2\", nd.top - arrowOffset - fontSize - 3).attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n          } else {\n            treeContainer.append(\"line\").attr(\"x1\", totalNode[i].left + totalNode[i].width).attr(\"y1\", totalNode[i].top + totalNode[i].height / 2 - fontSize - 3).attr(\"x2\", nd.left - arrowOffset).attr(\"y2\", nd.top + nd.height / 2 - fontSize - 3).attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n          }\n        });\n      } else if (lineType === \"fold\") {\n        totalNode[i].children.forEach(function (nd) {\n          if (totalNode[i].holder || nd.holder) return;\n          if (orientation === \"vertical\") {\n            treeContainer.append(\"line\").attr(\"x1\", totalNode[i].left + totalNode[i].width / 2).attr(\"y1\", totalNode[i].top + totalNode[i].height - fontSize - 3).attr(\"x2\", totalNode[i].left + totalNode[i].width / 2).attr(\"y2\", (totalNode[i].top + totalNode[i].height - fontSize - 3 + (nd.top - arrowOffset - fontSize - 3)) / 2);\n            treeContainer.append(\"line\").attr(\"x1\", totalNode[i].left + totalNode[i].width / 2).attr(\"y1\", (totalNode[i].top + totalNode[i].height - fontSize - 3 + (nd.top - arrowOffset - fontSize - 3)) / 2).attr(\"x2\", nd.left + nd.width / 2).attr(\"y2\", (totalNode[i].top + totalNode[i].height - fontSize - 3 + (nd.top - arrowOffset - fontSize - 3)) / 2);\n            treeContainer.append(\"line\").attr(\"x1\", nd.left + nd.width / 2).attr(\"y1\", (totalNode[i].top + totalNode[i].height - fontSize - 3 + (nd.top - arrowOffset - fontSize - 3)) / 2).attr(\"x2\", nd.left + nd.width / 2).attr(\"y2\", nd.top - arrowOffset - fontSize - 3).attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n          } else {\n            if (Math.abs(nd.top + nd.height / 2 - fontSize - 3 - (totalNode[i].top + totalNode[i].height / 2 - fontSize - 3)) < 4) {\n              treeContainer.append(\"line\").attr(\"x1\", totalNode[i].left + totalNode[i].width).attr(\"y1\", totalNode[i].top + totalNode[i].height / 2 - fontSize - 3).attr(\"x2\", nd.left - arrowOffset).attr(\"y2\", nd.top + nd.height / 2 - fontSize - 3).attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n            } else {\n              treeContainer.append(\"line\").attr(\"x1\", totalNode[i].left + totalNode[i].width).attr(\"y1\", totalNode[i].top + totalNode[i].height / 2 - fontSize - 3).attr(\"x2\", (totalNode[i].left + totalNode[i].width + (nd.left - arrowOffset)) / 2).attr(\"y2\", totalNode[i].top + totalNode[i].height / 2 - fontSize - 3);\n              treeContainer.append(\"line\").attr(\"x1\", (totalNode[i].left + totalNode[i].width + (nd.left - arrowOffset)) / 2).attr(\"y1\", totalNode[i].top + totalNode[i].height / 2 - fontSize - 3).attr(\"x2\", (totalNode[i].left + totalNode[i].width + (nd.left - arrowOffset)) / 2).attr(\"y2\", nd.top + nd.height / 2 - fontSize - 3);\n              treeContainer.append(\"line\").attr(\"x1\", (totalNode[i].left + totalNode[i].width + (nd.left - arrowOffset)) / 2).attr(\"y1\", nd.top + nd.height / 2 - fontSize - 3).attr(\"x2\", nd.left - arrowOffset).attr(\"y2\", nd.top + nd.height / 2 - fontSize - 3).attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n            }\n          }\n        });\n      } else if (lineType === \"curve\") {\n        totalNode[i].children.forEach(function (nd) {\n          if (totalNode[i].holder || nd.holder) return;\n          if (orientation === \"vertical\") {\n            let tempD = \"M\" + parseInt(totalNode[i].left + totalNode[i].width / 2);\n            tempD += \" \" + parseInt(totalNode[i].top + totalNode[i].height - fontSize - 3);\n            tempD += \" C\" + parseInt(totalNode[i].left + totalNode[i].width / 2);\n            tempD += \" \" + parseInt((totalNode[i].top + totalNode[i].height - fontSize - 3 + (nd.top - arrowOffset - fontSize - 3)) / 2);\n            tempD += \" \" + parseInt(nd.left + nd.width / 2);\n            tempD += \" \" + parseInt((totalNode[i].top + totalNode[i].height - fontSize - 3 + (nd.top - arrowOffset - fontSize - 3)) / 2);\n            tempD += \" \" + parseInt(nd.left + nd.width / 2);\n            tempD += \" \" + parseInt(nd.top - arrowOffset - fontSize - 3);\n            treeContainer.append(\"path\").attr(\"fill\", \"none\").attr(\"d\", tempD).attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n          } else {\n            let tempD = \"M\" + parseInt(totalNode[i].left + totalNode[i].width);\n            tempD += \" \" + parseInt(totalNode[i].top + totalNode[i].height / 2 - fontSize - 3);\n            tempD += \" C\" + parseInt((totalNode[i].left + totalNode[i].width + (nd.left - arrowOffset)) / 2);\n            tempD += \" \" + parseInt(totalNode[i].top + totalNode[i].height / 2 - fontSize - 3);\n            tempD += \" \" + parseInt((totalNode[i].left + totalNode[i].width + (nd.left - arrowOffset)) / 2);\n            tempD += \" \" + parseInt(nd.top + nd.height / 2 - fontSize - 3);\n            tempD += \" \" + parseInt(nd.left - arrowOffset);\n            tempD += \" \" + parseInt(nd.top + nd.height / 2 - fontSize - 3);\n            treeContainer.append(\"path\").attr(\"d\", tempD).attr(\"fill\", \"none\").attr(\"marker-end\", \"url(#\" + arrowType + \")\");\n          }\n        });\n      }\n      if (totalNode[i].holder) continue;\n      let nodeElement = treeContainer.append(\"g\");\n      nodeElement.on(\"mousedown\", function () {\n        if (!totalNode[i].holder) {\n          let theRowIndex = totalNode[i].context.rowIndex;\n          let theDataColumnIdx = [];\n          curXAxisList && curXAxisList.forEach(function (xAxis) {\n            theDataColumnIdx.push(xAxis.idx);\n          });\n          typeof options.mousedownCallback === 'function' && options.mousedownCallback(options.plugins.d3.event, {\n            dataColumnIndex: theDataColumnIdx,\n            dataRowIndex: theRowIndex\n          });\n        }\n      });\n      nodeElement.attr(\"transform\", function () {\n        return \"translate(\" + totalNode[i].left + \",\" + totalNode[i].top + \")\";\n      });\n      nodeElement.attr(\"stroke-width\", \"0\");\n      let tempCount = 0;\n      nodeElement.append(\"rect\").attr(\"rx\", rectRound).attr(\"ry\", rectRound).attr(\"stroke-width\", rectBoarderWidth).attr(\"stroke\", rectBoarderColor).attr(\"stroke-dasharray\", boarderDasharray).attr(\"fill\", rectFillColor).attr(\"width\", totalNode[i].width).attr(\"height\", totalNode[i].height).attr(\"transform\", \"translate(0,\" + (-fontSize - 3) + \")\");\n      for (let j = 0; totalNode[i].showContext && j < totalNode[i].showContext.length; j++) {\n        let showText = \"\";\n        showText += totalNode[i].showContext[j];\n        nodeElement.append(\"text\").attr(\"dominant-baseline\", \"text-after-edge\")\n        // 此处增加fontSize/8是因为text-after-edge的特性，导致文字不是居中显示，有点偏上\n        .attr(\"y\", fontSize / 8 + paddingRectSpace + rectBoarderWidth + (theRowHeight - theOriginalHeight) / 2 + theRowHeight * tempCount).attr(\"x\", paddingRectSpace).text(showText);\n        tempCount++;\n      }\n      for (let j = 0; totalNode[i].measureContext && j < totalNode[i].measureContext.length; j++) {\n        let showText = \"\";\n        showText += measureList[j].col_name + \":\";\n        showText += totalNode[i].measureContext[j];\n        nodeElement.append(\"text\").attr(\"dominant-baseline\", \"text-after-edge\")\n        // 此处增加fontSize/8是因为text-after-edge的特性，导致文字不是居中显示，有点偏上\n        .attr(\"y\", fontSize / 8 + paddingRectSpace + rectBoarderWidth + (theRowHeight - theOriginalHeight) / 2 + theRowHeight * tempCount).attr(\"x\", paddingRectSpace)\n        //.attr(\"x\",parseInt((totalNode[i].width-lenText)/2))\n        .text(showText);\n        tempCount++;\n      }\n    }\n    let tcLeft = 0,\n      tcTop = 0,\n      tcScale = 1;\n    let wheelInterrupt = false;\n    svgDiv.find(\"svg\").mousedown(function (e) {\n      wheelInterrupt = true;\n      let startX = e.clientX,\n        startY = e.clientY;\n      let tempLeft = tcLeft,\n        tempTop = tcTop,\n        finalLeft = tempLeft,\n        finalTop = tempTop;\n      $(document).bind(\"mousemove\", function (e) {\n        let moveWidth = e.clientX - startX;\n        let moveHeight = e.clientY - startY;\n        finalLeft = tempLeft + moveWidth;\n        finalTop = tempTop + moveHeight;\n        treeContainer.attr(\"transform\", function () {\n          return \"translate(\" + finalLeft + \",\" + finalTop + \") \" + \"scale(\" + tcScale + \")\";\n        });\n      });\n      $(document).one(\"mouseup\", function (e) {\n        wheelInterrupt = false;\n        tcLeft = finalLeft;\n        tcTop = finalTop;\n        $(document).unbind(\"mousemove\");\n      });\n    });\n    svgDiv.find(\"svg\").bind('mousewheel DOMMouseScroll', function (event) {\n      if (wheelInterrupt) return;\n      let pointerX = event.offsetX;\n      let pointerY = event.offsetY;\n      let forceX = (pointerX - tcLeft) / tcScale;\n      let forceY = (pointerY - tcTop) / tcScale;\n      let wheel = event.originalEvent.wheelDelta;\n      let detal = event.originalEvent.detail;\n      if (event.originalEvent.wheelDelta) {\n        //判断浏览器IE,谷歌滚轮事件\n        if (wheel > 0) {\n          //当滑轮向上滚动时\n          tcScale += 0.1;\n          if (tcScale > 1) tcScale = 1;\n        }\n        if (wheel < 0) {\n          //当滑轮向下滚动时\n          tcScale -= 0.1;\n          if (tcScale < 0.3) tcScale = 0.3;\n        }\n      } else if (event.originalEvent.detail) {\n        //Firefox滚轮事件\n        if (detal > 0) {\n          //当滑轮向下滚动时\n          tcScale -= 0.1;\n          if (tcScale < 0.3) tcScale = 0.3;\n        }\n        if (detal < 0) {\n          //当滑轮向上滚动时\n          tcScale += 0.1;\n          if (tcScale > 1) tcScale = 1;\n        }\n      }\n      let showX = forceX * tcScale + tcLeft;\n      let showY = forceY * tcScale + tcTop;\n      let residualX = pointerX - showX;\n      let residualY = pointerY - showY;\n      tcLeft += residualX;\n      tcTop += residualY;\n      treeContainer.attr(\"transform\", function () {\n        return \"translate(\" + tcLeft + \",\" + tcTop + \") \" + \"scale(\" + tcScale + \")\";\n      });\n    });\n  },\n  // 当前图形的配置项\n  chartConfigureList: [\n  // 通用\n  {\n    key: \"category_general\",\n    title: \"category_general\",\n    options: [{\n      key: \"chart_tree_orientation\",\n      title: \"option_chart_tree_orientation\",\n      description: \"option_chart_tree_orientation_desc\",\n      type: \"select\",\n      selection: [\"option_orientation_horizon\", \"option_orientation_vertical\"]\n    },\n    // {\n    //     key: \"tree_compact_context\",\n    //     title: \"option_tree_compact_context\",\n    //     description: \"option_tree_compact_context_desc\",\n    //     type: \"checkbox\"\n    // },\n    {\n      key: \"tree_font_size\",\n      title: \"option_tree_font_size\",\n      description: \"option_tree_font_size_desc\",\n      type: \"input\",\n      min: 14,\n      max: 96,\n      defaultNumber: 14\n    }, {\n      key: \"tree_font_color\",\n      title: \"option_tree_font_color\",\n      description: \"option_tree_font_color_desc\",\n      type: \"color\"\n    },\n    // 文字行高\n    {\n      key: \"tree_line_height\",\n      title: \"option_tree_line_height\",\n      description: \"option_tree_line_height_desc\",\n      type: \"input\",\n      min: 1,\n      max: 5,\n      step: 1,\n      defaultValue: 1\n    }]\n  },\n  // 节点配置\n  {\n    key: \"category_node_config\",\n    title: \"category_node_config\",\n    options: [{\n      key: \"tree_rect_color\",\n      title: \"option_tree_rect_color\",\n      description: \"option_tree_rect_color_desc\",\n      type: \"color\"\n    }, {\n      key: \"tree_rect_padding\",\n      title: \"option_tree_rect_padding\",\n      description: \"option_tree_rect_padding_desc\",\n      type: \"input\",\n      min: 0,\n      max: 100,\n      defaultNumber: 6\n    }, {\n      key: \"tree_rect_round\",\n      title: \"option_tree_rect_round\",\n      description: \"option_tree_rect_round_desc\",\n      type: \"input\",\n      min: 0,\n      max: 100,\n      defaultNumber: 8\n    }, {\n      key: \"tree_rect_boarder\",\n      title: \"option_tree_rect_boarder\",\n      description: \"option_tree_rect_boarder_desc\",\n      type: \"select\",\n      selection: [\"option_rect_boarder_solid\", \"option_rect_boarder_dashed\", \"option_rect_boarder_dotted\", \"option_rect_boarder_none\"]\n    }, {\n      key: \"tree_rect_boarder_width\",\n      title: \"option_tree_rect_boarder_width\",\n      description: \"option_tree_rect_boarder_width_desc\",\n      type: \"input\",\n      min: 0,\n      max: 10,\n      defaultNumber: 2\n    }, {\n      key: \"tree_rect_boarder_color\",\n      title: \"option_tree_rect_boarder_color\",\n      description: \"option_tree_rect_boarder_color_desc\",\n      type: \"color\"\n    }]\n  },\n  // 连线配置\n  {\n    key: \"category_line_config\",\n    title: \"category_line_config\",\n    options: [{\n      key: \"tree_line_style\",\n      title: \"option_line_style\",\n      description: \"option_line_style_desc\",\n      type: \"select\",\n      selection: [\"option_line_style_curve\", \"option_line_style_fold\", \"option_line_style_straight\"]\n    }, {\n      key: \"tree_line_color\",\n      title: \"option_tree_line_color\",\n      description: \"option_tree_line_color_desc\",\n      type: \"color\"\n    }, {\n      key: \"tree_arrow_style\",\n      title: \"option_arrow_style\",\n      description: \"option_arrow_style_desc\",\n      type: \"select\",\n      selection: [\"option_arrow_style_circle\", \"option_arrow_style_arrow\", \"option_arrow_style_none\"]\n    }, {\n      key: \"tree_arrow_color\",\n      title: \"option_tree_arrow_color\",\n      description: \"option_tree_arrow_color_desc\",\n      type: \"color\"\n    }]\n  }],\n  // 为模板问答生成样例数据\n  getTemplateData: function () {\n    let theTemplateData = {\n      headers: [{\n        idx: 0,\n        col_id: '10001',\n        col_uuid: '10001',\n        col_name: '索引1',\n        data_type: 'ATTRIBUTE',\n        operator: '',\n        geo_type: '',\n        col_type: 'int'\n      }, {\n        idx: 1,\n        col_id: '10002',\n        col_uuid: '10002',\n        col_name: '索引2',\n        data_type: 'ATTRIBUTE',\n        operator: '',\n        geo_type: '',\n        col_type: 'int',\n        parent: '10001'\n      }, {\n        idx: 2,\n        col_id: '10003',\n        col_uuid: '10003',\n        col_name: '测试属性列',\n        data_type: 'ATTRIBUTE',\n        operator: '',\n        geo_type: '',\n        col_type: 'string'\n      }, {\n        idx: 3,\n        col_id: '10004',\n        col_uuid: '10004',\n        col_name: '测试数值列',\n        data_type: 'MEASURE',\n        operator: 'SUM',\n        geo_type: '',\n        col_type: 'int',\n        statistics: {\n          sum: 123,\n          average: 32,\n          min: 5,\n          max: 40,\n          'standard deviation': 2.5,\n          'unique count': 10,\n          'variance': 23.5\n        }\n      }],\n      columns: [[null, 1, '测试1', 11], [1, 2, '测试2', 22], [1, 3, '测试3', 33], [2, 4, '测试4', 44]],\n      default_chart: {\n        type: 'tree',\n        xAxis: [0, 1, 2],\n        yAxis: [3]\n      },\n      charts: [{\n        type: 'tree',\n        xAxis: [0, 1, 2],\n        yAxis: [3]\n      }]\n    };\n    return theTemplateData;\n  },\n  // 当前图形定制的中英文[ 配置XY轴，图表配置 ]\n  i18nObj: {\n    chinese: {\n      \"chart-name-title\": \"嵌套树图\",\n      \"chart-description-title\": \"至少两个属性列 且 两个属性列的列中值(100以内)是包含与被包含的关系且能生成一个有向无环图\",\n      \"chart-key-cascade-title\": \"节点列（两个列生成有向无环树状结构）\",\n      \"chart-key-axis-title\": \"节点描述\",\n      \"chart-measure-axis-title\": \"数值列\",\n      \"chart-column-axis-null\": \"节点列需要两个属性列生成有向无环的树状结构\",\n      \"chart-column-axis-only-two\": \"节点列只允许两个\",\n      \"chart-values-axis-null\": \"数值列只允许一个\",\n      \"option_chart_tree_orientation\": \"树冠方向\",\n      \"option_chart_tree_orientation_desc\": \"设置树的朝向\",\n      \"option_orientation_horizon\": \"水平方向\",\n      \"option_orientation_vertical\": \"垂直方向\",\n      \"option_tree_compact_context\": \"内容聚拢\",\n      \"option_tree_compact_context_desc\": \"将展开的属性信息，聚集到一个节点中\",\n      \"option_tree_font_size\": \"文字大小\",\n      \"option_tree_font_size_desc\": \"设置文字大小\",\n      \"option_tree_font_color\": \"文字颜色\",\n      \"option_tree_font_color_desc\": \"设置文字颜色\",\n      \"option_tree_line_height\": \"文字行高\",\n      \"option_tree_line_height_desc\": \"设置文字行高\",\n      \"category_node_config\": \"节点\",\n      \"option_tree_rect_color\": \"矩形颜色\",\n      \"option_tree_rect_color_desc\": \"设置矩形颜色\",\n      \"option_tree_rect_padding\": \"矩形边距\",\n      \"option_tree_rect_padding_desc\": \"设置矩形边距\",\n      \"option_tree_rect_round\": \"矩形圆角\",\n      \"option_tree_rect_round_desc\": \"设置矩形圆角\",\n      \"option_tree_rect_boarder\": \"矩形边框\",\n      \"option_tree_rect_boarder_desc\": \"设置矩形边框\",\n      \"option_rect_boarder_solid\": \"实线\",\n      \"option_rect_boarder_dashed\": \"虚线\",\n      \"option_rect_boarder_dotted\": \"点线\",\n      \"option_rect_boarder_none\": \"无边框\",\n      \"option_tree_rect_boarder_width\": \"边框宽度\",\n      \"option_tree_rect_boarder_width_desc\": \"设置边框宽度\",\n      \"option_tree_rect_boarder_color\": \"边框颜色\",\n      \"option_tree_rect_boarder_color_desc\": \"设置边框颜色\",\n      \"category_line_config\": \"连线\",\n      \"option_line_style\": \"连线样式\",\n      \"option_line_style_desc\": \"设置连线样式\",\n      \"option_line_style_curve\": \"曲线\",\n      \"option_line_style_fold\": \"折线\",\n      \"option_line_style_straight\": \"直线\",\n      \"option_tree_line_color\": \"连线颜色\",\n      \"option_tree_line_color_desc\": \"设置连线颜色\",\n      \"option_arrow_style\": \"末端样式\",\n      \"option_arrow_style_desc\": \"设置末端样式\",\n      \"option_arrow_style_circle\": \"圆点\",\n      \"option_arrow_style_arrow\": \"箭头\",\n      \"option_arrow_style_none\": \"无端点\",\n      \"option_tree_arrow_color\": \"末端颜色\",\n      \"option_tree_arrow_color_desc\": \"设置末端颜色\",\n      \"option_tree_not_match_tooltip\": \"警告：您的数据不再适合树结构\"\n    },\n    english: {\n      \"chart-name-title\": \"Nested Tree\",\n      \"chart-description-title\": \"At least two attribute columns and one numerical column, and the values (within 100) of the two attribute columns have a relationship between containing and being included, and can generate a directed acyclic graph\",\n      \"chart-key-cascade-title\": \"Node Columns（Two columns generate a directed acyclic tree structure）\",\n      \"chart-key-axis-title\": \"Node Description\",\n      \"chart-measure-axis-title\": \"Number\",\n      \"chart-column-axis-null\": \"The node column requires two attribute columns to generate a directed acyclic tree structure\",\n      \"chart-column-axis-only-two\": \"Only two node columns are allowed\",\n      \"chart-values-axis-null\": \"Only one numerical column is allowed\",\n      \"option_chart_tree_orientation\": \"Canopy Orientation\",\n      \"option_chart_tree_orientation_desc\": \"Set canopy orientation\",\n      \"option_orientation_horizon\": \"horizon\",\n      \"option_orientation_vertical\": \"vertical\",\n      \"option_tree_compact_context\": \"Cluster Context\",\n      \"option_tree_compact_context_desc\": \"cluster the attribute context into one node\",\n      \"option_tree_font_size\": \"Font Size\",\n      \"option_tree_font_size_desc\": \"Set font size\",\n      \"option_tree_font_color\": \"Font color\",\n      \"option_tree_font_color_desc\": \"Set font color\",\n      \"option_tree_line_height\": \"Line Height\",\n      \"option_tree_line_height_desc\": \"Set line height\",\n      \"option_tree_rect_color\": \"Rect Color\",\n      \"option_tree_rect_color_desc\": \"Set rect color\",\n      \"option_tree_rect_padding\": \"Rect Padding\",\n      \"option_tree_rect_padding_desc\": \"Set rect padding\",\n      \"option_tree_rect_round\": \"Rect Round\",\n      \"option_tree_rect_round_desc\": \"Set rect round\",\n      \"option_tree_rect_boarder\": \"Rect Boarder\",\n      \"option_tree_rect_boarder_desc\": \"Set rect boarder\",\n      \"option_rect_boarder_solid\": \"solid\",\n      \"option_rect_boarder_dashed\": \"dashed\",\n      \"option_rect_boarder_dotted\": \"dotted\",\n      \"option_rect_boarder_none\": \"none\",\n      \"option_tree_rect_boarder_width\": \"Boarder Width\",\n      \"option_tree_rect_boarder_width_desc\": \"Set boarder width\",\n      \"option_tree_rect_boarder_color\": \"Boarder Color\",\n      \"option_tree_rect_boarder_color_desc\": \"Set boarder color\",\n      \"option_line_style\": \"Line Style\",\n      \"option_line_style_desc\": \"Set line style\",\n      \"option_line_style_curve\": \"curve\",\n      \"option_line_style_fold\": \"fold\",\n      \"option_line_style_straight\": \"straight\",\n      \"option_tree_line_color\": \"Line Color\",\n      \"option_tree_line_color_desc\": \"Set line color\",\n      \"option_arrow_style\": \"Arrow Style\",\n      \"option_arrow_style_desc\": \"Set arrow style\",\n      \"option_arrow_style_circle\": \"circle\",\n      \"option_arrow_style_arrow\": \"arrow\",\n      \"option_arrow_style_none\": \"none\",\n      \"option_tree_arrow_color\": \"Arrow Color\",\n      \"option_tree_arrow_color_desc\": \"Set arrow color\",\n      \"option_tree_not_match_tooltip\": \"Warning: Your data is not proper to the tree structure\"\n    }\n  }\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.senior/treeChart.js?");

/***/ })

}]);