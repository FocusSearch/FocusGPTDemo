(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[20],{

/***/ "../src-v5/assets/js/charts.system.basic/combination/CombinationChartComponent.js":
/*!****************************************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/combination/CombinationChartComponent.js ***!
  \****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/LegendComponent */ \"../src-v5/assets/js/charts.components/LegendComponent.js\");\n/* harmony import */ var _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pc/assets/js/d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n// 辅助柱形图画图的组件\n\n\n\n\nlet CombinationChartComponent = {\n  // 处理线条数据\n  getLineDataSet: function (chartSetData, options = {}) {\n    if (!chartSetData || !chartSetData.length) return false;\n    if (!options.attributeXAxis || !options.attributeXAxis.scale || !options.measureYAxis || !options.measureYAxis.firstMeasureScaleFunc || !options.curYAxis) return false;\n    let measureYScaleFunc = options.curYAxis.direction === 'right' ? options.measureYAxis.secondMeasureScaleFunc : options.measureYAxis.firstMeasureScaleFunc;\n    let attributeXScaleFunc = options.attributeXAxis.scale,\n      rangeBand = options.attributeXAxis.rangeBand || 0,\n      legendConfig = options.legendConfig || {},\n      scatterRadius = parseFloat(options.scatterRadius) || 5;\n    let theMax = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].max(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      }),\n      theMin = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].min(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      });\n    let points = [];\n    //\n    chartSetData.forEach(function (curData) {\n      if (!curData) return false;\n      let theXValue = curData.x0,\n        theYValue = curData['y' + options.yIndex];\n      if (_DataFocusMethod.isPureNumber(theYValue)) {\n        let theOX = attributeXScaleFunc(curData.x0) + rangeBand / 2,\n          theOY = measureYScaleFunc(curData['y' + options.yIndex]);\n        let theColor = legendConfig.color;\n        // Y轴的颜色规则\n        if (options.curYAxis.header && options.curYAxis.header.colorFormattings) {\n          let theYColorFormats = options.curYAxis.header.colorFormattings;\n          let curColor = _DataFocusMethod.calcTheColor(theYValue, theYColorFormats, {\n            rowData: curData.rowData\n          });\n          if (curColor) theColor = curColor;\n        }\n\n        // 当前点是警告点的情况下 , 则需要使用svg画该点，加上闪烁效果\n        if (curData[\"alarm\" + options.yIndex] || curData[\"alarm_x_0\"]) {\n          theColor = 'transparent';\n        }\n        const point = {\n          ox: theOX,\n          oy: theOY,\n          color: theColor,\n          radius: scatterRadius,\n          yIndex: options.yIndex,\n          x0: curData.x0,\n          [`y${options.yIndex}`]: curData['y' + options.yIndex],\n          legendType: options.legendType,\n          legendValue: options.legendValue,\n          legendIndex: options.legendIndex,\n          legendConfig: options.legendConfig,\n          legendId: options.legendId,\n          legendTotal: chartSetData.total,\n          rowData: curData.rowData,\n          rowIndex: curData.rowIndex,\n          isAlarmFlag: curData[\"alarm\" + options.yIndex],\n          isMaxFlag: curData['y' + options.yIndex] == theMax,\n          isMinFlag: curData['y' + options.yIndex] == theMin\n        };\n        points.push(point);\n      }\n    });\n\n    // 对点按X轴从小到大排序\n    points.sort(function (a, b) {\n      return a.ox - b.ox;\n    });\n    return {\n      points: points,\n      yIndex: options.yIndex,\n      legendType: options.legendType,\n      legendValue: options.legendValue,\n      legendIndex: options.legendIndex,\n      legendConfig: options.legendConfig,\n      legendId: options.legendId,\n      legendTotal: chartSetData.total,\n      dashedFlag: options.dashedFlag,\n      // 当前图例是否开启dashFlag\n      showShadowFlag: options.showShadowFlag // 线条是否开启阴影\n    };\n  },\n  // 计算当前数据之前，柱体已经堆积的高度。用来计算堆叠柱体和堆叠数据标签的Y坐标\n  calculatePrevStackHeight: function (options) {\n    const currentRow = options.currentRow;\n    const columnsInfoInCurrentPage = options.columnsInfoInCurrentPage;\n    const currentYIndex = options.yIndex; // 当前数值列在legendList中的索引\n    const currentColumnLegendIndex = options.columnLegendIndex; // 当前柱体在柱体柱体列表中的索引\n    const currentYAxis = options.yAxis;\n    const measureAxis = options.measureAxis;\n    const currentYValue = currentRow['y' + currentYIndex];\n    const currentYPositive = currentYValue > 0;\n    const currentYDirection = currentYAxis.direction;\n    let stackHeight = 0;\n    for (let i = 0; i < currentColumnLegendIndex; i++) {\n      const prevLegendData = columnsInfoInCurrentPage[i];\n      const prevYAxis = prevLegendData.yAxis;\n      const prevYIndex = prevLegendData.yIndex;\n      const prevYDirection = prevYAxis.direction;\n      const prevYValue = currentRow['y' + prevYIndex];\n      if (!_DataFocusMethod.isPureNumber(prevYValue)) {\n        continue;\n      }\n      const prevYPositive = prevYValue > 0;\n      if (prevYDirection !== currentYDirection || currentYPositive !== prevYPositive) {\n        continue;\n      }\n\n      // 计算前面相同刻度、相同Y轴Direction，相同正负的堆积高度\n      const theScaleFunc = prevYDirection !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc;\n      const theScaleMeasure = prevYDirection !== 'right' ? measureAxis.firstMeasure : measureAxis.secondMeasure;\n      let prevHeight = 0;\n      if (prevYValue > 0) {\n        prevHeight = theScaleFunc(prevYValue) - theScaleFunc(0);\n      } else {\n        let theTickScale = theScaleMeasure.measureTickScale;\n        prevHeight = theScaleFunc(theTickScale.min - prevYValue);\n      }\n      stackHeight += prevHeight;\n    }\n    return stackHeight;\n  },\n  /**\r\n   *\r\n   * 画水平平铺，垂直摆放的柱形图中的柱子对应的标签 [ 每个Attribute刻度中多个柱子是并排的 ]\r\n   * @param chartSetData  -   当前需要画的数据数组\r\n   * @param options       -    画图辅助信息\r\n   *          {\r\n   *              chartDetailContainer    -   画图的区域\r\n   *              conf                    -   图形实例的配置\r\n   *              chartAxis               -   图轴配置\r\n   *              attributeAxis           -   属性刻度轴的标尺配置\r\n   *              measureAxis             -   数值刻度的标尺配置\r\n   *\r\n   *              curYAxis                -   当前的Y轴\r\n   *              columnIndex             -   每个刻度上当前柱子前面已有柱子的个数（用于计算标签位置）\r\n   *              yIndex                  -   当前Y轴的顺序\r\n   *              yLength                 -   图轴配置中的Y的总数\r\n   *              legendType              -   图例类型 legendAxis: 图例属性列 ； yAxis : 多个Y轴\r\n   *              legendValue             -   legendAxis下当前的图例值 ； yAxis下当前Y轴的col_id\r\n   *              legendIndex             -   legendAxis下当前的图例顺序 ； yAxis下当前Y轴的顺序\r\n   *\r\n   *              translateLeft           -   画图区域的左偏移\r\n   *              translateTop            -   画图区域的顶部偏移\r\n   *              scaleMeasureHeight      -   数值刻度比例尺的高度 ， 即画图区域的高度\r\n   *              scaleAttributeWidth     -   X轴属性刻度比例尺的宽度，即画图区域的宽度\r\n   *              columnWidth             -   柱宽\r\n   *              outPadding              -   柱子在刻度内的左偏移\r\n   *              animateFlag             -   是否有动画\r\n   *\r\n   *              labelPosition           -   标签的位置, in：柱形图里面 ； center: 柱形图中间 ;  out： 柱形图外面 ； default: 自适应，如果外面放的下放外面，外面放不下就放里面，如果都放不下则不显示\r\n   *              labelRotation           -   标签旋转的角度，0： 不旋转 ； 90: 旋转90度 ； 270： 旋转270度 【目前只开放了3中角度】\r\n   *              labelVisibleMap         -   显示的标签集合 all: 显示所有标签  ； standard： 只显示最大最小\r\n   *              labelAllowOverlap       -   标签内容是否允许重叠  默认是不允许重叠\r\n   *         }\r\n   * **/\n  drawHorizontalColumnLabelSet: function (chartSetData, options) {\n    if (!chartSetData || !chartSetData.length) return false;\n    options = options || {};\n    const duration = options.duration;\n    if (!options.chartDetailContainer || !options.attributeAxis || !options.measureAxis || !options.curYAxis) return false;\n    let theChartDetailContainer = options.chartDetailContainer,\n      attributeAxis = options.attributeAxis,\n      measureAxis = options.measureAxis,\n      legendType = options.legendType,\n      legendValue = options.legendValue,\n      legendIndex = options.legendIndex,\n      translateLeft = parseFloat(options.translateLeft),\n      translateTop = parseFloat(options.translateTop),\n      scaleMeasureHeight = parseFloat(options.scaleMeasureHeight),\n      scaleAttributeWidth = parseFloat(options.scaleAttributeWidth),\n      theColumnWidth = parseFloat(options.columnWidth),\n      theOutPadding = parseFloat(options.outPadding),\n      animateFlag = !!options.animateFlag,\n      labelChartSpace = 3,\n      //  标签局内局外时，与柱形的距离\n      labelFontSize = options.labelFontSize || 10,\n      labelFontColor = options.labelFontColor === undefined ? 'inherit' : options.labelFontColor,\n      labelFontBold = options.labelFontBold === undefined ? 'inherit' : options.labelFontBold ? 'bold' : '500',\n      labelFontItalic = options.labelFontItalic === undefined ? 'inherit' : options.labelFontItalic ? 'italic' : 'normal',\n      labelPosition = options.labelPosition || \"default\",\n      labelRotation = options.labelRotation || 0,\n      labelVisibleMap = options.labelVisibleMap || 'all',\n      labelAllowOverlap = !!options.labelAllowOverlap,\n      drewLabelArray = options.drewLabelArray || [],\n      generateLabelTextFunc = typeof options.generateLabelTextFunc === 'function' && options.generateLabelTextFunc,\n      stackColumn = options.stackColumn,\n      columnsInfoInCurrentPage = options.columnsInfoInCurrentPage;\n    let theYAxis = options.curYAxis,\n      theYIndex = options.yIndex || 0;\n    let theScaleFunc = theYAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc,\n      theScaleMeasure = theYAxis.direction !== 'right' ? measureAxis.firstMeasure : measureAxis.secondMeasure;\n    // 因为Y轴的刻度比例尺是值越小高度越大, 计算Y轴柱高时需要调整\n    theScaleFunc.range([0, scaleMeasureHeight]);\n    let theLegendYMax = -Infinity,\n      theLegendYMaxIndex = -1,\n      theLegendYMin = Infinity,\n      theLegendYMinIndex = -1,\n      theLegendYDataIndex = {};\n    chartSetData.forEach(function (data, index) {\n      let d = data['y' + theYIndex];\n      if (_DataFocusMethod.isPureNumber(d)) {\n        theLegendYMax = Math.max(d, theLegendYMax);\n        theLegendYMin = Math.min(d, theLegendYMin);\n        theLegendYDataIndex[d] = index;\n      }\n    });\n    theLegendYMaxIndex = theLegendYDataIndex[theLegendYMax];\n    theLegendYMinIndex = theLegendYDataIndex[theLegendYMin];\n    const columnLabelGroups = theChartDetailContainer.selectAll('g.column-label').data(chartSetData.filter(function (d, index) {\n      // 需要判断当前标签是否需要显示\n      if (labelVisibleMap !== 'all' && index !== theLegendYMaxIndex && index !== theLegendYMinIndex) {\n        // 不是最大值或最小值\n        return false;\n      }\n      let curd = d['y' + theYIndex],\n        message = generateLabelTextFunc && generateLabelTextFunc(d) || curd || '';\n      // 数据标签可以换行，有换行时，得换行显示\n      let messageArray = message.trim().split('\\n'),\n        maxMessageWidth = 0,\n        maxMessageHeight = 0;\n      for (let i = 0; i < messageArray.length; i++) {\n        let theMsg = messageArray[i],\n          theMetrics = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', theMsg, {\n            fontSize: labelFontSize\n          });\n        maxMessageWidth = Math.max(theMetrics.width, maxMessageWidth);\n        maxMessageHeight += theMetrics.height;\n      }\n\n      // 计算柱子上标签的位置\n      let messageWidth = maxMessageWidth,\n        messageHeight = maxMessageHeight,\n        scale = 1,\n        theDataIndex = options.columnIndex || 0; // 所在图例中的位置,但不是柱子的顺序\n\n      let oX,\n        oY = theScaleFunc(curd) + messageHeight / 2;\n      if (!stackColumn) {\n        oX = attributeAxis.scale(d['x0']) + (theDataIndex * theColumnWidth + theColumnWidth / 2 + theOutPadding / 2);\n      } else {\n        // 左Y轴数据偏移0，右Y轴数据偏移1个columnWidth\n        // const yDirection = theYAxis.direction !== 'right';\n        const xOffset = theYAxis.direction !== 'right' ? 0 : theColumnWidth;\n        oX = attributeAxis.scale(d['x0']) + (xOffset + theColumnWidth / 2 + theOutPadding / 2);\n      }\n      let originX = oX,\n        originY = oY,\n        overlapFlag = false;\n\n      // 当前标签的位置信息\n      let curTextPosition = {\n        originX: originX,\n        //  标签元素的rotate位置\n        originY: originY,\n        //  标签元素的rotate位置\n        oX: oX,\n        //  标签元素的translate位置[ 标签的区域的中心点x ]\n        oY: oY,\n        //  标签元素的translate位置[ 标签的区域的中心点y ]\n\n        x: oX - messageWidth / 2,\n        //  标签矩形的左上角点的x\n        y: oY - messageHeight / 2,\n        //  标签矩形的左上角点的y\n        width: messageWidth,\n        //  标签的宽度\n        height: messageHeight,\n        //  标签的高度\n        messageArray: messageArray,\n        //  标签的内容数组【多行的数组】\n        messageHeight: maxMessageHeight / (messageArray.length || 1) //  每行标签的高度\n      };\n      // 负值的OY位置\n      if (curd < 0) {\n        if (labelPosition === 'in') {\n          // 图形内靠边，负数往上移动\n\n          if (!stackColumn) {\n            oY = theScaleFunc(curd) + messageHeight / 2;\n          } else {\n            const prevStackHeight = CombinationChartComponent.calculatePrevStackHeight({\n              currentRow: d,\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              columnLegendIndex: options.columnIndex,\n              yIndex: theYIndex,\n              yAxis: theYAxis,\n              measureAxis: measureAxis\n            });\n            oY = theScaleFunc(curd) + messageHeight / 2 - prevStackHeight;\n          }\n          scale = -1;\n        } else if (labelPosition === 'center') {\n          // 图形中居中\n\n          if (!stackColumn) {\n            oY = theScaleFunc(curd) + (theScaleFunc(0) - theScaleFunc(curd)) / 2;\n          } else {\n            const prevStackHeight = CombinationChartComponent.calculatePrevStackHeight({\n              currentRow: d,\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              columnLegendIndex: options.columnIndex,\n              yIndex: theYIndex,\n              yAxis: theYAxis,\n              measureAxis: measureAxis\n            });\n            oY = theScaleFunc(curd) + (theScaleFunc(0) - theScaleFunc(curd)) / 2 - prevStackHeight;\n          }\n          scale = 0;\n        } else {\n          // 图形外靠边[默认]\n          if (!stackColumn) {\n            oY = theScaleFunc(curd) - messageHeight / 2;\n          } else {\n            const prevStackHeight = CombinationChartComponent.calculatePrevStackHeight({\n              currentRow: d,\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              columnLegendIndex: options.columnIndex,\n              yIndex: theYIndex,\n              yAxis: theYAxis,\n              measureAxis: measureAxis\n            });\n            oY = theScaleFunc(curd) - messageHeight / 2 - prevStackHeight;\n          }\n          scale = 1;\n        }\n        curTextPosition.originX = oX;\n        curTextPosition.originY = oY;\n        curTextPosition.oX = oX;\n        curTextPosition.oY = oY;\n        curTextPosition.x = oX - messageWidth / 2;\n        curTextPosition.y = oY - scale * messageHeight / 2;\n        curTextPosition.width = messageWidth;\n        curTextPosition.height = messageHeight;\n\n        // 如果负数标签旋转，则中心点是往下移 ，则所占矩形的起点 及 宽高的值得调整\n        if (labelRotation > 0) {\n          if (labelPosition === 'in') {\n            // 图形内靠边，负数往上旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageWidth - messageHeight / 2;\n          } else if (labelPosition === 'center') {\n            // 图形居中，居中旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageWidth / 2;\n          } else {\n            // 标签居图形外，负数往下旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageHeight / 2;\n          }\n          curTextPosition.width = messageHeight;\n          curTextPosition.height = messageWidth;\n        }\n\n        // 如果与图形之间有间隔 , 父数，标签居外时标签下移； 居中时不移动； 局内时上移； [ 由scale决定 ]\n        if (labelChartSpace) {\n          curTextPosition.oY = curTextPosition.oY - scale * labelChartSpace;\n          curTextPosition.y = curTextPosition.y - scale * labelChartSpace;\n        }\n\n        // 负数数往下超出了区域\n        // 默认情况下，负值如果图形下方放的下，图形外靠边；如果图形外放不下，网上移动放不下的距离\n        if (curTextPosition.y - curTextPosition.height < 0) {\n          curTextPosition.y = curTextPosition.height;\n          curTextPosition.oY = curTextPosition.height / 2;\n          curTextPosition.originY = curTextPosition.height / 2;\n        }\n      }\n      // 正值的OY位置\n      else {\n        if (labelPosition === 'in') {\n          // 图形内靠内\n          if (!stackColumn) {\n            oY = theScaleFunc(curd) - messageHeight / 2;\n          } else {\n            const prevStackHeight = CombinationChartComponent.calculatePrevStackHeight({\n              currentRow: d,\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              columnLegendIndex: options.columnIndex,\n              yIndex: theYIndex,\n              yAxis: theYAxis,\n              measureAxis: measureAxis\n            });\n            oY = theScaleFunc(curd) - messageHeight / 2 + prevStackHeight;\n          }\n          scale = -1;\n        } else if (labelPosition === 'center') {\n          // 图形中居中\n          if (!stackColumn) {\n            oY = theScaleFunc(curd) - (theScaleFunc(curd) - theScaleFunc(0)) / 2;\n          } else {\n            const prevStackHeight = CombinationChartComponent.calculatePrevStackHeight({\n              currentRow: d,\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              columnLegendIndex: options.columnIndex,\n              yIndex: theYIndex,\n              yAxis: theYAxis,\n              measureAxis: measureAxis\n            });\n            oY = theScaleFunc(curd) - (theScaleFunc(curd) - theScaleFunc(0)) / 2 + prevStackHeight;\n          }\n          scale = 0;\n        } else {\n          // 图形外靠边[默认]\n          if (!stackColumn) {\n            // 非堆积的情况\n            oY = theScaleFunc(curd) + messageHeight / 2;\n          } else {\n            // 计算堆积高度以定位数据标签的Y坐标\n            const prevStackHeight = CombinationChartComponent.calculatePrevStackHeight({\n              currentRow: d,\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              columnLegendIndex: options.columnIndex,\n              yIndex: theYIndex,\n              yAxis: theYAxis,\n              measureAxis: measureAxis\n            });\n            oY = theScaleFunc(curd) + messageHeight / 2 + prevStackHeight;\n          }\n          scale = 1;\n        }\n        curTextPosition.originX = oX;\n        curTextPosition.originY = oY;\n        curTextPosition.oX = oX;\n        curTextPosition.oY = oY;\n        curTextPosition.x = oX - messageWidth / 2;\n        curTextPosition.y = oY + scale * messageHeight / 2;\n        curTextPosition.width = messageWidth;\n        curTextPosition.height = messageHeight;\n\n        // 如果正数标签旋转，则中心点是往下移 ，则所占矩形的起点 及 宽高的值得调整\n        if (labelRotation > 0) {\n          if (labelPosition === 'in') {\n            // 图形内靠边，正数往下旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageHeight / 2;\n          } else if (labelPosition === 'center') {\n            // 图形居中，居中旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageWidth / 2;\n          } else {\n            // 图形居外，正数往上旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageWidth - messageHeight / 2;\n          }\n          curTextPosition.width = messageHeight;\n          curTextPosition.height = messageWidth;\n        }\n\n        // 如果与图形之间有间隔 , 正数，标签上移\n        if (labelChartSpace) {\n          curTextPosition.oY = curTextPosition.oY + scale * labelChartSpace;\n          curTextPosition.y = curTextPosition.y + scale * labelChartSpace;\n        }\n\n        // 正数往上超出了区域\n        // 默认情况下，如果图形上方放的下，图形外靠边；如果图形外放不下，则正数往下移动放不下的距离\n        if (scaleMeasureHeight + translateTop < curTextPosition.y) {\n          curTextPosition.y = scaleMeasureHeight + translateTop - curTextPosition.height;\n          curTextPosition.oY = scaleMeasureHeight + translateTop - curTextPosition.height / 2;\n          curTextPosition.originY = scaleMeasureHeight + translateTop - curTextPosition.height / 2;\n        }\n      }\n\n      // 左右超出画图区域无需分正负数\n      // 如果当前数据标签显示区域超出了图形左侧范围，则标签往左放 ； 当前数据标签超出右侧图形范围，则标签往左放 ；\n      if (curTextPosition.x < 0) {\n        // 标签左侧超出了图形\n        curTextPosition.x = 0;\n        curTextPosition.oX = curTextPosition.width / 2;\n        curTextPosition.originX = curTextPosition.width / 2;\n      } else if (curTextPosition.x + curTextPosition.width > scaleAttributeWidth) {\n        // 标签右侧超出了图形\n        curTextPosition.x = scaleAttributeWidth - curTextPosition.width;\n        curTextPosition.oX = scaleAttributeWidth - curTextPosition.width / 2;\n        curTextPosition.originX = scaleAttributeWidth - curTextPosition.width / 2;\n      }\n\n      // 如果配置允许重叠（即allowOverlap = true) 则不需要判断文字标签是否会重叠了\n      for (let i = drewLabelArray.length - 1; !labelAllowOverlap && i >= 0; i--) {\n        let compScatterTextDom = drewLabelArray[i],\n          curScatterTextDom = curTextPosition;\n\n        // 数据标签经过垂直旋转后的矩形信息需要更新\n        curScatterTextDom = {\n          x: curTextPosition.oX - curTextPosition.width / 2,\n          y: scaleMeasureHeight - curTextPosition.oY - curTextPosition.height / 2,\n          width: curTextPosition.width,\n          height: curTextPosition.height\n        };\n        compScatterTextDom = {\n          x: compScatterTextDom.oX - compScatterTextDom.width / 2,\n          y: scaleMeasureHeight - compScatterTextDom.oY - compScatterTextDom.height / 2,\n          width: compScatterTextDom.width,\n          height: compScatterTextDom.height\n        };\n        if (_pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isOverlap(curScatterTextDom, compScatterTextDom)) {\n          overlapFlag = true;\n          break;\n        }\n      }\n      if (labelAllowOverlap || !overlapFlag) {\n        drewLabelArray.push(curTextPosition);\n        d.labelPosition = curTextPosition;\n        return true;\n      }\n      return false;\n    }), d => d.x0).join(enter => {\n      const g = enter.append('g').attr('class', 'column-label').attr(\"style\", \"cursor:pointer;\").attr(\"xLabel\", function (d) {\n        return d['x0'] + \"\";\n      }).style('font-size', labelFontSize + 'px').style(\"fill\", labelFontColor).style(\"font-weight\", labelFontBold).style(\"font-style\", labelFontItalic).attr(\"transform\", function (d) {\n        return 'translate(0 , 0)';\n      });\n      return g;\n    }, update => {\n      return update.attr(\"style\", \"cursor:pointer;\").attr(\"xLabel\", function (d) {\n        return d['x0'] + \"\";\n      }).style('font-size', labelFontSize + 'px').style(\"fill\", labelFontColor).style(\"font-weight\", labelFontBold).style(\"font-style\", labelFontItalic);\n    }, exit => exit.remove());\n    columnLabelGroups.each(function (parentData, labelIndex) {\n      _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__[\"default\"].select(this).selectAll('text').data(parentData => [parentData]).join(enter => enter.append('text').attr(\"class\", \"labels show-labels\").style(\"fill\", \"inherit\").style(\"stroke\", \"none\").style(\"text-anchor\", \"middle\").style(\"dominant-baseline\", \"middle\").attr(\"x\", function (d) {\n        let position = d.labelPosition;\n        return position && position.oX;\n      }).attr(\"y\", function (d) {\n        let position = d.labelPosition;\n        return position && scaleMeasureHeight - position.oY;\n      }).attr('legendId', options.legendConfig && options.legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateLegendId(legendType, legendValue)).attr(\"transform\", \"rotate(\" + labelRotation + \")\").attr(\"transform-origin\", function (d) {\n        let position = d.labelPosition;\n        if (position && labelRotation > 0) {\n          return position.originX + 'px ' + (scaleMeasureHeight - position.originY) + 'px';\n        }\n      }).each(function (d) {\n        let position = d.labelPosition,\n          theTextDom = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__[\"default\"].select(this),\n          theMessageArray = position && position.messageArray;\n        if (theMessageArray && theMessageArray.length) {\n          for (let i = 0; i < theMessageArray.length; i++) {\n            theTextDom.append(\"tspan\").style(\"dominant-baseline\", \"inherit\").attr(\"x\", position.oX).attr(\"y\", scaleMeasureHeight - position.oY - position.messageHeight * theMessageArray.length / 2 + position.messageHeight / 2 + i * position.messageHeight).text(theMessageArray[i]);\n          }\n        }\n      }), update => update.style(\"fill\", \"inherit\").style(\"stroke\", \"none\").style(\"text-anchor\", \"middle\").style(\"dominant-baseline\", \"middle\").attr(\"x\", function (d) {\n        let position = d.labelPosition;\n        return position && position.oX;\n      }).attr(\"y\", function (d) {\n        let position = d.labelPosition;\n        return position && scaleMeasureHeight - position.oY;\n      }).attr('legendId', options.legendConfig && options.legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateLegendId(legendType, legendValue)).attr(\"transform\", \"rotate(\" + labelRotation + \")\").attr(\"transform-origin\", function (d) {\n        let position = d.labelPosition;\n        if (position && labelRotation > 0) {\n          return position.originX + 'px ' + (scaleMeasureHeight - position.originY) + 'px';\n        }\n      }).each(function (d) {\n        let position = d.labelPosition,\n          theTextDom = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__[\"default\"].select(this),\n          theMessageArray = position && position.messageArray;\n        if (theMessageArray && theMessageArray.length) {\n          for (let i = 0; i < theMessageArray.length; i++) {\n            theTextDom.select(\"tspan\").style(\"dominant-baseline\", \"inherit\").transition().duration(duration.update).attr(\"x\", position.oX).attr(\"y\", scaleMeasureHeight - position.oY - position.messageHeight * theMessageArray.length / 2 + position.messageHeight / 2 + i * position.messageHeight).text(theMessageArray[i]);\n          }\n        }\n      }), exit => exit.remove());\n    });\n\n    // 计算完之后恢复刻度的比例尺\n    theScaleFunc.range([scaleMeasureHeight, 0]);\n  },\n  // 统一绘制对应数据的数据标签\n  drawHorizontalLineLabelSet: function (chartSetData, options) {\n    if (!chartSetData || !chartSetData.length) return false;\n    options = options || {};\n    const duration = options.duration;\n    if (!options.chartDetailContainer || !options.attributeAxis || !options.measureAxis || !options.curYAxis) return false;\n    let theChartDetailContainer = options.chartDetailContainer,\n      attributeAxis = options.attributeAxis,\n      measureAxis = options.measureAxis,\n      legendType = options.legendType,\n      legendValue = options.legendValue,\n      legendIndex = options.legendIndex,\n      translateLeft = parseFloat(options.translateLeft),\n      translateTop = parseFloat(options.translateTop),\n      scaleMeasureHeight = parseFloat(options.scaleMeasureHeight),\n      scaleAttributeWidth = parseFloat(options.scaleAttributeWidth),\n      theColumnWidth = parseFloat(options.columnWidth),\n      theOutPadding = parseFloat(options.outPadding),\n      animateFlag = !!options.animateFlag,\n      labelChartSpace = 3,\n      //  标签局内局外时，与柱形的距离\n      labelFontSize = options.labelFontSize || 10,\n      labelFontColor = options.labelFontColor === undefined ? 'inherit' : options.labelFontColor,\n      labelFontBold = options.labelFontBold === undefined ? 'inherit' : options.labelFontBold ? 'bold' : '500',\n      labelFontItalic = options.labelFontItalic === undefined ? 'inherit' : options.labelFontItalic ? 'italic' : 'normal',\n      labelPosition = options.labelPosition || \"default\",\n      labelRotation = options.labelRotation || 0,\n      labelVisibleMap = options.labelVisibleMap || 'all',\n      labelAllowOverlap = !!options.labelAllowOverlap,\n      drewLabelArray = options.drewLabelArray || [],\n      generateLabelTextFunc = typeof options.generateLabelTextFunc === 'function' && options.generateLabelTextFunc;\n    let theYAxis = options.curYAxis,\n      theYIndex = options.yIndex || 0;\n    let theScaleFunc = theYAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc,\n      theScaleMeasure = theYAxis.direction !== 'right' ? measureAxis.firstMeasure : measureAxis.secondMeasure;\n    // 因为Y轴的刻度比例尺是值越小高度越大, 计算Y轴柱高时需要调整\n    theScaleFunc.range([0, scaleMeasureHeight]);\n    let theLegendYMax = -Infinity,\n      theLegendYMaxIndex = -1,\n      theLegendYMin = Infinity,\n      theLegendYMinIndex = -1,\n      theLegendYDataIndex = {};\n    chartSetData.forEach(function (data, index) {\n      let d = data['y' + theYIndex];\n      if (_DataFocusMethod.isPureNumber(d)) {\n        theLegendYMax = Math.max(d, theLegendYMax);\n        theLegendYMin = Math.min(d, theLegendYMin);\n        theLegendYDataIndex[d] = index;\n      }\n    });\n    theLegendYMaxIndex = theLegendYDataIndex[theLegendYMax];\n    theLegendYMinIndex = theLegendYDataIndex[theLegendYMin];\n    const labelGroups = theChartDetailContainer.selectAll('g.line-label').data(chartSetData.filter(function (d, index) {\n      // 需要判断当前标签是否需要显示\n      if (labelVisibleMap !== 'all' && index !== theLegendYMaxIndex && index !== theLegendYMinIndex) return false;\n      let curd = d['y' + theYIndex],\n        message = generateLabelTextFunc && generateLabelTextFunc(d) || curd || '';\n      // 数据标签可以换行，有换行时，得换行显示\n      let messageArray = message.trim().split('\\n'),\n        maxMessageWidth = 0,\n        maxMessageHeight = 0;\n      for (let i = 0; i < messageArray.length; i++) {\n        let theMsg = messageArray[i],\n          theMetrics = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', theMsg, {\n            fontSize: labelFontSize\n          });\n        maxMessageWidth = Math.max(theMetrics.width, maxMessageWidth);\n        maxMessageHeight += theMetrics.height;\n      }\n      let messageWidth = maxMessageWidth,\n        messageHeight = maxMessageHeight,\n        scale = 1,\n        oX = attributeAxis.scale(d['x0']) + attributeAxis.rangeBand / 2,\n        oY = theScaleFunc(curd) + messageHeight / 2,\n        originX = oX,\n        originY = oY,\n        overlapFlag = false;\n      // 当前标签的位置信息\n      let curTextPosition = {\n        originX: originX,\n        //  标签元素的rotate位置\n        originY: originY,\n        //  标签元素的rotate位置\n        oX: oX,\n        //  标签元素的translate位置[ 标签的区域的中心点x ]\n        oY: oY,\n        //  标签元素的translate位置[ 标签的区域的中心点y ]\n\n        x: oX - messageWidth / 2,\n        //  标签矩形的左上角点的x\n        y: oY - messageHeight / 2,\n        //  标签矩形的左上角点的y\n        width: messageWidth,\n        //  标签的宽度\n        height: messageHeight,\n        //  标签的高度\n        messageArray: messageArray,\n        //  标签的内容数组【多行的数组】\n        messageHeight: maxMessageHeight / (messageArray.length || 1) //  每行标签的高度\n      };\n\n      // 负值的OY位置\n      if (curd < 0) {\n        if (labelPosition === 'in') {\n          // 图形内靠边，负数往上移动\n          oY = theScaleFunc(curd) + messageHeight / 2;\n          scale = -1;\n        } else if (labelPosition === 'center') {\n          // 图形中居中\n          oY = theScaleFunc(curd);\n          scale = 0;\n        } else {\n          // 图形外靠边[默认]\n          oY = theScaleFunc(curd) - messageHeight / 2;\n          scale = 1;\n        }\n        curTextPosition.originX = oX;\n        curTextPosition.originY = oY;\n        curTextPosition.oX = oX;\n        curTextPosition.oY = oY;\n        curTextPosition.x = oX - messageWidth / 2;\n        curTextPosition.y = oY - scale * messageHeight / 2;\n        curTextPosition.width = messageWidth;\n        curTextPosition.height = messageHeight;\n\n        // 如果负数标签旋转，则中心点是往下移 ，则所占矩形的起点 及 宽高的值得调整\n        if (labelRotation > 0) {\n          if (labelPosition === 'in') {\n            // 图形内靠边，负数往上旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageWidth - messageHeight / 2;\n          } else if (labelPosition === 'center') {\n            // 图形居中，居中旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageWidth / 2;\n          } else {\n            // 标签居图形外，负数往下旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageHeight / 2;\n          }\n          curTextPosition.width = messageHeight;\n          curTextPosition.height = messageWidth;\n        }\n\n        // 如果与图形之间有间隔 , 父数，标签居外时标签下移； 居中时不移动； 局内时上移； [ 由scale决定 ]\n        if (labelChartSpace) {\n          curTextPosition.oY = curTextPosition.oY - scale * labelChartSpace;\n          curTextPosition.y = curTextPosition.y - scale * labelChartSpace;\n        }\n\n        // 负数数往下超出了区域\n        // 默认情况下，负值如果图形下方放的下，图形外靠边；如果图形外放不下，网上移动放不下的距离\n        if (curTextPosition.y - curTextPosition.height < 0) {\n          curTextPosition.y = curTextPosition.height;\n          curTextPosition.oY = curTextPosition.height / 2;\n          curTextPosition.originY = curTextPosition.height / 2;\n        }\n      }\n      // 正值的OY位置\n      else {\n        if (labelPosition === 'in') {\n          // 图形内靠边\n          oY = theScaleFunc(curd) - messageHeight / 2;\n          scale = -1;\n        } else if (labelPosition === 'center') {\n          // 图形中居中\n          oY = theScaleFunc(curd);\n          scale = 0;\n        } else {\n          // 图形外靠边[默认]\n          oY = theScaleFunc(curd) + messageHeight / 2;\n          scale = 1;\n        }\n        curTextPosition.originX = oX;\n        curTextPosition.originY = oY;\n        curTextPosition.oX = oX;\n        curTextPosition.oY = oY;\n        curTextPosition.x = oX - messageWidth / 2;\n        curTextPosition.y = oY + scale * messageHeight / 2;\n        curTextPosition.width = messageWidth;\n        curTextPosition.height = messageHeight;\n\n        // 如果正数标签旋转，则中心点是往下移 ，则所占矩形的起点 及 宽高的值得调整\n        if (labelRotation > 0) {\n          if (labelPosition === 'in') {\n            // 图形内靠边，正数往下旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY - messageWidth / 2 + messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageHeight / 2;\n          } else if (labelPosition === 'center') {\n            // 图形居中，居中旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY - messageWidth / 2;\n          } else {\n            // 图形居外，正数往上旋转\n            curTextPosition.originX = oX;\n            curTextPosition.originY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.oX = oX;\n            curTextPosition.oY = oY + messageWidth / 2 - messageHeight / 2;\n            curTextPosition.x = oX - messageHeight / 2;\n            curTextPosition.y = oY + messageWidth - messageHeight / 2;\n          }\n          curTextPosition.width = messageHeight;\n          curTextPosition.height = messageWidth;\n        }\n\n        // 如果与图形之间有间隔 , 正数，标签上移\n        if (labelChartSpace) {\n          curTextPosition.oY = curTextPosition.oY + scale * labelChartSpace;\n          curTextPosition.y = curTextPosition.y + scale * labelChartSpace;\n        }\n\n        // 正数往上超出了区域\n        // 默认情况下，如果图形上方放的下，图形外靠边；如果图形外放不下，则正数往下移动放不下的距离\n        if (scaleMeasureHeight + translateTop < curTextPosition.y) {\n          curTextPosition.y = scaleMeasureHeight + translateTop - curTextPosition.height;\n          curTextPosition.oY = scaleMeasureHeight + translateTop - curTextPosition.height / 2;\n          curTextPosition.originY = scaleMeasureHeight + translateTop - curTextPosition.height / 2;\n        }\n      }\n\n      // 左右超出画图区域无需分正负数\n      // 如果当前数据标签显示区域超出了图形左侧范围，则标签往左放 ； 当前数据标签超出右侧图形范围，则标签往左放 ；\n      if (curTextPosition.x < 0) {\n        // 标签左侧超出了图形\n        curTextPosition.x = 0;\n        curTextPosition.oX = curTextPosition.width / 2;\n        curTextPosition.originX = curTextPosition.width / 2;\n      } else if (curTextPosition.x + curTextPosition.width > scaleAttributeWidth) {\n        // 标签右侧超出了图形\n        curTextPosition.x = scaleAttributeWidth - curTextPosition.width;\n        curTextPosition.oX = scaleAttributeWidth - curTextPosition.width / 2;\n        curTextPosition.originX = scaleAttributeWidth - curTextPosition.width / 2;\n      }\n\n      // 如果配置允许重叠（即allowOverlap = true) 则不需要判断文字标签是否会重叠了\n      for (let i = drewLabelArray.length - 1; !labelAllowOverlap && i >= 0; i--) {\n        let compScatterTextDom = drewLabelArray[i],\n          curScatterTextDom = curTextPosition;\n\n        // 数据标签经过垂直旋转后的矩形信息需要更新\n        curScatterTextDom = {\n          x: curTextPosition.oX - curTextPosition.width / 2,\n          y: scaleMeasureHeight - curTextPosition.oY - curTextPosition.height / 2,\n          width: curTextPosition.width,\n          height: curTextPosition.height\n        };\n        compScatterTextDom = {\n          x: compScatterTextDom.oX - compScatterTextDom.width / 2,\n          y: scaleMeasureHeight - compScatterTextDom.oY - compScatterTextDom.height / 2,\n          width: compScatterTextDom.width,\n          height: compScatterTextDom.height\n        };\n        if (_pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isOverlap(curScatterTextDom, compScatterTextDom)) {\n          overlapFlag = true;\n          break;\n        }\n      }\n      if (labelAllowOverlap || !overlapFlag) {\n        drewLabelArray.push(curTextPosition);\n        d.labelPosition = curTextPosition;\n        return true;\n      }\n      return false;\n    }), d => d.x0).join(enter => {\n      const g = enter.append('g').attr('class', 'line-label').attr(\"style\", \"cursor:pointer;\").attr(\"xLabel\", function (d) {\n        return d['x0'] + \"\";\n      }).style('font-size', labelFontSize + 'px').style(\"fill\", labelFontColor).style(\"font-weight\", labelFontBold).style(\"font-style\", labelFontItalic).attr(\"transform\", function (d) {\n        return 'translate(0 , 0)';\n      });\n\n      // g.append('rect')\n      //     .style('fill', 'green')\n      //     .attr(\"width\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && position.width ;\n      //     })\n      //     .attr(\"height\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && position.height ;\n      //     })\n      //     .attr(\"x\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && (position.oX - position.width / 2) ;\n      //     })\n      //     .attr(\"y\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && (scaleMeasureHeight - position.oY - position.height / 2) ;\n      //     });\n      return g;\n    }, update => {\n      // update\n      //     .select('rect')\n      //     .style('fill', 'green')\n      //     .attr(\"width\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && position.width ;\n      //     })\n      //     .attr(\"height\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && position.height ;\n      //     })\n      //     .attr(\"x\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && (position.oX - position.width / 2) ;\n      //     })\n      //     .attr(\"y\", function(d){\n      //         let position = d.labelPosition ;\n      //\n      //         return position && (scaleMeasureHeight - position.oY - position.height / 2) ;\n      //     })\n      return update.style('font-size', labelFontSize + 'px').style(\"fill\", labelFontColor).style(\"font-weight\", labelFontBold).style(\"font-style\", labelFontItalic);\n    }, exit => exit.remove());\n    labelGroups.each(function (parentData, labelIndex) {\n      _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__[\"default\"].select(this).selectAll('text').data(parentData => [parentData]).join(enter => enter.append('text').attr(\"class\", \"labels show-labels\").style(\"fill\", \"inherit\").style(\"stroke\", \"none\").style(\"text-anchor\", \"middle\").style(\"dominant-baseline\", \"middle\").attr(\"x\", function (d) {\n        let position = d.labelPosition;\n        return position && position.oX;\n      }).attr(\"y\", function (d) {\n        let position = d.labelPosition;\n        return position && scaleMeasureHeight - position.oY;\n      }).attr('legendId', options.legendConfig && options.legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateLegendId(legendType, legendValue)).attr(\"transform\", \"rotate(\" + labelRotation + \")\").attr(\"transform-origin\", function (d) {\n        let position = d.labelPosition;\n        if (position && labelRotation > 0) {\n          return position.originX + 'px ' + (scaleMeasureHeight - position.originY) + 'px';\n        }\n      }).each(function (d) {\n        let position = d.labelPosition,\n          theTextDom = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__[\"default\"].select(this),\n          theMessageArray = position && position.messageArray;\n        if (theMessageArray && theMessageArray.length) {\n          for (let i = 0; i < theMessageArray.length; i++) {\n            theTextDom.append(\"tspan\").style(\"dominant-baseline\", \"inherit\").attr(\"x\", position.oX).attr(\"y\", scaleMeasureHeight - position.oY - position.messageHeight * theMessageArray.length / 2 + position.messageHeight / 2 + i * position.messageHeight).text(theMessageArray[i]).attr('opacity', 0).transition().delay((d, i) => {\n              return animateFlag ? 1000 * (labelIndex / chartSetData.length) : 0;\n            }).duration(duration.lineLabelEnter).attr('opacity', 1);\n          }\n        }\n      }), update => update.attr(\"x\", function (d) {\n        let position = d.labelPosition;\n        return position && position.oX;\n      }).attr(\"y\", function (d) {\n        let position = d.labelPosition;\n        return position && scaleMeasureHeight - position.oY;\n      }).attr('legendId', options.legendConfig && options.legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].generateLegendId(legendType, legendValue)).attr(\"transform\", \"rotate(\" + labelRotation + \")\").attr(\"transform-origin\", function (d) {\n        let position = d.labelPosition;\n        if (position && labelRotation > 0) {\n          return position.originX + 'px ' + (scaleMeasureHeight - position.originY) + 'px';\n        }\n      }).each(function (d) {\n        let position = d.labelPosition,\n          theTextDom = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_3__[\"default\"].select(this),\n          theMessageArray = position && position.messageArray;\n        if (theMessageArray && theMessageArray.length) {\n          for (let i = 0; i < theMessageArray.length; i++) {\n            theTextDom.select(\"tspan\").style(\"dominant-baseline\", \"inherit\").text(theMessageArray[i]).transition().duration(duration.update).attr(\"x\", position.oX).attr(\"y\", scaleMeasureHeight - position.oY - position.messageHeight * theMessageArray.length / 2 + position.messageHeight / 2 + i * position.messageHeight);\n          }\n        }\n      }), exit => exit.remove());\n    });\n\n    // 计算完之后恢复刻度的比例尺\n    theScaleFunc.range([scaleMeasureHeight, 0]);\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (CombinationChartComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/combination/CombinationChartComponent.js?");

/***/ }),

/***/ "../src-v5/assets/js/charts.system.basic/combination/systemCombinationChart.js":
/*!*************************************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/combination/systemCombinationChart.js ***!
  \*************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ContainerComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/ContainerComponent */ \"../src-v5/assets/js/charts.components/ContainerComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_TranslateDataComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pc/assets/js/charts.components/TranslateDataComponent */ \"../src-v5/assets/js/charts.components/TranslateDataComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pc/assets/js/charts.components/LegendComponent */ \"../src-v5/assets/js/charts.components/LegendComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pc/assets/js/charts.components/TitleComponent */ \"../src-v5/assets/js/charts.components/TitleComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pc/assets/js/charts.components/MeasureAxisComponent */ \"../src-v5/assets/js/charts.components/MeasureAxisComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_AttributeAxisComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pc/assets/js/charts.components/AttributeAxisComponent */ \"../src-v5/assets/js/charts.components/AttributeAxisComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pc/assets/js/charts.components/MarkerComponent */ \"../src-v5/assets/js/charts.components/MarkerComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_SvgClipPathComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @pc/assets/js/charts.components/SvgClipPathComponent */ \"../src-v5/assets/js/charts.components/SvgClipPathComponent.js\");\n/* harmony import */ var _CombinationChartComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./CombinationChartComponent */ \"../src-v5/assets/js/charts.system.basic/combination/CombinationChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pc/assets/js/charts.components/ReferenceLineComponent */ \"../src-v5/assets/js/charts.components/ReferenceLineComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_PaginationChartComponent__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @pc/assets/js/charts.components/PaginationChartComponent */ \"../src-v5/assets/js/charts.components/PaginationChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ZoomChartComponent__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @pc/assets/js/charts.components/ZoomChartComponent */ \"../src-v5/assets/js/charts.components/ZoomChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_SelectChartComponent__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @pc/assets/js/charts.components/SelectChartComponent */ \"../src-v5/assets/js/charts.components/SelectChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MouseOverChartComponent__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @pc/assets/js/charts.components/MouseOverChartComponent */ \"../src-v5/assets/js/charts.components/MouseOverChartComponent.js\");\n/* harmony import */ var _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @pc/assets/js/d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n/**\r\n * 系统柱状图画图组件\r\n *\r\n * 从系统中剥离的目的\r\n * 1. 为了减轻图形打包文件的大小【20230301时最大的打包文件是10M左右】\r\n * 2. 各个图形控制各自的图表配置\r\n * 3. 支持图形的延迟分批加载\r\n * **/\n\n// 通用组件[ 获取字符串长度之类 ...  ]\n\n// 画图容器组件[ 主要区分svg部分与图例部分 ]\n\n// 数据处理组件[ 解析XY轴配置组的数据 ]\n\n// 画图例列表的组件\n\n// 画标题组件\n\n// 解析数值刻度 及  画数值刻度的组件\n\n// 画属性刻度轴\n\n// 画标准线[ 最大/最小/平均值 ]\n\n// 画图形区域的截取元素\n\n// 画柱形图\n\n// 画标度线\n\n// 画分页组件\n\n// 缩放页组件\n\n// 区域选择组件\n\n// 鼠标移入响应事件\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // [*必填项] 图姓唯一标识\n  chartType: \"column\",\n  // [*必填项] 图形名称中英文Key\n  chartDisplayNameKey: \"chart_column\",\n  // [*必填项] 图形描述中英文Key\n  chartDescriptionKey: \"chart_column_tooltip\",\n  // [*必填项] 图轴配置元素 ( X轴 ，Y轴（允许右Y轴） )\n  needAxis: {\n    xAxis: {},\n    yAxis: {\n      defaultYAxisNumber: -1,\n      allowMultiYAxis: true\n    }\n  },\n  // [*必填项] 搜索数据是否支持该图形 ( 至少一个属性列，一个数值列 )\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n    if (!searchResultStatistic) return false;\n    if (searchResultStatistic.attributeColumns && searchResultStatistic.measureColumns) {\n      if (searchResultStatistic.measureColumns.length >= 2 && searchResultStatistic.attributeColumns.length >= 1) {\n        satisfiedFlag = true;\n      }\n    }\n    return satisfiedFlag;\n  },\n  /**\r\n   * [选填] 获取当前图形各个needAxis中可选择的配置列\r\n   * @return\r\n   *      {\r\n   *          // 依据needAxis结构返回各个可选列的index\r\n   *          xAxis: [1,2,3] ,\r\n   *          yAxis: [4,5] ,\r\n   *          legend: [1,2,3] ,\r\n   *          size: [4,5] ,\r\n   *          time: [1,2]\r\n   *      }\r\n   * */\n  getSatisfiedChartAxis: function (searchResultStatistic) {\n    console.log('[combination] get satisfied axis');\n    let self = this; //  是当前_DataFocusChartTypes中的对象\n\n    const needAxis = self.needAxis || {};\n    if (!needAxis || !searchResultStatistic) return false;\n    let theAxisObj = {};\n    // xAxis / yAxis\n    // X轴的可选项\n    if (needAxis.xAxis) {\n      theAxisObj.xAxis = searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    // Y轴的可选项\n    if (needAxis.yAxis) {\n      theAxisObj.yAxis = searchResultStatistic.measureColumns && searchResultStatistic.measureColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    if (_DataFocusMethod.isObjEmpty(theAxisObj)) {\n      return false;\n    } else {\n      theAxisObj.name = self.name;\n      theAxisObj.type = self.name;\n      return theAxisObj;\n    }\n  },\n  /**\r\n   * [选填] 在图形没有图轴配置的情况下，从getSatisfiedChartAxis中图轴可选项中初始化画图配置\r\n   *\r\n   * 初始化规则：\r\n   * 1. 如果当前数据中有两个以上数值列，则默认X轴是数值列，Y轴是一个数值列\r\n   * 2. 如果当前数据只有一个数值列，则默认X轴是属性列，Y轴是数值列\r\n   *\r\n   * // 依据needAxis生成初始的图轴配置值，及各个轴的配置可选项\r\n   *    返回对象名字规则: 可选项是needAxis中各项名字 + Area ； 当前配置项是 cur + needAxis中各项名字\r\n   * @return chartAxis\r\n   *          {\r\n   *              xAxisArea: [  {col_id , index ...} , {} ] ,\r\n   *              curXAxis: [ {col_id , index ...} ]\r\n   *              yAxisArea: [ {col_id , index , min , max ...} , {} ] ,\r\n   *              curYAxis: [ {col_id , index , min , max ...} ] ,\r\n   *              sizeArea: [{col_id , index ...}] ,\r\n   *              curSize: {col_id , index ...} ,\r\n   *              timeArea: [ {col_id , index ...} ] ,\r\n   *              curTime: {col_id , index ...}\r\n   *          }\r\n   *\r\n   * */\n  initChartAxisConfig: function (options) {\n    console.log('[combination] init axis');\n    options = options || {};\n    if (!options.tableData || !options.tableData.headers) return false;\n    let self = this,\n      //  是当前_DataFocusChartTypes中的对象\n      tableData = options.tableData,\n      headers = tableData.headers,\n      columns = tableData.columns;\n\n    // charts是依据各个图形中的getSatisfiedChartAxis生成的\n    let theMatchedChart = tableData.charts && tableData.charts.find(function (chart) {\n        return (chart.name || chart.type) === self.name;\n      }),\n      chartAxis = {};\n    if (!theMatchedChart) {\n      console.log(\"当前数据不适合组合图\");\n      return chartAxis;\n    }\n    let getIdIndexInHeader = function (colIdx, headers) {\n      // 目前charts返回的都是索引\n      if (colIdx < headers.length) return colIdx;\n      for (let i = 0; i < headers.length; i++) {\n        if (headers[i].col_id === colIdx) return i;\n      }\n      return -1;\n    };\n\n    // 获取XAxis列及可选数组\n    if (self.needAxis && self.needAxis.xAxis) {\n      chartAxis.xAxisArea = [];\n      theMatchedChart.xAxis && theMatchedChart.xAxis.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        chartAxis.xAxisArea.push(obj);\n      });\n\n      // 赋值默认的X轴\n      let xAxisArea = chartAxis.xAxisArea;\n      // 如果指令了属性列的数量\n      let defaultXAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.xAxis.defaultXAxisNumber) ? self.needAxis.xAxis.defaultXAxisNumber : -1;\n      let withoutSortX = xAxisArea && xAxisArea.filter(function (head) {\n        return !head.isSortNoFlag;\n      });\n      // 如果没有排序列的属性列足够分配需要的X轴，则优先使用非排序列的属性列\n      if (defaultXAxisNumber < 0) {\n        chartAxis.curXAxis = withoutSortX.length ? withoutSortX : xAxisArea;\n      } else {\n        if (withoutSortX.length >= defaultXAxisNumber) {\n          chartAxis.curXAxis = withoutSortX.slice(0, defaultXAxisNumber);\n        } else {\n          chartAxis.curXAxis = xAxisArea.slice(0, defaultXAxisNumber);\n        }\n      }\n    }\n\n    // 获取YAxis列及可选数组 [ 必须计算yAxis的最大值与最小值，计算刻度使用 ]\n    if (self.needAxis && self.needAxis.yAxis) {\n      chartAxis.yAxisArea = [];\n      const percentGrowthCategorySet = new Set(['growth_rate', 'growth_interval_rate',\n      // 同期增长率\n      'percentage_attr_measure' // 百分比\n      ]);\n      const amountGrowthCategorySet = new Set(['growth_amount', 'growth_interval_amount' // 同期增长量\n      ]);\n\n      // 增长前后相关值的 category: 使用柱状展示\n      const amountCategorySet = new Set(['growth_previous', 'growth_current']);\n      const growthCategorySet = new Set([...percentGrowthCategorySet, ...amountGrowthCategorySet, ...amountCategorySet]);\n\n      // 是否是增长量、增长率相关的搜索语句。如果是，则采用专门的方案区分左右轴。\n      const isGrowthSearch = theMatchedChart && theMatchedChart.yAxis.some((c, index) => {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        const headerCategories = headers[curColumnIndex] && headers[curColumnIndex].categories || [];\n        return headerCategories.some(categoryItem => growthCategorySet.has(categoryItem));\n      });\n      let hasAmountAxis = false,\n        hasPercentAxis = false;\n      for (const c of theMatchedChart.yAxis) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex]; // 把 header 信息追加到轴上\n        obj.index = curColumnIndex;\n        const categories = obj.header.categories || [];\n        if (!hasPercentAxis && categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n          hasPercentAxis = true;\n        } else if (!hasAmountAxis && categories.some(categoryItem => amountGrowthCategorySet.has(categoryItem))) {\n          hasAmountAxis = true;\n        }\n      }\n      theMatchedChart.yAxis && theMatchedChart.yAxis.forEach(function (c, index) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex]; // 把 header 信息追加到轴上\n        obj.index = curColumnIndex;\n        if (isGrowthSearch) {\n          // 是增长相关的语句\n          const categories = obj.header.categories || [];\n\n          // 1. 如果同时包含增长量和增长率，则前后值和增长量在左Y轴，增长率在右Y轴。\n          // 2. 如果仅包含增长量或增长率，则前后值在左Y轴，增长量或增长率在右Y轴\n          if (hasAmountAxis && hasPercentAxis) {\n            if (categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n              obj.direction = 'right';\n            } else {\n              obj.direction = 'left';\n            }\n          } else {\n            // 变化量、变化率，放在右Y轴，画图时展示为折线图\n            if (categories.some(categoryItem => amountGrowthCategorySet.has(categoryItem)) || categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n              obj.direction = 'right';\n            } else {\n              obj.direction = 'left';\n            }\n          }\n        } else {\n          // 前一半分配给左Y轴，后一半分配给右Y轴\n          obj.direction = index < theMatchedChart.yAxis.length / 2 ? 'left' : 'right';\n        }\n        let min = obj.statistics && obj.statistics.min,\n          max = obj.statistics && obj.statistics.max;\n        if (!_DataFocusMethod.isPureNumber(min) || !_DataFocusMethod.isPureNumber(max)) {\n          let theMin = Infinity,\n            theMax = -Infinity;\n          columns && columns.forEach(function (d) {\n            if (_DataFocusMethod.isPureNumber(d[curColumnIndex])) {\n              theMin = Math.min(theMin, d[curColumnIndex]);\n              theMax = Math.max(theMax, d[curColumnIndex]);\n            }\n          });\n          min = theMin;\n          max = theMax;\n        }\n        min = min > 0 ? 0 : min;\n        max = max < 0 ? 0 : max;\n        max = min === max && max === 0 && min === 0 ? 1 : max;\n        obj.min = min;\n        obj.max = max;\n        chartAxis.yAxisArea.push(obj);\n      });\n\n      // 没有图例的情况，使用配置中默认的Y轴数量\n      let yAxisArea = chartAxis.yAxisArea;\n      let defaultYAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.yAxis.defaultYAxisNumber) ? self.needAxis.yAxis.defaultYAxisNumber : 1;\n      // 如果默认Y轴< 0 ， 说明剩下所有可用Y轴全部是默认Y轴\n\n      if (defaultYAxisNumber < 0 || hasPercentAxis || hasAmountAxis) {\n        if (hasPercentAxis || hasAmountAxis) {\n          // 当是增长率相关的问题时，上方已经分配了direction\n          chartAxis.curYAxis = yAxisArea;\n        } else {\n          // 根据数量级分配左右\n          chartAxis.curYAxis = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].sortYAxisAreaByMagnitude(yAxisArea);\n        }\n      } else {\n        chartAxis.curYAxis = yAxisArea.slice(0, defaultYAxisNumber);\n        let defaultRightYAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.yAxis.defaultRightYAxisNumber) ? self.needAxis.yAxis.defaultRightYAxisNumber : 0;\n        const rightYAxis = yAxisArea.slice(defaultYAxisNumber, defaultYAxisNumber + defaultRightYAxisNumber);\n        if (rightYAxis && rightYAxis.length) {\n          rightYAxis && rightYAxis.forEach(function (yAxis) {\n            yAxis.direction = 'right';\n          });\n          chartAxis.curYAxis = chartAxis.curYAxis.concat(rightYAxis);\n        }\n      }\n    }\n    return chartAxis;\n  },\n  /***\r\n   * [*必填项] 图轴配置是否合法\r\n   * - X轴不允许为空\r\n   * - Y轴不允许为空\r\n   * - 左Y轴不允许为空\r\n   * - Y轴不允许重复\r\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let chartErrorMsg = '';\n    if (!theAxisConfig) return chartErrorMsg;\n\n    // X轴为必填选项\n    if (!theAxisConfig.xAxis || !theAxisConfig.xAxis.length) {\n      chartErrorMsg = 'chart_modify_x_not_null';\n      return chartErrorMsg;\n    }\n\n    // Y轴不允许为空\n    if (!theAxisConfig.yAxis || !theAxisConfig.yAxis.length) {\n      chartErrorMsg = 'chart_modify_y_not_null';\n      return chartErrorMsg;\n    }\n\n    // 左Y轴不允许为空\n    let leftYIds = theAxisConfig.yAxis && theAxisConfig.yAxis.filter(function (axis) {\n      return axis.direction === 'left';\n    });\n    if (!leftYIds || !leftYIds.length) {\n      chartErrorMsg = 'chart_modify_y_left_not_null';\n      return chartErrorMsg;\n    }\n\n    // Y轴不允许重复\n    for (let i = 0, yyIds = []; theAxisConfig.yAxis && i < theAxisConfig.yAxis.length; i++) {\n      let theAxis = theAxisConfig.yAxis[i];\n      if (yyIds.indexOf(theAxis.index) > -1) {\n        chartErrorMsg = 'chart_modify_y_not_repeat';\n        yyIds.push(theAxis.index);\n        return chartErrorMsg;\n      }\n    }\n    return chartErrorMsg;\n  },\n  // [* 必填项]画图方法\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n    let self = this,\n      container = options.container,\n      chartAxis = options.chartAxis,\n      currentChart = options.currentChart,\n      conf = currentChart.defaultConf || {},\n      chartUUID = conf.chartUUID,\n      systemLanguage = conf.systemLanguage || 'chinese',\n      chartConfigures = options.chartConfigures || {},\n      hasLegendFlag = !!(chartAxis.curLegend || chartAxis.curYAxis && chartAxis.curYAxis.length > 1),\n      allowMousedownFlag = !!(conf.action && !conf.wxFlag); //  移动端的mousedown事件不执行\n\n    // 获取图例的位置，默认在右侧\n    let legendPosition = hasLegendFlag ? 'right' : '';\n    if (legendPosition) {\n      legendPosition = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendConfigure(chartConfigures.legend_position);\n    }\n    // 给柱状图初始化画图容器  SVG图形部分(X轴Y轴图形) / X轴标题(位置) / Y轴标题(位置) / 图例(位置)\n    let containerResult = _pc_assets_js_charts_components_ContainerComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawCommonContainer({\n      container: container,\n      legendPosition: !!(chartConfigures.show_legend === undefined || chartConfigures.show_legend) ? legendPosition : ''\n    });\n    if (!containerResult.svgJqDom) return false;\n    if (!options.datas.columns || !options.datas.columns.length) {\n      container.innerHTML = '';\n      console.log('当前图形没有合法的画图数据');\n      return false;\n    }\n\n    // 获取图形的整体宽度和高度\n    let chartWidth = container.offsetWidth,\n      chartHeight = container.offsetHeight;\n    // 当前画图区域的缩放比例【会影响到获取字体高度的计算】\n    if (_DataFocusMethod.isPureNumber(chartConfigures._DF_SYS_TRANSFORM_SCALE)) {\n      _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformScale = chartConfigures._DF_SYS_TRANSFORM_SCALE;\n    }\n\n    // 获取当前图形的配置颜色主题方法\n    let colorFunc = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translateColorThemeConfigure(chartConfigures.chart_color_theme, {\n      chart_custom_theme: chartConfigures.chart_custom_theme\n    });\n    // 获取隐藏聚合方式的标志配置, 即所有属性列的聚合方式不显示在标签内\n    let hideOperatorFlag = false;\n    if (chartConfigures.hide_operator_label) hideOperatorFlag = true;\n    // 获取图形的字体大小配置\n    let chartFontSize = chartConfigures.font_size_label && parseInt(chartConfigures.font_size_label.fontSize) || 10,\n      chartFontColor = chartConfigures.font_size_label && chartConfigures.font_size_label.fontColor,\n      chartFontBold = chartConfigures.font_size_label && chartConfigures.font_size_label.fontBold,\n      chartFontItalic = chartConfigures.font_size_label && chartConfigures.font_size_label.fontItalic;\n    chartFontSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translateFontSizeConfigure(chartFontSize) || 10;\n    if (chartFontColor) {\n      container.style.color = chartFontColor || 'inherit';\n      container.style.fill = chartFontColor || 'inherit';\n      containerResult.svgJqDom.style.color = chartFontColor;\n      containerResult.svgJqDom.style.fill = chartFontColor;\n    } else {\n      container.style.color = '';\n      container.style.fill = '';\n      containerResult.svgJqDom.style.color = '';\n      containerResult.svgJqDom.style.fill = '';\n    }\n    if (chartFontBold) {\n      container.style.fontWeight = 'bold';\n    } else {\n      container.style.fontWeight = 'normal';\n    }\n    if (chartFontItalic) {\n      container.style.fontStyle = 'italic';\n    } else {\n      container.style.fontStyle = 'normal';\n    }\n    let theXTitleFontSize = chartConfigures.x_axis_title_style && parseInt(chartConfigures.x_axis_title_style.fontSize) || chartFontSize || 10,\n      //  X轴标题字体大小\n      theXAxisFontSize = chartConfigures.x_axis_label_style && parseInt(chartConfigures.x_axis_label_style.fontSize) || chartFontSize || 10,\n      //  X轴刻度字体大小， 默认使用图形统一的字体大小\n      theYTitleFontSize = chartConfigures.y_axis_title_style && parseInt(chartConfigures.y_axis_title_style.fontSize) || chartFontSize || 10,\n      //  Y轴标题字体大小\n      theYAxisFontSize = chartConfigures.y_axis_label_style && parseInt(chartConfigures.y_axis_label_style.fontSize) || chartFontSize || 10,\n      //  Y轴刻度字体大小， 默认使用图形统一的字体大小\n      theLegendFontSize = chartConfigures.legend_font_style && parseInt(chartConfigures.legend_font_style.fontSize) || chartFontSize || 10;\n    let gridShowAllLine = chartConfigures.grid_show_all_line === undefined ? true : chartConfigures.grid_show_all_line;\n\n    // 先填充图例区域 [ 绘制图例列表，翻页 ，宽度高度限制 ]\n    // 计算图例列表\n    let showColumnLegendLength = 0,\n      legendValueList = [],\n      defaultLegendList = [];\n    const getSavedLegendColorConfig = legendConfigList => _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendColor({\n      // legendColors: conf.legendColors ,\n      // yAxisColors: conf.yAxisColors ,\n      curYAxis: chartAxis.curYAxis,\n      configureLegendList: legendConfigList\n    });\n\n    // 读取配置中的图例配置\n    let savedLegendColorConfig = getSavedLegendColorConfig(chartConfigures.chart_legend_list);\n\n    // 解析画布中元素的配置\n    let lineStyle,\n      lineWidth = 1,\n      lineSymbolType = 'circle',\n      lineDashedFlag = false,\n      theAnalysisColor = 'red',\n      theAnalysisWidth = 1,\n      circleRadius = 5,\n      // 曲线上的symbol尺寸\n      showPoint = false;\n    const getLineStyle = lineStyleConfigStr => {\n      const lineStyleMap = {\n        option_default_value: 'linear',\n        option_line_style_linear: 'linear',\n        option_line_style_step: 'step',\n        option_line_style_step_after: 'step-after',\n        option_line_style_step_before: 'step-before',\n        option_line_style_curve_natural: 'curve-natural',\n        option_line_style_curve_bump_x: 'curve-bump-x',\n        option_line_style_curve_monotone_x: 'curve-monotone-x',\n        option_line_style_curve_monotone_y: 'curve-monotone-y',\n        option_line_style_curve_basis: 'curve-basis'\n      };\n      return lineStyleMap[lineStyleConfigStr] || lineStyleMap['option_default_value'];\n    };\n    lineStyle = getLineStyle(chartConfigures.style_of_line);\n    if (chartConfigures.show_point !== undefined) {\n      showPoint = !!chartConfigures.show_point;\n    }\n    let stackColumn = false;\n    if (chartConfigures.chart_column_stack !== undefined) {\n      stackColumn = !!chartConfigures.chart_column_stack;\n    }\n    const lineSymbolMap = {\n      option_legend_shape_type_default: 'circle',\n      option_legend_shape_type_circle: 'circle',\n      // option_legend_shape_type_rect: 'rect',\n      option_legend_shape_type_four: 'four',\n      option_legend_shape_type_diamond: 'diamond',\n      option_legend_shape_type_three: 'three',\n      option_legend_shape_type_five: 'five',\n      option_legend_shape_type_loop: 'loop'\n    };\n    const legendShapeType = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendShapeConfigure(chartConfigures && chartConfigures.legend_shape_type);\n    circleRadius = parseInt(chartConfigures.symbol_size_of_line) || 5;\n    if (_DataFocusMethod.isPureNumber(chartConfigures.thickness_of_line)) {\n      lineWidth = parseInt(chartConfigures.thickness_of_line) || 1;\n    }\n    lineDashedFlag = chartConfigures.dashed_solid_of_line === 'option_dashed_solid_of_line_dashed';\n    theAnalysisColor = chartConfigures.outlier_correlation_line_color;\n    if (_DataFocusMethod.isPureNumber(chartConfigures.outlier_correlation_line_width)) {\n      theAnalysisWidth = parseInt(chartConfigures.outlier_correlation_line_width);\n      theAnalysisWidth = Math.max(theAnalysisWidth, 0);\n    }\n\n    // 根据图例配置，分配Y轴的形状\n    const assignYAxisTypesFromLegend = () => {\n      let showLegendLength = 0;\n      legendValueList = [];\n      defaultLegendList = [];\n      showColumnLegendLength = 0;\n      let hasAmountAxis = false,\n        hasPercentAxis = false;\n      const percentGrowthCategorySet = new Set(['growth_rate', 'growth_interval_rate',\n      // 同期增长率\n      'percentage_attr_measure' // 百分比\n      ]);\n      const amountGrowthCategorySet = new Set(['growth_amount', 'growth_interval_amount' // 同期增长量\n      ]);\n\n      // 增长前后相关值的 category: 使用柱状展示\n      const amountCategorySet = new Set(['growth_previous', 'growth_current']);\n      if (chartAxis.curYAxis && chartAxis.curYAxis.length) {\n        for (const yAxis of chartAxis.curYAxis) {\n          const categories = yAxis.header.categories || [];\n          if (!hasPercentAxis && categories.some(categoryItem => percentGrowthCategorySet.has(categoryItem))) {\n            hasPercentAxis = true;\n          } else if (!hasAmountAxis && categories.some(categoryItem => amountGrowthCategorySet.has(categoryItem))) {\n            hasAmountAxis = true;\n          }\n        }\n        // 分配默认的Y轴图表类型，更新 legendValueList。\n        chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis, index) {\n          let theYLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('yAxis', yAxis.idx); //  \"measure-column-id-\" + yAxis.col_id ,\n          // 图例配置中，当前Y轴图例的配置项\n          const theConfigLegend = savedLegendColorConfig && savedLegendColorConfig.find(function (theConfig) {\n            return theConfig.id === theYLegendId;\n          });\n\n          // 两种情况：option_legend_shape_type_column || option_legend_shape_type_line\n          const legendConfigShape = theConfigLegend && theConfigLegend.shape ? theConfigLegend.shape : undefined;\n          const getDefaultShape = () => {\n            // 无特殊情况，第一个YAxis是柱体，其余YAxis是线条\n            let defaultShape = index === 0 ? \"option_legend_shape_type_column\" : 'option_legend_shape_type_line';\n\n            // 如果可以判断是增长率相关的列，则更细致地分配该列地形状类型。\n            if (yAxis.header && (hasAmountAxis || hasPercentAxis)) {\n              const categories = yAxis.header.categories || [];\n              // 增长率相关的category: 使用折线展示\n              const lineCategorySet = new Set(['growth_rate', 'growth_interval_rate',\n              // 同期增长率\n              'percentage_attr_measure' // 百分比\n              ]);\n              // 增长前后相关值的 category: 使用柱状展示\n              const columnCategorySet = new Set(['growth_previous', 'growth_current', 'growth_amount',\n              // 增长量\n              'growth_interval_amount' // 同期增长量\n              ]);\n              if (hasPercentAxis && hasAmountAxis) {\n                if (categories.some(categoryItem => lineCategorySet.has(categoryItem))) {\n                  defaultShape = 'option_legend_shape_type_line';\n                } else if (categories.some(categoryItem => columnCategorySet.has(categoryItem))) {\n                  defaultShape = 'option_legend_shape_type_column';\n                }\n              } else if (hasAmountAxis || hasPercentAxis) {\n                if (categories.some(categoryItem => ['growth_amount', 'growth_interval_amount', 'growth_rate', 'growth_interval_rate'].includes(categoryItem))) {\n                  defaultShape = 'option_legend_shape_type_line';\n                } else {\n                  defaultShape = 'option_legend_shape_type_column';\n                }\n              }\n            }\n            return defaultShape;\n          };\n          const defaultShape = getDefaultShape();\n          legendValueList.push({\n            type: 'measureColumn',\n            legend: _DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n              hideOperator: hideOperatorFlag\n            }),\n            id: theYLegendId,\n            index: index,\n            color: theConfigLegend && theConfigLegend.color || colorFunc(index),\n            show: !theConfigLegend || theConfigLegend.show === undefined ? true : !!theConfigLegend.show,\n            shape: legendConfigShape ? legendConfigShape : defaultShape\n          });\n          defaultLegendList.push({\n            type: 'measureColumn',\n            legend: _DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n              hideOperator: hideOperatorFlag\n            }),\n            id: theYLegendId,\n            //  \"measure-column-id-\" + yAxis.col_id ,\n            index: index,\n            color: colorFunc(index),\n            show: true,\n            shape: defaultShape\n          });\n        });\n      }\n      showColumnLegendLength = legendValueList.filter(theLegend => theLegend.show && theLegend.shape === 'option_legend_shape_type_column').length;\n      // 如果没有显示的图例，则至少保证显示一个\n      legendValueList && legendValueList.forEach(function (theLegend) {\n        if (theLegend.show) showLegendLength++;\n      });\n      if (!showLegendLength) {\n        showLegendLength = 1;\n        legendValueList[0] && (legendValueList[0].show = true);\n      }\n      const drawLegend = () => {\n        if (!hasLegendFlag || !containerResult.legendContainer) return;\n        let drawLegendFlag = !!(chartConfigures.show_legend === undefined || chartConfigures.show_legend);\n        if (!drawLegendFlag) return;\n\n        // 画图例元素,先将图例元素画完成后，才可以计算SVG的宽度与高度\n        _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].drawAttributeLegend({\n          container: containerResult.legendContainer,\n          chartWidth: chartWidth,\n          chartHeight: chartHeight,\n          legendPosition: legendPosition,\n          legendMaxWidthInVertical: chartConfigures.legend_position_width,\n          legendValueList: legendValueList,\n          legendFontSize: theLegendFontSize,\n          legendFontColor: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontColor,\n          legendBoldStyle: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontBold,\n          legendItalicStyle: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontItalic,\n          legendOffsetSpace: chartConfigures.legend_position_offset,\n          legendIntervalSpace: chartConfigures.legend_position_interval,\n          legendShapeType: legendShapeType,\n          changeLegendColorFlag: !!(conf.action && !conf.wxFlag) && !conf.inPinboard,\n          chooseButtonText: self.getPluginKeyText(),\n          changeLegendColorCallback: function (options) {\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              // 修改图形中的图例配置，并将其传给配置组件，然后由配置组件触发画图， 而不是在此处直接画图\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend) {\n                let theMatchedConfigure = chartConfigures.chart_legend_list && chartConfigures.chart_legend_list.find(function (configure) {\n                  return configure.id === theMatchedLegend.id || configure.legend === theMatchedLegend.legend;\n                });\n                if (theMatchedConfigure) {\n                  // 修改图表配置中，对应图例的颜色\n                  theMatchedConfigure.color = options.color || undefined;\n                } else {\n                  // 如果图表配置中未找到当前画布上的图例，那就往配置中增加此图例。什么情况会发生？\n                  chartConfigures.chart_legend_list = chartConfigures.chart_legend_list || [];\n                  chartConfigures.chart_legend_list.push({\n                    id: theMatchedLegend.id,\n                    legend: theMatchedLegend.legend,\n                    color: options.color || undefined\n                  });\n                }\n                // 修改图形配置\n                currentChart.requireSetConfig({\n                  key: \"chart_legend_list\",\n                  value: chartConfigures.chart_legend_list\n                });\n              }\n            }\n          },\n          // 点击 显示/隐藏 图例\n          mousedownEventCallback: function (options) {\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              // 修改图形中的图例配置，并将其传给配置组件，然后由配置组件触发画图， 而不是在此处直接画图\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend) {\n                let theMatchedConfigure = chartConfigures.chart_legend_list && chartConfigures.chart_legend_list.find(function (configure) {\n                  return configure.id === theMatchedLegend.id || configure.legend === theMatchedLegend.legend;\n                });\n                let theShownLegendLength = legendValueList.filter(function (legend) {\n                  return legend.show;\n                }).length;\n                // 如果只有一个图例显示，则不再隐藏最后一个了\n                if (theShownLegendLength === 1 && !!theMatchedLegend.show) return false;\n                if (theMatchedConfigure) {\n                  theMatchedConfigure.show = !theMatchedLegend.show;\n                } else {\n                  chartConfigures.chart_legend_list = chartConfigures.chart_legend_list || [];\n                  chartConfigures.chart_legend_list.push({\n                    id: theMatchedLegend.id,\n                    legend: theMatchedLegend.legend,\n                    show: !theMatchedLegend.show\n                  });\n                }\n                // 修改图形配置\n                currentChart.requireSetConfig({\n                  key: \"chart_legend_list\",\n                  value: chartConfigures.chart_legend_list\n                });\n              }\n            }\n          },\n          mouseoverEventCallback: function (options) {\n            // 高亮当前图例所对应的图形元素，置灰其他元素\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend && theMatchedLegend.id && theMatchedLegend.show) {\n                // 柱体\n                _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect\").attr(\"class\", \"fill-grey\");\n                _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect[legendId=\" + theMatchedLegend.id + \"]\").attr(\"class\", \"\");\n                const currentContainer = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(container);\n                // 线条\n                currentContainer.selectAll('.chartset-line-group .chartset-line-path').classed('stroke-grey', function () {\n                  return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('legendId') !== theMatchedLegend.id;\n                });\n                // 节点\n                currentContainer.selectAll('.chartset-line-group .dots .line-symbol').classed('fill-grey', function () {\n                  return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('legendId') !== theMatchedLegend.id;\n                });\n\n                // 数据标签\n                currentContainer.selectAll('.chartset-label-column, .chartset-label-line').classed('fill-grey', function () {\n                  return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('legendId') !== theMatchedLegend.id;\n                });\n                if (options.legendDom) {\n                  $(options.legendDom).find(\"svg\").removeClass(\"fill-grey\");\n                  $(options.legendDom).siblings().find(\"svg\").addClass(\"fill-grey\");\n                }\n              }\n            }\n          },\n          mouseoutEventCallback: function (options) {\n            options = options || {};\n            // 恢复柱体颜色\n            _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect\").attr(\"class\", \"\");\n\n            // 恢复线条颜色\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(containerResult.svgJqDom).selectAll('.chartset-line-group .chartset-line-path').classed('stroke-grey', false);\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(containerResult.svgJqDom).selectAll('.chartset-label-column, .chartset-label-line').classed('fill-grey', false);\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(containerResult.svgJqDom).selectAll('.chartset-line-group .dots .line-symbol').classed('fill-grey', false);\n            if (options.legendDom) $(options.legendDom).parent().find(\"svg\").removeClass(\"fill-grey\");\n          }\n        });\n      };\n      // legendValueList 更新成功后，重新绘制图表中的图例列表\n      drawLegend();\n    };\n    assignYAxisTypesFromLegend();\n\n    // 再填充画图区域\n    // 0. 先计算Y轴刻度比例尺[ 左Y轴比例尺 及 右Y轴比例尺 及 左右Y轴宽度 ]\n    if (!chartAxis.curYAxis || !chartAxis.curYAxis.length) {\n      console.log('当前图形Y轴配置异常');\n      container.innerHTML = '';\n      return false;\n    }\n    let svgDrawWidth = $(containerResult.svgJqDom).width(),\n      svgDrawHeight = $(containerResult.svgJqDom).height();\n    let showYTitleFlag = !conf.inPinboard;\n    if (!chartConfigures.y_axis_title_visible || chartConfigures.y_axis_title_visible === 'system_auto_default') {\n      showYTitleFlag = !conf.inPinboard;\n    } else {\n      showYTitleFlag = !!(chartConfigures.y_axis_title_visible === \"option_title_visible_show\");\n    }\n\n    // 2. 解析数据为当前画图数据\n    let translateData = _pc_assets_js_charts_components_TranslateDataComponent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].translateXYLegendBasicData({\n      tableData: conf.datas,\n      chartAxis: chartAxis,\n      xLabelType: chartConfigures.x_axis_draw_type === 'option_select_x_axis_dot_line' ? 'dotLine' : 'auto',\n      language: systemLanguage\n    });\n    if (!translateData || !translateData.datas) {\n      console.log('当前图形没有合法的画图数据');\n      container.innerHTML = '';\n      return false;\n    }\n\n    // 获取数据标签的配置\n    let labelFontSize = chartConfigures.label_text_font_style && parseInt(chartConfigures.label_text_font_style.fontSize) || Math.max(chartFontSize - 2, 10) || 10,\n      showLabelFlag = false,\n      labelPosition = 'default',\n      labelRotation = 0,\n      labelVisibleMap = 'all',\n      allowOverlap = false;\n    if (chartConfigures.label_text_visible) {\n      showLabelFlag = true;\n    }\n    if (chartConfigures.label_text_column_position) {\n      switch (conf.chartConfigures.label_text_column_position) {\n        case 'option_label_position_in':\n          labelPosition = 'in';\n          break;\n        case 'option_label_position_center':\n          labelPosition = 'center';\n          break;\n        case 'option_label_position_out':\n          labelPosition = 'out';\n          break;\n        default:\n          labelPosition = 'default';\n          break;\n      }\n    }\n    if (chartConfigures.label_text_rotation_angle) {\n      switch (chartConfigures.label_text_rotation_angle) {\n        case 'option_label_rotation_90':\n          labelRotation = 90;\n          break;\n        case 'option_label_rotation_270':\n          labelRotation = 270;\n          break;\n        default:\n          labelRotation = 0;\n          break;\n      }\n    }\n    if (chartConfigures.label_text_visible_items) {\n      switch (chartConfigures.label_text_visible_items) {\n        case 'option_label_visible_all':\n          labelVisibleMap = 'all';\n          break;\n        case 'option_label_visible_standard':\n          labelVisibleMap = 'standard';\n          break;\n        default:\n          labelVisibleMap = 'all';\n          break;\n      }\n    }\n    if (chartConfigures.label_text_allow_overlap) {\n      allowOverlap = true;\n    }\n\n    // 是否显示X轴标题的配置\n    let showXTitleFlag = !conf.inPinboard; //  用户没有配置X轴或配置为自动的情况下，系统按是否是看板自动分配\n    if (!chartConfigures.x_axis_title_visible || chartConfigures.x_axis_title_visible === 'system_auto_default') {\n      showXTitleFlag = !conf.inPinboard;\n    } else {\n      showXTitleFlag = !!(chartConfigures.x_axis_title_visible === \"option_title_visible_show\");\n    }\n    const animateFlag = !chartConfigures.animation_forbidden,\n      //  是否禁止动画的标志\n      colorAssignedToScaleFlag = !!chartConfigures.chart_color_assigned_to_x_scale,\n      //  在没有图例且单个Y轴的情况下，将颜色按X轴刻度分配的标志\n      thePositiveOutlierColor = '#0000ff',\n      //  离群分析正向颜色\n      theNegativeOutlierColor = '#eeeeee'; //  离群分析负向颜色\n\n    const duration = {\n      enter: animateFlag ? 300 : 0,\n      update: animateFlag ? 300 : 0,\n      exit: animateFlag ? 300 : 0,\n      columnEnter: animateFlag ? 800 : 0,\n      // 柱体进入\n      columnHover: animateFlag ? 100 : 0,\n      // 柱体悬浮\n      pathEnter: animateFlag ? 1000 : 0,\n      // 线条进入\n      dotEnter: animateFlag ? 200 : 0,\n      // 点进入\n      dotExit: animateFlag ? 100 : 0,\n      // 点退出\n\n      columnLabelEnter: animateFlag ? 300 : 0,\n      lineLabelEnter: animateFlag ? 200 : 0\n    };\n\n    // 如果当前图形可以配置将颜色分配给X轴刻度，则计算当前X轴刻度的颜色\n    let theXLabelColorList = [],\n      defaultXLabelColorList = [];\n    if (!hasLegendFlag) {\n      let theLabelColorConfig = chartConfigures.chart_custom_label_color;\n      translateData.xLabelDistinct && translateData.xLabelDistinct.forEach(function (xLabel, index) {\n        let theMatchedColorConfig = theLabelColorConfig && theLabelColorConfig.find(function (theConfig) {\n          return theConfig.legend === xLabel;\n        });\n        theXLabelColorList.push({\n          id: xLabel,\n          legend: xLabel,\n          //  因为使用的legendList组件，所以显示名命名都是legend\n          color: theMatchedColorConfig && theMatchedColorConfig.color || colorFunc(index)\n        });\n        defaultXLabelColorList.push({\n          id: xLabel,\n          legend: xLabel,\n          color: colorFunc(index)\n        });\n      });\n    }\n\n    // 柱状图的柱宽比例\n    let columnWidthPercent = (parseFloat(chartConfigures.chart_column_width_percent_1) || 60) / 100; //  柱状图柱子占刻度宽的比例\n\n    let yAxisBasicMessage = null;\n    /**\r\n     * frameOptions 主要用于翻页 及 缩放时的参数传递\r\n     * @param frameOptions\r\n     *      {\r\n     *          type    -   操作类型    page: 翻页； zoom: 缩放 ； select: 区域选择 ； 无：是初始化\r\n     *          start   -   X刻度开始的索引\r\n     *          steps   -   X轴可以放的X刻度数量\r\n     *      }\r\n     * */\n    const drawOneFrame = function (frameOptions) {\n      frameOptions = frameOptions || {};\n      const svgDom = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(containerResult.svgJqDom);\n      // 3. 填充X轴刻度值 [ 先通过Y轴刻度宽度值 及 标准线宽度值，计算X轴刻度的宽度 ， 画完X轴刻度后才可以确认X轴刻度的高度]\n      let measureSeparate = 5,\n        //  刻度值与轴之间的间隔[ Y轴刻度与Y轴线之间的间隔 ]\n        attributeSeparate = 2,\n        //  属性刻度与轴之间的间隔 [ X轴刻度与Y轴最小的一条线的间隔 ]\n        titleSeparate = 5; //  轴标题与轴刻度之间的间隔 [ X轴标题与X轴刻度的间隔 ； Y轴标题与Y轴刻度的间隔 ]\n      let attributeTitleHeight = 0,\n        //  X轴横向摆放的高度\n        scalePaddingTop = 10; //  垂直方向的刻度轴顶部需要预留10px空白\n\n      // 首次计算Y轴的基本信息：宽度，刻度值等\n      yAxisBasicMessage = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].calcMeasureAxisBasicMessage({\n        direction: 'vertical',\n        language: systemLanguage,\n        axisFontSize: theYAxisFontSize,\n        drawWidth: svgDrawWidth,\n        drawHeight: svgDrawHeight,\n        firstMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n          return axis.direction !== 'right';\n        }), {\n          axisType: 'normal',\n          scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type),\n          min: chartConfigures.measure_scale_min,\n          max: chartConfigures.measure_scale_max,\n          definedMin: chartConfigures.measure_scale_defined_min || 0,\n          definedSeparate: chartConfigures.measure_scale_step,\n          definedStep: chartConfigures.measure_scale_step_number,\n          definedScaleFormat: chartConfigures.measure_left_y_configure\n        }),\n        secondMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n          return axis.direction === 'right';\n        }), {\n          axisType: 'normal',\n          scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type_right),\n          min: chartConfigures.measure_scale_min_right,\n          max: chartConfigures.measure_scale_max_right,\n          definedMin: chartConfigures.measure_scale_defined_min_right || 0,\n          definedSeparate: chartConfigures.measure_scale_step_right,\n          definedStep: chartConfigures.measure_scale_step_number_right,\n          definedScaleFormat: chartConfigures.measure_right_y_configure\n        }),\n        showAxisTitleFlag: showYTitleFlag,\n        // Y轴标签没有配置的情况下, 默认是显示的\n        measureAxisVisible: chartConfigures.y_axis_label_visible === undefined ? true : chartConfigures.y_axis_label_visible,\n        titleFontSize: theYTitleFontSize,\n        maxLabelWidthPercent: chartConfigures.y_axis_label_max_width_percent,\n        alignZeroFlag: chartConfigures.measure_scale_parallel\n      });\n      if (!yAxisBasicMessage || !yAxisBasicMessage.firstMeasure) return false;\n\n      // 1. 计算是否有标准线及 标准线的宽度\n      let hasMarkerFlag = !hasLegendFlag && chartAxis.curYAxis.length === 1; //  没有图例的情况下[只有一个yAxis时]就有可以有标准线\n      hasMarkerFlag = hasMarkerFlag && !chartConfigures.grid_remove_standard_line; //  是否配置了移除标准线\n      let theMarkerBasicMessage = null;\n      if (hasMarkerFlag) {\n        theMarkerBasicMessage = _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_8__[\"default\"].calcMeasureMarkerMessage({\n          direction: 'vertical',\n          measureAxis: chartAxis.curYAxis,\n          markerFontSize: chartFontSize,\n          drawWidth: svgDrawWidth,\n          drawHeight: svgDrawHeight,\n          scaleFormat: yAxisBasicMessage.firstMeasure.measureAxis && yAxisBasicMessage.firstMeasure.measureAxis.yScaleFormat,\n          getI18nKey: conf.curLanguage\n        });\n        if (!theMarkerBasicMessage || !theMarkerBasicMessage.hasMarkerFlag) hasMarkerFlag = false;\n      }\n      let firstTitleWidth = yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag ? (yAxisBasicMessage.firstMeasure.measureTitleSize || 0) + titleSeparate : 0,\n        firstMeasureWidth = (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.measureTickWidth || 0) + measureSeparate,\n        secondTitleWidth = yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag ? (yAxisBasicMessage.secondMeasure.measureTitleSize || 0) + titleSeparate : 0,\n        secondMeasureWidth = yAxisBasicMessage.secondMeasure ? yAxisBasicMessage.secondMeasure.measureTickWidth + measureSeparate : 0,\n        markerMessageWidth = theMarkerBasicMessage && theMarkerBasicMessage.markerMaxWidth || 0; // 由于markerMessage在后面计算的\n\n      // 画图部分的有效宽度\n      let scaleAttributeWidth = svgDrawWidth - firstMeasureWidth - firstTitleWidth - secondMeasureWidth - secondTitleWidth - markerMessageWidth;\n      let start = parseInt(frameOptions.start),\n        end = 0,\n        steps = parseInt(frameOptions.steps) || 0;\n\n      // 如果没有传入steps，则使用配置值手动计算每页的数量\n      if (!steps) {\n        // 翻页/或初始化\n        // 计算是否有翻页，翻页的pageSize 及 每页的柱宽\n        let minimumColumnWidth = parseFloat(chartConfigures.chart_column_minimum_width) || 5,\n          definedColumnWidth = parseFloat(chartConfigures.chart_column_width);\n        minimumColumnWidth = Math.max(1, minimumColumnWidth);\n        let definedSteps = parseInt(chartConfigures.chart_default_step);\n        // 配置了固定柱宽\n        if (!isNaN(definedColumnWidth)) {\n          steps = Math.floor(scaleAttributeWidth / (definedColumnWidth * legendValueList.length / columnWidthPercent));\n          steps = Math.min(steps, translateData.xLabelDistinct.length);\n          steps = Math.max(steps, 1); //  至少有一个刻度可以画图\n\n          // 如果当前页展示了所有数据，则按照柱子的实际宽度显示；如果有翻页，则按照实际宽度自适应柱宽，固定柱宽值会出现一定的误差\n          if (steps === translateData.xLabelDistinct.length) {\n            scaleAttributeWidth = Math.min(scaleAttributeWidth, steps * (definedColumnWidth * legendValueList.length));\n          }\n        }\n        // 配置了固定分页数\n        else if (!isNaN(definedSteps)) {\n          steps = definedSteps;\n          steps = Math.min(steps, translateData.xLabelDistinct.length);\n        }\n        // 默认情况下使用最小刻度宽计算分页数\n        else {\n          // 使用最小柱宽计算每页的pageSize\n          steps = Math.floor(scaleAttributeWidth / (minimumColumnWidth * (translateData.legendLength || translateData.yLength || 1)));\n        }\n      }\n\n      // 检正start , step , end的值\n      steps = Math.min(steps, translateData.xLabelDistinct.length);\n      steps = Math.max(steps, 1); //  至少有一个刻度可以画图\n\n      // 默认情况下，需要依据x_axis_right_first_flag来判断start的值： 优先画右侧数据,还是优先画左侧数据\n      if (isNaN(start) || start === undefined || start === null) {\n        if (chartConfigures.x_axis_right_first_flag) {\n          // 优先画右侧数据\n          start = translateData.xLabelDistinct.length - steps;\n          start = Math.max(0, start);\n        } else {\n          start = 0;\n        }\n      }\n      end = start + steps;\n      if (end > translateData.xLabelDistinct.length) {\n        end = translateData.xLabelDistinct.length;\n        start = end - steps;\n      }\n      let xLabelDatas = {}; //  按X刻度索引当前的画的所有数值 ， 供MouseOverChartComponent.handleSvgMouseOverEvent使用\n      let theLegendData = translateData.datas;\n      let currentPageLegendData = theLegendData && theLegendData.filter(function (data) {\n        let theMappingObj = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[data.x0];\n        let theIndex = theMappingObj && theMappingObj.index || 0;\n        if (theIndex >= start && theIndex < end) {\n          if (!xLabelDatas[data.x0]) xLabelDatas[data.x0] = [];\n          xLabelDatas[data.x0].push(data);\n          return true;\n        }\n      });\n      const tableData = {\n        // 当前页的所有数据\n        columns: currentPageLegendData.map(d => d.rowData)\n      };\n      const leftYAxisList = chartAxis.curYAxis.filter(function (axis, index) {\n        const theLegendConfig = legendValueList[index];\n        if (!theLegendConfig.show) return false;\n        return axis.direction !== 'right' && theLegendConfig.shape === 'option_legend_shape_type_column';\n      });\n      const rightYAxisList = chartAxis.curYAxis.filter(function (axis, index) {\n        const theLegendConfig = legendValueList[index];\n        if (!theLegendConfig.show) return false;\n        return axis.direction === 'right' && theLegendConfig.shape === 'option_legend_shape_type_column';\n      });\n      if (stackColumn) {\n        // 堆积的情况下， Y轴刻度范围硬取决于堆积完成后的高度\n        const firstLeftYAxisIndex = leftYAxisList[0] && leftYAxisList[0].index;\n        const firstRightYAxisIndex = rightYAxisList[0] && rightYAxisList[0].index;\n        // 每行数据新增2行正负的堆积数据供translateMeasureAxis计算最大最小值。\n        const newColumns = [];\n        for (const row of tableData.columns) {\n          newColumns.push(row);\n          const stackPositiveRow = [];\n          const stackNegativeRow = [];\n          if (firstLeftYAxisIndex !== undefined) {\n            stackPositiveRow[firstLeftYAxisIndex] = 0;\n            stackNegativeRow[firstLeftYAxisIndex] = 0;\n          }\n          if (firstRightYAxisIndex !== undefined) {\n            stackPositiveRow[firstRightYAxisIndex] = 0;\n            stackNegativeRow[firstRightYAxisIndex] = 0;\n          }\n          for (const leftYAxis of leftYAxisList) {\n            const yValue = row[leftYAxis.index];\n            if (yValue > 0) {\n              stackPositiveRow[firstLeftYAxisIndex] += yValue;\n            } else {\n              stackNegativeRow[firstLeftYAxisIndex] += yValue;\n            }\n          }\n          for (const rightYAxis of rightYAxisList) {\n            const yValue = row[rightYAxis.index];\n            if (yValue > 0) {\n              stackPositiveRow[firstRightYAxisIndex] += yValue;\n            } else {\n              stackNegativeRow[firstRightYAxisIndex] += yValue;\n            }\n          }\n          newColumns.push(stackPositiveRow, stackNegativeRow);\n        }\n        tableData.columns = newColumns;\n      }\n\n      // 计算Y轴的基本信息：宽度，刻度值等\n      yAxisBasicMessage = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].calcMeasureAxisBasicMessage({\n        direction: 'vertical',\n        language: systemLanguage,\n        axisFontSize: theYAxisFontSize,\n        drawWidth: svgDrawWidth,\n        drawHeight: svgDrawHeight,\n        firstMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n          return axis.direction !== 'right';\n        }), {\n          axisType: 'normal',\n          useDataFlag: true,\n          tableData: tableData,\n          scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type),\n          min: chartConfigures.measure_scale_min,\n          max: chartConfigures.measure_scale_max,\n          definedMin: chartConfigures.measure_scale_defined_min || 0,\n          definedSeparate: chartConfigures.measure_scale_step,\n          definedStep: chartConfigures.measure_scale_step_number,\n          definedScaleFormat: chartConfigures.measure_left_y_configure\n        }),\n        secondMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n          return axis.direction === 'right';\n        }), {\n          axisType: 'normal',\n          useDataFlag: true,\n          tableData: tableData,\n          scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type_right),\n          min: chartConfigures.measure_scale_min_right,\n          max: chartConfigures.measure_scale_max_right,\n          definedMin: chartConfigures.measure_scale_defined_min_right || 0,\n          definedSeparate: chartConfigures.measure_scale_step_right,\n          definedStep: chartConfigures.measure_scale_step_number_right,\n          definedScaleFormat: chartConfigures.measure_right_y_configure\n        }),\n        showAxisTitleFlag: showYTitleFlag,\n        // Y轴标签没有配置的情况下, 默认是显示的\n        measureAxisVisible: chartConfigures.y_axis_label_visible === undefined ? true : chartConfigures.y_axis_label_visible,\n        titleFontSize: theYTitleFontSize,\n        maxLabelWidthPercent: chartConfigures.y_axis_label_max_width_percent,\n        alignZeroFlag: chartConfigures.measure_scale_parallel\n      });\n      if (showXTitleFlag) {\n        let theSettingXTitleText = chartConfigures.x_axis_title_content,\n          theDefaultXTitleText = [];\n        chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n          theDefaultXTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, xAxis, {\n            hideOperator: hideOperatorFlag\n          }));\n        });\n        let theXTitleSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', \"KKK\", {\n          fontSize: theXTitleFontSize\n        });\n        _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n          svgContainer: containerResult.svgJqDom,\n          direction: 'horizontal',\n          titleText: theSettingXTitleText || theDefaultXTitleText.join(','),\n          //  标题内容\n          titleAlignment: chartConfigures.x_axis_title_alignment || 'center',\n          titleFontSize: theXTitleFontSize,\n          titleFontColor: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontColor,\n          titleFontBold: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontBold,\n          titleFontItalic: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontItalic,\n          translateTop: svgDrawHeight - theXTitleSize.height,\n          translateLeft: firstTitleWidth + firstMeasureWidth,\n          titleHeight: theXTitleSize.height,\n          titleWidth: scaleAttributeWidth,\n          titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? chartAxis.curXAxis : null\n        });\n        attributeTitleHeight = theXTitleSize.height + titleSeparate;\n      } else {\n        // 移除元素\n        svgDom.select('g.title.horizontal-title').remove();\n      }\n\n      // 画X轴刻度\n      let attributeAxis = _pc_assets_js_charts_components_AttributeAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].drawHorizontalAttributeAxis({\n        axisType: translateData.xLabelType,\n        axisTimeType: translateData.xAxisTimeType,\n        svgContainer: containerResult.svgJqDom,\n        drawWidth: svgDrawWidth - firstTitleWidth - secondTitleWidth,\n        drawHeight: svgDrawHeight - attributeTitleHeight,\n        axisFontSize: theXAxisFontSize,\n        animateFlag: animateFlag,\n        axisFontColor: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontColor,\n        axisFontBold: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontBold,\n        axisFontItalic: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontItalic,\n        position: 'bottom',\n        attributeValueList: translateData.xLabelDistinct,\n        attributeValueMap: translateData.xLabelDistinctMapping,\n        start: start,\n        end: end,\n        // X轴标签没有配置的情况下, 默认是显示的\n        attributeAxisVisible: chartConfigures.x_axis_label_visible === undefined ? true : chartConfigures.x_axis_label_visible,\n        hoverTranslateLeft: firstTitleWidth + firstMeasureWidth,\n        hoverTranslateTop: scalePaddingTop,\n        scaleWidth: scaleAttributeWidth,\n        maxLabelHeightPercent: chartConfigures.x_axis_label_max_height_percent,\n        rotate: chartConfigures.x_axis_label_dot_line_rotation_value,\n        labelStepWidth: chartConfigures.x_axis_label_dot_line_space_width\n      });\n      if (!attributeAxis || !attributeAxis.attributeContainer) {\n        console.log('画点X属性轴异常');\n        return false;\n      }\n      if (attributeAxis.attributeContainer) {\n        attributeAxis.attributeContainer.attr('transform', `translate(${firstTitleWidth + firstMeasureWidth}, ${svgDrawHeight - (attributeAxis.maxLabelHeight || 0) - attributeTitleHeight})`);\n      }\n\n      // 画柱形图\n      let theColumnWidth = attributeAxis.rangeBand * columnWidthPercent / (showColumnLegendLength || 1),\n        //  只显示显示的图例的柱子\n        theOutPadding = attributeAxis.rangeBand * (1 - columnWidthPercent);\n\n      // ======= 绘制线条或柱体开始\n\n      // 4. 填充Y轴标题 及 刻度 [ 通过X轴刻度高度确定Y轴比例尺的高度，画Y轴刻度，返回Y轴刻度比例尺 ]\n      let scaleMeasureHeight = svgDrawHeight - (attributeAxis.maxLabelHeight || 0) - attributeTitleHeight - attributeSeparate - scalePaddingTop;\n\n      // 画截取区域\n      let chartClipDefId = _pc_assets_js_charts_components_SvgClipPathComponent__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawClipPath({\n        svgContainer: containerResult.svgJqDom,\n        chartUUID: chartUUID,\n        width: scaleAttributeWidth,\n        height: scaleMeasureHeight + scalePaddingTop,\n        x: firstTitleWidth + firstMeasureWidth,\n        y: 0\n      });\n\n      // 创建需要超出区域截取的容器，该容器上不允许增加transform的属性，会影响clipPath的作用位置\n      const theChartDetailContainer = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].reuseElement({\n        container: svgDom,\n        selector: 'g.chart-detail',\n        elementCreator: () => svgDom.append('g').attr('class', 'chart-detail')\n      }).attr(\"clip-path\", \"url(#\" + chartClipDefId + \")\");\n\n      // 画第一个Y轴标题\n      if (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag) {\n        let theDefaultTitleText = [];\n        let theMeasureAxis = yAxisBasicMessage.firstMeasure.measureAxis;\n        theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n          theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n            hideOperator: hideOperatorFlag\n          }));\n        });\n        let theSettingTitleText = chartConfigures.y_axis_title_content;\n        _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n          verticalTitleClass: 'first-y-title',\n          svgContainer: containerResult.svgJqDom,\n          direction: 'vertical',\n          titleText: theSettingTitleText || theDefaultTitleText.join(','),\n          //  标题内容\n          titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n          titleFontSize: theYTitleFontSize,\n          titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n          titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n          titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n          translateLeft: 0,\n          translateTop: scalePaddingTop,\n          titleHeight: scaleMeasureHeight,\n          titleWidth: yAxisBasicMessage.firstMeasure.measureTitleSize,\n          titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n        });\n      } else {\n        svgDom.select('g.title.vertical-title.first-y-title').remove();\n      }\n      // 画第二个Y轴标题\n      if (yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag) {\n        let theDefaultTitleText = [];\n        let theMeasureAxis = yAxisBasicMessage.secondMeasure.measureAxis;\n        theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n          theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n            hideOperator: hideOperatorFlag\n          }));\n        });\n        let theSettingTitleText = chartConfigures.right_y_axis_title_content;\n        _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n          verticalTitleClass: 'second-y-title',\n          svgContainer: containerResult.svgJqDom,\n          direction: 'vertical',\n          titleText: theSettingTitleText || theDefaultTitleText.join(','),\n          //  标题内容\n          titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n          //  标题内容\n          titleFontSize: theYTitleFontSize,\n          titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n          titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n          titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n          translateLeft: firstMeasureWidth + firstTitleWidth + scaleAttributeWidth + secondMeasureWidth + titleSeparate,\n          translateTop: scalePaddingTop,\n          titleHeight: scaleMeasureHeight,\n          titleWidth: yAxisBasicMessage.secondMeasure.measureTitleSize,\n          titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n        });\n      } else {\n        svgDom.select('g.title.vertical-title.second-y-title').remove();\n      }\n\n      // 画Y轴刻度\n      const measureAxis = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawMeasureAxis({\n        svgContainer: containerResult.svgJqDom,\n        drawWidth: svgDrawWidth,\n        drawHeight: svgDrawHeight,\n        axisFontSize: theYAxisFontSize,\n        axisFontColor: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontColor,\n        axisFontBold: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontBold,\n        axisFontItalic: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontItalic,\n        direction: 'vertical',\n        separate: measureSeparate,\n        scaleHeight: scaleMeasureHeight,\n        scaleLineWidth: scaleAttributeWidth,\n        firstMeasure: yAxisBasicMessage.firstMeasure,\n        secondMeasure: yAxisBasicMessage.secondMeasure,\n        // 默认显示网格线\n        showAxisLineFlag: gridShowAllLine,\n        // 网格线样式\n        strokeLineStyle: chartConfigures.grid_line_style,\n        // 只显示零线\n        showOnlyZeroLineFlag: !!chartConfigures.grid_show_only_zero_line,\n        // 零线样式\n        zeroStrokeLineStyle: chartConfigures.grid_zero_line_style\n      });\n      measureAxis.measureContainer.attr(\"transform\", \"translate( \" + firstTitleWidth + \" , \" + scalePaddingTop + \")\");\n\n      // 画标准线\n      if (hasMarkerFlag && theMarkerBasicMessage) {\n        _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_8__[\"default\"].drawHorizontalMarkerLine({\n          svgContainer: containerResult.svgJqDom,\n          markerTextList: theMarkerBasicMessage.markerTextList,\n          translateLeft: firstTitleWidth + firstMeasureWidth,\n          translateTop: scalePaddingTop,\n          markerFontSize: chartFontSize,\n          maxWidth: theMarkerBasicMessage.markerMaxWidth,\n          lineWidth: scaleAttributeWidth,\n          scaleHeight: scaleMeasureHeight,\n          scaleFunc: measureAxis.firstMeasureScaleFunc,\n          markerLineColor: conf.colors(0)\n        });\n      }\n\n      // 画目标线\n      const existedGoalLine = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(containerResult.svgJqDom).selectAll('g.goal-line');\n      if (!existedGoalLine.empty()) {\n        existedGoalLine.remove();\n      }\n      chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis) {\n        if (_DataFocusMethod.isPureNumber(yAxis.goal)) {\n          // 设置目标值后，需要画目标线\n          if (yAxis.direction !== 'right') {\n            let theScaleFunc = measureAxis.firstMeasureScaleFunc,\n              yScaleFormat = measureAxis.firstMeasure && measureAxis.firstMeasure.yScaleFormat;\n            _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawHorizontalGoalLine({\n              svgContainer: containerResult.svgJqDom,\n              position: \"left\",\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n              lineWidth: scaleAttributeWidth,\n              hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n            });\n          } else {\n            let theScaleFunc = measureAxis.secondMeasureScaleFunc,\n              yScaleFormat = measureAxis.secondMeasure && measureAxis.secondMeasure.yScaleFormat;\n            _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawHorizontalGoalLine({\n              svgContainer: containerResult.svgJqDom,\n              position: \"right\",\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n              lineWidth: scaleAttributeWidth,\n              hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n            });\n          }\n        }\n      });\n      // 画标度[参考]线 及 区域\n      const previousDivisionRange = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(containerResult.svgJqDom).selectAll('g.reference-container');\n      if (!previousDivisionRange.empty()) previousDivisionRange.remove();\n      if (chartConfigures.scale_y_visible && chartConfigures.scale_y_range) {\n        _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawHorizontalDivisionRange({\n          language: systemLanguage,\n          referenceConfigure: chartConfigures.scale_y_range,\n          svgContainer: containerResult.svgJqDom,\n          translateLeft: firstTitleWidth + firstMeasureWidth,\n          translateTop: scalePaddingTop,\n          measureAxis: measureAxis,\n          rangeWidth: scaleAttributeWidth,\n          defaultTitleText: conf.curLanguage(\"option_scale_config_text_default\")\n        });\n      }\n      const translateLeft = firstTitleWidth + firstMeasureWidth;\n      const translateTop = scalePaddingTop;\n      const chartDetail = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(container).select('g.chart-detail');\n      const theLineGroup = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].reuseElement({\n        container: chartDetail,\n        selector: 'g.chartset-line-group',\n        elementCreator: () => chartDetail.append('g').attr('class', 'chartset-line-group')\n      }).attr(\"transform\", \"translate(\" + translateLeft + \" , \" + translateTop + \")\");\n      function pathTween(pathDom, d1, precision) {\n        const path0 = pathDom;\n        const path1 = path0.cloneNode();\n        path1.setAttribute(\"d\", d1);\n        const n0 = path0.getTotalLength();\n        const n1 = path1.getTotalLength();\n\n        // Uniform sampling of distance based on specified precision.\n        const distances = [0];\n        const dt = precision / Math.max(n0, n1);\n        let i = 0;\n        while ((i += dt) < 1) distances.push(i);\n        distances.push(1);\n\n        // Compute point-interpolators at each distance.\n        const points = distances.map(t => {\n          const p0 = path0.getPointAtLength(t * n0);\n          const p1 = path1.getPointAtLength(t * n1);\n          return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].interpolate([p0.x, p0.y], [p1.x, p1.y]);\n        });\n        return t => t < 1 ? \"M\" + points.map(p => p(t)).join(\"L\") : d1;\n      }\n      const updateLines = () => {\n        // 所有Y轴的线条数据\n        const linesInfoInCurrentPage = (chartAxis.curYAxis || []).map((yAxis, yIndex) => ({\n          yAxis,\n          yIndex\n        })).filter(({\n          yAxis,\n          yIndex\n        }) => {\n          // 由于组合图的画图前提是得有多个Y轴，此处的legendValueList一定会有\n          const theLegendConfig = legendValueList[yIndex] || {};\n          if (!theLegendConfig.show) return false;\n          return theLegendConfig.shape === 'option_legend_shape_type_line';\n        }).map(({\n          yAxis,\n          yIndex\n        }) => {\n          const theLegendConfig = legendValueList[yIndex];\n          const lineInfo = _CombinationChartComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].getLineDataSet(currentPageLegendData, {\n            chartDetailContainer: theChartDetailContainer,\n            attributeXAxis: attributeAxis,\n            measureYAxis: measureAxis,\n            curYAxis: chartAxis.curYAxis && chartAxis.curYAxis[yIndex],\n            yIndex: yIndex,\n            yLength: translateData.yLength,\n            legendType: \"YAxis\",\n            legendId: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('yAxis', yAxis.idx),\n            legendValue: yAxis.col_id,\n            legendIndex: yIndex,\n            legendConfig: theLegendConfig,\n            animateFlag: animateFlag\n          });\n          const pointsOfCurLegend = lineInfo.points;\n          const pointPositionAccessor = {\n            x: d => d.ox,\n            y: d => d.oy\n          };\n          const lineGenerator = _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].line().x(pointPositionAccessor.x).y(pointPositionAccessor.y);\n          // 设置线条生成器\n          (() => {\n            const curveGeneratorMap = {\n              'step': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveStep,\n              'step-before': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveStepBefore,\n              'step-after': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveStepAfter,\n              'curve-basis': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveBasis,\n              'curve-natural': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveNatural,\n              'curve-monotone-x': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveMonotoneX,\n              // 两点间基于Y的曲线拥有单调性，极值只会出现在起始点或结束点\n              'curve-monotone-y': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveMonotoneY,\n              // 两点间基于X的曲线拥有单调性，极值只会出现在起始点或结束点\n              'curve-bump-x': _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].curveBumpX\n            };\n            if (curveGeneratorMap[lineStyle]) {\n              lineGenerator.curve(curveGeneratorMap[lineStyle]);\n            }\n          })();\n\n          // 线条生成器\n          const pathData = lineGenerator(pointsOfCurLegend);\n          let colorOfCurLegend = theLegendConfig.color; // 当前图例的颜色\n          const currentLegendId = frameOptions.currentLegend && frameOptions.currentLegend.id;\n          if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== lineInfo.legendId) {\n            colorOfCurLegend = '#eeeeee';\n          }\n          return {\n            yAxis,\n            yIndex,\n            lineInfo,\n            pathData,\n            pointsOfCurLegend,\n            colorOfCurLegend,\n            lineWidth,\n            lineDashedFlag,\n            showPoint\n          };\n        });\n        theLineGroup.selectAll('path').data(linesInfoInCurrentPage, function (d) {\n          return d.yIndex;\n        }).join(enter => {\n          const pathSelection = enter.append('path').attr('class', 'chartset-line-path').attr(\"style\", \"cursor:pointer;\").attr('d', d => d.pathData).attr('stroke', d => d.colorOfCurLegend).attr('stroke-width', d => d.lineWidth).attr('stroke-dasharray', d => d.lineDashedFlag ? '5 0 5' : '').attr('fill', 'none').attr('opacity', '1').attr('legendId', d => {\n            const legendConfig = legendValueList[d.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          });\n          pathSelection.each(function () {\n            // 每条线条都有一个自己的clip-path\n            const uuid = _DataFocusMethod.getUUID();\n            const clipPathId = `line-clip-path-${uuid}`;\n            const defsId = `defs-${uuid}`;\n            chartDetail.append('defs').attr('id', defsId).append('clipPath').attr('id', clipPathId).append('path').attr('d', () => {\n              return `M${translateLeft} 0L0 0L0 ${scaleMeasureHeight}L0 ${scaleMeasureHeight}Z`;\n            }).transition().duration(duration.pathEnter).ease(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].easeLinear).attr('d', () => {\n              return `M${translateLeft} 0L${translateLeft + scaleAttributeWidth} 0L${translateLeft + scaleAttributeWidth} ${scaleMeasureHeight}L0 ${scaleMeasureHeight}Z`;\n            }).on('end', function () {\n              _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(`#${defsId}`).remove();\n            });\n\n            // 为线条设置 clip-path\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('clip-path', `url(#${clipPathId})`);\n          });\n          return pathSelection;\n        }, update => {\n          return update.call(update => update.attr('legendId', d => {\n            const legendConfig = legendValueList[d.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }).transition().duration(duration.update).attr('d', d => d.pathData).attr('stroke', d => d.colorOfCurLegend).attr('stroke-width', d => d.lineWidth).attr('stroke-dasharray', d => d.lineDashedFlag ? '5 0 5' : ''));\n        }, exit => exit.transition().duration(duration.exit).attr('opacity', '0').remove());\n        const dotsGroup = theLineGroup.selectAll('g.dots').data(linesInfoInCurrentPage, d => d.yIndex).join(enter => enter.append('g').attr('class', 'dots'), update => update, exit => exit.transition().duration(duration.exit).remove());\n        dotsGroup.each(function (parentData, parentIndex) {\n          function generateSymbolPath(symbolType, size) {\n            if (symbolType === 'three') {\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolTriangle, size)();\n            }\n            if (symbolType === 'four') {\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolSquare, size)();\n            }\n            if (symbolType === 'rect') {\n              // 自定义symbol type\n              const rectSymbol = {\n                draw(context, size) {\n                  const w = Math.sqrt(size);\n                  const h = w * 0.5;\n                  const x = -w / 2;\n                  const y = -h / 2;\n                  context.rect(x, y, w, h);\n                }\n              };\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(rectSymbol, size)();\n            }\n            if (symbolType === 'five') {\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolStar, size)();\n            }\n            if (symbolType === 'diamond') {\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolDiamond, size)();\n            }\n            if (symbolType === 'add') {\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolPlus, size)();\n            }\n            if (symbolType === 'cross') {\n              return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolCross, size)();\n            }\n            // circle\n            return _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbol(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].symbolCircle, size)();\n          }\n          let shape = legendShapeType;\n          if (legendShapeType === 'loop') {\n            shape = ['circle', 'three', 'four', 'rect', 'five', 'diamond'][parentIndex % 6];\n          }\n          _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).selectAll('.line-symbol')\n          // 嵌套数据绑定，通常用函数。函数入参是父元素的 data，\n          .data(parentD => parentD.pointsOfCurLegend).join(enter => enter.append('path').classed('circles', true).classed('line-symbol', true).classed('cursor-pointer', true).attr('transform', function (point) {\n            return `translate(${point.ox} ${point.oy})`;\n          }).attr('d', function (point, index) {\n            return generateSymbolPath(shape, Math.max(Math.PI, circleRadius ** 2 * Math.PI));\n          }).attr('legendId', d => {\n            const legendConfig = legendValueList[parentData.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }).attr(\"alarm-status\", function (d) {\n            return d.isAlarmFlag;\n          }).attr('fill', parentData.colorOfCurLegend).attr('opacity', 0).on('mouseenter', function () {\n            _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('opacity', 1).attr('stroke-width', 3).attr('stroke', _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('fill'));\n          }).on(\"mousemove\", function (event, d) {\n            _DataFocusMethod.stopEventDefault(event);\n            let theTranslateSuspendText;\n            const theLegendIndex = parentData.yIndex;\n            const theLegendConfig = legendValueList[theLegendIndex];\n            if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n              let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[d.x0];\n              let theSuspendTextConfig = chartConfigures.suspend_text_regex || '';\n              if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_SERIES_NAME %_BR %_NAME %_BR  %_VALUE_NAME : %_VALUE\";\n              theTranslateSuspendText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n                xLabel: d.x0,\n                xLabelIndex: theXLabelMapping && theXLabelMapping.index,\n                xLabelTotal: theXLabelMapping && theXLabelMapping.total,\n                xLabelNumber: theXLabelMapping && theXLabelMapping.number,\n                yValue: d['y' + parentData.yIndex],\n                yAxis: parentData.yAxis,\n                legend: theLegendConfig.legend,\n                legendIndex: theLegendConfig.index,\n                legendTotal: theLegendData['legendTotal0'],\n                rowData: d.rowData,\n                headers: options.datas && options.datas.headers\n              });\n            }\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].positionChartPrompt(event, theTranslateSuspendText || d.x0 + ':' + d['y' + parentData.yIndex]);\n            if (theLegendConfig && theLegendConfig.show) {\n              _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect\").attr(\"class\", \"fill-grey\");\n              _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect[legendId='\" + theLegendConfig.id + \"']\").attr(\"class\", \"\");\n              _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-label text\").attr(\"class\", \"fill-grey\");\n              _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-label text[legendId='\" + theLegendConfig.id + \"']\").attr(\"class\", \"\");\n              if (containerResult.legendContainer) {\n                let theLegendDom = $(containerResult.legendContainer).find(\".legend-item[data-legend-id='\" + theLegendConfig.id + \"']\");\n                theLegendDom.find(\"svg\").removeClass(\"fill-grey\");\n                theLegendDom.siblings().find(\"svg\").addClass(\"fill-grey\");\n              }\n            }\n          }).on(\"mouseout\", function (event, d) {\n            let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n            _DataFocusMethod.stopEventDefault(event);\n            theDom.attr(\"stroke\", \"none\").attr(\"stroke-width\", \"\").attr('opacity', showPoint ? 1 : 0).style(\"transition\", \"\");\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n            _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .fill-grey\").attr(\"class\", \"\");\n            if (containerResult.legendContainer) $(containerResult.legendContainer).find(\".legend-item svg\").removeClass(\"fill-grey\");\n          }).on(\"mousedown\", function (event, d) {\n            // // 移动端的mousedown事件不执行\n            if (allowMousedownFlag) {\n              let theDataColumnIdx = [];\n              chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n                theDataColumnIdx.push(xAxis.idx);\n              });\n              if (chartAxis && chartAxis.curLegend) {\n                theDataColumnIdx.push(chartAxis.curLegend.idx);\n              }\n              typeof options.mousedownCallback === 'function' && options.mousedownCallback.call(this, event, {\n                dataColumnIndex: theDataColumnIdx,\n                dataRowIndex: d.rowIndex,\n                theHideCategoryValue: d.x0\n              });\n            }\n          }).transition().delay((d, i) => {\n            return animateFlag ? 1000 * (i / parentData.pointsOfCurLegend.length) : 0;\n          }).ease(_pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].easeBounceOut).duration(duration.dotEnter).attr('opacity', () => showPoint ? 1 : 0), update => update.attr('legendId', d => {\n            const legendConfig = legendValueList[parentData.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }).transition().duration(duration.update).attr('transform', function (point) {\n            return `translate(${point.ox} ${point.oy})`;\n          }).attr('d', function (point, index) {\n            return generateSymbolPath(shape, Math.max(Math.PI, circleRadius ** 2 * Math.PI));\n          }).attr('fill', parentData.colorOfCurLegend).attr('opacity', () => showPoint ? 1 : 0), exit => exit.remove());\n        });\n      };\n      const updateColumns = () => {\n        // 所有Y轴的柱体信息\n        const columnsInfoInCurrentPage = (chartAxis.curYAxis || []).map((yAxis, yIndex) => ({\n          yAxis,\n          yIndex\n        })).filter(({\n          yAxis,\n          yIndex\n        }) => {\n          const theLegendConfig = legendValueList[yIndex];\n          if (!theLegendConfig.show) return false;\n          return theLegendConfig.shape === 'option_legend_shape_type_column';\n        }).map(({\n          yAxis,\n          yIndex\n        }) => {\n          // 1. 先根据图例区分大类  2. 再根据X轴刻度区分同一图例下的多个柱体\n          return {\n            yAxis,\n            // yAxis.index 是在header中的索引，\n            yIndex,\n            // 当前Y轴在所有Y轴中的索引\n            // 当前页的所有行数据\n            rows: currentPageLegendData\n          };\n        });\n        if (!stackColumn) {\n          //  只显示显示的图例的柱子\n          theColumnWidth = attributeAxis.rangeBand * columnWidthPercent / (showColumnLegendLength || 1);\n        } else {\n          // 堆积展示柱体。\n          if (leftYAxisList.length && rightYAxisList.length) {\n            // 如果分左右轴，则同一刻度下有两列堆积柱体\n            theColumnWidth = attributeAxis.rangeBand * columnWidthPercent / 2;\n          } else {\n            // 只有左Y轴\n            theColumnWidth = attributeAxis.rangeBand * columnWidthPercent / 1;\n          }\n        }\n        theOutPadding = attributeAxis.rangeBand * (1 - columnWidthPercent);\n\n        // 每个 .chartset 代表一组图例\n        const legendGroups = chartDetail.selectAll('g.chartset').data(columnsInfoInCurrentPage, d => d.yIndex).join(enter => {\n          return enter.append('g').attr(\"class\", \"chartset\").attr(\"opacity\", \"1\").attr(\"data-y-index\", d => d.yIndex).attr(\"transform\", \"translate(\" + translateLeft + \" , \" + translateTop + \")\").lower();\n        }, update => update, exit => exit.transition().duration(duration.exit).attr('opacity', '0').remove());\n        measureAxis.firstMeasureScaleFunc && measureAxis.firstMeasureScaleFunc.range([0, scaleMeasureHeight]);\n        measureAxis.secondMeasureScaleFunc && measureAxis.secondMeasureScaleFunc.range([0, scaleMeasureHeight]);\n\n        // rect开始渐变前的状态\n        function setColumnRectBeforeTransition(rect, parentData, parentIndex) {\n          rect.attr(\"x\", 0).attr(\"y\", function () {\n            const theScaleFunc = parentData.yAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc;\n            return -theScaleFunc(0);\n          }).attr(\"height\", 0).attr('opacity', '0.8');\n        }\n\n        // 为柱体Rect设置相关的样式\n        function setColumnRect(rect, parentData, parentIndex) {\n          // rect 偏移当前刻度下图例的宽度\n          rect.attr('legendId', () => {\n            const theLegendIndex = parentData.yIndex;\n            const legendConfig = legendValueList[theLegendIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", parentData.yAxis.col_id);\n          }).attr(\"transform\", () => {\n            if (!stackColumn) {\n              return \"translate(\" + (parentIndex * theColumnWidth + theOutPadding / 2) + \", 0)\";\n            } else {\n              // 堆积的情况下，Rect只根据左右Y轴进行水平偏移\n              const yAxis = parentData.yAxis;\n              const xOffset = yAxis.direction !== 'right' ? 0 : theColumnWidth;\n              return `translate(${xOffset + theOutPadding / 2}, 0)`;\n            }\n          }).attr(\"stroke\", \"none\").attr(\"stroke-width\", 0).attr('opacity', '1').attr(\"alarm-status\", function (d) {\n            return d['alarm' + parentData.yIndex];\n          }).attr(\"fill\", function (d, i) {\n            const theYIndex = parentData.yIndex;\n            const theLegendIndex = parentData.yIndex;\n            const colorFormats = parentData.yAxis.header && parentData.yAxis.header.colorFormattings;\n            const getColorFunc = colorFunc;\n            const legendConfig = legendValueList[theLegendIndex];\n            let theDefaultColor, theColumnColor;\n            // 柱子颜色规则使用的颜色优先级最高\n            if (_DataFocusMethod.isPureNumber(d['y' + theYIndex]) && colorFormats && colorFormats.length > 0) {\n              theColumnColor = _DataFocusMethod.calcTheColor(d['y' + theYIndex], colorFormats, {\n                rowData: d.rowData\n              });\n            }\n            if (!theDefaultColor && getColorFunc) theDefaultColor = getColorFunc(theLegendIndex);\n            return theColumnColor || legendConfig && legendConfig.color || theDefaultColor;\n          }).attr(\"width\", theColumnWidth).attr(\"height\", function (d) {\n            let curd = d['y' + parentData.yIndex];\n            if (!_DataFocusMethod.isPureNumber(curd)) return;\n            const theScaleFunc = parentData.yAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc;\n            const theScaleMeasure = parentData.yAxis.direction !== 'right' ? measureAxis.firstMeasure : measureAxis.secondMeasure;\n            if (curd > 0) {\n              return theScaleFunc(curd) - theScaleFunc(0);\n            } else {\n              let theTickScale = theScaleMeasure.measureTickScale;\n              return theScaleFunc(theTickScale.min - curd);\n            }\n          }).attr(\"x\", 0).attr(\"y\", function (d) {\n            let curd = d['y' + parentData.yIndex];\n            if (!_DataFocusMethod.isPureNumber(curd)) return;\n\n            // 计算当前x刻度下，其他柱体已经堆积的高度\n            let prevStackHeight = 0;\n            if (stackColumn) {\n              prevStackHeight = _CombinationChartComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].calculatePrevStackHeight({\n                currentRow: d,\n                columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n                yIndex: parentData.yIndex,\n                // Y在所有Y轴中的索引\n                columnLegendIndex: parentIndex,\n                yAxis: parentData.yAxis,\n                measureAxis: measureAxis\n              });\n            }\n            const theScaleFunc = parentData.yAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc;\n            if (curd > 0) {\n              return -theScaleFunc(curd) - prevStackHeight;\n            } else {\n              return -theScaleFunc(0) + prevStackHeight;\n            }\n          });\n        }\n\n        // 使用 each 可同时访问父元素的数据和子元素的数据。\n        legendGroups.each(function (parentData, parentIndex) {\n          // chartset-columns 的横坐标偏移X刻度的宽度\n          _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).selectAll('g.chartset-columns')\n          // 嵌套数据绑定，通常用函数。函数入参是父元素的 data，\n          .data(parentD => parentD.rows, function (d, i) {\n            // 如果是翻页引起的重绘，则基于当前索引进行动画\n            if (frameOptions.type === 'page') return i;\n            // 如果是zoom, select 或其他操作引起的重绘，则基于X刻度进行动画\n            return d['x0'];\n          }).join(enter => {\n            return enter.append('g').attr('class', 'chartset-columns').attr(\"style\", \"cursor:pointer;\").attr(\"xLabel\", d => d['x0']).attr(\"transform\", function (d) {\n              return 'translate(' + attributeAxis.scale(d['x0']) + ',' + scaleMeasureHeight + ')';\n            }).append('rect').call(setColumnRect, parentData, parentIndex).call(setColumnRectBeforeTransition, parentData, parentIndex).on('mouseenter', function () {\n              _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('stroke-width', 3).attr('stroke', _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this).attr('fill'));\n            }).on(\"mousemove\", function (event, d) {\n              _DataFocusMethod.stopEventDefault(event);\n              let theTranslateSuspendText;\n              const theLegendIndex = parentData.yIndex;\n              const theLegendConfig = legendValueList[theLegendIndex];\n              if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n                let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[d.x0];\n                let theSuspendTextConfig = chartConfigures.suspend_text_regex || '';\n                if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_SERIES_NAME %_BR %_NAME %_BR  %_VALUE_NAME : %_VALUE\";\n                theTranslateSuspendText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n                  xLabel: d.x0,\n                  xLabelIndex: theXLabelMapping && theXLabelMapping.index,\n                  xLabelTotal: theXLabelMapping && theXLabelMapping.total,\n                  xLabelNumber: theXLabelMapping && theXLabelMapping.number,\n                  yValue: d['y' + parentData.yIndex],\n                  yAxis: parentData.yAxis,\n                  legend: theLegendConfig.legend,\n                  legendIndex: theLegendConfig.index,\n                  legendTotal: theLegendData['legendTotal0'],\n                  rowData: d.rowData,\n                  headers: options.datas && options.datas.headers\n                });\n              }\n              _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].positionChartPrompt(event, theTranslateSuspendText || d.x0 + ':' + d['y' + parentData.yIndex]);\n              if (theLegendConfig && theLegendConfig.show) {\n                _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect\").attr(\"class\", \"fill-grey\");\n                _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-columns rect[legendId='\" + theLegendConfig.id + \"']\").attr(\"class\", \"\");\n                _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-label text\").attr(\"class\", \"fill-grey\");\n                _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .chartset-label text[legendId='\" + theLegendConfig.id + \"']\").attr(\"class\", \"\");\n                if (containerResult.legendContainer) {\n                  let theLegendDom = $(containerResult.legendContainer).find(\".legend-item[data-legend-id='\" + theLegendConfig.id + \"']\");\n                  theLegendDom.find(\"svg\").removeClass(\"fill-grey\");\n                  theLegendDom.siblings().find(\"svg\").addClass(\"fill-grey\");\n                }\n              }\n            }).on(\"mouseout\", function (event, d) {\n              let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n              _DataFocusMethod.stopEventDefault(event);\n              theDom.attr(\"stroke\", \"none\").attr(\"stroke-width\", \"\").style(\"transition\", \"\");\n              _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n              _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).selectAll(\".chart-detail .fill-grey\").attr(\"class\", \"\");\n              if (containerResult.legendContainer) $(containerResult.legendContainer).find(\".legend-item svg\").removeClass(\"fill-grey\");\n            }).on(\"mousedown\", function (event, d) {\n              // // 移动端的mousedown事件不执行\n              if (allowMousedownFlag) {\n                let theDataColumnIdx = [];\n                chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n                  theDataColumnIdx.push(xAxis.idx);\n                });\n                if (chartAxis && chartAxis.curLegend) {\n                  theDataColumnIdx.push(chartAxis.curLegend.idx);\n                }\n                typeof options.mousedownCallback === 'function' && options.mousedownCallback.call(this, event, {\n                  dataColumnIndex: theDataColumnIdx,\n                  dataRowIndex: d.rowIndex,\n                  theHideCategoryValue: d.x0\n                });\n              }\n            }).transition('column-position').duration(duration.columnEnter).call(setColumnRect, parentData, parentIndex);\n          }, update => {\n            update.attr(\"xLabel\", d => d['x0'] + \"\").transition('sssaaa').duration(duration.update).attr(\"transform\", function (d) {\n              return 'translate(' + attributeAxis.scale(d['x0']) + ',' + scaleMeasureHeight + ')';\n            });\n            update.select('rect').transition('column-position').duration(duration.update).attr(\"transform\", \"translate(\" + (parentIndex * theColumnWidth + theOutPadding / 2) + \", 0)\").call(setColumnRect, parentData, parentIndex);\n          }, exit => {\n            exit.select('rect').transition().duration(duration.exit).attr(\"y\", function () {\n              const theScaleFunc = parentData.yAxis.direction !== 'right' ? measureAxis.firstMeasureScaleFunc : measureAxis.secondMeasureScaleFunc;\n              return -theScaleFunc(0);\n            }).attr(\"height\", 0);\n            exit.remove();\n          });\n        });\n\n        // 计算完柱子后恢复比例尺\n        measureAxis.firstMeasureScaleFunc && measureAxis.firstMeasureScaleFunc.range([scaleMeasureHeight, 0]);\n        measureAxis.secondMeasureScaleFunc && measureAxis.secondMeasureScaleFunc.range([scaleMeasureHeight, 0]);\n      };\n      updateLines();\n      updateColumns();\n\n      // 把所有线条移到顶层\n      theChartDetailContainer.selectAll('.chartset-line-group').each(function () {\n        this.parentNode.appendChild(this);\n      });\n      // ======= 绘制线条或柱体结束\n\n      // ======= 绘制数据标签[ 为了放置标签不会被柱形图挡住，所以统一画所有标签 ] ===========================\n      (() => {\n        let existedLabelArray = [];\n\n        // 按Y轴画多组数据标签\n        (() => {\n          let theLegendData = translateData.datas;\n          let currentPageLegendData = theLegendData && theLegendData.filter(function (data) {\n            let theMappingObj = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[data.x0];\n            let theIndex = theMappingObj && theMappingObj.index || 0;\n            return theIndex >= start && theIndex < end;\n          });\n\n          // 线条中需要画图的文字标签\n          const linesInfoInCurrentPage = (chartAxis.curYAxis || []).map((yAxis, yIndex) => ({\n            yAxis,\n            yIndex\n          })).filter(({\n            yAxis,\n            yIndex\n          }) => {\n            const theLegendConfig = legendValueList[yIndex];\n            if (!theLegendConfig.show) return false;\n            return theLegendConfig.shape === 'option_legend_shape_type_line' && showLabelFlag;\n          }).map(({\n            yAxis,\n            yIndex\n          }) => {\n            const theLegendConfig = legendValueList[yIndex];\n            return {\n              yAxis,\n              yIndex,\n              theLegendConfig\n            };\n          });\n          const lineLabelContainers = theChartDetailContainer.selectAll('g.chartset-label-line').data(linesInfoInCurrentPage).join(enter => enter.append('g').attr('class', 'chartset-label-line').attr(\"transform\", \"translate(\" + translateLeft + \" , \" + translateTop + \")\").attr('legendId', function (d) {\n            const legendConfig = legendValueList[d.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }), update => update.attr(\"transform\", \"translate(\" + translateLeft + \" , \" + translateTop + \")\").attr('legendId', function (d) {\n            const legendConfig = legendValueList[d.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }).raise(), exit => exit.remove());\n          lineLabelContainers.each(function (parentData) {\n            const {\n              yAxis,\n              yIndex,\n              theLegendConfig\n            } = parentData;\n            _CombinationChartComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalLineLabelSet(currentPageLegendData, {\n              chartUUID: chartUUID,\n              chartDetailContainer: _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this),\n              duration: duration,\n              attributeAxis: attributeAxis,\n              measureAxis: measureAxis,\n              start: start,\n              end: end,\n              curYAxis: yAxis,\n              yIndex: yIndex,\n              yLength: translateData.yLength,\n              legendType: \"YAxis\",\n              legendValue: yAxis.col_id,\n              legendIndex: yIndex,\n              legendConfig: theLegendConfig,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              scaleMeasureHeight: scaleMeasureHeight,\n              scaleAttributeWidth: scaleAttributeWidth,\n              columnWidth: theColumnWidth,\n              outPadding: theOutPadding,\n              animateFlag: animateFlag,\n              // 标签字体大小\n              labelFontSize: labelFontSize,\n              labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n              labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n              labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n              // 标签位置\n              labelPosition: labelPosition,\n              // 旋转方向\n              labelRotation: labelRotation,\n              // 显示的集合\n              labelVisibleMap: labelVisibleMap,\n              // 标签是否允许重复\n              labelAllowOverlap: allowOverlap,\n              // 已经画了的标签信息数组\n              drewLabelArray: existedLabelArray || [],\n              // 生成数据标签的具体值的方法\n              generateLabelTextFunc: function (d) {\n                if (!d) return false;\n                if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n                  let theLabelTextConfig = chartConfigures.label_text_regex || '';\n                  if (!theLabelTextConfig.trim()) theLabelTextConfig = \"%_VALUE\";\n                  let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[d.x0];\n                  return self.chartConfigureAdvanced.translateMacro(theLabelTextConfig, {\n                    type: 'label',\n                    xLabel: d.x0,\n                    xLabelIndex: theXLabelMapping && theXLabelMapping.index,\n                    xLabelTotal: theXLabelMapping && theXLabelMapping.total,\n                    xLabelNumber: theXLabelMapping && theXLabelMapping.number,\n                    yValue: d['y' + yIndex],\n                    yAxis: yAxis,\n                    legend: null,\n                    legendIndex: yIndex,\n                    legendTotal: theLegendData['legendTotal' + yIndex],\n                    rowData: d.rowData,\n                    headers: options.datas && options.datas.headers\n                  });\n                }\n                return _DataFocusMethod.formatData(d['y' + yIndex], yAxis);\n              }\n            });\n          });\n\n          // 柱体的数据标签\n          const columnsInfoInCurrentPage = (chartAxis.curYAxis || []).map((yAxis, yIndex) => ({\n            yAxis,\n            yIndex\n          })).filter(({\n            yAxis,\n            yIndex\n          }) => {\n            const theLegendConfig = legendValueList[yIndex];\n            if (!theLegendConfig.show) return false;\n            return theLegendConfig.shape === 'option_legend_shape_type_column' && showLabelFlag;\n          }).map(({\n            yAxis,\n            yIndex\n          }) => {\n            // 1. 先根据图例区分大类  2. 再根据X轴刻度区分同一图例下的多个柱体\n\n            return {\n              yAxis,\n              yIndex,\n              // 当前页的所有行数据\n              rows: currentPageLegendData\n            };\n          });\n          const columnLabelContainers = theChartDetailContainer.selectAll('g.chartset-label-column').data(columnsInfoInCurrentPage).join(enter => enter.append('g').attr('class', 'chartset-label-column').attr(\"transform\", \"translate(\" + translateLeft + \" , \" + translateTop + \")\").attr('legendId', function (d) {\n            const legendConfig = legendValueList[d.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }), update => update.attr(\"transform\", \"translate(\" + translateLeft + \" , \" + translateTop + \")\").attr('legendId', function (d) {\n            const legendConfig = legendValueList[d.yIndex];\n            return legendConfig && legendConfig.id || _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", d.yAxis.col_id);\n          }).raise(), exit => exit.remove());\n          columnLabelContainers.each(function (parentData, parentIndex) {\n            const {\n              yAxis,\n              yIndex,\n              theLegendConfig\n            } = parentData;\n            _CombinationChartComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalColumnLabelSet(currentPageLegendData, {\n              chartDetailContainer: _pc_assets_js_d3v7Export__WEBPACK_IMPORTED_MODULE_16__[\"default\"].select(this),\n              attributeAxis: attributeAxis,\n              measureAxis: measureAxis,\n              start: start,\n              end: end,\n              duration: duration,\n              stackColumn: stackColumn,\n              // 是否堆积\n              columnsInfoInCurrentPage: columnsInfoInCurrentPage,\n              // 计算堆积高度需要\n\n              curYAxis: yAxis,\n              yIndex: yIndex,\n              yLength: translateData.yLength,\n              columnIndex: parentIndex,\n              // 当前柱体在当前刻度下的横向偏移\n              legendType: \"YAxis\",\n              legendValue: yAxis.col_id,\n              legendIndex: yIndex,\n              legendConfig: theLegendConfig,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              scaleMeasureHeight: scaleMeasureHeight,\n              scaleAttributeWidth: scaleAttributeWidth,\n              columnWidth: theColumnWidth,\n              outPadding: theOutPadding,\n              animateFlag: animateFlag,\n              // 标签字体大小\n              labelFontSize: labelFontSize,\n              labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n              labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n              labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n              // 标签位置\n              labelPosition: labelPosition,\n              // 旋转方向\n              labelRotation: labelRotation,\n              // 显示的集合\n              labelVisibleMap: labelVisibleMap,\n              // 标签是否允许重复\n              labelAllowOverlap: allowOverlap,\n              // 已经画了的标签信息数组\n              drewLabelArray: existedLabelArray || [],\n              // 生成数据标签的具体值的方法\n              generateLabelTextFunc: function (d) {\n                if (!d) return false;\n                if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n                  let theLabelTextConfig = chartConfigures.label_text_regex || '';\n                  if (!theLabelTextConfig.trim()) theLabelTextConfig = \"%_VALUE\";\n                  let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[d.x0];\n                  return self.chartConfigureAdvanced.translateMacro(theLabelTextConfig, {\n                    type: 'label',\n                    xLabel: d.x0,\n                    xLabelIndex: theXLabelMapping && theXLabelMapping.index,\n                    xLabelTotal: theXLabelMapping && theXLabelMapping.total,\n                    xLabelNumber: theXLabelMapping && theXLabelMapping.number,\n                    yValue: d['y' + yIndex],\n                    yAxis: yAxis,\n                    legend: null,\n                    legendIndex: yIndex,\n                    legendTotal: theLegendData['legendTotal' + yIndex],\n                    rowData: d.rowData,\n                    headers: options.datas && options.datas.headers\n                  });\n                }\n                return _DataFocusMethod.formatData(d['y' + yIndex], yAxis);\n              }\n            });\n          });\n        })();\n      })();\n\n      // 画翻页的元素 [ 翻页也是临时的，不保存在配置中的 ]\n      _pc_assets_js_charts_components_PaginationChartComponent__WEBPACK_IMPORTED_MODULE_12__[\"default\"].drawHorizontalPagination({\n        chartContainer: containerResult.svgContainer,\n        translateLeft: firstTitleWidth,\n        translateTop: scalePaddingTop,\n        height: scaleMeasureHeight,\n        width: scaleAttributeWidth + firstMeasureWidth + secondMeasureWidth + markerMessageWidth,\n        start: start,\n        pageSize: steps,\n        totalNumber: translateData.xLabelDistinct.length,\n        pagingFunc: drawOneFrame\n      });\n      // 绑定缩放的事件 [ 缩放事件都是临时的，不保存在配置中的 ]\n      _pc_assets_js_charts_components_ZoomChartComponent__WEBPACK_IMPORTED_MODULE_13__[\"default\"].zoomColumnChart({\n        svgContainer: containerResult.svgJqDom,\n        start: start,\n        steps: steps,\n        zoomRelativeToMouse: true,\n        zoomingFunc: drawOneFrame\n      });\n      // 区域选择事件\n      _pc_assets_js_charts_components_SelectChartComponent__WEBPACK_IMPORTED_MODULE_14__[\"default\"].selectHorizontalSvgColumnChart({\n        svgContainer: containerResult.svgContainer,\n        translateLeft: firstTitleWidth + firstMeasureWidth,\n        translateTop: scalePaddingTop,\n        width: scaleAttributeWidth,\n        height: scaleMeasureHeight,\n        rangeBand: attributeAxis.rangeBand,\n        prevStart: start,\n        prevSteps: steps,\n        selectFunc: drawOneFrame\n      });\n\n      // 鼠标移入事件\n      // 图形区域移入，显示每个刻度的固定的数据信息 及 阴影\n      let prevXLabelIndex = -1,\n        theMouseoverHtml,\n        showMousemoveTimer;\n      _pc_assets_js_charts_components_MouseOverChartComponent__WEBPACK_IMPORTED_MODULE_15__[\"default\"].handleSvgMouseOverEvent({\n        svgContainer: containerResult.svgJqDom,\n        direction: \"horizontal\",\n        width: scaleAttributeWidth,\n        height: scaleMeasureHeight,\n        left: firstTitleWidth + firstMeasureWidth,\n        top: scalePaddingTop,\n        animateFlag: animateFlag,\n        prevStart: start,\n        hoverWidth: attributeAxis.rangeBand,\n        hoverHeight: scaleMeasureHeight,\n        mousemoveCallback: function (options) {\n          options = options || {};\n          let theXLabelIndex = parseInt(options.xLabelIndex);\n          if (!isNaN(theXLabelIndex) || !options.event) {\n            // 显示当前X刻度的数据信息\n            if (prevXLabelIndex !== theXLabelIndex) {\n              prevXLabelIndex = theXLabelIndex;\n\n              // 显示X刻度 及 各个图例的颜色，图例名称 及 数值\n              let theXLabel = translateData.xLabelDistinct && translateData.xLabelDistinct[theXLabelIndex],\n                theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[theXLabel],\n                theXLabelData = xLabelDatas && xLabelDatas[theXLabel];\n              theMouseoverHtml = (theXLabelMapping && theXLabelMapping.text || theXLabel) + '<br/>';\n              theXLabelData && theXLabelData.forEach(function (data) {\n                if (data.legend !== undefined) {\n                  if (!hasLegendFlag && colorAssignedToScaleFlag) {\n                    let theXLabelColor = theXLabelColorList && theXLabelColorList.find(function (theLegend) {\n                      return theLegend.legend === theXLabel;\n                    });\n                    if (theXLabelColor) {\n                      theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theXLabelColor.color + ';margin-right:2px;\"></span>';\n                    }\n                  } else {\n                    let theLegendColor = legendValueList && legendValueList.find(function (theLegend) {\n                      return theLegend.legend === data.legend;\n                    });\n                    if (theLegendColor) {\n                      theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theLegendColor.color + ';margin-right:2px;\"></span>';\n                    }\n                  }\n                  theMouseoverHtml += data.legend + ':' + _DataFocusMethod.formatData(data.y0, chartAxis.curYAxis && chartAxis.curYAxis[0]);\n                  theMouseoverHtml += '<br />';\n                } else {\n                  chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis, index) {\n                    if (!hasLegendFlag && colorAssignedToScaleFlag) {\n                      let theXLabelColor = theXLabelColorList && theXLabelColorList.find(function (theLegend) {\n                        return theLegend.legend === theXLabel;\n                      });\n                      if (theXLabelColor) {\n                        theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theXLabelColor.color + ';margin-right:2px;\"></span>';\n                      }\n                    } else {\n                      let theLegendColor = legendValueList && legendValueList.find(function (theLegend) {\n                        return theLegend.index === index;\n                      });\n                      if (theLegendColor) {\n                        theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theLegendColor.color + ';margin-right:2px;\"></span>';\n                      }\n                    }\n                    theMouseoverHtml += _DataFocusMethod.getDisplayOperateColumn(conf.curLanguage, yAxis, {\n                      hideOperator: !conf.aggregationFlag\n                    }) + ':' + _DataFocusMethod.formatData(data['y' + index], yAxis);\n                    theMouseoverHtml += '<br />';\n                  });\n                }\n              });\n            }\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].positionChartPrompt(options.event, theMouseoverHtml);\n          } else {\n            prevXLabelIndex = -1;\n            theMouseoverHtml = '';\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n            if (showMousemoveTimer) clearTimeout(showMousemoveTimer);\n          }\n        },\n        mouseoutCallback: function () {\n          // 清除悬浮框\n          prevXLabelIndex = -1;\n          theMouseoverHtml = '';\n          _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n          if (showMousemoveTimer) clearTimeout(showMousemoveTimer);\n        }\n      });\n      // 多层X轴区域移入，如果是多层X轴顶层，显示阴影 ； 如果是多层X轴的最叶子层，显示该刻度下的数据信息 及 阴影\n      _pc_assets_js_charts_components_MouseOverChartComponent__WEBPACK_IMPORTED_MODULE_15__[\"default\"].handleXLevelMouseOverEvent({\n        svgContainer: containerResult.svgJqDom,\n        direction: \"horizontal\",\n        left: firstTitleWidth + firstMeasureWidth,\n        top: scalePaddingTop,\n        separate: attributeSeparate,\n        //  X刻度与图形之间的间隔\n\n        prevStart: start,\n        hoverWidth: attributeAxis.rangeBand,\n        hoverHeight: scaleMeasureHeight,\n        mousemoveCallback: function (options) {\n          options = options || {};\n          let theXLabelIndex = parseInt(options.xLabelIndex);\n          if (!isNaN(theXLabelIndex) || !options.event) {\n            // 显示当前X刻度的数据信息\n            if (prevXLabelIndex !== theXLabelIndex) {\n              prevXLabelIndex = theXLabelIndex;\n\n              // 显示X刻度 及 各个图例的颜色，图例名称 及 数值\n              let theXLabel = translateData.xLabelDistinct && translateData.xLabelDistinct[theXLabelIndex],\n                theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[theXLabel],\n                theXLabelData = xLabelDatas && xLabelDatas[theXLabel];\n              theMouseoverHtml = (theXLabelMapping && theXLabelMapping.text || theXLabel) + '<br/>';\n              theXLabelData && theXLabelData.forEach(function (data) {\n                if (data.legend !== undefined) {\n                  if (!hasLegendFlag && colorAssignedToScaleFlag) {\n                    let theXLabelColor = theXLabelColorList && theXLabelColorList.find(function (theLegend) {\n                      return theLegend.legend === theXLabel;\n                    });\n                    if (theXLabelColor) {\n                      theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theXLabelColor.color + ';margin-right:2px;\"></span>';\n                    }\n                  } else {\n                    let theLegendColor = legendValueList && legendValueList.find(function (theLegend) {\n                      return theLegend.legend === data.legend;\n                    });\n                    if (theLegendColor) {\n                      theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theLegendColor.color + ';margin-right:2px;\"></span>';\n                    }\n                  }\n                  theMouseoverHtml += data.legend + ':' + _DataFocusMethod.formatData(data.y0, chartAxis.curYAxis && chartAxis.curYAxis[0]);\n                  theMouseoverHtml += '<br />';\n                } else {\n                  chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis, index) {\n                    if (!hasLegendFlag && colorAssignedToScaleFlag) {\n                      let theXLabelColor = theXLabelColorList && theXLabelColorList.find(function (theLegend) {\n                        return theLegend.legend === theXLabel;\n                      });\n                      if (theXLabelColor) {\n                        theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theXLabelColor.color + ';margin-right:2px;\"></span>';\n                      }\n                    } else {\n                      let theLegendColor = legendValueList && legendValueList.find(function (theLegend) {\n                        return theLegend.index === index;\n                      });\n                      if (theLegendColor) {\n                        theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + theLegendColor.color + ';margin-right:2px;\"></span>';\n                      }\n                    }\n                    theMouseoverHtml += _DataFocusMethod.getDisplayOperateColumn(conf.curLanguage, yAxis, {\n                      hideOperator: !conf.aggregationFlag\n                    }) + ':' + _DataFocusMethod.formatData(data['y' + index], yAxis);\n                    theMouseoverHtml += '<br />';\n                  });\n                }\n              });\n            }\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].positionChartPrompt(options.event, theMouseoverHtml);\n          } else {\n            prevXLabelIndex = -1;\n            theMouseoverHtml = '';\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n            if (showMousemoveTimer) clearTimeout(showMousemoveTimer);\n          }\n        },\n        mouseoutCallback: function () {\n          // 清除悬浮框\n          prevXLabelIndex = -1;\n          theMouseoverHtml = '';\n          _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n          if (showMousemoveTimer) clearTimeout(showMousemoveTimer);\n        }\n      });\n    };\n\n    // 默认画第一页数据\n    drawOneFrame({\n      animateFlag: animateFlag\n    });\n\n    /* *\r\n    * 画完图需要告诉外部的配置组件，当前图形的配置：\r\n    *   X轴类型是单层刻度/多层刻度/时间轴 及 单层刻度列表 ； 或者用户配置的类型 ；\r\n    *   标题是自动显示，还是自动隐藏 ； 或者是用户配置的显示及隐藏\r\n    *   是否有右Y轴\r\n    *   是否有图例，属性列图例；多Y轴图例 ；\r\n    * */\n    let returnConfigureAutoValue = {};\n    // 如果用户配置的X轴类型是自动，则返回给图形配置组件提供当前X轴的自动类型\n    if (chartConfigures.x_axis_draw_type !== 'option_select_x_axis_dot_line') {\n      switch (translateData.autoXLabelType) {\n        case \"dotLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_dot_line';\n          break;\n        case \"timeLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_time_line';\n          break;\n        case \"levelLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_level_line';\n          break;\n        case \"scaleLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_scale_line';\n          break;\n      }\n    }\n    // 如果用户配置X轴标题显示自动，则返回给图形配置组件提供当前X轴标题的自动显示类型\n    if (!chartConfigures.x_axis_title_visible || chartConfigures.x_axis_title_visible === 'system_auto_default') {\n      returnConfigureAutoValue.x_axis_title_visible = showXTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n    }\n    // 如果用户配置Y轴标题显示自动，则返回给图形配置组件提供当前Y轴标题的自动显示类型\n    if (!chartConfigures.y_axis_title_visible || chartConfigures.y_axis_title_visible === 'system_auto_default') {\n      returnConfigureAutoValue.y_axis_title_visible = yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n    }\n    // 如果用户配置了右Y轴，则将右Y轴存在的标志传给图形\n    if (yAxisBasicMessage.secondMeasure) {\n      returnConfigureAutoValue.has_right_y_axis = true;\n      // 如果用户配置右Y轴标题显示自动，则返回给图形配置组件提供当前右Y轴标题的自动显示类型\n      if (!chartConfigures.right_y_axis_title_visible || chartConfigures.right_y_axis_title_visible === 'system_auto_default') {\n        returnConfigureAutoValue.right_y_axis_title_visible = yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n      }\n    }\n    // 如果当前图形配置有图例，则将图例配置传给图形\n    if (hasLegendFlag) {\n      returnConfigureAutoValue.has_legend_flag = hasLegendFlag;\n      returnConfigureAutoValue.legendValueList = legendValueList;\n      returnConfigureAutoValue.defaultLegendList = defaultLegendList;\n    } else {\n      returnConfigureAutoValue.xLabelColorList = theXLabelColorList;\n      returnConfigureAutoValue.defaultXLabelColorList = defaultXLabelColorList;\n    }\n    // 如果当前图形可以配置最大最小值标准线，则将该配置传给图形\n    if (!hasLegendFlag && chartAxis.curYAxis.length === 1) {\n      returnConfigureAutoValue.allow_marker_flag = true;\n    }\n\n    /**\r\n     * @return\r\n     *      {\r\n     *          // 当前图形自动识别的配置，主要可以用于chartConfigureList中条件判断\r\n     *          chartAutoConfigures: {}\r\n     *      }\r\n     * */\n    return {\n      chartAutoConfigures: returnConfigureAutoValue\n    };\n  },\n  // [*必填项]图表配置列表，其中的require条件不仅可以使用以下配置项的key，也可以使用drawChart中返回的chartAutoConfigures中的值\n  // drawChart返回的chartAutoConfigures是图形返回给图形配置组件的信息，用于开发者可以控制配置的显示与隐藏\n  chartConfigureList: [\n  // 通用 ： 字体大小，动画，最小柱宽，\n  {\n    key: \"category_general\",\n    title: \"category_general\",\n    options: [\n    // 图形的颜色主题\n    {\n      key: \"chart_color_theme\",\n      title: \"option_chart_color_theme\",\n      description: \"option_chart_color_theme_desc\",\n      type: \"theme\",\n      selection: [\"option_chart_theme_eight\", \"option_chart_theme_one\", \"option_chart_theme_two\", \"option_chart_theme_three\", \"option_chart_theme_four\", \"option_chart_theme_five\", \"option_chart_theme_six\", \"option_chart_theme_seven\", \"option_chart_theme_custom\"],\n      defaultValue: \"option_chart_theme_one\"\n    },\n    //自定义主题颜色\n    {\n      key: \"chart_custom_theme\",\n      title: \"option_chart_custom_theme\",\n      description: \"option_chart_custom_theme_desc\",\n      type: \"colorList\",\n      require: \"chart_color_theme=option_chart_theme_custom\"\n    },\n    // 图形字体大小\n    {\n      key: \"font_size_label\",\n      title: \"option_font_size_label\",\n      description: \"option_font_size_label_desc\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      }\n    },\n    // 隐藏聚合方式 [ 图例的聚合方式 ]\n    {\n      key: \"hide_operator_label\",\n      title: \"option_hide_operator_label\",\n      description: \"option_hide_operator_label_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 禁止图形动画\n    {\n      key: \"animation_forbidden\",\n      title: \"option_animation_forbidden\",\n      description: \"option_animation_forbidden_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 图例限制条目数，默认为50\n    {\n      key: \"legend_count_limit\",\n      title: \"option_legend_count_limit\",\n      description: \"option_legend_count_limit_desc\",\n      defaultNumber: 50,\n      withoutSlider: true,\n      type: \"input\",\n      reTranslateResult: true\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 颜色：颜色主题，图例形状颜色，单Y轴情况下，将颜色分配给各个X轴刻度，各个刻度的颜色\n  {\n    key: \"category_color\",\n    title: \"category_color\",\n    options: [\n    // 自定义图例颜色[ @20221201 tong - 新的图例颜色样式配置结构  从attrColorArray组件调整为container组件 ]\n    // 仪表图只能通过点击选择图例颜色，无法通过配置设置\n    // 图例类型是单个属性列的情况下，配置各个图例的颜色，虚实....\n    {\n      key: \"chart_legend_list\",\n      // \"chart_custom_legend_new\",\n      type: \"legendList\",\n      legendConfigSet: ['color', 'show', 'shape'],\n      //  当前图例可以配置的值 color: 颜色 ； shape:形状 ；dash： 虚实 ； shadow: 阴影\n      legendShapeSelection: [\"option_legend_shape_type_column\", \"option_legend_shape_type_line\"],\n      legendValueList: \"legendValueList\",\n      //  当前所有图例使用的配置值\n      defaultLegendList: \"defaultLegendList\",\n      //  当前所有图例的默认值\n      require: \"has_legend_flag\",\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    // 柱状图支持按X轴属性值分配颜色后，自定义的各个属性值的颜色\n    {\n      key: \"chart_custom_label_color\",\n      type: \"legendList\",\n      legendConfigSet: ['color'],\n      //  当前图例可以配置的值 color: 颜色 ； shape:形状 ；dash： 虚实 ； shadow: 阴影\n      legendValueList: \"xLabelColorList\",\n      //  当前所有图例使用的配置值\n      defaultLegendList: \"defaultXLabelColorList\",\n      //  当前所有图例的默认值\n      require: \"chart_color_assigned_to_x_scale\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  }, {\n    key: 'category_column_config',\n    title: 'category_column_config',\n    options: [\n    // 固定柱宽\n    {\n      key: \"chart_column_width\",\n      title: \"option_chart_column_width\",\n      description: \"option_chart_column_width_desc\",\n      placeholder: 'option_default_value',\n      type: \"input\",\n      min: 5,\n      allowNullFlag: true,\n      withoutSlider: true,\n      require: \"!chart_default_step\"\n    },\n    // 固定分页条目数【 没有配置固定柱宽的情况下才有效 】\n    {\n      key: \"chart_default_step\",\n      title: \"option_chart_default_step\",\n      description: \"option_chart_default_step_desc\",\n      placeholder: 'option_default_value',\n      type: \"input\",\n      min: 1,\n      allowNullFlag: true,\n      withoutSlider: true,\n      require: \"!chart_column_width\"\n    },\n    // 最小柱宽[ 没有配置固定柱宽及每页条目数的情况下，才可以使用 ]\n    {\n      key: \"chart_column_minimum_width\",\n      title: \"option_chart_column_minimum_width\",\n      description: \"option_chart_column_minimum_width_desc\",\n      type: \"input\",\n      min: 5,\n      defaultNumber: 5,\n      allowNullFlag: true,\n      withoutSlider: true,\n      require: \"!chart_column_width;!chart_default_step\"\n    },\n    // 柱宽比例\n    {\n      key: \"chart_column_width_percent_1\",\n      title: \"option_chart_column_width_percent\",\n      description: \"option_chart_column_width_percent_desc\",\n      type: \"input\",\n      min: 10,\n      max: 100,\n      defaultNumber: 60,\n      step: 10,\n      unit: \"%\"\n    },\n    // 柱体堆积\n    {\n      key: \"chart_column_stack\",\n      title: \"option_chart_column_stack\",\n      description: \"option_chart_column_stack_desc\",\n      type: \"checkbox-prev\",\n      defaultValue: false\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  }, {\n    key: 'category_line_config',\n    title: 'category_line_config',\n    options: [\n    // 折线样式配置\n    {\n      key: \"style_of_line\",\n      title: \"option_style_of_line\",\n      description: \"option_style_of_line_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_line_style_linear\", \"option_line_style_step\", \"option_line_style_step_after\", \"option_line_style_step_before\", \"option_line_style_curve_natural\", \"option_line_style_curve_basis\", \"option_line_style_curve_bump_x\", \"option_line_style_curve_monotone_x\", \"option_line_style_curve_monotone_y\"\n      // \"option_style_line_normal_symbol\",\n      // \"option_style_line_curve_symbol\",\n      // \"option_style_line_step_symbol\"\n      ]\n    }, {\n      key: \"thickness_of_line\",\n      title: \"option_thickness_of_line\",\n      description: \"option_thickness_of_line_desc\",\n      type: \"input\",\n      min: 1,\n      defaultNumber: 1\n    },\n    // 显示节点\n    {\n      key: \"show_point\",\n      title: \"option_show_point\",\n      description: \"option_show_point_desc\",\n      type: \"checkbox-prev\",\n      defaultValue: false\n    },\n    // 节点半径\n    {\n      key: \"symbol_size_of_line\",\n      title: \"option_symbol_size_of_line\",\n      description: \"option_symbol_size_of_line_desc\",\n      withoutSlider: true,\n      type: 'input',\n      defaultNumber: 5,\n      require: \"show_point\"\n    },\n    // 虚实\n    {\n      key: \"dashed_solid_of_line\",\n      title: \"option_dashed_solid_of_line\",\n      description: \"option_dashed_solid_of_line_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_dashed_solid_of_line_solid\", \"option_dashed_solid_of_line_dashed\"]\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // X轴： X刻度类型[单层/多层/时间]，最高高度，倾斜角度，X轴标题显示，标题自定义，隐藏X轴\n  {\n    key: \"category_x_axis\",\n    title: \"category_x_axis\",\n    options: [\n    // 优先画X轴最右侧的数据\n    {\n      key: \"x_axis_right_first_flag\",\n      title: \"option_x_axis_right_first_flag\",\n      description: \"option_x_axis_right_first_flag_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 显示隐藏X轴标签\n    {\n      key: \"x_axis_label_visible\",\n      title: \"option_axis_label_visible\",\n      type: 'checkbox-prev',\n      defaultValue: true\n    },\n    // X轴标签字体样式 [ 显示轴标签才可以配置， 大小 ，颜色，字体，加粗，斜体，下划线 ]\n    {\n      key: \"x_axis_label_style\",\n      title: \"option_font_style\",\n      type: 'fontStyle',\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"x_axis_label_visible\"\n    },\n    // X轴刻度类型[ 单层属性 / 多层属性 / 时间轴 ]\n    // 刻度类型只能在单层与多层之间切换 或者 单层与时间轴之间切换， 所以提供两种选项：自动 ; 单层 ；\n    {\n      key: \"x_axis_draw_type\",\n      title: \"option_x_axis_draw_type\",\n      description: \"option_x_axis_draw_type_desc\",\n      type: 'selectTile',\n      selection: [\"system_auto_default\", \"option_select_x_axis_dot_line\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\",\n      require: \"x_axis_label_visible\"\n    },\n    // X轴单层属性下，旋转角度\n    {\n      // attribute_label_rotate\n      key: \"x_axis_label_dot_line_rotation_value\",\n      title: \"option_x_axis_label_dot_line_rotation_value\",\n      type: 'input',\n      withoutSlider: true,\n      defaultNumber: 30,\n      min: 0,\n      max: 180,\n      // X轴是单层散点模式 且 显示轴标签时，才可以配置旋转角度\n      require: \"x_axis_label_visible;x_axis_draw_type=option_select_x_axis_dot_line\"\n    },\n    // X轴单层属性下，刻度间距\n    {\n      // attribute_label_space_width\n      key: \"x_axis_label_dot_line_space_width\",\n      title: \"option_x_axis_label_dot_line_space_width\",\n      description: \"option_x_axis_label_dot_line_space_width_desc\",\n      type: 'input',\n      withoutSlider: true,\n      min: 1,\n      max: 999,\n      defaultNumber: 50,\n      // X轴是单层散点模式 且 显示轴标签时，才可以配置旋转角度\n      require: \"x_axis_label_visible;x_axis_draw_type=option_select_x_axis_dot_line\"\n    },\n    // X轴最大高度限制\n    {\n      // attribute_label_max_height\n      key: \"x_axis_label_max_height_percent\",\n      title: \"option_x_axis_label_max_height_percent\",\n      description: \"option_x_axis_label_max_height_percent_desc\",\n      type: 'input',\n      min: 0,\n      max: 100,\n      defaultNumber: 30,\n      step: 5,\n      require: \"x_axis_label_visible\"\n    },\n    // X轴标题自动 / 强制显示 / 强制隐藏 [ 平铺选项 ]\n    {\n      key: \"x_axis_title_visible\",\n      title: \"option_axis_title_visible\",\n      description: \"option_axis_title_visible_desc\",\n      type: 'selectTile',\n      prevIcon: \"eye-icon\",\n      openEyeValue: \"option_title_visible_show\",\n      selection: [\"system_auto_default\", \"option_title_visible_show\", \"option_title_visible_hide\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\"\n    },\n    // 自定义的X轴标题内容\n    {\n      key: \"x_axis_title_content\",\n      title: \"option_axis_title_content\",\n      description: \"option_axis_title_content_desc\",\n      type: \"text\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题字体样式\n    {\n      key: \"x_axis_title_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题对齐方式\n    {\n      key: \"x_axis_title_alignment\",\n      title: \"option_font_alignment\",\n      type: \"fontAlign\",\n      defaultValue: \"center\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // Y轴：Y轴刻度最宽宽度，Y轴标尺，Y轴标题\n  {\n    key: \"category_y_axis\",\n    title: \"category_y_axis\",\n    options: [\n    // 显示隐藏Y轴标签\n    {\n      key: \"y_axis_label_visible\",\n      title: \"option_axis_label_visible\",\n      type: 'checkbox-prev',\n      defaultValue: true\n    },\n    // Y轴标签字体样式 [ 显示轴标签才可以配置， 大小 ，颜色，字体，加粗，斜体，下划线 ]\n    {\n      key: \"y_axis_label_style\",\n      title: \"option_font_style\",\n      type: 'fontStyle',\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"y_axis_label_visible\"\n    },\n    // Y轴数据格式\n    {\n      key: \"measure_left_y_configure\",\n      title: \"option_measure_configure\",\n      description: \"option_measure_left_y_configure_desc\",\n      type: \"axisFormat\"\n    },\n    // Y轴最大宽度限制\n    {\n      key: \"y_axis_label_max_width_percent\",\n      title: \"option_y_axis_label_max_width_percent\",\n      type: 'input',\n      min: 0,\n      max: 100,\n      defaultNumber: 30,\n      step: 5,\n      require: \"y_axis_label_visible\"\n    },\n    // Y轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      explainDefaultFlag: true,\n      defaultValue: \"option_default_value\"\n    },\n    // 默认类型下手动设置的最小值\n    {\n      key: \"measure_scale_min\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_scale_type!=option_measure_scale_type_define'\n    },\n    // 默认类型下手动设置的最大值\n    {\n      key: \"measure_scale_max\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_scale_type!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // Y轴标题自动 / 强制显示 / 强制隐藏 [ 平铺选项 ]\n    {\n      key: \"y_axis_title_visible\",\n      title: \"option_axis_title_visible\",\n      description: \"option_axis_title_visible_desc\",\n      type: 'selectTile',\n      prevIcon: \"eye-icon\",\n      openEyeValue: \"option_title_visible_show\",\n      selection: [\"system_auto_default\", \"option_title_visible_show\", \"option_title_visible_hide\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\"\n    },\n    // 自定义的Y轴标题内容\n    {\n      key: \"y_axis_title_content\",\n      title: \"option_axis_title_content\",\n      type: \"text\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题字体样式\n    {\n      key: \"y_axis_title_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题对齐方式\n    {\n      key: \"y_axis_title_alignment\",\n      title: \"option_font_alignment\",\n      type: \"fontAlign\",\n      defaultValue: \"center\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 右Y轴[ 有右Y轴的情况下，该信息由画图组件提供出去 ]\n  {\n    key: \"category_right_y_axis\",\n    title: \"category_right_y_axis\",\n    require: \"has_right_y_axis\",\n    options: [\n    // Y轴数据格式\n    {\n      key: \"measure_right_y_configure\",\n      title: \"option_measure_configure\",\n      description: \"option_measure_right_y_configure_desc\",\n      type: \"axisFormat\"\n    },\n    // Y轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type_right\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      explainDefaultFlag: true,\n      defaultValue: \"option_default_value\"\n    },\n    // 默认类型下最大值\n    {\n      key: \"measure_scale_min_right\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right!=option_measure_scale_type_define'\n    },\n    // 默认类型下最小值\n    {\n      key: \"measure_scale_max_right\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min_right\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step_right\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number_right\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义的Y轴标题内容\n    {\n      key: \"right_y_axis_title_content\",\n      title: \"option_axis_title_content\",\n      type: \"text\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 左右Y轴0刻度对齐\n    {\n      key: \"measure_scale_parallel\",\n      title: \"option_measure_scale_parallel\",\n      description: \"option_measure_scale_parallel_desc\",\n      type: \"checkbox-prev\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //图例： 是否隐藏，图例色块形状，图例位置，图例宽度，图例间隔 ， 图例限制条目数\n  {\n    key: \"category_legend_config\",\n    title: \"category_legend_config\",\n    require: \"has_legend_flag\",\n    options: [\n    // 隐藏图例\n    {\n      key: \"show_legend\",\n      title: \"option_map_info_show\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // 字体样式\n    {\n      key: \"legend_font_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"show_legend\"\n    },\n    // 图例形状\n    {\n      key: \"legend_shape_type\",\n      title: \"option_legend_shape_type\",\n      description: \"option_legend_shape_type_desc\",\n      type: \"select\",\n      selection: [\"option_legend_shape_type_circle\", \"option_legend_shape_type_three\", \"option_legend_shape_type_four\", \"option_legend_shape_type_rect\", \"option_legend_shape_type_five\", \"option_legend_shape_type_diamond\", \"option_legend_shape_type_loop\"],\n      require: \"show_legend\"\n    },\n    // 图例位置\n    {\n      key: \"legend_position\",\n      title: \"option_legend_position\",\n      description: \"option_legend_position_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_position_right\", \"option_position_top\", \"option_position_bottom\", \"option_position_right_top\"],\n      require: \"show_legend\"\n    },\n    // 图例宽度\n    {\n      key: \"legend_position_width\",\n      title: \"option_legend_position_width\",\n      description: \"option_legend_position_width_desc\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      max: 200,\n      defaultNumber: 80,\n      require: \"show_legend;legend_position=option_position_top,option_position_bottom\"\n    },\n    // 图例离画图区域的间隔\n    {\n      key: \"legend_position_offset\",\n      title: \"option_legend_position_offset\",\n      description: \"option_legend_position_offset_desc\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      max: 100,\n      defaultNumber: 5,\n      require: \"show_legend\"\n    },\n    // 图例之间的间隔\n    {\n      key: \"legend_position_interval\",\n      title: \"option_legend_position_interval\",\n      description: \"option_legend_position_interval_desc\",\n      type: \"input\",\n      allowNullFlag: true,\n      withoutSlider: true,\n      min: 0,\n      max: 100,\n      require: \"show_legend\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 网格线配置\n  {\n    key: \"category_grid_line\",\n    title: \"category_grid_line\",\n    options: [\n    // 网格线分别可以配置零线显示/样式（虚实粗细颜色） ； 非零线显示/样式（虚实粗细颜色）；\n    // 显示所有的网格线\n    {\n      key: \"grid_show_all_line\",\n      title: \"option_grid_show_all_line\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // 只显示零线\n    {\n      key: \"grid_show_only_zero_line\",\n      title: \"option_grid_show_only_zero_line\",\n      description: \"option_grid_show_only_zero_line_desc\",\n      type: \"checkbox-prev\",\n      require: \"grid_show_all_line\"\n    },\n    // 网格线样式\n    {\n      key: \"grid_line_style\",\n      title: \"option_grid_line_style\",\n      description: \"option_grid_line_style_desc\",\n      type: \"lineStyle\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"grid_show_all_line\"\n    },\n    // 零线样式\n    {\n      key: \"grid_zero_line_style\",\n      title: \"option_grid_zero_line_style\",\n      description: \"option_grid_zero_line_style_desc\",\n      type: \"lineStyle\",\n      defaultValueConfig: \"grid_line_style\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"grid_show_all_line\"\n    },\n    // 隐藏最大值/最小值标准线，在有的情况下显示该配置\n    {\n      key: \"grid_remove_standard_line\",\n      title: \"option_grid_remove_standard_line\",\n      description: \"option_grid_remove_standard_line_desc\",\n      type: \"checkbox-prev\",\n      require: \"allow_marker_flag\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 数据标签格式\n  {\n    key: \"category_label\",\n    title: \"category_label\",\n    options: [\n    // 是否显示数据标签\n    {\n      key: \"label_text_visible\",\n      title: \"option_label_text_visible\",\n      description: \"option_label_text_visible_desc\",\n      type: 'checkbox-prev'\n    },\n    // 字体样式\n    {\n      key: \"label_text_font_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label-2\",\n      require: \"label_text_visible\"\n    },\n    // 数据标签的内容\n    {\n      key: \"label_text_regex\",\n      title: \"option_label_text_regex\",\n      description: \"option_suspend_text_regex_desc\",\n      type: \"chartRichText\",\n      require: 'label_text_visible',\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    // 柱状（居内/居外/居中）\n    {\n      key: \"label_text_column_position\",\n      title: \"option_label_text_position\",\n      description: \"option_label_text_position_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_position_in\", \"option_label_position_out\", \"option_label_position_center\"],\n      require: 'label_text_visible'\n    },\n    // 旋转角度0/90/270\n    {\n      key: \"label_text_rotation_angle\",\n      title: \"option_label_text_rotation_angle\",\n      description: \"option_label_text_rotation_angle_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_rotation_0\", \"option_label_rotation_90\", \"option_label_rotation_270\"],\n      require: 'label_text_visible'\n    },\n    // 标签显示项 [ 全部/标准最大值最小值平均值 ]\n    {\n      key: \"label_text_visible_items\",\n      title: \"option_label_text_visible_items\",\n      description: \"option_label_text_visible_items_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_visible_all\", \"option_label_visible_standard\"],\n      require: 'label_text_visible'\n    },\n    // 标签是否允许重叠\n    {\n      key: \"label_text_allow_overlap\",\n      title: \"option_label_text_allow_overlap\",\n      description: \"option_label_text_allow_overlap_desc\",\n      type: \"checkbox\",\n      require: 'label_text_visible'\n    },\n    // // 使用坐标轴的格式\n    // {\n    //     key: \"label_use_scale_abbreviation\",\n    //     title: \"option_label_use_scale_abbreviation\",\n    //     description: \"option_label_use_scale_abbreviation_desc\",\n    //     type: \"checkbox\",\n    //     require: 'label_text_visible'\n    // }\n\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 悬浮文本设置\n  {\n    key: \"category_suspend_text\",\n    title: \"category_suspend_text\",\n    options: [{\n      key: \"suspend_text_regex\",\n      title: \"option_suspend_text_regex\",\n      description: \"option_suspend_text_regex_desc\",\n      type: \"chartRichText\",\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 标度配置\n  {\n    key: \"category_scale_config\",\n    title: \"category_scale_config\",\n    require: \"!has_right_y_axis\",\n    options: [\n    // 显示/隐藏标度\n    {\n      key: \"scale_y_visible\",\n      title: \"option_scale_y_visible\",\n      type: 'checkbox-prev'\n    },\n    // 其他图形的标度配置全部调整为数组(container)模式  @20221206 by tong\n    {\n      key: \"scale_y_range\",\n      description: \"option_scale_y_range_desc\",\n      type: \"container\",\n      containerClassType: \"borderItem\",\n      options: [\n      // 标度类型 - 直线或区间 [ 默认为直线 ]\n      {\n        type: \"selectTile\",\n        key: \"option_scale_config_type\",\n        title: \"option_scale_config_type\",\n        selection: [\"options_scale_config_type_line\", \"options_scale_config_type_range\"]\n      },\n      // 文本\n      {\n        type: \"text\",\n        title: \"option_scale_config_text\"\n      },\n      // ==== 标度为直线的情况下 start==================================\n      // 标度值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_value_type\",\n        title: \"option_scale_config_value_type\",\n        selection: [\"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"],\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        defaultValue: \"options_config_value_avg\"\n      },\n      // 标度值\n      {\n        type: \"text\",\n        key: \"option_scale_config_value_input\",\n        title: \"option_scale_config_value_input\",\n        require: \"option_scale_config_type=options_scale_config_type_line;option_scale_config_value_type=options_config_value_input\"\n      }, {\n        type: \"color\",\n        title: \"option_scale_config_value_color\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        defaultColor: \"#D62728\"\n      },\n      // 粗细\n      {\n        type: \"input\",\n        title: \"option_scale_config_value_thickness\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        withoutSlider: true,\n        min: 0,\n        defaultNumber: 1\n      },\n      // 虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_value_style\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        selection: [\"option_line_style_solid_line\", \"option_line_style_dashed\"],\n        defaultValue: \"option_line_style_solid_line\"\n      },\n      // ==== 标度为直线的情况下 end==================================\n\n      // ==== 标度为区间的情况下 start==================================\n      // 上区间值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_top_range_type\",\n        title: \"option_scale_config_top_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"],\n        defaultValue: \"options_config_value_input\"\n      },\n      // 上区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_top_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_top_range_type=option_default_value,options_config_value_input\"\n      }, {\n        type: \"select\",\n        key: \"option_scale_config_bottom_range_type\",\n        title: \"option_scale_config_bottom_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"],\n        defaultValue: \"options_config_value_input\"\n      },\n      // 下区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_bottom_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_bottom_range_type=option_default_value,options_config_value_input\"\n      },\n      // 区间颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        defaultColor: \"#D62728\"\n      },\n      // 区间透明度\n      {\n        type: \"input\",\n        title: \"option_scale_config_range_color_transparent\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        min: 0,\n        step: 5,\n        max: 100,\n        defaultNumber: 30,\n        unit: \"%\"\n      },\n      // 区间边框颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_edge_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        defaultColor: \"#D62728\"\n      },\n      // 区间边框虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_range_edge_style\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_line_style_solid_line\", \"option_line_style_dashed\"],\n        defaultValue: \"option_line_style_solid_line\"\n      }\n      // ==== 标度为区间的情况下 end==================================\n      ],\n      withoutRange: true,\n      rangeInits: [{}],\n      require: \"scale_y_visible\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  }],\n  /**\r\n   * 图形配置的辅助对象：当前图形定义的宏列表 及 宏 解析方法 ； 适配之前图形配置值的方法 ；\r\n   *\r\n   * 当前图形提供的宏列表[ 宏名的命名规则： 开头是%_ 用_连接的大写字符字符串 ]\r\n   * 供自定义数据标签 及 悬浮文本使用，可以让用户配置显示内容\r\n   * 键值对  MacroName : MacroDisplayNameKey\r\n   * */\n  chartConfigureAdvanced: {\n    // 根据宏配置列表，已足够外部组件将 %_NAME:%_VALUE 翻译成 [属性]：[值] 显示给用户\n    // 如果当前图形支持换行的宏，则输入时允许输入换行符 ； 否则编辑时也不支持换行符 ；\n    chartMacroList: [{\n      key: '%_NAME',\n      nameKey: '%_NAME',\n      descriptionKey: '%_NAME_desc'\n    }, {\n      key: '%_CATEGORY_NAME',\n      nameKey: '%_CATEGORY_NAME',\n      descriptionKey: '%_CATEGORY_NAME_desc'\n    }, {\n      key: '%_CATEGORY_NUMBER',\n      nameKey: '%_CATEGORY_NUMBER',\n      descriptionKey: '%_CATEGORY_NUMBER_desc'\n    }, {\n      key: '%_SERIES_NAME',\n      nameKey: '%_SERIES_NAME',\n      descriptionKey: '%_SERIES_NAME_desc'\n    }, {\n      key: '%_SERIES_NUMBER',\n      nameKey: '%_SERIES_NUMBER',\n      descriptionKey: '%_SERIES_NUMBER_desc'\n    }, {\n      key: '%_VALUE_NAME',\n      nameKey: '%_VALUE_NAME',\n      descriptionKey: '%_VALUE_NAME_desc'\n    }, {\n      key: '%_VALUE',\n      nameKey: '%_VALUE',\n      descriptionKey: '%_VALUE_desc'\n    }, {\n      key: '%_CATEGORY_TOTAL',\n      nameKey: '%_CATEGORY_TOTAL',\n      descriptionKey: '%_CATEGORY_TOTAL_desc'\n    }, {\n      key: '%_CATEGORY_AVERAGE',\n      nameKey: '%_CATEGORY_AVERAGE',\n      descriptionKey: '%_CATEGORY_AVERAGE_desc'\n    }, {\n      key: '%_PERCENT_OF_CATEGORY',\n      nameKey: '%_PERCENT_OF_CATEGORY',\n      descriptionKey: '%_PERCENT_OF_CATEGORY_desc'\n    }, {\n      key: '%_PERCENT_OF_TOTAL',\n      nameKey: '%_PERCENT_OF_TOTAL',\n      descriptionKey: '%_PERCENT_OF_TOTAL_desc'\n    }, {\n      key: '%_BR',\n      nameKey: '%_BR',\n      descriptionKey: '%_BR_desc'\n    }],\n    // 依据当前配置，将 %_NAME:%_VALUE 转译成真实值显示\n    /**\r\n     * @param configMacroStr    -   用户配置的带宏的内容\r\n     * @param options\r\n     *          {\r\n     *              type        -\r\n     *\r\n     *              xLabel       -   图形单元对应的属性值 用于实现%_NAME %_CATEGORY_NAME\r\n     *              xLabelIndex  -   图形单元对应的属性索引，用于实现 %_CATEGORY_NUMBER\r\n     *              xLabelTotal  -   图形单元对应的属性上所有值的总和用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              xLabelNumber -   图形单元对应的属性上所有值的个数用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              yValue       -   图形单元对应的值 用于实现 %_VALUE\r\n     *              yAxis        -   图形单元对应的值列 用于实现 %_VALUE_NAME  %_SERIES_NAME\r\n     *              legend       -   图形单元对应的图例名(为空时说明是多Y轴) 用于实现 %_SERIES_NAME\r\n     *              legendIndex  -   图形单元对应的图例索引 用于实现 %_SERIES_NUMBER\r\n     *              legendTotal  -   图形单元对应的图例上所有值的总和,用于实现 %_PERCENT_OF_TOTAL\r\n     *              rowData -  图形单元对应的一整行数据 用于实现%_COLUMN_N的宏\r\n     *          }\r\n     * */\n    translateMacro: function (configMacroStr, options) {\n      options = options || {};\n      if (!configMacroStr) return false;\n      let macroRegex = /%(_[A-Z0-9]*){1,}/g;\n      let theMatchedTextValue = '',\n        matchedIndex = 0;\n      macroRegex.lastIndex = -1;\n      for (let i = 0, execResult; (execResult = macroRegex.exec(configMacroStr)) && i < 100; i++) {\n        if (!execResult || !execResult[0][0]) break;\n        let theMatchStr = execResult[0],\n          theMatchIndex = execResult.index;\n        theMatchedTextValue += configMacroStr.substring(matchedIndex, Math.max(theMatchIndex, matchedIndex));\n        switch (theMatchStr) {\n          case \"%_NAME\":\n          case \"%_CATEGORY_NAME\":\n            theMatchedTextValue += options.xLabel || '';\n            break;\n          case \"%_CATEGORY_NUMBER\":\n            theMatchedTextValue += options.xLabelIndex || '';\n            break;\n          case \"%_SERIES_NAME\":\n            if (options.legend) {\n              theMatchedTextValue += options.legend || '';\n            } else if (options.yAxis) {\n              theMatchedTextValue += options.yAxis.displayName || options.yAxis.col_name || '';\n            }\n            break;\n          case \"%_SERIES_NUMBER\":\n            theMatchedTextValue += options.legendIndex || '';\n            break;\n          case \"%_VALUE_NAME\":\n            if (options.yAxis) {\n              theMatchedTextValue += options.yAxis.displayName || options.yAxis.col_name || '';\n            }\n            break;\n          case \"%_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.yValue, options.yAxis) || '';\n            break;\n          case \"%_CATEGORY_TOTAL\":\n            theMatchedTextValue += options.xLabelTotal || '';\n            break;\n          case \"%_CATEGORY_AVERAGE\":\n            let theAverage = options.xLabelTotal / (options.xLabelNumber || 1);\n            if (!isNaN(theAverage)) {\n              theMatchedTextValue += _DataFocusMethod.formatData(_DataFocusMethod.getValidNum(theAverage, 2), options.yAxis);\n            }\n            break;\n          case \"%_PERCENT_OF_CATEGORY\":\n            let theCPercent = options.yValue / (options.xLabelTotal || 1);\n            if (!isNaN(theCPercent)) {\n              theMatchedTextValue += _DataFocusMethod.getValidNum(theCPercent * 100, 2) + '%';\n            }\n            break;\n          case \"%_PERCENT_OF_TOTAL\":\n            let theTPercent = options.yValue / (options.legendTotal || 1);\n            if (!isNaN(theTPercent)) {\n              theMatchedTextValue += _DataFocusMethod.getValidNum(theTPercent * 100, 2) + '%';\n            }\n            break;\n          case \"%_BR\":\n            theMatchedTextValue += options.type === 'label' ? '\\n' : '<br/>';\n            break;\n          default:\n            if (theMatchStr.startsWith(\"%_COLUMN_\")) {\n              let theColumnN = parseInt(theMatchStr.substring(9));\n              if (!isNaN(theColumnN) && options.rowData && theColumnN > 0 && theColumnN <= options.rowData.length) {\n                theMatchedTextValue += options.rowData[theColumnN - 1];\n              }\n            }\n            break;\n        }\n        matchedIndex = theMatchIndex + theMatchStr.length;\n      }\n      if (matchedIndex < configMacroStr.length) {\n        theMatchedTextValue += configMacroStr.substring(matchedIndex);\n      }\n      return theMatchedTextValue;\n    },\n    // 如果当前图形配置在上线后需要更新配置，需要兼容行为，则在此处处理[ 不同图形兼容方法不一样 ]\n    compatibleHistoryConfigure: function (chartConfigure, options) {\n      if (!options) return false;\n      options = options || {};\n\n      // 将以前的线条类型转换为现在的类型\n      if (chartConfigure.style_of_line) {\n        if (chartConfigure.style_of_line === 'option_style_line_normal') {\n          chartConfigure.style_of_line = 'option_line_style_linear';\n          chartConfigure.show_point = false;\n        }\n        // 原先的带有符号，现在拆成两个配置\n        if (chartConfigure.style_of_line === 'option_style_line_normal_symbol') {\n          chartConfigure.style_of_line = 'option_line_style_linear';\n          chartConfigure.show_point = true;\n        }\n        if (chartConfigure.style_of_line === 'option_style_line_step') {\n          chartConfigure.style_of_line = 'option_line_style_step';\n          chartConfigure.show_point = false;\n        }\n        // 原先的带有符号，现在拆成两个配置\n        if (chartConfigure.style_of_line === 'option_style_line_step_symbol') {\n          chartConfigure.style_of_line = 'option_line_style_step';\n          chartConfigure.show_point = true;\n        }\n        if (chartConfigure.style_of_line === 'option_style_line_curve') {\n          chartConfigure.style_of_line = 'option_line_style_curve_natural';\n          chartConfigure.show_point = false;\n        }\n        // 原先的带有符号，现在拆成两个配置\n        if (chartConfigure.style_of_line === 'option_style_line_curve_symbol') {\n          chartConfigure.style_of_line = 'option_line_style_curve_natural';\n          chartConfigure.show_point = true;\n        }\n      }\n\n      // 将原先的线宽”粗细“变为数值\n      if (chartConfigure.thickness_of_line) {\n        switch (chartConfigure.thickness_of_line) {\n          case \"option_thickness_line_heavy\":\n            chartConfigure.thickness_of_line = \"3\";\n            break;\n          case \"option_thickness_line_medium\":\n            chartConfigure.thickness_of_line = \"2\";\n            break;\n          case \"option_thickness_line_thin\":\n            chartConfigure.thickness_of_line = \"1\";\n            break;\n        }\n      }\n\n      // 节点描边的大小-半径-尺寸\n      if (chartConfigure.symbol_size_of_line) {\n        const symbolSizeOfLineMap = {\n          option_font_size_smaller: 3.5,\n          option_font_size_Minimum: 2,\n          option_font_size_bigger: 6.5,\n          option_font_size_Maximum: 8,\n          option_font_size_super: 10,\n          option_font_size_default: 5\n        };\n        if (symbolSizeOfLineMap[chartConfigure.symbol_size_of_line]) {\n          chartConfigure.symbol_size_of_line = symbolSizeOfLineMap[chartConfigure.symbol_size_of_line];\n        }\n      }\n\n      // 图形字体大小修改了值结构\n      if (_DataFocusMethod.isPureNumber(chartConfigure.font_size_label)) {\n        let theFontSize = parseInt(chartConfigure.font_size_label);\n        chartConfigure.font_size_label = {\n          fontSize: theFontSize\n        };\n      }\n      if (chartConfigure.attribute_label_rotate !== undefined) {\n        chartConfigure.x_axis_label_dot_line_rotation_value = chartConfigure.attribute_label_rotate;\n        chartConfigure.attribute_label_rotate = undefined;\n      }\n      // 刻度间隔 变了名字\n      if (chartConfigure.attribute_label_space_width !== undefined) {\n        chartConfigure.x_axis_label_dot_line_space_width = chartConfigure.attribute_label_space_width;\n        chartConfigure.attribute_label_space_width = undefined;\n      }\n      // 最大高度限制 变了名字\n      if (chartConfigure.attribute_label_max_height !== undefined) {\n        chartConfigure.x_axis_label_max_height_percent = chartConfigure.attribute_label_max_height * 100;\n        chartConfigure.attribute_label_max_height = undefined;\n      }\n\n      // 图形标题隐藏配置调整为两个配置值 [ 新的柱状图 ]\n      if (chartConfigure.hidden_chart_title) {\n        chartConfigure.x_axis_title_visible = \"option_title_visible_hide\";\n        chartConfigure.y_axis_title_visible = \"option_title_visible_hide\";\n        chartConfigure.hidden_chart_title = undefined;\n      }\n      // 隐藏X轴标签修改了名字\n      if (chartConfigure.hide_x_axis) {\n        chartConfigure.x_axis_label_visible = false;\n        chartConfigure.hide_x_axis = undefined;\n      }\n      // 隐藏Y轴就是隐藏Y轴标签及Y轴网格线 , 修改了名字\n      if (chartConfigure.hide_y_axis) {\n        chartConfigure.y_axis_label_visible = false;\n        chartConfigure.grid_show_all_line = false;\n        chartConfigure.hide_y_axis = undefined;\n      }\n\n      // 属性图例颜色 与 Y轴颜色只会存在其中一个 [ 将之前图形中配置的 yAxisColors 及 legendColors 全部统一到当前配置chart_legend_list中]\n      if (!chartConfigure.chart_legend_list) {\n        // 图例配置列表配置了属性图例的颜色\n        if (chartConfigure.chart_custom_legend_new && chartConfigure.chart_custom_legend_new.length || options.legendColors && options.legendColors.length) {\n          let theLegendList = [],\n            theLegendIdObj = {};\n          chartConfigure.chart_custom_legend_new && chartConfigure.chart_custom_legend_new.forEach(function (legend) {\n            if (legend.legend !== undefined && legend.color) {\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"legendAxis\", legend.legend);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: legend.legend,\n                  color: legend.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_custom_legend_new = undefined;\n\n          // 继承之前保存的legendColors配置\n          options.legendColors && options.legendColors.forEach(function (legend) {\n            if (legend.legend !== undefined && legend.color) {\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"legendAxis\", legend.legend);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: legend.legend,\n                  color: legend.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_legend_list = theLegendList;\n        }\n        // 图例配置列表配置了Y轴的颜色\n        if (chartConfigure.chart_custom_legend_new_measure && chartConfigure.chart_custom_legend_new_measure.length || options.yAxisColors && options.yAxisColors.length || options.yAxisType && options.yAxisType.length) {\n          let theLegendList = [],\n            theLegendIdObj = {};\n          chartConfigure.chart_custom_legend_new_measure && chartConfigure.chart_custom_legend_new_measure.forEach(function (configLeg) {\n            let theLegendNameObj = configLeg.options && configLeg.options.find(function (obj) {\n                return obj.title === 'option_chart_legend_measure_name';\n              }),\n              theLegendName = theLegendNameObj && theLegendNameObj.value || '',\n              theLegendColorObj = configLeg.options && configLeg.options.find(function (obj) {\n                return obj.title === 'option_chart_legend_color';\n              }),\n              theLegendColor = theLegendColorObj && theLegendColorObj.value || '';\n            theLegendName = theLegendName.replace(\"-y-axis-\", \"\");\n            let theYAxisArray = theLegendName.split('-'),\n              theColIdx = theYAxisArray[0],\n              theColName = theYAxisArray[1],\n              theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('YAxis', theColIdx);\n            if (theLegendName && theLegendColor) {\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: theColName,\n                  color: theLegendColor\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_custom_legend_new_measure = undefined;\n\n          // 继承之前保存的yAxisColors配置\n          console.log('---------------yAxisColors------------');\n          options.yAxisColors && options.yAxisColors.forEach(function (yAxis) {\n            if (yAxis.col_id !== undefined && yAxis.color) {\n              if (options.tableData && options.tableData.headers) {\n                let theMatchedHeader = options.tableData.headers.find(function (head) {\n                  return yAxis.col_id === head.col_id || head.idx + '' === yAxis.col_id + '';\n                });\n                if (theMatchedHeader) yAxis.col_id = theMatchedHeader.idx;\n              }\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", yAxis.col_id);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: yAxis.name,\n                  color: yAxis.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n\n          // 继承之前保存的yAxisType配置\n          console.log('---------------yAxisType------------');\n          options.yAxisType && options.yAxisType.forEach(function (yAxis) {\n            if (yAxis.type) {\n              if (options.tableData && options.tableData.headers) {\n                // 找到匹配的列\n                let theMatchedHeader = options.tableData.headers.find(function (head) {\n                  return head.idx + '' === yAxis.index + '';\n                });\n                if (theMatchedHeader) yAxis.col_id = theMatchedHeader.idx;\n              }\n              const savedShape = yAxis.type ? yAxis.type === 'column' ? 'option_legend_shape_type_column' : 'option_legend_shape_type_line' : undefined;\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", yAxis.col_id);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: yAxis.name,\n                  color: yAxis.color,\n                  shape: savedShape\n                });\n                theLegendIdObj[theLegendId] = true;\n              } else {\n                const matchedLegend = theLegendList.find(legend => legend.id === theLegendId);\n                if (matchedLegend) {\n                  matchedLegend.shape = savedShape;\n                }\n              }\n            }\n          });\n          chartConfigure.chart_legend_list = theLegendList;\n        }\n      }\n      // 隐藏网格线调整了显示网格线的名字\n      if (chartConfigure.grid_hide_all_line) {\n        chartConfigure.grid_show_all_line = false;\n        chartConfigure.grid_hide_all_line = undefined;\n      }\n      // 零线颜色及零线粗细调整了配置名\n      if (chartConfigure.grid_zero_color || chartConfigure.grid_zero_width) {\n        chartConfigure.grid_zero_line_style = {\n          lineColor: chartConfigure.grid_zero_color,\n          lineWidth: chartConfigure.grid_zero_width\n        };\n        chartConfigure.grid_zero_color = undefined;\n        chartConfigure.grid_zero_width = undefined;\n      }\n      // 柱宽比例调整了名字,并且变了值\n      if (_DataFocusMethod.isPureNumber(chartConfigure.chart_column_width_percent)) {\n        chartConfigure.chart_column_width_percent_1 = chartConfigure.chart_column_width_percent * 100;\n        chartConfigure.chart_column_width_percent = undefined;\n      }\n      // 显示图例\n      if (chartConfigure.hide_legend && chartConfigure.show_legend === undefined) {\n        chartConfigure.show_legend = false;\n        chartConfigure.hide_legend = undefined;\n      }\n\n      // 标度增加了显示与隐藏的配置\n      if (chartConfigure.scale_y_visible === undefined && chartConfigure.scale_y_range && chartConfigure.scale_y_range.length) {\n        chartConfigure.scale_y_visible = true;\n        chartConfigure.scale_y_range && chartConfigure.scale_y_range.forEach(function (theScaleYItem) {\n          // 以前标度类型默认值是default, 现在默认的类型是直线，所以得将之前的配置转换为具体值\n          let theTypeOption = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_type\";\n          });\n          if (!theTypeOption) {\n            theScaleYItem.options = theScaleYItem.options || [];\n            theScaleYItem.options.push({\n              title: \"option_scale_config_type\",\n              value: \"option_default_value\"\n            });\n          } else if (theTypeOption && !theTypeOption.value) theTypeOption.value = 'option_default_value';\n\n          // 以前直线的粗细是类型，目前调整为数值\n          let theThickness = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_value_thickness\";\n          });\n          if (theThickness && theThickness.value) {\n            switch (theThickness.value) {\n              case \"option_thickness_line_medium\":\n                theThickness.value = 2;\n                break;\n              case \"option_thickness_line_heavy\":\n                theThickness.value = 3;\n                break;\n            }\n          }\n        });\n      }\n    }\n  },\n  // [*必填项]图轴及图表自定义的中英文\n  i18nObj: {\n    chinese: {\n      \"system_auto_default\": \"自动\",\n      \"user_define_text\": \"自定义\",\n      \"category_x_axis\": \"X轴\",\n      \"option_x_axis_right_first_flag\": \"优先画X轴最右侧数据\",\n      \"option_x_axis_right_first_flag_desc\": \"默认情况下，从X轴最左侧数据开始画，超出一屏时往右分页显示。<br />开启优先画X轴最右侧数据后，从X轴最右侧数据开始画，超出一屏时往左分页显示\",\n      \"option_x_axis_draw_type\": \"X轴类型\",\n      \"option_select_x_axis_dot_line\": \"单层散点\",\n      \"option_select_x_axis_time_line\": \"时间轴\",\n      \"option_select_x_axis_level_line\": \"多层属性\",\n      \"option_x_axis_draw_type_desc\": \"X轴总共有三种类型：\" + \"<br /> 多层属性<span class='color-main-green'>[自动识别]</span>：X轴有2个或3个属性列时，自动会识别使用多层属性展示X轴刻度\" + \"<br /> 时间轴<span class='color-main-green'>[自动识别]</span>：X轴只有1个时间列 且 经过每天/每小时/每分钟聚合时，自动会识别使用时间轴展示X轴刻度\" + \"<br /> 单层散点<span class='color-main-green'>[自动识别]</span>：所有数据均可以强制使用单层三点的模式展示X轴刻度\" + \"<br /> 系统会自动适配合适的X轴，但是您可以强制切换称单层单点模式\",\n      \"option_axis_label_visible\": \"轴标签\",\n      \"option_axis_title_visible\": \"轴标题\",\n      \"option_axis_title_visible_desc\": \"自动情况下，会在搜索页面会显示标题 ； 在看板中会隐藏标题 ；\",\n      \"option_title_visible_show\": \"显示\",\n      \"option_title_visible_hide\": \"隐藏\",\n      \"option_axis_title_content\": \"标题内容\",\n      \"option_axis_title_content_desc\": \"默认会使用X轴的列名\",\n      \"option_x_axis_label_dot_line_rotation_value\": \"旋转角度\",\n      \"option_x_axis_label_dot_line_space_width\": \"刻度间距\",\n      \"option_x_axis_label_dot_line_space_width_desc\": \"X轴刻度是单层散点模式下，刻度之间的最小间距，默认是50（即每50px显示一个刻度）\",\n      \"option_x_axis_label_max_height_percent\": \"最大高度(%)\",\n      \"option_x_axis_label_max_height_percent_desc\": \"X轴是单层散点模式下，超出最大高度百分比时，截取字符串显示；其他模式下，超出最大高度时，将不显示X轴刻度\",\n      \"option_font_style\": \"字体\",\n      \"option_font_alignment\": \"对齐方式\",\n      \"category_y_axis\": \"Y轴\",\n      \"option_y_axis_label_max_width_percent\": \"最大宽度(%)\",\n      \"option_measure_configure\": \"格式配置\",\n      \"category_right_y_axis\": \"右Y轴\",\n      \"category_color\": \"图形配置\",\n      option_legend_shape_type: '形状',\n      option_legend_shape_type_column: '柱状图',\n      option_legend_shape_type_line: '折线图',\n      category_column_config: '柱体配置',\n      category_line_config: '线条配置',\n      \"option_chart_column_minimum_width\": \"最小柱宽\",\n      \"option_chart_column_minimum_width_desc\": \"在您没有配置固定刻度宽度及固定每页刻度数的情况下，会依据画图区域宽度及最小柱宽自适应画图数据，默认最小柱宽是5px\",\n      \"option_chart_column_width\": \"固定柱宽\",\n      \"option_chart_column_width_desc\": \"配置固定柱宽后，图形中X轴每个刻度中柱子的宽度是当前配置值 * 柱宽比例 。 <br />没有配置的情况下，依据最小柱宽及画图区域宽度自适应刻度宽度\",\n      \"option_chart_column_width_percent_desc\": \"设置图表中柱子占刻度的宽度比例(0%~100%)，默认为60%\",\n      \"option_chart_default_step\": \"固定每页刻度数\",\n      \"option_chart_default_step_desc\": \"配置图形中按X轴刻度分页时，每页的刻度数量。 默认情况下，图形依据画图区域宽度及最小柱宽自适应刻度数 \",\n      \"option_suspend_text_regex_desc\": \"要显示的文本。有以下替换宏可用：<br /> \" + \"<span class='mr3'>[值]</span> - 对应的Y轴的数值 <br />\" + \"<span class='mr3'>[属性]</span> - 显示的数值标签为对应的X轴的值<br /> \" + \"<span class='mr3'>[刻度]</span> - 显示的数值标签为对应的X轴的值<br /> \" + \"<span class='mr3'>[刻度索引]</span> - 数值标签为对应的X轴值的顺序 <br /> \" + \"<span class='mr3'>[类别]</span> - 对应的图例的类别值<br /> \" + \"<span class='mr3'>[类别索引]</span> - 对应的图例的类别顺序索引<br /> \" + \"<span class='mr3'>[刻度总和]</span> - 可显示X轴为某个值时所有Y轴的数值之和 <br /> \" + \"<span class='mr3'>[刻度平均值]</span> - 可显示X轴为某个值时所有Y轴的平均值<br /> \" + \"<span class='mr3'>[类别百分比]</span> - X轴的刻度上Y值占所有Y值总和的百分比 <br />\" + \"<span class='mr3'>[刻度百分比]</span> - X轴的刻度上Y值占该X刻度上所有Y值总和的百分比 <br /> \" + \"<span class='mr3'>[(列N)]</span> - 第N列的数值 <br /> \" + \"<span class='mr3'>[换行]</span> - 换行符\",\n      \"%_NAME\": \"属性\",\n      \"%_NAME_desc\": \"对应的X轴的刻度值\",\n      \"%_VALUE\": \"值\",\n      \"%_VALUE_desc\": \"对应的Y轴的数值\",\n      \"%_VALUE_NAME\": \"值名称\",\n      \"%_VALUE_NAME_desc\": \"对应的Y轴的名称\",\n      \"%_SERIES_NAME\": \"类别\",\n      \"%_SERIES_NAME_desc\": \"对应的图例的类别值\",\n      \"%_SERIES_NUMBER\": \"类别索引\",\n      \"%_SERIES_NUMBER_desc\": \"对应的图例的类别顺序索引\",\n      \"%_CATEGORY_NAME\": \"刻度\",\n      \"%_CATEGORY_NAME_desc\": \"对应的X轴的刻度值\",\n      \"%_CATEGORY_NUMBER\": \"刻度索引\",\n      \"%_CATEGORY_NUMBER_desc\": \"对应的X轴的刻度顺序索引\",\n      \"%_CATEGORY_TOTAL\": \"刻度总和\",\n      \"%_CATEGORY_TOTAL_desc\": \"各个X轴刻度上所有Y轴值的总和\",\n      \"%_CATEGORY_AVERAGE\": \"刻度平均值\",\n      \"%_CATEGORY_AVERAGE_desc\": \"各个X轴刻度上所有Y轴值的平均值\",\n      \"%_PERCENT_OF_TOTAL\": \"类别百分比\",\n      \"%_PERCENT_OF_TOTAL_desc\": \"X轴的刻度上Y值占所有Y值总和的百分比\",\n      \"%_PERCENT_OF_CATEGORY\": \"刻度百分比\",\n      \"%_PERCENT_OF_CATEGORY_desc\": \"X轴的刻度上Y值占该X刻度上所有Y值总和的百分比\",\n      \"%_BR\": \"换行\",\n      \"option_grid_show_all_line\": \"显示全部网格线\",\n      \"option_grid_line_style\": \"网格线样式\",\n      \"option_grid_line_style_desc\": \"配置所有网格线的样式，包括虚实，颜色及粗细\",\n      \"option_grid_show_only_zero_line\": \"只显示零线\",\n      \"option_grid_show_only_zero_line_desc\": \"配置后，网格线中非零线将全部隐藏，只显示零线 <br /> 如果Y轴最小值大于0，则没有零线，所有网格线均都不显示 \",\n      \"option_grid_zero_line_style\": \"零线样式\",\n      \"option_grid_zero_line_style_desc\": \"配置零线的样式，包括虚实，颜色及粗细\",\n      \"option_scale_y_visible\": \"显示/隐藏\",\n      \"option_line_style_linear\": \"线性\",\n      \"option_line_style_step\": \"阶梯\",\n      \"option_line_style_step_after\": \"阶梯后对齐\",\n      \"option_line_style_step_before\": \"阶梯前对齐\",\n      \"option_line_style_curve_basis\": \"Basis曲线\",\n      \"option_line_style_curve_natural\": \"自然曲线\",\n      \"option_line_style_curve_bump_x\": \"二阶贝塞尔曲线\",\n      \"option_line_style_curve_monotone_x\": \"MonotoneX曲线\",\n      \"option_line_style_curve_monotone_y\": \"MonotoneY曲线\",\n      \"option_thickness_of_line\": \"线宽\",\n      \"option_thickness_of_line_desc\": \"设置图表中线条的宽度\",\n      \"option_chart_column_stack\": \"柱体堆积展示\",\n      \"option_chart_column_stack_desc\": \"同一刻度下，堆积展示柱体\",\n      \"option_show_point\": \"显示节点\",\n      \"option_show_point_desc\": \"设置是否显示节点\",\n      \"option_symbol_size_of_line\": \"节点半径\",\n      \"option_symbol_size_of_line_desc\": \"设置节点的半径\",\n      \"option_point_stroke\": \"节点描边\",\n      \"option_point_stroke_desc\": \"是否开启节点描边\",\n      \"option_point_stroke_style\": \"描边样式\",\n      \"option_point_stroke_style_desc\": \"设置节点描边线条的样式\",\n      \"option_show_line_shadow\": '阴影线',\n      \"option_show_line_shadow_desc\": '设置线条是否开启阴影'\n    },\n    english: {\n      \"option_chart_column_stack\": \"Stack column\",\n      \"option_chart_column_stack_desc\": \"Stack column at the same scale\",\n      \"system_auto_default\": \"Auto\",\n      \"user_define_text\": \"Define\",\n      \"category_x_axis\": \"X Axis\",\n      \"option_x_axis_right_first_flag\": \"Prioritize drawing the rightmost data on the X-axis\",\n      \"option_x_axis_right_first_flag_desc\": \"By default, the data is drawn from the leftmost side of the X-axis, and when it exceeds one screen, it is paginated to the right.<br/> After enabling priority drawing of the rightmost data on the X-axis, start drawing from the rightmost data on the X-axis and display it in a left page when it exceeds one screen\",\n      \"option_x_axis_draw_type\": \"X axis type\",\n      \"option_select_x_axis_dot_line\": \"Single dot\",\n      \"option_select_x_axis_time_line\": \"Time \",\n      \"option_select_x_axis_level_line\": \"Multi level\",\n      \"option_x_axis_draw_type_desc\": \"There are three types of X-axis in total:\" + \"<br /> Multi level<span class='color-main-green'>[Auto]</span>: 2 or 3 attribute columns on the X-axis, it will automatically recognize the multi level \" + \"<br /> Time line<span class='color-main-green'>[Auto]</span>: only one time column on the X-axis and it is aggregated daily / hourly / minutely , it will automatically recognize the time line\" + \"<br /> Single dot<span class='color-main-green'>[Auto]</span>: All data can be forced to display the single level\" + \"<br /> The system will automatically adapt to the appropriate X-axis, but you can forcibly switch to the single level\",\n      \"option_axis_label_visible\": \"Axis Label\",\n      \"option_axis_title_visible\": \"Axis Title\",\n      \"option_axis_title_visible_desc\": \"In automatic mode, the title will be displayed on the answer detail page and hidden in the pinboard\",\n      \"option_title_visible_show\": \"Show\",\n      \"option_title_visible_hide\": \"Hidden\",\n      \"option_axis_title_content\": \"Title Content\",\n      \"option_axis_title_content_desc\": \"By default, column names on the axis will be used\",\n      \"option_x_axis_label_dot_line_rotation_value\": \"Rotate\",\n      \"option_x_axis_label_dot_line_space_width\": \"Label Spacing\",\n      \"option_x_axis_label_dot_line_space_width_desc\": \"The scale is the minimum spacing between labels in single level axis, with a default of 50 (i.e. one scale displayed every 50px)\",\n      \"option_x_axis_label_max_height_percent\": \"Max height(%)\",\n      \"option_x_axis_label_max_height_percent_desc\": \"The axis is in single level, and when the maximum height percentage is exceeded, the string is truncated and displayed; In other modes, when the maximum height is exceeded, the scale will not be displayed\",\n      \"option_font_style\": \"Font\",\n      \"option_font_alignment\": \"Alignment\",\n      \"category_y_axis\": \"Y Axis\",\n      \"option_y_axis_label_max_width_percent\": \"Max Width(%)\",\n      \"option_measure_configure\": \"Data Format\",\n      \"category_right_y_axis\": \"Right Y Axis\",\n      \"category_color\": \"Color\",\n      \"option_chart_column_minimum_width\": \"Adaptive minimum column width\",\n      \"option_chart_column_minimum_width_desc\": \"If you do not configure a fixed scale width and a fixed number of divisions per page, the drawing data will be adaptively drawn based on the drawing area width and minimum column width. The default minimum column width is 5px\",\n      \"option_chart_column_width\": \"Fixed column width\",\n      \"option_chart_column_width_desc\": \"After configuring a fixed column width, each column width on the X-axis in the graph is the current configured value <br/> Without configuration, adjust the scale width adaptively based on the minimum column width and drawing area width\",\n      \"option_chart_column_width_percent_desc\": \"Set the percent of the column in the chart (0% ~ 100%), default 60%\",\n      \"option_chart_default_step\": \"Fixed ticks number per page\",\n      \"option_chart_default_step_desc\": \"Configure the number of ticks per page when pagination is based on the X-axis scale in the graph. By default, the graph adapts the number of divisions based on the width of the drawing area and the minimum column width\",\n      \"option_suspend_text_regex_desc\": \"The text to be displayed. The following replacement macros are available:<br /> \" + \"<span class='mr3'>[Value]</span> - The corresponding value of the Y-axis <br />\" + \"<span class='mr3'>[Attribute]</span> - The displayed numerical labels are the corresponding X-axis values<br /> \" + \"<span class='mr3'>[Label]</span> - The displayed numerical labels are the corresponding X-axis values<br /> \" + \"<span class='mr3'>[Label Index]</span> - The order in which the numerical labels correspond to the X-axis values <br /> \" + \"<span class='mr3'>[Series]</span> - The series value of the corresponding legend<br /> \" + \"<span class='mr3'>[Series Index]</span> - The series order of the corresponding legend<br /> \" + \"<span class='mr3'>[Label Total]</span> - Can display the sum of all Y-axis values when the X-axis is a certain value <br /> \" + \"<span class='mr3'>[Label AVG]</span> - Can display the average value of all Y-axes when the X-axis is a certain value<br /> \" + \"<span class='mr3'>[Series Percentage]</span> - The percentage of Y values on the scale of the X-axis to the total of all Y values on the legend<br />\" + \"<span class='mr3'>[Label Percentage]</span> - The percentage of Y values on the scale of the X-axis to the total of all Y values on that scale <br /> \" + \"<span class='mr3'>[(ColumnN)]</span> - Value in column N <br /> \" + \"<span class='mr3'>[Wrap]</span> - Line break\",\n      \"%_NAME\": \"Attribute\",\n      \"%_NAME_desc\": \"The displayed numerical labels are the corresponding X-axis values\",\n      \"%_VALUE\": \"Value\",\n      \"%_VALUE_desc\": \"The corresponding value of the Y-axis\",\n      \"%_VALUE_NAME\": \"Value Name\",\n      \"%_VALUE_NAME_desc\": \"The corresponding y-axis column name\",\n      \"%_SERIES_NAME\": \"Series\",\n      \"%_SERIES_NAME_desc\": \"The category value of the corresponding legend\",\n      \"%_SERIES_NUMBER\": \"Series Index\",\n      \"%_SERIES_NUMBER_desc\": \"Category order index of corresponding legend\",\n      \"%_CATEGORY_NAME\": \"Label\",\n      \"%_CATEGORY_NAME_desc\": \"The corresponding X-axis scale value\",\n      \"%_CATEGORY_NUMBER\": \"Label Index\",\n      \"%_CATEGORY_NUMBER_desc\": \"Corresponding X-axis scale sequence index\",\n      \"%_CATEGORY_TOTAL\": \"Label Total\",\n      \"%_CATEGORY_TOTAL_desc\": \"The sum of all Y-axis values on each X-axis scale\",\n      \"%_CATEGORY_AVERAGE\": \"Label AVG\",\n      \"%_CATEGORY_AVERAGE_desc\": \"The average value of all Y-axis values on each X-axis scale\",\n      \"%_PERCENT_OF_TOTAL\": \"Series Percentage\",\n      \"%_PERCENT_OF_TOTAL_desc\": \"The percentage of Y value on the X-axis scale to the total sum of all Y values\",\n      \"%_PERCENT_OF_CATEGORY\": \"Label Percentage\",\n      \"%_PERCENT_OF_CATEGORY_desc\": \"The percentage of Y value on the X-axis scale to the total sum of all Y values on that X-axis scale\",\n      \"%_BR\": \"Wrap\",\n      \"option_grid_show_all_line\": \"Show all grid lines\",\n      \"option_grid_line_style\": \"Line style\",\n      \"option_grid_line_style_desc\": \"Configure the styles of all grid lines, including virtual and solid, color, and thickness\",\n      \"option_grid_show_only_zero_line\": \"Only show the zero line\",\n      \"option_grid_show_only_zero_line_desc\": \"After configuration, all non zero lines in the grid lines will be hidden, and only zero lines will be displayed.<br/>If the minimum value of the Y-axis is greater than 0, there will be no zero lines, and all grid lines will not be displayed\",\n      \"option_grid_zero_line_style\": \"Zero line style\",\n      \"option_grid_zero_line_style_desc\": \"Configure the style of the zero line, including virtual and solid, color, and thickness\",\n      \"option_scale_y_visible\": \"Show/Hide\"\n    }\n  },\n  // [*必填项]生成当前图表类型的模板数据\n  getTemplateData: function () {}\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/combination/systemCombinationChart.js?");

/***/ })

}]);