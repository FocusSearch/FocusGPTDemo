(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[3],{

/***/ "../src-v5/assets/js/charts.components/AttributeAxisComponent.js":
/*!***********************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/AttributeAxisComponent.js ***!
  \***********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _d3v7Export__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n// 画属性轴的组件： 画dotline类型的属性轴[ 水平/垂直 ] ； 画levelline类型的属性轴 ； 画timeline类型的属性轴[ 水平/垂直 ]\n\n\n\n\nlet AttributeAxisComponent = {\n  /**\r\n   * 画水平方向的属性坐标\r\n   * @param options\r\n   *     {\r\n   *         axisType                 -   轴类型 timeLine: 时间轴 ； levelLine: 多层刻度轴 ； dotLine: 单层刻度轴 ；\r\n   *         attributeValueList       -   刻度数组\r\n   *         attributeValueMap        -   刻度数组对应的详细信息[ 接受TranslateDataComponent.translateXYLegendBasicData处理的数据 ]\r\n   *\r\n   *     }\r\n   * **/\n  drawHorizontalAttributeAxis: function (options) {\n    options = options || {};\n    let self = this,\n      resultObj;\n    const previousXAxis = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(options.svgContainer).select('g.x-axis');\n    const previousXAxisType = !previousXAxis.empty() && previousXAxis.attr('data-axis-type');\n    if (previousXAxisType !== options.axisType) previousXAxis.remove();\n    switch (options.axisType) {\n      case \"timeLine\":\n        // todo 注： 时间轴Mappding的值与globalModule中translateSearchResult方法中规范不同聚合方式下的时间的数据格式一致\n        //  时间轴[ 每分 / 每小时 / 每天 ]\n        if (options.position === 'bottom') {\n          // 目前时间轴只支持在底部\n          resultObj = self.drawAttributeTimeLineAxis(options);\n        } else {\n          // 目前支支持其他位置不支持时间轴\n          resultObj = self.drawAttributeDotLineAxis(options);\n        }\n        break;\n      case \"levelLine\":\n        //  多层属性刻度轴\n        resultObj = self.drawAttributeLevelLineAxis(options);\n        break;\n      case \"dotLine\":\n      default:\n        // 单层属性刻度轴\n        resultObj = self.drawAttributeDotLineAxis(options);\n        break;\n    }\n    return resultObj;\n  },\n  /**\r\n   * 画竖直方向的属性坐标\r\n   * @param options\r\n   *     {\r\n   *         axisType                 -   轴类型 timeLine: 时间轴 ； levelLine: 多层刻度轴 ； dotLine: 单层刻度轴 ；\r\n   *         attributeValueList       -   刻度数组\r\n   *         attributeValueMap        -   刻度数组对应的详细信息[ 接受TranslateDataComponent.translateXYLegendBasicData处理的数据 ]\r\n   *\r\n   *     }\r\n   * **/\n  drawVerticalAttributeAxis: function (options) {\n    options = options || {};\n    let self = this,\n      resultObj;\n    switch (options.axisType) {\n      case \"timeLine\":\n        // todo 注： 时间轴Mappding的值与globalModule中translateSearchResult方法中规范不同聚合方式下的时间的数据格式一致\n        //  时间轴[ 每分 / 每小时 / 每天 ]\n        if (options.position === 'bottom') {\n          // 目前时间轴只支持在底部\n          resultObj = self.drawAttributeTimeLineAxis(options);\n        } else {\n          // 目前支支持其他位置不支持时间轴\n          resultObj = self.drawAttributeDotLineAxis(options);\n        }\n        break;\n      case \"levelLine\":\n        //  多层属性刻度轴\n        resultObj = self.drawAttributeLevelLineAxis(options);\n        break;\n      case \"dotLine\":\n      default:\n        // 单层属性刻度轴\n        resultObj = self.drawAttributeDotLineAxis(options);\n        break;\n    }\n    return resultObj;\n  },\n  /***\r\n   * 画单层刻度属性轴[ 垂直方向/水平方向 ]\r\n   * @param options\r\n   * {\r\n   *      svgContainer            -   画图容器svg\r\n   *      drawWidth               -   画图容器中图形部分的宽度【去除了标题部分】\r\n   *      drawHeight              -   画图容器中图形部分的高度【去除了标题部分】\r\n   *      axisFontSize            -   坐标字体大小\r\n   *      position                -   刻度位置及方向， left：左垂直 ； top: 上水平  ； bottom: 下水平  ； right： 右垂直\r\n   *      attributeValueList      -   刻度数组\r\n   *      attributeValueMap       -   刻度数组的补充信息\r\n   *\r\n   *      scaleWidth              -   水平(top/bottom)时，属性轴刻度宽度\r\n   *      maxLabelHeightPercent   -   水平(top/bottom)时，属性轴最大高度限制 0 - 100\r\n   *      rotate                  -   水平(top/bottom)时，属性刻度旋转角度\r\n   *      labelStepWidth          -   水平(top/bottom)时，每个属性刻度的所占的最小宽度\r\n   *\r\n   *      scaleHeight             -   垂直(left/right)时, 属性轴刻度高度\r\n   *      maxLabelWidthPercent    -   垂直(left/right)时，属性轴最大宽度限制\r\n   *      labelStepHeight         -   垂直(left/right)时，每个属性刻度的所占的最小高度，默认20， 即每隔20px放置一个可以\r\n   *\r\n   *      attributeAxisVisible    -   是否显示数据标签的标志，undefined/null情况下默认为true\r\n   * }\r\n   * */\n  drawAttributeDotLineAxis: function (options) {\n    options = options || {};\n    if (!options.svgContainer || !options.drawWidth || !options.drawHeight || !options.attributeValueList || !options.attributeValueList.length) return false;\n    let theSvgContainer = options.svgContainer,\n      thePosition = options.position || 'bottom',\n      theDirection = ['top', 'bottom'].indexOf(thePosition) > -1 ? 'horizontal' : 'vertical',\n      attributeValueList = options.attributeValueList,\n      attributeValueMap = options.attributeValueMap,\n      axisFontSize = parseInt(options.axisFontSize) || 10,\n      axisFontColor = options.axisFontColor,\n      axisFontBold = options.axisFontBold === undefined ? 'inherit' : options.axisFontBold ? 'bold' : 500,\n      axisFontItalic = options.axisFontItalic === undefined ? 'inherit' : options.axisFontItalic ? 'italic' : 'normal',\n      start = parseInt(options.start) || 0,\n      end = parseInt(options.end) || options.attributeValueList.length,\n      attributeAxisVisible = options.attributeAxisVisible === undefined || options.attributeAxisVisible === null ? true : options.attributeAxisVisible;\n    const animateFlag = options.animateFlag;\n    const duration = {\n      enter: animateFlag ? 300 : 0,\n      update: animateFlag ? 300 : 0,\n      exit: animateFlag ? 300 : 0\n    };\n    let theAttributeList = attributeValueList && attributeValueList.filter(function (theAttribute, index) {\n      return index >= start && index < end;\n    });\n    let returnResult = {};\n    let theMaxValueSize = {\n        width: 0,\n        height: 0\n      },\n      theAttributeValueIndexMap = {};\n    theAttributeList && theAttributeList.forEach(function (theLabel, index) {\n      let theValueSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theLabel, {\n        fontSize: axisFontSize\n      });\n      theMaxValueSize.width = Math.max(theValueSize.width, theMaxValueSize.width);\n      theMaxValueSize.height = Math.max(theValueSize.height, theMaxValueSize.height);\n      theAttributeValueIndexMap[theLabel] = index;\n    });\n    const svgContainer = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(theSvgContainer);\n    switch (theDirection) {\n      case \"vertical\":\n        // 校验垂直方向刻度高度是否合理\n        if (!_DataFocusMethod.isPureNumber(options.scaleHeight) || !options.scaleHeight) {\n          console.log('垂直方向属性Axis轴没有合法的高度值');\n          return false;\n        }\n        let maxLabelWidthPercent = parseFloat(options.maxLabelWidthPercent / 100);\n        if (isNaN(maxLabelWidthPercent)) maxLabelWidthPercent = 0.3;\n        const maxLabelWidth = options.drawWidth * maxLabelWidthPercent; // 最大宽度限制\n\n        const theVerticalAttrContainer = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reuseElement({\n          container: svgContainer,\n          selector: 'g.axis.x-axis.x-axis-vertical',\n          elementCreator: () => svgContainer.append('g').attr(\"class\", \"axis x-axis x-axis-vertical\")\n        }).attr(\"class\", \"axis x-axis x-axis-vertical\").style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || \"inherit\").style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n\n        // 刻度间距\n        const theLabelStepHeight = _DataFocusMethod.isPureNumber(options.labelStepWidth) ? parseInt(options.labelStepWidth) : 25;\n        let theScaleHeight = options.scaleHeight,\n          theVerticalXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(theAttributeList).rangeBands([0, theScaleHeight]),\n          theVerticalXRangeBand = theVerticalXScale.rangeBand(),\n          // 当前比例尺下每个刻度的宽度\n          verticalColumnLabelStep = Math.ceil(theLabelStepHeight / theVerticalXRangeBand);\n        verticalColumnLabelStep = Math.max(1, verticalColumnLabelStep);\n        let haveShowALabelFlag = false;\n        const shownAttributeList = theAttributeList && theAttributeList.filter(function (d, i) {\n          let theShowFlag = verticalColumnLabelStep === 1 || i % verticalColumnLabelStep === Math.ceil(verticalColumnLabelStep / 2) && verticalColumnLabelStep !== 1;\n          haveShowALabelFlag = haveShowALabelFlag || theShowFlag;\n\n          // 如果等到最后一条数据，还没有显示过一个标签，则最后一个标签必须显示\n          if (i === theAttributeList.length - 1 && !haveShowALabelFlag) {\n            theShowFlag = true;\n          }\n          return theShowFlag;\n        }) || [];\n        let attributeLabelList, attributeLabelTexts;\n        // 绘制刻度轴\n        if (attributeAxisVisible) {\n          // 刻度容器\n          attributeLabelList = theVerticalAttrContainer.selectAll(\"g.x-axis.label\").data(shownAttributeList, d => d).join(enter => enter.append('g').attr('class', 'x-axis label').attr('opacity', 0).attr(\"transform\", function (d) {\n            return `translate(0, ${theVerticalXScale(d)})`;\n          }).transition().duration(0).attr('opacity', 1), update => update.transition().duration(0).attr(\"transform\", function (d) {\n            return `translate(0, ${theVerticalXScale(d)})`;\n          }), exit => exit.remove());\n\n          // 刻度文字tag\n          attributeLabelTexts = attributeLabelList.append(\"text\").attr(\"class\", \"axis-x-label\").attr(\"transform\", function () {\n            return `translate(0, ${theVerticalXRangeBand / 2})`;\n          }).attr('text-anchor', 'end').attr('dominant-baseline', 'middle');\n\n          // 刻度文字内容\n          attributeLabelTexts.text(function (d) {\n            let dText = d;\n            // X轴刻度需要数据转换， 由于时间格式配置 或 时间聚合引起的\n            if (attributeValueMap && attributeValueMap[d]) {\n              dText = attributeValueMap[d].text;\n            }\n            if (!dText) return;\n            let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                fontSize: axisFontSize\n              }),\n              baseTextWidth = maxLabelWidth;\n\n            // 文字最大宽度过小的情况下，不显示文字标签\n            if (baseTextWidth < 1) return '';else if (baseTextWidth < 3) return '.';\n\n            // 获取未超出宽度内的文字内容，并补充...\n            if (theTextSize.width > baseTextWidth) {\n              let theSubText = '';\n              for (let i = 0; i < dText.length; i++) {\n                let chart = dText.charAt(i);\n                // 如果当前文本 + '..'后超出限制，则不再加标签了\n                let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText + chart + (theSubText.length < dText.length ? '..' : ''), {\n                  fontSize: axisFontSize\n                });\n                if (theSubTextSize.width >= baseTextWidth) {\n                  break;\n                } else {\n                  theSubText += chart;\n                }\n              }\n              if (theSubText.length === dText.length) {\n                return dText;\n              } else if (theSubText) {\n                return theSubText + '..';\n              }\n            }\n            return dText;\n          }).append(\"title\").text(function (d) {\n            return d;\n          });\n        }\n\n        // 重新计算整个图轴区域的高度\n        let theMaxLabelWidth = 0;\n        let theBoundingWidth = theVerticalAttrContainer.node().getBBox().width;\n        theMaxLabelWidth = Math.max(theMaxLabelWidth, theBoundingWidth);\n        attributeLabelTexts && attributeLabelTexts.attr(\"transform\", `translate(${theMaxLabelWidth}, ${theVerticalXRangeBand / 2})`);\n\n        // [ 因为实际的宽度与最大宽度会有误差 ]如果超出了最大宽度限制，则不显示X轴刻度了【 如果误差超过5就显示 】\n        if (theMaxLabelWidth - maxLabelWidth > 5) {\n          theMaxLabelWidth = 0;\n          theVerticalAttrContainer.remove();\n        }\n        returnResult.maxLabelWidth = theMaxLabelWidth;\n        returnResult.scale = theVerticalXScale;\n        returnResult.rangeBand = theVerticalXRangeBand;\n        returnResult.attributeContainer = theVerticalAttrContainer;\n        break;\n      case \"horizontal\":\n      default:\n        // 校验水平方向刻度宽度是否合理\n        if (!_DataFocusMethod.isPureNumber(options.scaleWidth) || !options.scaleWidth) {\n          console.log('水平方向属性Axis轴没有合法的宽度值');\n          return false;\n        }\n\n        // 没设置的情况下，0.3的高度限制\n        let maxLabelHeightPercent = parseFloat(options.maxLabelHeightPercent / 100);\n        if (isNaN(maxLabelHeightPercent)) maxLabelHeightPercent = 0.3;\n        let maxLabelHeight = options.drawHeight * maxLabelHeightPercent;\n        const theHorizontalAttrContainer = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reuseElement({\n          container: svgContainer,\n          selector: 'g.x-axis.x-axis-horizontal',\n          elementCreator: () => svgContainer.append(\"g\").attr(\"class\", \"axis x-axis x-axis-horizontal\").attr('data-axis-type', 'dotLine')\n        }).style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || \"inherit\").style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n        let theMaxValueSize = {\n            width: 0,\n            height: 0\n          },\n          theAttributeValueIndexMap = {};\n        theAttributeList && theAttributeList.forEach(function (theLabel, index) {\n          let theValueSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theLabel, {\n            fontSize: axisFontSize\n          });\n          theMaxValueSize.width = Math.max(theValueSize.width, theMaxValueSize.width);\n          theMaxValueSize.height = Math.max(theValueSize.height, theMaxValueSize.height);\n          theAttributeValueIndexMap[theLabel] = index;\n        });\n        let theLabelStepWidth = _DataFocusMethod.isPureNumber(options.labelStepWidth) ? parseInt(options.labelStepWidth) : 50;\n        let theWidth = options.scaleWidth,\n          theXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(theAttributeList).rangeBands([0, theWidth]),\n          theXRangeBand = theXScale.rangeBand(),\n          columnLabelStep = Math.ceil(theLabelStepWidth / theXRangeBand),\n          theXLabelRotate = 0;\n        columnLabelStep = Math.max(1, columnLabelStep);\n\n        // 单个刻度宽度放不下属性刻度时，需要旋转摆放\n        if (theMaxValueSize.width > theXRangeBand) {\n          if (_DataFocusMethod.isPureNumber(options.rotate)) {\n            theXLabelRotate = parseInt(options.rotate);\n          } else {\n            theXLabelRotate = theXLabelRotate || 30;\n          }\n        }\n\n        // 当单个标签被旋转时，有旋转空余的高度\n        let theRotateHeight = axisFontSize / 2;\n        //绘制刻度下的x轴显示信息[ 所有的刻度中至少显示一个 ]\n        if (attributeAxisVisible) {\n          let haveShowALabelFlag = false;\n          const attributeData = theAttributeList && theAttributeList.filter(function (d, i) {\n            let theShowFlag = !(!d || i % columnLabelStep !== Math.ceil(columnLabelStep / 2) && columnLabelStep !== 1);\n            haveShowALabelFlag = haveShowALabelFlag || theShowFlag;\n\n            // 如果等到最后一条数据，还没有显示过一个标签，则最后一个标签必须显示\n            if (i === theAttributeList.length - 1 && !haveShowALabelFlag) {\n              theShowFlag = true;\n            }\n            return theShowFlag;\n          }) || [];\n          let attributeLabelList = theHorizontalAttrContainer.selectAll(\"g.label\").data(attributeData, d => d).join(enter => enter.append('g').attr('class', 'x-axis label').attr('opacity', 0).attr(\"transform\", function (d) {\n            return `translate(${theXScale(d) - 8}, 0)`;\n          }).transition('fade-in').duration(duration.enter).attr('opacity', 1).attr(\"transform\", function (d) {\n            return `translate(${theXScale(d)}, 0)`;\n          }), update => update.transition().duration(duration.update).attr(\"transform\", function (d) {\n            return `translate(${theXScale(d)}, 0)`;\n          }), exit => exit.remove());\n\n          // 绘制刻度值\n          let attributeLabelTexts = attributeLabelList.selectAll('.axis-x-label').data(d => [d], d => d).join(enter => enter.append('text').attr(\"class\", \"axis-x-label\").attr(\"transform\", function () {\n            let theCosValue = Math.cos(theXLabelRotate * Math.PI / 180);\n            return 'translate(' + (theXLabelRotate ? theXRangeBand / 2 + theXRangeBand / 4 * Math.pow(theCosValue, 4) : theXRangeBand / 2) + ', ' + axisFontSize / 2 + '  ) ' + (theXLabelRotate ? ' rotate(-' + theXLabelRotate + ')' : '');\n          }).style(\"text-anchor\", !theXLabelRotate || theXLabelRotate === 180 ? 'middle' : 'end').style(\"dominant-baseline\", options.position === 'bottom' ? theXLabelRotate > 100 ? \"auto\" : \"central\" : \"central\"), update => update.transition().duration(duration.update).attr(\"transform\", function () {\n            let theCosValue = Math.cos(theXLabelRotate * Math.PI / 180);\n            return 'translate(' + (theXLabelRotate ? theXRangeBand / 2 + theXRangeBand / 4 * Math.pow(theCosValue, 4) : theXRangeBand / 2) + ', '\n            // + (theMaxValueSize.height / 2 * Math.cos(theXLabelRotate * Math.PI / 180)) +' ) '\n            + axisFontSize / 2 + '  ) ' + (theXLabelRotate ? ' rotate(-' + theXLabelRotate + ')' : '');\n          }).style(\"text-anchor\", !theXLabelRotate || theXLabelRotate === 180 ? 'middle' : 'end').style(\"dominant-baseline\", options.position === 'bottom' ? theXLabelRotate > 100 ? \"auto\" : \"central\" : \"central\"), exit => exit.remove());\n          attributeLabelTexts.text(function (d) {\n            let dText = d;\n            // X轴刻度需要数据转换， 由于时间格式配置 或 时间聚合引起的\n            if (attributeValueMap && attributeValueMap[d]) {\n              dText = attributeValueMap[d].text;\n            }\n            let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                fontSize: axisFontSize\n              }),\n              baseTextHeight = maxLabelHeight;\n            if (!dText) return;\n            if (baseTextHeight < 1) return '';else if (baseTextHeight < 3) return '.';\n            // 如果当前倾斜放置不够当前文本，则需要截取\n            if (theXLabelRotate) {\n              let theLabelHeight = theTextSize.height;\n              if (theXLabelRotate > 90) {\n                theLabelHeight = theTextSize.width * Math.cos((theXLabelRotate - 90) / 180 * Math.PI) + theTextSize.height * Math.sin((theXLabelRotate - 90) / 180 * Math.PI);\n              } else {\n                theLabelHeight = theTextSize.width * Math.sin(theXLabelRotate / 180 * Math.PI) + theTextSize.height * Math.cos(theXLabelRotate / 180 * Math.PI);\n              }\n              if (theLabelHeight > baseTextHeight - theRotateHeight) {\n                let theSubText = '';\n                for (let i = 0; i < dText.length; i++) {\n                  let chart = dText.charAt(i);\n                  let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText + chart + (theSubText.length + 1 < dText.length ? '..' : ''), {\n                    fontSize: axisFontSize\n                  });\n                  let theHeight = theSubTextSize.height;\n                  if (theXLabelRotate > 90) {\n                    theHeight = theSubTextSize.width * Math.cos((theXLabelRotate - 90) / 180 * Math.PI) + theSubTextSize.height * Math.sin((theXLabelRotate - 90) / 180 * Math.PI);\n                  } else {\n                    theHeight = theSubTextSize.width * Math.sin(theXLabelRotate / 180 * Math.PI) + theSubTextSize.height * Math.cos(theXLabelRotate / 180 * Math.PI);\n                  }\n                  if (theHeight > baseTextHeight - theRotateHeight) {\n                    break;\n                  } else {\n                    theSubText += chart;\n                  }\n                }\n                if (theSubText.length === dText.length) {\n                  return dText;\n                } else if (theSubText) {\n                  return theSubText + '..';\n                }\n              }\n            } else {\n              // 如果不倾斜，则按区域宽度截取\n              if (theTextSize.width > theXRangeBand * Math.max(1, columnLabelStep - 1)) {\n                let theSubText = '';\n                for (let i = 0; i < dText.length; i++) {\n                  let chart = dText.charAt(i);\n                  theSubText += chart;\n                  let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                    fontSize: axisFontSize\n                  });\n                  if (theSubTextSize.width > theXRangeBand * Math.max(1, columnLabelStep - 1)) {\n                    break;\n                  }\n                }\n                if (theSubText.length === dText.length) {\n                  return dText;\n                } else {\n                  return theSubText + '..';\n                }\n              }\n            }\n            return dText;\n          }).append(\"title\").text(function (d) {\n            return d;\n          });\n          let theMaxLabelHeight = 0;\n          // 统计所有X刻度中的最大高度\n          attributeLabelTexts && attributeLabelTexts.each(function () {\n            let theDom = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(this);\n            let theBoundingHeight = theDom.node().getBBox().height;\n            theMaxLabelHeight = Math.max(theMaxLabelHeight, theBoundingHeight);\n          });\n\n          // 如果标签是在上面，则文本是在\n          if (thePosition === 'top') {\n            attributeLabelTexts.attr('transform', function () {\n              let theCosValue = Math.cos(theXLabelRotate * Math.PI / 180);\n              return 'translate(' + (theXLabelRotate ? theXRangeBand / 2 - theXRangeBand / 4 * Math.pow(theCosValue, 4) : theXRangeBand / 2) + ', ' + (theMaxLabelHeight - theMaxValueSize.height / 2 * Math.cos(theXLabelRotate * Math.PI / 180)) + ') ' + (theXLabelRotate ? ' rotate(-' + theXLabelRotate + ')' : '');\n            }).attr(\"text-anchor\", theXLabelRotate ? 'start' : 'middle');\n          }\n        }\n\n        // 重新计算整个图轴区域的高度\n        let theMaxLabelHeight = 0;\n        let theBoundingHeight = theHorizontalAttrContainer.node().getBBox().height;\n        theMaxLabelHeight = Math.max(theMaxLabelHeight, theBoundingHeight);\n        // 当旋转时，有旋转高度需要\n        if (theXLabelRotate) theMaxLabelHeight += theRotateHeight;\n\n        // 先按照maxLabelHeight截取字符串，但是会倾斜放置，所以实际高度在画图区域比较小时才会超出最大高度\n        if (theMaxLabelHeight - maxLabelHeight > 5) {\n          theMaxLabelHeight = 0;\n          theHorizontalAttrContainer.remove();\n        }\n        returnResult.maxLabelHeight = theMaxLabelHeight;\n        returnResult.scale = theXScale;\n        returnResult.rangeBand = theXRangeBand;\n        returnResult.attributeContainer = theHorizontalAttrContainer;\n        break;\n    }\n    return returnResult;\n  },\n  /***\r\n   * 画时间属性轴  每分钟/每小时/每天支持时间轴 【目前只支持水平底部摆放】\r\n   * 时间轴总共两层水平摆放的刻度，一层最小时间粒度[ hh:mm(每分钟/每小时) ， 15(每天) ] ， 一层年月日的时间粒度[ yyy-mm-dd(每分钟/每小时) ， yyyy-mm(每天) ]\r\n   * @param options\r\n   * {\r\n   *      svgContainer            -   画图容器svg\r\n   *      drawWidth               -   画图容器的宽度\r\n   *      drawHeight              -   画图容器的高度\r\n   *      axisFontSize            -   坐标字体大小\r\n   *      attributeValueList      -   刻度数组\r\n   *      attributeValueMap       -   刻度数组的补充信息\r\n   *      start                   -   刻度开始的索引\r\n   *      end                     -   刻度结束的索引\r\n   *\r\n   *      scaleWidth              -   属性轴刻度宽度\r\n   *      maxLabelHeightPercent   -   属性轴刻度值所占的最大高度限制 0 - 100\r\n   *      attributeAxisVisible    -   是否显示数据标签的标志，undefined/null情况下默认为true\r\n   * }\r\n   * */\n  drawAttributeTimeLineAxis: function (options) {\n    options = options || {};\n    if (!options.svgContainer || !options.drawWidth || !options.drawHeight || !options.attributeValueList || !options.attributeValueList.length) return false;\n    let theSvgContainer = options.svgContainer,\n      attributeValueList = options.attributeValueList,\n      attributeValueMap = options.attributeValueMap,\n      axisFontSize = parseInt(options.axisFontSize) || 10,\n      axisFontColor = options.axisFontColor,\n      axisFontBold = options.axisFontBold === undefined ? 'inherit' : options.axisFontBold ? 'bold' : 500,\n      axisFontItalic = options.axisFontItalic === undefined ? 'inherit' : options.axisFontItalic ? 'italic' : 'normal',\n      start = parseInt(options.start) || 0,\n      end = parseInt(options.end) || options.attributeValueList.length,\n      attributeAxisVisible = options.attributeAxisVisible === undefined || options.attributeAxisVisible === null ? true : options.attributeAxisVisible;\n\n    // 校验水平方向刻度宽度是否合理\n    if (!_DataFocusMethod.isPureNumber(options.scaleWidth) || !options.scaleWidth) {\n      console.log('水平方向属性Axis轴没有合法的宽度值');\n      return false;\n    }\n\n    // 没设置的情况下，0.3的高度限制\n    let maxLabelHeightPercent = parseFloat(options.maxLabelHeightPercent / 100);\n    if (isNaN(maxLabelHeightPercent)) maxLabelHeightPercent = 0.3;\n    let maxLabelHeight = options.drawHeight * maxLabelHeightPercent;\n    let returnResult = {};\n    let theAttributeList = attributeValueList && attributeValueList.filter(function (theAttribute, index) {\n      return index >= start && index < end;\n    });\n    let theHorizontalAttrContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(theSvgContainer).append(\"g\").attr(\"class\", \"axis x-axis x-axis-horizontal-timeline\").style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || 'inherit').style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n    let theWidth = options.scaleWidth,\n      theXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(theAttributeList).rangeBands([0, theWidth]),\n      theXRangeBand = theXScale.rangeBand();\n\n    //绘制刻度下的时间x轴的显示信息\n    let theMaxShowLabel = ''; // 获取不同axisTimeType下第一层数据标签的最长的刻度值\n    theAttributeList && theAttributeList.forEach(function (d) {\n      let theMapping = attributeValueMap && attributeValueMap[d];\n      if (!theMapping) return;\n      if (options.axisTimeType === 'minute') {\n        if (theMapping.minute && theMapping.minute.length > theMaxShowLabel.length) {\n          theMaxShowLabel = theMapping.minute;\n        }\n      } else if (options.axisTimeType === 'hour') {\n        if (theMapping.hour && theMapping.hour.length > theMaxShowLabel.length) {\n          theMaxShowLabel = theMapping.hour;\n        }\n      } else if (options.axisTimeType === 'day') {\n        if (theMapping.day && theMapping.day.length > theMaxShowLabel.length) {\n          theMaxShowLabel = theMapping.day;\n        }\n      }\n    });\n    // 通过filter数据主要是为了减少无效的g.label标签\n    if (attributeAxisVisible) {\n      let attributeLabelList = theHorizontalAttrContainer.selectAll(\"g.label\").data(theAttributeList && theAttributeList.filter(function (d, index) {\n        // 如果是分钟，则需要计算多长的刻度放一个分钟\n        let theMapping = attributeValueMap && attributeValueMap[d];\n        if (!theMapping) return false;\n        if (options.axisTimeType === 'minute') {\n          let theMinuteLabel = theMaxShowLabel || '00:00',\n            theMinuteSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theMinuteLabel, {\n              fontSize: axisFontSize\n            }),\n            theLabelStep = theXRangeBand / theMinuteSize.width;\n          if (theLabelStep > 1) {\n            // 每个刻度可以放下分钟数，则显示分钟数\n            theMapping.show = true;\n            theMapping.showType = 'minute';\n          } else if (theLabelStep > 0.2) {\n            // 每五个刻度可以放下一个分钟数，则每5分钟显示一个分钟数\n            theMapping.show = theMapping.minuteNum % 5 === 0;\n            theMapping.showType = 'minute';\n          } else if (theLabelStep > 0.1) {\n            // 每10个刻度可以放下一个分钟数，则每10分钟显示一个分钟数\n            theMapping.show = theMapping.minuteNum % 10 === 0;\n            theMapping.showType = 'minute';\n          } else if (theLabelStep > 1 / 30) {\n            // 每30个刻度可以放下一个分钟数，则每30分钟显示一个分钟数\n            theMapping.show = theMapping.minuteNum % 30 === 0;\n            theMapping.showType = 'minute';\n          } else if (theLabelStep > 1 / 60) {\n            // 每60个刻度可以放下一个分钟数，只显示每小时中的0分钟时刻\n            theMapping.show = theMapping.minuteNum === 0;\n            theMapping.showType = 'minute';\n          } else {\n            // N个小时显示一个时刻\n            let step = Math.max(Math.ceil(theMinuteSize.width / theXRangeBand / 60), 1);\n            // 隔N隔小时显示0分钟的时刻\n            theMapping.show = Math.floor(index / 60) % step === 0 && theMapping.minuteNum === 0;\n            theMapping.showType = 'minute';\n          }\n          return theMapping.show;\n        }\n        // 如果是小时，则需要计算多长的刻度放一个小时\n        else if (options.axisTimeType === 'hour') {\n          let theHourLabel = theMaxShowLabel || '02上午',\n            theHourSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theHourLabel, {\n              fontSize: axisFontSize\n            }),\n            theLabelStep = theXRangeBand / theHourSize.width;\n          if (theLabelStep > 1) {\n            // 每个刻度可以放下小时数，则显示小时数\n            theMapping.show = true;\n            theMapping.showType = 'hour';\n          } else if (theLabelStep > 1 / 3) {\n            // 每3个刻度可以放下一个小时数，则每3小时显示一个\n            theMapping.show = theMapping.hourNum % 3 === 0;\n            theMapping.showType = 'hour';\n          } else if (theLabelStep > 1 / 6) {\n            // 每6个刻度可以放下一个分钟数，则每6小时显示一个\n            theMapping.show = theMapping.hourNum % 6 === 0;\n            theMapping.showType = 'hour';\n          } else if (theLabelStep > 1 / 12) {\n            // 每12个刻度可以放下一个小时数，则每12个小时显示\n            theMapping.show = theMapping.hourNum % 12 === 0;\n            theMapping.showType = 'hour';\n          } else if (theLabelStep > 1 / 24) {\n            // 每24个刻度可以放下一个小时数，则每24个小时显示\n            theMapping.show = theMapping.hourNum === 0;\n            theMapping.showType = 'hour';\n          } else if (theLabelStep > 1 / (24 * 3)) {\n            // 每24 * 3个刻度可以放下一个小时数，则每3天显示\n            theMapping.show = theMapping.hourNum === 0 && theMapping.dayNum % 3 === 0;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 1 / (24 * 10)) {\n            // 每24 * 10个刻度可以放下一个小时数，则每10天显示\n            theMapping.show = theMapping.hourNum === 0 && theMapping.dayNum % 10 === 0;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 1 / (24 * 15)) {\n            // 每24 * 15个刻度可以放下一个小时数，则每15天显示\n            theMapping.show = theMapping.hourNum === 0 && (theMapping.dayNum === 0 || theMapping.dayNum === 15);\n            theMapping.showType = 'day';\n          } else {\n            // 只显示每天中的0分钟时刻\n            theMapping.show = theMapping.hourNum === 0 && theMapping.dayNum === 0;\n            theMapping.showType = 'day';\n          }\n          return theMapping.show;\n        }\n        // 如果是天，则需要计算多长的刻度放一个天\n        else if (options.axisTimeType === 'day') {\n          let theDayLabel = theMaxShowLabel || '30日',\n            theDaySize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theDayLabel, {\n              fontSize: axisFontSize\n            }),\n            theLabelStep = theXRangeBand / theDaySize.width;\n          if (theLabelStep > 1) {\n            // 每个刻度可以放下天数，则显示天数\n            theMapping.show = true;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 0.5) {\n            // 每2个刻度可以放下天数，则每2天显示一个\n            theMapping.show = theMapping.dayNum % 2 === 0;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 0.2) {\n            // 每5个刻度可以放下天数，则每5天显示一个\n            theMapping.show = theMapping.dayNum % 5 === 0;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 0.1) {\n            // 每10个刻度可以放下一个天数，则每10天显示一个\n            theMapping.show = theMapping.dayNum === 1 || theMapping.dayNum === 10 || theMapping.dayNum === 20;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 1 / 15) {\n            // 每15个刻度可以放下一个天数，则每15天显示一个\n            theMapping.show = theMapping.dayNum === 1 || theMapping.dayNum === 15;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 1 / 30) {\n            // 每30个刻度可以放下一个天数，则每30天显示一个\n            theMapping.show = theMapping.dayNum === 1;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 1 / 90) {\n            // 每90个刻度可以放下一个天数，则每90天显示一个\n            theMapping.show = theMapping.monthNum % 3 === 0 && theMapping.dayNum === 1;\n            theMapping.showType = 'day';\n          } else if (theLabelStep > 1 / 180) {\n            // 每180个刻度可以放下一个天数，则每180天显示一个\n            theMapping.show = theMapping.monthNum % 6 === 0 && theMapping.dayNum === 1;\n            theMapping.showType = 'day';\n          } else {\n            // 每年显示一个\n            theMapping.show = theMapping.monthNum === 1 && theMapping.dayNum === 1;\n            theMapping.showType = 'day';\n          }\n          return theMapping.show;\n        }\n        return false;\n      })).enter().append(\"g\").attr(\"class\", \"x-axis label\").attr(\"transform\", function (d) {\n        return \"translate(\" + theXScale(d) + \", 0)\";\n      });\n\n      // 绘制第一层最小粒度的时间刻度值\n      let attributeLabelTexts = attributeLabelList.append(\"text\").attr(\"class\", \"axis-x-label first-time\").attr(\"transform\", function (theText) {\n        let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theText, {\n          fontSize: axisFontSize\n        });\n        return 'translate(' + theXRangeBand / 2 + ' , 0)';\n      }).attr(\"text-anchor\", 'middle').style(\"dominant-baseline\", options.position === 'bottom' ? \"text-before-edge\" : \"central\");\n      attributeLabelTexts.text(function (d) {\n        let dText = d,\n          theMapping = attributeValueMap && attributeValueMap[d];\n        if (!theMapping) return '';\n        if (theMapping.showType === 'minute') {\n          dText = theMapping.minute;\n        } else if (theMapping.showType === 'hour') {\n          dText = theMapping.hour;\n        } else if (theMapping.showType === 'day') {\n          dText = theMapping.day;\n        }\n        return dText;\n      }).append(\"title\").text(function (d) {\n        return d;\n      });\n\n      // 绘制第二层的时间刻度值, 需要判断当前刻度是否与前一层的刻度重合\n      let haveShown = {},\n        prevLabelPosition = [];\n      attributeLabelList.append(\"text\").attr(\"class\", \"axis-x-label second-time\").attr(\"text-anchor\", 'middle').style(\"dominant-baseline\", options.position === 'bottom' ? \"text-before-edge\" : \"central\").attr(\"data-text\", function (d) {\n        let theMapping = attributeValueMap && attributeValueMap[d];\n        if (theMapping && theMapping.show) {\n          let showText;\n          if (theMapping.showType === 'day') {\n            showText = theMapping.year + theMapping.month;\n            if (showText.trim().length > 8) showText = theMapping.yearNum + '-' + theMapping.monthNum;\n            if (!haveShown[showText]) {\n              // haveShown.push(showText);\n              haveShown[showText] = true;\n              return showText;\n            }\n          } else if (theMapping.showType === 'hour' || theMapping.showType === 'minute') {\n            showText = theMapping.year + theMapping.month + theMapping.day;\n            if (showText.trim().length > 11) showText = theMapping.yearNum + '-' + theMapping.monthNum + \"-\" + theMapping.dayNum;\n            if (!haveShown[showText]) {\n              // haveShown.push(showText);\n              haveShown[showText] = true;\n              return showText;\n            }\n          }\n        }\n      }).attr(\"transform\", function (d) {\n        let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this),\n          theText = theDom.attr('data-text') || '';\n        if (theText) {\n          let theLeft = theXScale(d) + theXRangeBand / 2;\n          let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theText, {\n            fontSize: axisFontSize\n          });\n          let translateLeft = 0,\n            translateTop = 0;\n          if (theLeft < theTextSize.width / 2) {\n            translateLeft = theXRangeBand / 2 - theLeft + theTextSize.width / 2;\n            translateTop = theTextSize.height * 1.2;\n          } else if (theLeft + theTextSize.width / 2 > options.scaleWidth) {\n            translateLeft = theXRangeBand / 2 + (options.scaleWidth - theLeft - theTextSize.width / 2);\n            translateTop = theTextSize.height * 1.2;\n          } else {\n            translateLeft = theXRangeBand / 2;\n            translateTop = theTextSize.height * 1.2;\n          }\n\n          // 判断当前元素是否与前面的元素重叠，重叠了则不显示，不重叠则显示\n          let thePosition = {\n              x: theLeft + translateLeft - theTextSize.width / 2,\n              y: translateTop,\n              width: theTextSize.width,\n              height: theTextSize.height\n            },\n            hasOverFlag = false;\n          for (let i = 0; i < prevLabelPosition.length; i++) {\n            let prevPosition = prevLabelPosition[i];\n            hasOverFlag = hasOverFlag || _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].isOverlap(thePosition, prevPosition);\n          }\n          if (hasOverFlag) {\n            theDom.remove();\n            return \"\";\n          } else {\n            prevLabelPosition.push(thePosition);\n            return \"translate(\" + translateLeft + \" , \" + translateTop + \")\";\n          }\n        }\n      }).text(function () {\n        return _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this).attr('data-text');\n      });\n    }\n\n    // 重新计算整个图轴区域的高度\n    let theMaxLabelHeight = 0;\n    // let theBoundingHeight = theHorizontalAttrContainer[0][0] && theHorizontalAttrContainer[0][0].getBoundingClientRect().height ;\n    let theBoundingHeight = theHorizontalAttrContainer[0][0] && theHorizontalAttrContainer[0][0].getBBox().height;\n    theMaxLabelHeight = Math.max(theMaxLabelHeight, theBoundingHeight);\n\n    // 如果超出了最大高度限制，则不显示X轴刻度了\n    if (theMaxLabelHeight > maxLabelHeight) {\n      theMaxLabelHeight = 0;\n      theHorizontalAttrContainer.remove();\n    }\n    returnResult.maxLabelHeight = theMaxLabelHeight;\n    returnResult.scale = theXScale;\n    returnResult.rangeBand = theXRangeBand;\n    returnResult.attributeContainer = theHorizontalAttrContainer;\n    return returnResult;\n  },\n  /**\r\n   * 画多层刻度属性轴[ 垂直方向/水平方向 ]\r\n   * @param options\r\n   * {\r\n   *      svgContainer            -   画图容器svg\r\n   *      drawWidth               -   画图容器的宽度\r\n   *      drawHeight              -   画图容器的高度\r\n   *      axisFontSize            -   坐标字体大小\r\n   *      position                -   刻度位置及方向， left：左垂直 ； top: 上水平  ； bottom: 下水平  ； right： 右垂直\r\n   *      attributeValueList      -   刻度数组\r\n   *      attributeValueMap       -   刻度数组的补充信息\r\n   *\r\n   *      scaleWidth              -   水平(top/bottom)时，属性轴刻度宽度\r\n   *      maxLabelHeightPercent   -   水平(top/bottom)时，属性轴最大高度限制 0 - 100\r\n   *      labelStepWidth          -   水平(top/bottom)时，每个属性刻度的所占的最小宽度\r\n   *\r\n   *      scaleHeight             -   垂直(left/right)时, 属性轴刻度高度\r\n   *      maxLabelWidthPercent    -   垂直(left/right)时，属性轴最大宽度限制\r\n   *      labelStepHeight         -   垂直(left/right)时，每个属性刻度的所占的最小高度，默认20， 即每隔20px放置一个可以\r\n   *      attributeAxisVisible    -   是否显示数据标签的标志，undefined/null情况下默认为true\r\n   * **/\n  drawAttributeLevelLineAxis: function (options) {\n    options = options || {};\n    if (!options.svgContainer || !options.drawWidth || !options.drawHeight || !options.attributeValueList || !options.attributeValueList.length) return false;\n    let theSvgContainer = options.svgContainer,\n      thePosition = options.position || 'bottom',\n      theDirection = ['top', 'bottom'].indexOf(thePosition) > -1 ? 'horizontal' : 'vertical',\n      attributeValueList = options.attributeValueList,\n      attributeValueMap = options.attributeValueMap,\n      axisFontSize = parseInt(options.axisFontSize) || 10,\n      axisFontColor = options.axisFontColor,\n      axisFontBold = options.axisFontBold === undefined ? 'inherit' : options.axisFontBold ? 'bold' : 500,\n      axisFontItalic = options.axisFontItalic === undefined ? 'inherit' : options.axisFontItalic ? 'italic' : 'normal',\n      start = parseInt(options.start) || 0,\n      end = parseInt(options.end) || options.attributeValueList.length,\n      attributeAxisVisible = options.attributeAxisVisible === undefined || options.attributeAxisVisible === null ? true : options.attributeAxisVisible;\n    let theAttributeList = attributeValueList && attributeValueList.filter(function (theAttribute, index) {\n      return !(index < start || index >= end);\n    });\n\n    // 计算属性刻度的各个层级的数据\n    let levelAttributeMappingList = [];\n    for (let i = 0; attributeValueMap.levelLength && i < attributeValueMap.levelLength; i++) {\n      let theLevelDistinct = [],\n        theLevelMapping = {};\n      theAttributeList && theAttributeList.forEach(function (theData) {\n        let theMapping = attributeValueMap[theData],\n          theLevelData = theMapping && theMapping[\"level\" + i];\n        if (theLevelData === undefined) return;\n\n        // 每个层级单点的唯一标识\n        let distinctData = '';\n        for (let j = 0; j <= i; j++) {\n          distinctData += theMapping && theMapping[\"level\" + j] + ',';\n        }\n        if (!theLevelMapping[distinctData]) {\n          theLevelMapping[distinctData] = {\n            length: 0,\n            prevLength: 0,\n            text: theLevelData\n          };\n          theLevelDistinct.push(distinctData);\n        }\n        theLevelMapping[distinctData].length++;\n      });\n      // 计算每个刻度的前置刻度\n      for (let i = 1; i < theLevelDistinct.length; i++) {\n        let theDistinct = theLevelDistinct[i],\n          theMapping = theLevelMapping[theDistinct];\n        if (!theMapping) continue;\n        for (let j = 0; j < i; j++) {\n          let prevDistinct = theLevelDistinct[j],\n            prevMapping = theLevelMapping[prevDistinct];\n          if (!prevMapping) continue;\n          theMapping.prevLength += prevMapping.length || 0;\n        }\n      }\n      levelAttributeMappingList.push({\n        levelAttributeDistinct: theLevelDistinct,\n        levelAttributeMapping: theLevelMapping\n      });\n    }\n    let returnResult = {};\n    const svgContainer = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(theSvgContainer);\n    const theHorizontalAttrContainer = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].reuseElement({\n      container: svgContainer,\n      selector: 'g.axis.x-axis.x-axis-level-horizontal',\n      elementCreator: () => svgContainer.append('g').attr('class', 'axis x-axis x-axis-level-horizontal').attr('data-axis-type', 'levelLine')\n    }).style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || 'inherit').style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n    switch (theDirection) {\n      case \"vertical\":\n        // 校验垂直方向刻度高度是否合理\n        if (!_DataFocusMethod.isPureNumber(options.scaleHeight) || !options.scaleHeight) {\n          console.log('垂直方向属性Axis轴没有合法的高度值');\n          return false;\n        }\n\n        // 没设置的情况下，0.3的高度限制\n        let maxLabelWidthPercent = parseFloat(options.maxLabelWidthPercent / 100);\n        if (isNaN(maxLabelWidthPercent)) maxLabelWidthPercent = 0.3;\n        let maxLabelWidth = options.drawWidth * maxLabelWidthPercent;\n        let theMaxLabelWidth = 0; //  X中刻度的最大高度\n\n        let theVerticalAttrContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(theSvgContainer).append(\"g\").attr(\"class\", \"axis x-axis x-axis-level-vertical\").style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || 'inherit').style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n        let theHeight = parseFloat(options.scaleHeight),\n          theVerticalXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(theAttributeList).rangeBands([0, theHeight]),\n          theVerticalXRangeBand = theVerticalXScale.rangeBand();\n        let prevLevelTotalWidth = 0; // 左侧所有刻度层的宽度。\n        if (attributeAxisVisible) {\n          // 获取每层的完整文字宽度\n          const labelWidthEachLevel = levelAttributeMappingList.map(levelItem => {\n            // 每一层的文字\n            const theDistinctList = levelItem.levelAttributeDistinct;\n            const theDistinctMapping = levelItem.levelAttributeMapping;\n\n            // 当前Level文字的最大宽度\n            return theDistinctList.reduce((maxWidth, textKey) => {\n              let theMapping = theDistinctMapping[textKey];\n              const curText = theMapping.text;\n              const curLabelSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', curText, {\n                fontSize: axisFontSize\n              });\n              return Math.max(maxWidth, curLabelSize.width);\n            }, 0);\n          });\n\n          // 如果所有层级的宽度总和大于最大宽度限制，则调整各层的X轴宽度。否则各层都完整显示\n          let resetWidthOfEachLevels = [];\n          let labelWidthOfAllLevels = labelWidthEachLevel.reduce((acc, cur) => acc + cur, 0);\n          if (labelWidthOfAllLevels > maxLabelWidth) {\n            // 总体超出最大宽度\n            let restMaxWidth = maxLabelWidth;\n            for (let i = 0; i < labelWidthEachLevel.length; i++) {\n              const currentLevelLabelWidth = labelWidthEachLevel[i];\n              let resetLabelWidth = currentLevelLabelWidth; // 整理后的宽度\n              const restLabelCount = labelWidthEachLevel.length - i; // 包括当前层级在内的剩余需要分配宽度的层级个数\n              const restMeanLabelMaxWidth = restMaxWidth / restLabelCount;\n              if (currentLevelLabelWidth > restMeanLabelMaxWidth) {\n                resetLabelWidth = restMeanLabelMaxWidth; // 重置为剩余空间\n              }\n              resetWidthOfEachLevels.push(resetLabelWidth);\n              restMaxWidth = restMaxWidth - resetLabelWidth;\n            }\n          } else {\n            // 不需要整理宽度\n            resetWidthOfEachLevels = labelWidthEachLevel;\n          }\n          for (let i = 0; i < levelAttributeMappingList.length; i++) {\n            // 绘制每一层X轴\n            if (!levelAttributeMappingList[i]) continue;\n            const theDistinctList = levelAttributeMappingList[i].levelAttributeDistinct,\n              theDistinctMapping = levelAttributeMappingList[i].levelAttributeMapping;\n            if (!theDistinctList || !theDistinctMapping) continue;\n            const currentLabelWidth = resetWidthOfEachLevels[i];\n            const theLevelLabel = theVerticalAttrContainer.selectAll(\"g.level\" + i + \"-label\").data(theDistinctList).enter().append(\"g\").attr(\"class\", \"level-label-item level\" + i + \"-label\").attr(\"level\", i).attr(\"level-length\", levelAttributeMappingList.length).attr('prevLevelTotalWidth', prevLevelTotalWidth).attr(\"prevHeight\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let thePrevRangeBandLength = theMapping.prevLength || 0;\n              return thePrevRangeBandLength * theVerticalXRangeBand;\n            }).attr(\"height\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n\n              // 叶子属性的个数\n              let theRangeBandLength = theMapping.length || 0;\n              return theRangeBandLength * theVerticalXRangeBand;\n            }).attr(\"width\", currentLabelWidth).attr(\"transform\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let thePrevRangeBandLength = theMapping.prevLength || 0;\n              let thePrevHeight = thePrevRangeBandLength * theVerticalXRangeBand;\n              return `translate(${prevLevelTotalWidth}, ${thePrevHeight})`;\n            }).on(\"mouseover.axis\", function (d) {\n              let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n              theDom.select(\".background-rect\").style(\"fill\", \"rgba(224,224,224,0.5)\");\n            }).on(\"mouseout.axis\", function (d) {\n              let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n              theDom.select(\".background-rect\").style(\"fill\", \"rgba(0,0,0,0)\");\n            });\n\n            // 叶子label上追加index\n            if (i === levelAttributeMappingList.length - 1) {\n              theLevelLabel.attr('leafLabelIndex', function (d, index) {\n                return index;\n              });\n            }\n\n            // 每个刻度的背景\n            theLevelLabel.append(\"rect\").attr(\"class\", \"background-rect\").attr(\"x\", \"0\").attr(\"y\", \"0\").style(\"fill\", \"rgba(0,0,0,0)\").style(\"stroke\", \"none\").attr(\"height\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let theRangeBandLength = theMapping.length || 0;\n              return theRangeBandLength * theVerticalXRangeBand;\n            }).attr(\"width\", currentLabelWidth);\n\n            // 每个刻度的显示\n            theLevelLabel.append(\"text\").attr(\"transform\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let theRangeBandLength = theMapping.length || 0;\n              let theHeight = theRangeBandLength * theVerticalXRangeBand;\n\n              // 根据文字内容确定是否居中偏移\n              let theText = theMapping.text;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theText, {\n                fontSize: axisFontSize\n              });\n              // 显示一个点的情况\n              if (theTextSize.height * 0.7 > theHeight) {\n                return `translate(${currentLabelWidth / 2},${theHeight / 2})`;\n              }\n              // 显示一个点的情况\n              if (theTextSize.width > currentLabelWidth) {\n                if (currentLabelWidth < 10) {\n                  return `translate(${currentLabelWidth / 2},${theHeight / 2})`;\n                }\n              }\n\n              // 水平靠后显示，垂直居中显示\n              return `translate(${currentLabelWidth}, ${theHeight / 2})`;\n            }).attr(\"text-anchor\", function () {\n              return 'end';\n            }).style(\"dominant-baseline\", 'middle').text(function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping || !theMapping.text) return '';\n              let theText = theMapping.text;\n              let theRangeBandLength = theMapping.length || 0;\n              let theHeight = theRangeBandLength * theVerticalXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theText, {\n                fontSize: axisFontSize\n              });\n              if (theTextSize.height * 0.7 > theHeight) {\n                return '.';\n              }\n              if (theTextSize.width > currentLabelWidth) {\n                if (currentLabelWidth < 3) return '';else if (currentLabelWidth < 10) {\n                  return '.';\n                } else if (currentLabelWidth < 20) return '..';\n                let theSubText = '';\n                for (let i = 0; i < theText.length; i++) {\n                  let chart = theText.charAt(i);\n                  theSubText += chart;\n                  let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                    fontSize: axisFontSize\n                  });\n                  if (theSubTextSize.width > currentLabelWidth - axisFontSize) {\n                    break;\n                  }\n                }\n                if (theSubText.length === theText.length) {\n                  return theText;\n                } else {\n                  return theSubText + '..';\n                }\n              }\n              return theText;\n            }).append(\"title\").text(function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping || !theMapping.text) return '';\n              return theMapping.text;\n            });\n            // 增加前后的分割线。叶子属性无分割线\n            if (i !== levelAttributeMappingList.length - 1) {\n              // 前分割线\n              theLevelLabel.filter(function (d, i) {\n                return i === 0;\n              }).append(\"line\").attr(\"transform\", `translate(0, 0)`).attr(\"x1\", \"0\").attr(\"y1\", \"0\").attr(\"x2\", currentLabelWidth).attr('y2', '0').style(\"stroke\", \"#eee\").style(\"stroke-width\", \"1px\");\n\n              // 后分割线\n              theLevelLabel.append(\"line\").attr(\"transform\", `translate(0,0)`).attr(\"x1\", \"0\").attr(\"y1\", function (d) {\n                let theMapping = theDistinctMapping[d];\n                if (!theMapping) return '';\n                let theRangeBandLength = theMapping.length || 0;\n                let theHeight = theRangeBandLength * theVerticalXRangeBand;\n                return theHeight;\n              }).attr(\"x2\", currentLabelWidth).attr(\"y2\", function (d) {\n                let theMapping = theDistinctMapping[d];\n                if (!theMapping) return '';\n                let theRangeBandLength = theMapping.length || 0;\n                let theHeight = theRangeBandLength * theVerticalXRangeBand;\n                return theHeight;\n              }).style(\"stroke\", \"#eee\").style(\"stroke-width\", \"1px\");\n            }\n            prevLevelTotalWidth += currentLabelWidth + 2; // 各层level间距2像素\n          }\n        }\n\n        // 重新计算整个图轴区域的宽度\n        // let theBoundingWidth = theVerticalAttrContainer[0][0] && theVerticalAttrContainer[0][0].getBoundingClientRect().height ;\n        let theBoundingWidth = theVerticalAttrContainer[0][0] && theVerticalAttrContainer[0][0].getBBox().width;\n        theMaxLabelWidth = Math.max(theMaxLabelWidth, theBoundingWidth);\n        returnResult.maxLabelWidth = theMaxLabelWidth;\n        returnResult.scale = theVerticalXScale;\n        returnResult.rangeBand = theVerticalXRangeBand;\n        returnResult.attributeContainer = theVerticalAttrContainer;\n        break;\n      case \"horizontal\":\n      default:\n        // 校验水平方向刻度宽度是否合理\n        if (!_DataFocusMethod.isPureNumber(options.scaleWidth) || !options.scaleWidth) {\n          console.log('水平方向属性Axis轴没有合法的宽度值');\n          return false;\n        }\n\n        // 没设置的情况下，0.3的高度限制\n        let maxLabelHeightPercent = parseFloat(options.maxLabelHeightPercent / 100);\n        if (isNaN(maxLabelHeightPercent)) maxLabelHeightPercent = 0.3;\n        let maxLabelHeight = options.drawHeight * maxLabelHeightPercent;\n        let theMaxLabelHeight = 0; //  X中刻度的最大高度\n\n        let theWidth = parseFloat(options.scaleWidth),\n          theXScale = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.ordinal().domain(theAttributeList).rangeBands([0, theWidth]),\n          theXRangeBand = theXScale.rangeBand();\n        if (attributeAxisVisible) {\n          // N 层 X 轴刻度\n          const levelGroups = theHorizontalAttrContainer.selectAll('g.level-group').data(levelAttributeMappingList).join(enter => enter.append('g').attr('class', 'level-group').attr('data-level', (d, i) => i).attr(\"data-level-length\", levelAttributeMappingList.length), update => update, exit => exit.remove());\n          levelGroups.each(function (parentData, parentIndex) {\n            const i = parentIndex;\n            const currentLevelGroup = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(this);\n            const {\n              levelAttributeDistinct: theDistinctList,\n              levelAttributeMapping: theDistinctMapping\n            } = parentData;\n            const labelItems = currentLevelGroup.selectAll(`g.level-label-item`).data(theDistinctList).join(enter => enter.append('g').attr('class', `level-label-item level${i}-label`).attr('level', i).attr(\"level-length\", levelAttributeMappingList.length).attr(\"prevWidth\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let thePrevRangeBandLength = theMapping.prevLength || 0;\n              return thePrevRangeBandLength * theXRangeBand;\n            }).attr(\"width\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let theRangeBandLength = theMapping.length || 0;\n              return theRangeBandLength * theXRangeBand;\n            }).attr(\"height\", function (d) {\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                fontSize: axisFontSize\n              });\n              return theTextSize.height;\n            }).attr(\"transform\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let thePrevRangeBandLength = theMapping.prevLength || 0;\n              let thePrevWidth = thePrevRangeBandLength * theXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                fontSize: axisFontSize\n              });\n              return \"translate(\" + thePrevWidth + \" , \" + theTextSize.height * (levelAttributeMappingList.length - i - 1) + \")\";\n            }).on(\"mouseover.axis\", function (d) {\n              let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n              theDom.select(\".background-rect\").style(\"fill\", \"rgba(224,224,224,0.5)\");\n            }).on(\"mouseout.axis\", function (d) {\n              let theDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this);\n              theDom.select(\".background-rect\").style(\"fill\", \"rgba(0,0,0,0)\");\n            }), update => update.transition().duration(300).attr(\"prevWidth\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let thePrevRangeBandLength = theMapping.prevLength || 0;\n              return thePrevRangeBandLength * theXRangeBand;\n            }).attr(\"width\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let theRangeBandLength = theMapping.length || 0;\n              return theRangeBandLength * theXRangeBand;\n            }).attr(\"height\", function (d) {\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                fontSize: axisFontSize\n              });\n              return theTextSize.height;\n            }).attr(\"transform\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let thePrevRangeBandLength = theMapping.prevLength || 0;\n              let thePrevWidth = thePrevRangeBandLength * theXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                fontSize: axisFontSize\n              });\n              return \"translate(\" + thePrevWidth + \" , \" + theTextSize.height * (levelAttributeMappingList.length - i - 1) + \")\";\n            }), exit => exit.remove());\n\n            // label-item 内的文字标签\n            const labelText = labelItems.selectAll('text').data(parentData => [parentData]).join(enter => enter.append('text').attr(\"transform\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let theRangeBandLength = theMapping.length || 0;\n              let theWidth = theRangeBandLength * theXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theMapping.text, {\n                fontSize: axisFontSize\n              });\n              return \"translate(\" + theWidth / 2 + \" , 0)\";\n            }).attr(\"text-anchor\", 'middle').style(\"dominant-baseline\", options.position === 'bottom' ? \"text-before-edge\" : \"central\").text(function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping || !theMapping.text) return '';\n              let theText = theMapping.text;\n              let theRangeBandLength = theMapping.length || 0;\n              let theWidth = theRangeBandLength * theXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theText, {\n                fontSize: axisFontSize\n              });\n              if (theTextSize.width > theWidth) {\n                if (theWidth < 3) return '';else if (theWidth < 10) return '.';else if (theWidth < 20) return '..';\n                let theSubText = '';\n                for (let i = 0; i < theText.length; i++) {\n                  let chart = theText.charAt(i);\n                  theSubText += chart;\n                  let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                    fontSize: axisFontSize\n                  });\n                  if (theSubTextSize.width > theWidth - axisFontSize) {\n                    break;\n                  }\n                }\n                if (theSubText.length === theText.length) {\n                  return theText;\n                } else {\n                  return theSubText + '..';\n                }\n              }\n              return theText;\n            }).append(\"title\").text(function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping || !theMapping.text) return '';\n              return theMapping.text;\n            }), update => update.attr(\"transform\", function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping) return '';\n              let theRangeBandLength = theMapping.length || 0;\n              let theWidth = theRangeBandLength * theXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theMapping.text, {\n                fontSize: axisFontSize\n              });\n              return \"translate(\" + theWidth / 2 + \" , 0)\";\n            }).attr(\"text-anchor\", 'middle').style(\"dominant-baseline\", options.position === 'bottom' ? \"text-before-edge\" : \"central\").text(function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping || !theMapping.text) return '';\n              let theText = theMapping.text;\n              let theRangeBandLength = theMapping.length || 0;\n              let theWidth = theRangeBandLength * theXRangeBand;\n              let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theText, {\n                fontSize: axisFontSize\n              });\n              if (theTextSize.width > theWidth) {\n                if (theWidth < 3) return '';else if (theWidth < 10) return '.';else if (theWidth < 20) return '..';\n                let theSubText = '';\n                for (let i = 0; i < theText.length; i++) {\n                  let chart = theText.charAt(i);\n                  theSubText += chart;\n                  let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                    fontSize: axisFontSize\n                  });\n                  if (theSubTextSize.width > theWidth - axisFontSize) {\n                    break;\n                  }\n                }\n                if (theSubText.length === theText.length) {\n                  return theText;\n                } else {\n                  return theSubText + '..';\n                }\n              }\n              return theText;\n            }).append(\"title\").text(function (d) {\n              let theMapping = theDistinctMapping[d];\n              if (!theMapping || !theMapping.text) return '';\n              return theMapping.text;\n            }), exit => exit.remove());\n\n            // label-item 中的分割线\n            labelItems.each(function (parentData, parentIndex) {\n              const labelItem = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(this);\n              let dividerData;\n              if (i === levelAttributeMappingList.length - 1) {\n                // 叶子节点不需要分隔符\n                dividerData = [];\n              } else {\n                // 当前层级, 首个label有前后两条分割线，其余label只有后面一条分割线\n                if (parentIndex === 0) {\n                  dividerData = [parentData, parentData];\n                } else {\n                  dividerData = [parentData];\n                }\n              }\n              labelItem.selectAll('line').data(dividerData).join(enter => enter.append('line').attr(\"transform\", function (d, index) {\n                let theMapping = theDistinctMapping[d];\n                if (!theMapping) return '';\n                let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                  fontSize: axisFontSize\n                });\n                const isLeftDivider = index === 0;\n                if (parentIndex === 0 && isLeftDivider) {\n                  // 首个标签的左侧分隔符\n                  // 第二层需要网上多偏移一个高度，其他都不需要偏移\n                  let theHeightScale = 0;\n                  if (i === levelAttributeMappingList.length - 2) theHeightScale = 1;\n                  return \"translate(0 , -\" + (theTextSize.height * theHeightScale + 1) + \")\";\n                } else {\n                  let theRangeBandLength = theMapping.length || 0;\n                  let theWidth = theRangeBandLength * theXRangeBand;\n\n                  // 第二层需要网上多偏移一个高度，其他都不需要偏移\n                  let theHeightScale = 0;\n                  if (i === levelAttributeMappingList.length - 2) theHeightScale = 1;\n                  return \"translate(\" + theWidth + \" , -\" + (theTextSize.height * theHeightScale + 1) + \")\";\n                }\n              }).attr(\"x1\", \"0\").attr(\"y1\", \"0\").attr(\"x2\", \"0\").attr(\"y2\", function (d) {\n                let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                  fontSize: axisFontSize\n                });\n\n                // 第二层需要两层高度，其他都只需要一层高度\n                let theHeightScale = 1;\n                if (i === levelAttributeMappingList.length - 2) theHeightScale = 2;\n                return theTextSize.height * theHeightScale;\n              }).style(\"stroke\", \"#eee\").style(\"stroke-width\", \"1px\"), update => update.transition().duration(300).attr(\"transform\", function (d, index) {\n                let theMapping = theDistinctMapping[d];\n                if (!theMapping) return '';\n                let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                  fontSize: axisFontSize\n                });\n                const isLeftDivider = index === 0;\n                if (parentIndex === 0 && isLeftDivider) {\n                  // 首个标签的左侧分隔符\n                  // 第二层需要网上多偏移一个高度，其他都不需要偏移\n                  let theHeightScale = 0;\n                  if (i === levelAttributeMappingList.length - 2) theHeightScale = 1;\n                  return \"translate(0 , -\" + (theTextSize.height * theHeightScale + 1) + \")\";\n                } else {\n                  let theRangeBandLength = theMapping.length || 0;\n                  let theWidth = theRangeBandLength * theXRangeBand;\n\n                  // 第二层需要网上多偏移一个高度，其他都不需要偏移\n                  let theHeightScale = 0;\n                  if (i === levelAttributeMappingList.length - 2) theHeightScale = 1;\n                  return \"translate(\" + theWidth + \" , -\" + (theTextSize.height * theHeightScale + 1) + \")\";\n                }\n              }).attr(\"y2\", function (d) {\n                let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', d, {\n                  fontSize: axisFontSize\n                });\n\n                // 第二层需要两层高度，其他都只需要一层高度\n                let theHeightScale = 1;\n                if (i === levelAttributeMappingList.length - 2) theHeightScale = 2;\n                return theTextSize.height * theHeightScale;\n              }), exit => exit.remove());\n            });\n          });\n        }\n\n        // 重新计算整个图轴区域的高度\n        let theBoundingHeight = theHorizontalAttrContainer.node().getBBox().height;\n        theMaxLabelHeight = Math.max(theMaxLabelHeight, theBoundingHeight);\n\n        // 如果超出了最大高度限制，则不显示\n        if (theMaxLabelHeight > maxLabelHeight) {\n          theMaxLabelHeight = 0;\n          theHorizontalAttrContainer.remove();\n        }\n        returnResult.maxLabelHeight = theMaxLabelHeight;\n        returnResult.scale = theXScale;\n        returnResult.rangeBand = theXRangeBand;\n        returnResult.attributeContainer = theHorizontalAttrContainer;\n        break;\n    }\n    return returnResult;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (AttributeAxisComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/AttributeAxisComponent.js?");

/***/ }),

/***/ "../src-v5/assets/js/charts.components/PaginationChartComponent.js":
/*!*************************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/PaginationChartComponent.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/**\r\n * 图形分页的组件\r\n * */\nlet PaginationChartComponent = {\n  /**\r\n   * 画水平方向的分页元素\r\n   *\r\n   * @param options\r\n   *          {\r\n   *              chartContainer  -   svg元素的父div容器\r\n   *              translateLeft   -   左侧偏移量\r\n   *              translateTop    -   顶部偏移量\r\n   *\r\n   *              height          -   翻页元素的高度\r\n   *              width           -   翻页区域的宽度, 主要用于定位下一页的位置\r\n   *              start           -   当前起点索引\r\n   *              pageSize        -   每页可以放的索引\r\n   *              totalNumber     -   总数\r\n   *              pagingFunc      -   翻页方法\r\n   *          }\r\n   * */\n  drawHorizontalPagination: function (options) {\n    options = options || {};\n    if (!options.chartContainer || !_DataFocusMethod.isPureNumber(options.width) || !_DataFocusMethod.isPureNumber(options.height)) return false;\n    let start = parseInt(options.start) || 0,\n      pageSize = parseInt(options.pageSize) || 0,\n      totalNumber = parseInt(options.totalNumber) || 0;\n    // 矫正start\n    if (start + pageSize > totalNumber) {\n      start = totalNumber - pageSize;\n    }\n    let hasPrevPageFlag = !!(start > 0),\n      hasNextPageFlag = !!(start + pageSize < totalNumber);\n    // 清除翻页元素\n    $(options.chartContainer).find(\".pagination-chart-container\").remove();\n    // 如果需要翻页，则填充翻页信息\n    if (hasPrevPageFlag || hasNextPageFlag) {\n      let thePaginationContainer = document.createElement(\"div\");\n      thePaginationContainer.className = 'pagination-chart-container';\n      thePaginationContainer.style.position = 'absolute';\n      thePaginationContainer.style.top = options.translateTop + 'px';\n      thePaginationContainer.style.left = options.translateLeft + 'px';\n      // 上一页\n      if (hasPrevPageFlag) {\n        let thePrevPageDom = document.createElement(\"div\");\n        thePrevPageDom.className = 'pagination-dom pagination-prev-dom';\n        thePrevPageDom.style.position = 'absolute';\n        let theWidth = Math.min(20, options.width * 0.1),\n          theHeight = Math.min(32, options.height * 0.1);\n        thePrevPageDom.style.width = theWidth + 'px';\n        thePrevPageDom.style.height = theHeight + 'px';\n        thePrevPageDom.style.left = '0';\n        thePrevPageDom.style.top = options.height / 2 - theHeight / 2 + 'px';\n        thePrevPageDom.style.textAlign = 'center';\n        thePrevPageDom.style.fontSize = '16px';\n        thePrevPageDom.style.color = '#fff';\n        thePrevPageDom.style.background = 'rgba(134,134,134,0.4)';\n        thePrevPageDom.style.borderRadius = '6px';\n        thePrevPageDom.style.display = 'flex';\n        thePrevPageDom.style.flexDirection = 'column';\n        thePrevPageDom.style.justifyContent = 'center';\n        thePrevPageDom.style.cursor = 'pointer';\n        thePrevPageDom.style.opacity = '0';\n        thePrevPageDom.innerHTML = '<span class=\"icon-triangle-left\" style=\"font-weight: bold;\"></span>';\n        thePrevPageDom.onmouseover = function () {\n          let theDom = this;\n          theDom.style.background = 'rgba(134,134,134,0.6)';\n        };\n        thePrevPageDom.onmouseout = function () {\n          let theDom = this;\n          theDom.style.background = 'rgba(134,134,134,0.4)';\n        };\n        thePrevPageDom.onmousedown = function (event) {\n          _DataFocusMethod.stopEventDefault(event);\n          typeof options.pagingFunc === 'function' && options.pagingFunc({\n            type: 'page',\n            start: Math.max(0, start - pageSize),\n            steps: pageSize\n          });\n        };\n        thePaginationContainer.appendChild(thePrevPageDom);\n      }\n      // 下一页\n      if (hasNextPageFlag) {\n        let theNextPageDom = document.createElement(\"div\");\n        theNextPageDom.className = 'pagination-dom pagination-next-dom';\n        theNextPageDom.style.position = 'absolute';\n        let theWidth = Math.min(20, options.width * 0.1),\n          theHeight = Math.min(32, options.height * 0.1);\n        theNextPageDom.style.width = theWidth + 'px';\n        theNextPageDom.style.height = theHeight + 'px';\n        theNextPageDom.style.left = options.width - theWidth + 'px';\n        theNextPageDom.style.top = options.height / 2 - theHeight / 2 + 'px';\n        theNextPageDom.style.textAlign = 'center';\n        theNextPageDom.style.fontSize = '16px';\n        theNextPageDom.style.color = '#fff';\n        theNextPageDom.style.background = 'rgba(134,134,134,0.4)';\n        theNextPageDom.style.borderRadius = '6px';\n        theNextPageDom.style.display = 'flex';\n        theNextPageDom.style.flexDirection = 'column';\n        theNextPageDom.style.justifyContent = 'center';\n        theNextPageDom.style.cursor = 'pointer';\n        theNextPageDom.style.opacity = '0';\n        theNextPageDom.innerHTML = '<span class=\"icon-triangle-right-2\" style=\"font-weight: bold;\"></span>';\n        thePaginationContainer.appendChild(theNextPageDom);\n        theNextPageDom.onmouseover = function () {\n          let theDom = this;\n          theDom.style.background = 'rgba(134,134,134,0.6)';\n        };\n        theNextPageDom.onmouseout = function () {\n          let theDom = this;\n          theDom.style.background = 'rgba(134,134,134,0.4)';\n        };\n        theNextPageDom.onmousedown = function (event) {\n          _DataFocusMethod.stopEventDefault(event);\n          typeof options.pagingFunc === 'function' && options.pagingFunc({\n            type: 'page',\n            start: Math.min(start + pageSize, totalNumber - pageSize),\n            steps: pageSize\n          });\n        };\n      }\n      options.chartContainer.onmouseover = function (event) {\n        $(thePaginationContainer).find(\".pagination-dom\").css(\"opacity\", \"1\");\n      };\n      options.chartContainer.onmouseout = function (event) {\n        $(thePaginationContainer).find(\".pagination-dom\").css(\"opacity\", \"0\");\n      };\n      $(options.chartContainer).append(thePaginationContainer);\n    }\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (PaginationChartComponent);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/PaginationChartComponent.js?");

/***/ })

}]);