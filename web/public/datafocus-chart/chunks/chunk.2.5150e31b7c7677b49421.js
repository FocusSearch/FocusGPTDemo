(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[2],{

/***/ "../src-v5/assets/js/charts.components/ContainerComponent.js":
/*!*******************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/ContainerComponent.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// 画图形容器的组件\nlet ContainerComponent = {\n  /**\r\n   * 画图形的容器，只需要区分图例部分与图形部分[图形内部自己画X轴Y轴标题及图形]\r\n   * @param options\r\n   *          {\r\n   *              container           -   [ *必填项 ]画图容器DOM\r\n   *              legendPosition      -   图例位置[默认没有图例]  top / right / left / bottom\r\n   *              needCanvasFlag      -   是否需要canvas标签的标志\r\n   *          }\r\n   * @return 在container中插入图形区域 及 图例区域\r\n   *          {\r\n   *              svgContainer    -   包裹svg元素的div容器\r\n   *              svgJqDom        -   SVG的DOM元素\r\n   *              canvasJqDom     -   Canvas的DOM元素\r\n   *              legendContainer -   包裹图例的div容器\r\n   *          }\r\n   * */\n  drawCommonContainer: function (options) {\n    options = options || {};\n    if (!options.container) return false;\n    const getChartContent = container => {\n      const existedChartContent = container.querySelector('.chart-content');\n      if (existedChartContent) {\n        return existedChartContent;\n      }\n      const newChartContent = document.createElement('div');\n      newChartContent.classList.add('chart-content');\n      return newChartContent;\n    };\n    const getLegendContent = chartContent => {\n      const existedLegendContent = chartContent.querySelector('.legend-content');\n      if (options.legendPosition) {\n        if (existedLegendContent) return existedLegendContent;\n        const newLegendContent = document.createElement('div');\n        newLegendContent.classList.add('legend-content');\n        return newLegendContent;\n      } else {\n        if (existedLegendContent) existedLegendContent.remove();\n        return null;\n      }\n    };\n    const getSvgContent = chartContent => {\n      const existedSvgContent = chartContent.querySelector('.svg-content');\n      // 每次重新生成元素时，将临时回退元素清除\n      if (existedSvgContent) {\n        let theReturnDom = existedSvgContent.querySelector('.select-return-dom');\n        if (theReturnDom) theReturnDom.remove();\n        return existedSvgContent;\n      }\n      const newSvgContent = document.createElement('div');\n      newSvgContent.classList.add('svg-content');\n      return newSvgContent;\n    };\n    const getSvgDom = svgContent => {\n      const existedSvgDom = svgContent.querySelector('.svg-dom');\n      if (existedSvgDom) {\n        return existedSvgDom;\n      }\n      const newSvgDom = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n      newSvgDom.classList.add('svg-dom');\n      return newSvgDom;\n    };\n    const getCanvasDom = svgContent => {\n      const existedCanvasDom = svgContent.querySelector('.canvas-dom');\n      if (options.needCanvasFlag) {\n        if (existedCanvasDom) return existedCanvasDom;\n        const newCanvasDom = document.createElement('canvas');\n        newCanvasDom.classList.add('canvas-dom');\n        return newCanvasDom;\n      } else {\n        if (existedCanvasDom) existedCanvasDom.remove();\n        return null;\n      }\n    };\n    const updateContainerLayout = (container, legendPosition) => {\n      const chartContent = getChartContent(container);\n      const legendContent = getLegendContent(chartContent);\n      const svgContent = getSvgContent(chartContent);\n      const svgDom = getSvgDom(svgContent);\n      const canvasDom = getCanvasDom(svgContent);\n      switch (legendPosition) {\n        case \"top\":\n          chartContent.style.cssText = 'display: flex;flex-direction: column;justify-content: center;align-items: center;width:100%;height:100%;';\n          legendContent.style.cssText = 'display:flex;flex-direction:row;width:100%;';\n          svgContent.style.cssText = 'position:relative;flex:1;flex-grow:1;width:100%;height: 0;';\n          svgDom.style.cssText = 'width:100%;height:100%;';\n          canvasDom && (canvasDom.style.cssText = 'position:absolute;width:100%;height:100%;top:0;left:0;');\n          svgContent.appendChild(svgDom);\n          canvasDom && svgContent.appendChild(canvasDom);\n          chartContent.appendChild(legendContent);\n          chartContent.appendChild(svgContent);\n          break;\n        case \"bottom\":\n          chartContent.style.cssText = 'display: flex;flex-direction: column;justify-content: center;align-items: center;width:100%;height:100%;';\n          legendContent.style.cssText = 'display:flex;flex-direction:row;width:100%;';\n          svgContent.style.cssText = 'position:relative;flex:1;flex-grow:1;width:100%;height: 0;';\n          svgDom.style.cssText = 'width:100%;height:100%;';\n          canvasDom && (canvasDom.style.cssText = 'position:absolute;width:100%;height:100%;top:0;left:0;');\n          svgContent.appendChild(svgDom);\n          canvasDom && svgContent.appendChild(canvasDom);\n          chartContent.appendChild(svgContent);\n          chartContent.appendChild(legendContent);\n          break;\n        case \"right\":\n          chartContent.style.cssText = 'display: flex;flex-direction: row;justify-content: center;align-items: center;width:100%;height:100%;';\n          legendContent.style.cssText = 'display:flex;flex-direction:column;height:100%;';\n          svgContent.style.cssText = 'position:relative;flex:1;flex-grow:1;height:100%;';\n          svgDom.style.cssText = 'width:100%;height:100%;';\n          canvasDom && (canvasDom.style.cssText = 'position:absolute;width:100%;height:100%;top:0;left:0;');\n          svgContent.appendChild(svgDom);\n          canvasDom && svgContent.appendChild(canvasDom);\n          chartContent.appendChild(svgContent);\n          chartContent.appendChild(legendContent);\n          break;\n        case \"left\":\n          chartContent.style.cssText = 'display: flex;flex-direction: row;justify-content: center;align-items: center;width:100%;height:100%;';\n          legendContent.style.cssText = 'height:100%;';\n          svgContent.style.cssText = 'position:relative;flex:1;flex-grow:1;height:100%;';\n          svgDom.style.cssText = 'width:100%;height:100%;';\n          canvasDom && (canvasDom.style.cssText = 'position:absolute;width:100%;height:100%;top:0;left:0;');\n          svgContent.appendChild(svgDom);\n          canvasDom && svgContent.appendChild(canvasDom);\n          chartContent.appendChild(legendContent);\n          chartContent.appendChild(svgContent);\n          break;\n        case \"rightTop\":\n          // 图例在右上角\n          chartContent.style.cssText = 'display: flex;flex-direction: row;justify-content: center;align-items: center;width:100%;height:100%;';\n          legendContent.style.cssText = 'position:absolute;right:0;top:0;z-index:1;';\n          svgContent.style.cssText = 'position:relative;flex:1;flex-grow:1;width:100%;height:100%;';\n          svgDom.style.cssText = 'width:100%;height:100%;';\n          canvasDom && (canvasDom.style.cssText = 'position:absolute;width:100%;height:100%;top:0;left:0;');\n          svgContent.appendChild(svgDom);\n          canvasDom && svgContent.appendChild(canvasDom);\n          chartContent.appendChild(legendContent);\n          chartContent.appendChild(svgContent);\n          break;\n        default:\n          // 无图例的部分\n          chartContent.style.cssText = 'display: flex;flex-direction: row;justify-content: center;align-items: center;width:100%;height:100%;';\n          // legendContent.style.cssText = 'position:absolute;right:0;top:0;z-index:1;';\n          svgContent.style.cssText = 'position:relative;flex:1;flex-grow:1;width:100%;height:100%;';\n          svgDom.style.cssText = 'width:100%;height:100%;';\n          canvasDom && (canvasDom.style.cssText = 'position:absolute;width:100%;height:100%;top:0;left:0;');\n          svgContent.appendChild(svgDom);\n          canvasDom && svgContent.appendChild(canvasDom);\n\n          // chartContent.appendChild(legendContent);\n          chartContent.appendChild(svgContent);\n      }\n\n      // 最后插入减少浏览器重绘\n      options.container.innerHTML = '';\n      options.container.appendChild(chartContent);\n      return {\n        chartContent,\n        legendContent,\n        svgContent,\n        svgDom,\n        canvasDom\n      };\n    };\n    const {\n      chartContent,\n      legendContent,\n      svgContent,\n      svgDom,\n      canvasDom\n    } = updateContainerLayout(options.container, options.legendPosition);\n    return {\n      chartContainer: chartContent,\n      svgContainer: svgContent,\n      svgJqDom: svgDom,\n      canvasJqDom: canvasDom,\n      legendContainer: legendContent\n    };\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ContainerComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/ContainerComponent.js?");

/***/ }),

/***/ "../src-v5/assets/js/charts.components/MeasureAxisComponent.js":
/*!*********************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/MeasureAxisComponent.js ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _d3v7Export__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../d3v7Export */ \"../src-v5/assets/js/d3v7Export.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n// 计算数值轴的组件： 计算数值刻度, 解析数值标尺的配置类型，解析数值标尺的最大值最小值配置 ...\n\n\n\nlet MeasureAxisComponent = {\n  // 转换数值标尺的配置类型\n  translateScaleType: function (scaleType) {\n    if (!scaleType) return false;\n    switch (scaleType) {\n      case \"option_measure_scale_type_define\":\n        return \"defined\";\n      case \"option_default_value\":\n      default:\n        return \"auto\";\n    }\n  },\n  /**\r\n   * 解析数值轴的数据信息，最大值，最小值，数据格式等 将其转换为固定格式供calcYAxisBasicMessage使用\r\n   * @param yAxisList                 -   Y轴的图轴配置\r\n   * @param options\r\n   *          {\r\n   *              currentRows         -       当前页的数据\r\n   *              currentShownLegend  -       当前处于显示状态的图例\r\n   *\r\n   *              axisType            -       图轴类型    normal(默认 已实现)：各列的最大最小值 ； waterfallTrend: 所有数值的累加最大最小值 ； waterfallTrendReverse: 所有数值累减的最大最小值；\r\n   *              scaleType           -       比例尺类型  auto: 自动通过Y轴真实值的最大值最小值计算Y轴刻度 ； define: 用户自定义刻度起点 ；\r\n   *              tableData           -       当前搜索结果数据\r\n   *              min                 -       自适应模式下，用户定义的最小值\r\n   *              max                 -       自适应模式下，用户定义的最大值\r\n   *\r\n   *              definedMin          -       自定义坐标轴的模式下，用户定义的最小值[坐标起点]\r\n   *              definedSeparate     -       自定义坐标轴的模式下，用户定义的间隔\r\n   *              definedStep         -       自定义坐标轴的模式下，用户定义的刻度数\r\n   *\r\n   *              definedScaleFormat    -   Y轴格式配置\r\n   *          }\r\n   *\r\n   * @return returnObj {\r\n   *     type         -   刻度类型  auto: 自动通过Y轴最大值最小值生成的刻度  ； defined: 用户自定义的固定间隔的刻度\r\n   *     min          -   [auto] 真实值的最小值\r\n   *     max          -   [auto] 真实值的最大值\r\n   *     definedMin   -   [auto] 用户定义的最小值\r\n   *     definedMax   -   [auto] 用户定义的最大值\r\n   *\r\n   *     min          -   [defined] 自定义区间的起始值\r\n   *     separate     -   [defined] 自定义区间的间隔\r\n   *     step         -   [defined] 自定义区间个数\r\n   *\r\n   *     yScaleFormat  -   数据格式\r\n   *     measureLength -   使用的数值轴的个数\r\n   * }\r\n   * **/\n  translateMeasureAxis: function (yAxisList, options) {\n    if (!yAxisList || !yAxisList.length) {\n      return false;\n    }\n    options = options || {};\n    let min = Infinity,\n      max = -Infinity,\n      yScaleFormat;\n    yAxisList.forEach(function (yAxis) {\n      // 瀑布图累加轴\n      if (options.axisType === 'waterfallTrend') {\n        min = Math.min(min, yAxis.addMin);\n        max = Math.max(max, yAxis.addMax);\n      }\n      // 瀑布图累减轴\n      else if (options.axisType === 'waterfallTrendReverse') {\n        min = Math.min(min, yAxis.deleteMin);\n        max = Math.max(max, yAxis.deleteMax);\n      }\n      // 常规最大最小值轴\n      else {\n        min = Math.min(min, yAxis.min);\n        max = Math.max(max, yAxis.max);\n      }\n\n      // 将属性列上的目标值作为\n      if (_DataFocusMethod.isPureNumber(yAxis.goal)) {\n        min = Math.min(min, yAxis.goal);\n        max = Math.max(max, yAxis.goal);\n      }\n      if (!yScaleFormat) yScaleFormat = yAxis;\n    });\n\n    // 如果各个列没有传入各个列的最大值最小值，则需要从原始数据中获取\n    if (options.useDataFlag || min === Infinity || max === -Infinity) {\n      if (options.tableData && options.tableData.columns) {\n        min = Infinity;\n        max = -Infinity;\n        let theColumns = options.tableData.columns;\n        yAxisList.forEach(function (yAxis) {\n          theColumns && theColumns.forEach(function (theRowData) {\n            let theData = theRowData && theRowData[yAxis.index];\n            if (_DataFocusMethod.isPureNumber(theData)) {\n              min = Math.min(min, theData);\n              max = Math.max(max, theData);\n            }\n          });\n        });\n      }\n      if (min === Infinity || max === -Infinity) return false;\n    }\n\n    // // @20230313 以前在没有配置的情况下，默认是用第一个Y轴的文字配置\n    // // 如果左Y轴是多个数值列，则默认没有数据格式\n    // if(yAxisList.length > 1) yScaleFormat = undefined ;\n    // 如果用户自定义了Y轴数据格式，则使用配置\n    if (options.definedScaleFormat && options.definedScaleFormat.formatType !== 'default') {\n      yScaleFormat = options.definedScaleFormat;\n    }\n    if (options.axisType === 'stacked') {\n      const {\n        stackedMax,\n        stackedMin\n      } = options;\n      min = stackedMin;\n      max = stackedMax;\n    }\n\n    // 如果配置了合法的自定义Y轴刻度间隔\n    let theDefinedMin = _DataFocusMethod.isPureNumber(options.definedMin) ? options.definedMin : 0;\n    if (options.scaleType === 'defined' && _DataFocusMethod.isPureNumber(theDefinedMin) && _DataFocusMethod.isPureNumber(options.definedSeparate)) {\n      return {\n        type: 'defined',\n        axisLength: yAxisList.length,\n        axisList: yAxisList,\n        min: parseFloat(theDefinedMin),\n        separate: parseFloat(options.definedSeparate),\n        step: parseInt(options.definedStep) || 5,\n        yScaleFormat: yScaleFormat\n      };\n    }\n    // 否则使用自动的Y轴刻度间隔\n    else {\n      return {\n        type: 'auto',\n        axisLength: yAxisList.length,\n        axisList: yAxisList,\n        min: min,\n        max: max,\n        definedMin: options.min && options.min.replace(/\\s/g, ''),\n        definedMax: options.max && options.max.replace(/\\s/g, ''),\n        yScaleFormat: yScaleFormat\n      };\n    }\n  },\n  /***\r\n   * 计算数值轴的基础信息： 刻度值，刻度最大宽度\r\n   * @params  options\r\n   *          {\r\n   *              direction       -       数值刻度水平摆放(horizontal)或垂直摆放(vertical) , 默认垂直\r\n   *              language        -       系统语言[ 主要用于默认显示K的单位还是万的单位 ]\r\n   *              axisFontSize    -       图轴的字体大小\r\n   *              drawWidth       -       svg图形区域的宽度\r\n   *              drawHeight      -       svg图形区域的高度\r\n   *              firstMeasureAxis      -       第一个Y轴对象[ translateMeasureAxis方法返回的结果 ]\r\n   *              secondMeasureAxis     -       第二个Y轴对象[ translateMeasureAxis方法返回的结果 ]\r\n   *              showAxisTitleFlag     -       是否显示各个Y轴的标题\r\n   *              alignZeroFlag         -       多个Y轴刻度是否需要对齐0刻度\r\n   *              measureAxisVisible    -       是否显示数据标签的标志 ， undefined/null的情况下，默认为true\r\n   *              mustHaveZeroFlag      -       是否从零开始的标志，缺失时默认为true ,从0开始刻度 ； false表示按数值范围自适应刻度范围\r\n   *          }\r\n   *\r\n   * **/\n  calcMeasureAxisBasicMessage: function (options) {\n    // 水平方向： 计算数值轴的各个刻度；第一个数值轴各个刻度在配置的数据格式下的最大宽度 ； 第二个数值轴的各个刻度；第二个数值轴各个刻度值在配置的数据格式下的最大宽度\n    options = options || {};\n    if (!options.firstMeasureAxis || !options.drawWidth || !options.drawWidth) return false; // 第一个数值配置一定要有\n\n    let self = this,\n      direction = options.direction || 'horizontal',\n      axisFontSize = parseInt(options.axisFontSize) || 10,\n      axisMaxWidthPercent = _DataFocusMethod.isPureNumber(options.maxLabelWidthPercent) ? parseFloat(options.maxLabelWidthPercent) : 30,\n      axisMaxHeightPercent = _DataFocusMethod.isPureNumber(options.maxLabelHeightPercent) ? parseFloat(options.maxLabelHeightPercent) : 20,\n      multiYFlag = false,\n      // 是否有多个数值刻度\n      measureAxisVisible = options.measureAxisVisible === undefined || options.measureAxisVisible === null ? true : options.measureAxisVisible;\n    let firstMeasureScale;\n    if (options.firstMeasureAxis) {\n      firstMeasureScale = self.calcMeasureTicks($.extend({}, options.firstMeasureAxis, {\n        mustHaveZeroFlag: options.mustHaveZeroFlag,\n        language: options.language\n      }));\n\n      // 主刻度数值异常\n      if (!firstMeasureScale || !firstMeasureScale.ticks) return false;\n    }\n    let secondMeasureScale;\n    if (options.secondMeasureAxis) {\n      secondMeasureScale = self.calcMeasureTicks($.extend({}, options.secondMeasureAxis, {\n        mustHaveZeroFlag: options.mustHaveZeroFlag,\n        language: options.language\n      }));\n      // 如果有第二个刻度，则说明有多个数值轴\n      if (secondMeasureScale && secondMeasureScale.ticks) multiYFlag = true;\n      // 如果右侧刻度比左侧刻度少，则增加右侧的刻度数 [@20240117 沿用focus.chart中左右Y轴的规则，to fix bug #7981]\n      if (firstMeasureScale && firstMeasureScale.ticks.length >= 4 && secondMeasureScale && secondMeasureScale.ticks.length <= 3) {\n        secondMeasureScale = self.calcMeasureTicks($.extend({}, options.secondMeasureAxis, {\n          mustHaveZeroFlag: options.mustHaveZeroFlag,\n          language: options.language,\n          maxSeparate: secondMeasureScale.separate\n        }));\n      }\n    }\n\n    // 如果有多个刻度，且开启了多个刻度的零刻度对齐标志\n    if (options.alignZeroFlag && firstMeasureScale && secondMeasureScale) {\n      self.alignMeasureZeroTicks({\n        firstMeasureScale: firstMeasureScale,\n        secondMeasureScale: secondMeasureScale,\n        language: options.language\n      });\n    }\n    let returnObj = {};\n    if (firstMeasureScale && firstMeasureScale.ticks) {\n      // 计算轴刻度的宽度高度限制\n      let theMeasureTickMaxWidth = 0,\n        theMeasureTickMaxHeight = 0;\n      if (options.defaultShowYPercent) {\n        const percentTicks = self.getPercentYTicks(firstMeasureScale.ticksLength);\n        percentTicks.ticks && percentTicks.ticks.forEach(function (theTick) {\n          let theDisplaySize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas(\"string\", theTick.name, {\n            fontSize: axisFontSize\n          });\n          theMeasureTickMaxWidth = Math.max(theDisplaySize.width, theMeasureTickMaxWidth);\n          theMeasureTickMaxHeight = Math.max(theDisplaySize.height, theMeasureTickMaxHeight);\n        });\n      } else {\n        firstMeasureScale.ticks && firstMeasureScale.ticks.forEach(function (theTick) {\n          let theDisplaySize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas(\"string\", theTick.name, {\n            fontSize: axisFontSize\n          });\n          theMeasureTickMaxWidth = Math.max(theDisplaySize.width, theMeasureTickMaxWidth);\n          theMeasureTickMaxHeight = Math.max(theDisplaySize.height, theMeasureTickMaxHeight);\n        });\n      }\n      // 垂直方向摆放刻度时，限制刻度值的最大显示宽度[ 不得超过画图区域宽度的30% ]\n      if (direction === 'vertical') {\n        theMeasureTickMaxWidth = Math.min(options.drawWidth * axisMaxWidthPercent / 100, theMeasureTickMaxWidth);\n        if (theMeasureTickMaxWidth < 5) {\n          theMeasureTickMaxWidth = 0;\n        }\n        if (!measureAxisVisible) theMeasureTickMaxWidth = 0;\n      }\n      // 水平方向摆放刻度，限制刻度值的最大显示高度[ 不得超过画图区域高度的15% ]\n      else {\n        theMeasureTickMaxHeight = Math.min(options.drawHeight * axisMaxHeightPercent / 100, theMeasureTickMaxHeight);\n        if (theMeasureTickMaxHeight < 5) {\n          theMeasureTickMaxHeight = 0;\n        }\n        if (!measureAxisVisible) theMeasureTickMaxHeight = 0;\n      }\n      let theTitleSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas(\"string\", 'TITLE', {\n        fontSize: options.titleFontSize\n      });\n      returnObj.firstMeasure = {\n        showTitleFlag: !!options.showAxisTitleFlag,\n        measureTitleSize: theTitleSize.height,\n        measureLength: options.firstMeasureAxis && options.firstMeasureAxis.axisLength,\n        measureTickWidth: theMeasureTickMaxWidth,\n        measureTickHeight: theMeasureTickMaxHeight,\n        measureTickScale: firstMeasureScale,\n        measureAxis: options.firstMeasureAxis,\n        yScaleFormat: options.firstMeasureAxis && options.firstMeasureAxis.yScaleFormat\n      };\n    }\n    if (secondMeasureScale && secondMeasureScale.ticks) {\n      // 计算轴刻度的宽度高度限制\n      let theMeasureTickMaxWidth = 0,\n        theMeasureTickMaxHeight = 0;\n      secondMeasureScale.ticks && secondMeasureScale.ticks.forEach(function (theTick) {\n        let theDisplaySize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas(\"string\", theTick.name, {\n          fontSize: axisFontSize\n        });\n        theMeasureTickMaxWidth = Math.max(theDisplaySize.width, theMeasureTickMaxWidth);\n        theMeasureTickMaxHeight = Math.max(theDisplaySize.height, theMeasureTickMaxHeight);\n      });\n      // 垂直方向摆放刻度时，限制刻度值的最大显示宽度[ 不得超过画图区域宽度的20% ]\n      if (direction === 'vertical') {\n        theMeasureTickMaxWidth = Math.min(options.drawWidth * axisMaxWidthPercent / 100, theMeasureTickMaxWidth);\n        if (theMeasureTickMaxWidth < 5) {\n          theMeasureTickMaxWidth = 0;\n        }\n        if (!measureAxisVisible) theMeasureTickMaxWidth = 0;\n      }\n      // 水平方向摆放刻度，限制刻度值的最大显示高度[ 不得超过画图区域高度的10% ]\n      else {\n        theMeasureTickMaxHeight = Math.min(options.drawHeight * axisMaxHeightPercent / 100, theMeasureTickMaxHeight);\n        if (theMeasureTickMaxHeight < 5) {\n          theMeasureTickMaxHeight = 0;\n        }\n        if (!measureAxisVisible) theMeasureTickMaxHeight = 0;\n      }\n      returnObj.secondMeasure = {\n        showTitleFlag: !!options.showAxisTitleFlag,\n        measureTitleSize: _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas(\"string\", 'TITLE', {\n          fontSize: options.titleFontSize\n        }).height,\n        measureLength: options.secondMeasureAxis && options.secondMeasureAxis.axisLength,\n        measureTickWidth: theMeasureTickMaxWidth,\n        measureTickHeight: theMeasureTickMaxHeight,\n        measureTickScale: secondMeasureScale,\n        measureAxis: options.secondMeasureAxis,\n        yScaleFormat: options.secondMeasureAxis && options.secondMeasureAxis.yScaleFormat\n      };\n    }\n    return returnObj;\n  },\n  /***\r\n   * 画数值刻度轴[ 垂直方向/水平方向 ]\r\n   * @param options\r\n   * {\r\n   *      svgContainer            -   画图容器svg\r\n   *      drawWidth               -   画图容器的宽度\r\n   *      drawHeight              -   画图容器的高度\r\n   *      axisFontSize            -   坐标字体大小\r\n   *      direction               -   刻度方向， vertical: 垂直方向，左右两侧[ 左主 ] ； horizontal: 水平方向，上下两侧[ 上主 ]\r\n   *      position                -   主刻度的位置，bottom: horizontal主刻度位置在下方 ，线在上方     vertical默认是是左侧是主刻度 ； horizontal默认是上侧是主刻度；\r\n   *      separate                -   [ 垂直方向 ]刻度标签与刻度线之间的间隔\r\n   *      scaleHeight             -   [ 垂直方向 ]刻度高度\r\n   *      scaleLineWidth          -   [ 垂直方向 ]刻度线宽度（必须得和横向的属性刻度宽度一致）\r\n   *\r\n   *\r\n   *\r\n   *      scaleWidth              -   [ 水平方向 ]刻度宽度\r\n   *      firstMeasure            -   [ 必填 ]主刻度轴\r\n   *      secondMeasure           -   [ 可选 ]副刻度轴\r\n   * }\r\n   * */\n  drawMeasureAxis: function (options) {\n    options = options || {};\n    if (!options.svgContainer || !options.drawWidth || !options.drawHeight) return false;\n    let theSvgContainer = options.svgContainer,\n      direction = options.direction || \"vertical\",\n      zeroStrokeLineWidth = parseInt(options.zeroStrokeLineWidth) || 1,\n      zeroStrokeLineColor = options.zeroStrokeLineColor,\n      axisFontSize = parseInt(options.axisFontSize) || 10,\n      axisFontColor = options.axisFontColor,\n      axisFontBold = options.axisFontBold === undefined ? 'inherit' : options.axisFontBold ? 'bold' : 500,\n      axisFontItalic = options.axisFontItalic === undefined ? 'inherit' : options.axisFontItalic ? 'italic' : 'normal',\n      showAxisLineFlag = !!options.showAxisLineFlag,\n      showOnlyZeroLineFlag = !!options.showOnlyZeroLineFlag,\n      axisLineStyle = options.strokeLineStyle,\n      zeroAxisLineStyle = options.zeroStrokeLineStyle,\n      stackedPercent = options.defaultShowYPercent;\n    let prevTextDom;\n    switch (direction) {\n      case \"horizontal\":\n        // 数值刻度水平摆放，必须得有刻度宽度\n        if (!_DataFocusMethod.isPureNumber(options.scaleWidth) || !options.scaleWidth) {\n          console.log('水平方向数值Axis轴没有合法的宽度值');\n          return false;\n        }\n        let scaleWidth = parseFloat(options.scaleWidth);\n        let theHorizontalMeasContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(theSvgContainer).append(\"g\").attr(\"class\", \"axis y-axis y-axis-horizontal\").style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || 'inherit').style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n\n        // 画第一个刻度标尺的线 及 刻度值\n        let theLineHeight = parseFloat(options.scaleLineHeight),\n          theFirstMeasureHeight = 0,\n          theHSeparate = parseInt(options.separate) || 5; //  刻度与线之间的间隔\n        let theHFirstScaleFunc;\n        if (options.firstMeasure && options.firstMeasure.measureTickScale) {\n          let theMeasureTickScale = options.firstMeasure.measureTickScale,\n            theMeasureTickHeight = options.firstMeasure.measureTickHeight;\n          // 第一个数值刻度的比例尺\n          theHFirstScaleFunc = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.linear().domain([theMeasureTickScale.min, theMeasureTickScale.max]).range([0, scaleWidth]);\n          theHFirstScaleFunc.clamp(true);\n          theLineHeight = theLineHeight || options.drawHeight - theMeasureTickHeight - theHSeparate;\n          theFirstMeasureHeight = theMeasureTickHeight + theHSeparate;\n          let prevTextSize, prevScale;\n          theMeasureTickScale.ticks && theMeasureTickScale.ticks.forEach(function (theTick, tickIndex) {\n            let theTickContainer = theHorizontalMeasContainer.append(\"g\").attr(\"class\", 'y-axis-item tick left-axis-item').attr(\"transform\", \"translate(\" + theHFirstScaleFunc(theTick.value) + \" , 0)\");\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            theTickContainer.append(\"line\").attr(\"class\", \"y-tick-line left-line\").attr(\"y1\", options.position === 'bottom' ? -(theMeasureTickHeight + theHSeparate + theLineHeight) : theMeasureTickHeight + theHSeparate).attr(\"x1\", theHFirstScaleFunc(theTick.value) <= theStrokeWidth / 2 ? theStrokeWidth / 2 : scaleWidth - theHFirstScaleFunc(theTick.value) < theStrokeWidth / 2 ? scaleWidth - theHFirstScaleFunc(theTick.value) - theStrokeWidth / 2 : theStrokeWidth).style(\"stroke-dasharray\", function () {\n              if (theTick.value === 0) {\n                // 零线样式\n                let lineStyle = zeroAxisLineStyle && zeroAxisLineStyle.lineStyle || axisLineStyle && axisLineStyle.lineStyle || 'solid';\n                return lineStyle === 'solid' ? '' : '5,5';\n              } else {\n                // 非零线样式\n                let lineStyle = axisLineStyle && axisLineStyle.lineStyle || 'solid';\n                return lineStyle === 'solid' ? '' : '5,5';\n              }\n              return '';\n            }).style(\"stroke-width\", theStrokeWidth).style(\"stroke\", function () {\n              if (theTick.value === 0) {\n                // 零线样式\n                return zeroAxisLineStyle && zeroAxisLineStyle.lineColor || axisLineStyle && axisLineStyle.lineColor || 'rgba(28, 28, 28 , 0.1)';\n              } else {\n                // 非零线样式\n                return axisLineStyle && axisLineStyle.lineColor || 'rgba(28, 28, 28 , 0.1)';\n              }\n              return 'rgba(28, 28, 28 , 0.1)';\n            }).style(\"stroke-opacity\", function () {\n              if (theTick.value === 0) {\n                // 显示零线\n                return showAxisLineFlag ? 1 : 0;\n              } else {\n                // 显示非零线\n                if (showOnlyZeroLineFlag) return 0;\n                return showAxisLineFlag ? 1 : 0;\n              }\n            }).attr(\"y2\", options.position === 'bottom' ? -(theMeasureTickHeight + theHSeparate) : theMeasureTickHeight + theHSeparate + theLineHeight).attr(\"x2\", theHFirstScaleFunc(theTick.value) <= theStrokeWidth / 2 ? theStrokeWidth / 2 : scaleWidth - theHFirstScaleFunc(theTick.value) < theStrokeWidth / 2 ? scaleWidth - theHFirstScaleFunc(theTick.value) - theStrokeWidth / 2 : theStrokeWidth);\n            prevTextDom = theTickContainer.append(\"text\").attr(\"class\", \"y-tick-text left-text\").attr(\"text-anchor\", \"middle\").style(\"dominant-baseline\", options.position === 'bottom' ? \"text-after-edge\" : \"text-before-edge\").text(function () {\n              // 如果刻度高度限制\n              if (theMeasureTickHeight < 3) return '';else if (theMeasureTickHeight < 5) return '.';\n\n              /**\r\n               * 不管是画顶部Y轴刻度或底部Y轴刻度，都需要做重叠处理及超出画图区域的处理\r\n               * 1. 第一个或最后一个刻度是否超出了画图区域，\r\n               * 2. 每个刻度与前一个刻度是否文字重叠了\r\n               * */\n              let dText = theTick.name || '',\n                curScale = theHFirstScaleFunc(theTick.value),\n                curTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                  fontSize: axisFontSize\n                });\n              if (!prevTextSize) {\n                // 第一个刻度, 如果超出了画图区域，则截取显示\n                if (curScale + curTextSize.width / 2 > scaleWidth) {\n                  let theSubText = '';\n                  let theSubTextSize;\n                  for (let i = 0; i < dText.length; i++) {\n                    let chart = dText.charAt(i);\n                    theSubText += chart;\n                    let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                      fontSize: axisFontSize\n                    });\n                    if (curScale + theSubTextSize.width / 2 > scaleWidth) {\n                      break;\n                    }\n                  }\n                  prevTextSize = theSubTextSize;\n                  prevScale = curScale;\n                  if (theSubText.length === dText.length) {\n                    return dText;\n                  } else {\n                    return theSubText + '..';\n                  }\n                }\n              } else {\n                // 如果两个刻度重叠，则不显示当前刻度\n                if (prevScale + prevTextSize.width / 2 > curScale - curTextSize.width / 2) {\n                  return '';\n                }\n                // 如果当前刻度超出画图区域，判断是否能往前放置的下，放置的下，则往前挪，否则截取\n                else if (curScale + curTextSize.width / 2 > scaleWidth) {\n                  // 往前放是否会不与前一个刻度重叠\n                  if (scaleWidth - curTextSize.width > prevScale + prevTextSize.width / 2) {\n                    prevScale = scaleWidth - curTextSize.width / 2;\n                    prevTextSize = curTextSize;\n                    _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this).attr(\"transform\", \"translate(\" + (prevScale - curScale) + \" , 0)\");\n                    return theTick.name;\n                  } else {\n                    if (scaleWidth - curScale < 3) return '';\n                    if (scaleWidth - curScale < 5) return '.';\n                    let theSubText = '';\n                    let theSubTextSize = curTextSize;\n                    for (let i = 0; i < dText.length; i++) {\n                      let chart = dText.charAt(i);\n                      theSubText += chart;\n                      let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                        fontSize: axisFontSize\n                      });\n                      if (curScale + theSubTextSize.width / 2 > scaleWidth) {\n                        break;\n                      }\n                    }\n                    prevTextSize = theSubTextSize;\n                    prevScale = curScale;\n                    if (theSubText.length === dText.length) {\n                      return dText;\n                    } else {\n                      return theSubText + '..';\n                    }\n                  }\n                }\n              }\n              prevScale = curScale;\n              prevTextSize = curTextSize;\n              return theTick.name;\n            }).append(\"title\").text(theTick.name);\n          });\n        }\n        let theSecondMeasureHeight = 0;\n        let theHSecondScaleFunc;\n        if (options.secondMeasure && options.secondMeasure.measureTickScale) {\n          let theMeasureTickScale = options.secondMeasure.measureTickScale,\n            theMeasureTickHeight = options.secondMeasure.measureTickHeight;\n          // 第二个数值刻度的比例尺\n          theHSecondScaleFunc = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.linear().domain([theMeasureTickScale.min, theMeasureTickScale.max]).range([0, scaleWidth]);\n          theHSecondScaleFunc.clamp(true);\n          theLineHeight = theLineHeight || options.drawHeight - theMeasureTickHeight - theHSeparate;\n          theSecondMeasureHeight = theMeasureTickHeight + theHSeparate;\n          let prevTextSize, prevScale;\n          theMeasureTickScale.ticks && theMeasureTickScale.ticks.forEach(function (theTick, tickIndex) {\n            let theTickContainer = theHorizontalMeasContainer.append(\"g\").attr(\"class\", 'y-axis-item tick right-axis-item').attr(\"transform\", `translate(${theHSecondScaleFunc(theTick.value)}, ${options.firstMeasureHeight + options.scaleAttributeHeight + options.measureSeparate})`);\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            prevTextDom = theTickContainer.append(\"text\").attr(\"class\", \"y-tick-text right-text\").attr(\"text-anchor\", \"middle\").style(\"dominant-baseline\", options.position === 'bottom' ? \"text-after-edge\" : \"text-before-edge\").text(function () {\n              // 如果刻度高度限制\n              if (theMeasureTickHeight < 3) return '';else if (theMeasureTickHeight < 5) return '.';\n\n              /**\r\n               * 不管是画顶部Y轴刻度或底部Y轴刻度，都需要做重叠处理及超出画图区域的处理\r\n               * 1. 第一个或最后一个刻度是否超出了画图区域，\r\n               * 2. 每个刻度与前一个刻度是否文字重叠了\r\n               * */\n              let dText = theTick.name || '',\n                curScale = theHSecondScaleFunc(theTick.value),\n                curTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                  fontSize: axisFontSize\n                });\n              if (!prevTextSize) {\n                // 第一个刻度, 如果超出了画图区域，则截取显示\n                if (curScale + curTextSize.width / 2 > scaleWidth) {\n                  let theSubText = '';\n                  let theSubTextSize;\n                  for (let i = 0; i < dText.length; i++) {\n                    let chart = dText.charAt(i);\n                    theSubText += chart;\n                    let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                      fontSize: axisFontSize\n                    });\n                    if (curScale + theSubTextSize.width / 2 > scaleWidth) {\n                      break;\n                    }\n                  }\n                  prevTextSize = theSubTextSize;\n                  prevScale = curScale;\n                  if (theSubText.length === dText.length) {\n                    return dText;\n                  } else {\n                    return theSubText + '..';\n                  }\n                }\n              } else {\n                // 如果两个刻度重叠，则不显示当前刻度\n                if (prevScale + prevTextSize.width / 2 > curScale - curTextSize.width / 2) {\n                  return '';\n                }\n                // 如果当前刻度超出画图区域，判断是否能往前放置的下，放置的下，则往前挪，否则截取\n                else if (curScale + curTextSize.width / 2 > scaleWidth) {\n                  // 往前放是否会不与前一个刻度重叠\n                  if (scaleWidth - curTextSize.width > prevScale + prevTextSize.width / 2) {\n                    prevScale = scaleWidth - curTextSize.width / 2;\n                    prevTextSize = curTextSize;\n                    _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(this).attr(\"transform\", \"translate(\" + (prevScale - curScale) + \" , 0)\");\n                    return theTick.name;\n                  } else {\n                    if (scaleWidth - curScale < 3) return '';\n                    if (scaleWidth - curScale < 5) return '.';\n                    let theSubText = '';\n                    let theSubTextSize = curTextSize;\n                    for (let i = 0; i < dText.length; i++) {\n                      let chart = dText.charAt(i);\n                      theSubText += chart;\n                      let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                        fontSize: axisFontSize\n                      });\n                      if (curScale + theSubTextSize.width / 2 > scaleWidth) {\n                        break;\n                      }\n                    }\n                    prevTextSize = theSubTextSize;\n                    prevScale = curScale;\n                    if (theSubText.length === dText.length) {\n                      return dText;\n                    } else {\n                      return theSubText + '..';\n                    }\n                  }\n                }\n              }\n              prevScale = curScale;\n              prevTextSize = curTextSize;\n              return theTick.name;\n            }).append(\"title\").text(theTick.name);\n          });\n        }\n        return {\n          measureContainer: theHorizontalMeasContainer,\n          firstMeasureScaleFunc: theHFirstScaleFunc,\n          firstMeasure: options.firstMeasure,\n          firstMeasureHeight: theFirstMeasureHeight,\n          secondMeasureScaleFunc: theHSecondScaleFunc,\n          secondMeasure: options.secondMeasure,\n          secondMeasureHeight: theSecondMeasureHeight\n        };\n        break;\n      case \"vertical\":\n      default:\n        // 数值刻度垂直摆放，必须得有刻度高度\n        if (!_DataFocusMethod.isPureNumber(options.scaleHeight) || !options.scaleHeight) {\n          console.log('垂直方向数值Axis轴没有合法的高度值');\n          return false;\n        }\n        let scaleHeight = parseFloat(options.scaleHeight),\n          scalePaddingTop = parseFloat(options.scalePaddingTop) || 0;\n        const svgContainer = _d3v7Export__WEBPACK_IMPORTED_MODULE_1__[\"default\"].select(theSvgContainer);\n\n        // 多次重画Y轴应该复用已存在的Y轴容器\n        const theVerticalMeasContainer = svgContainer.select('g.axis.y-axis.y-axis-vertical').empty() ? svgContainer.append(\"g\").attr(\"class\", \"axis y-axis y-axis-vertical\").style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || 'inherit').style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic) : svgContainer.select('g.axis.y-axis.y-axis-vertical').style(\"font-size\", axisFontSize + 'px').style(\"fill\", axisFontColor || 'inherit').style(\"font-weight\", axisFontBold).style(\"font-style\", axisFontItalic);\n\n        // 画第一个刻度标尺的线 及 刻度值\n        let theLineWidth = parseFloat(options.scaleLineWidth),\n          theFirstMeasureWidth = 0,\n          theSeparate = parseInt(options.separate) || 5,\n          prevTick;\n        let theFirstScaleFunc;\n        if (options.firstMeasure && options.firstMeasure.measureTickScale) {\n          let theMeasureTickScale = options.firstMeasure.measureTickScale,\n            theMeasureTickWidth = options.firstMeasure.measureTickWidth;\n          // 第一个数值刻度的比例尺\n          theFirstScaleFunc = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.linear().domain([theMeasureTickScale.min, theMeasureTickScale.max]).range([scaleHeight, 0]);\n          if (stackedPercent) {\n            theMeasureTickScale = this.getPercentYTicks(theMeasureTickScale.ticksLength);\n            theFirstScaleFunc = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.linear().domain([theMeasureTickScale.min, theMeasureTickScale.max]).range([scaleHeight, 0]);\n          }\n          theLineWidth = theLineWidth || options.drawWidth - theMeasureTickWidth - theSeparate;\n          theFirstMeasureWidth = theMeasureTickWidth + theSeparate;\n\n          // 使用D3数据绑定的方式绘制Y轴刻度\n          const yAxisGroup = theVerticalMeasContainer.selectAll('g.y-axis-item.tick.left-axis-item').data(theMeasureTickScale.ticks, d => d.value).join(enter => enter.append('g').attr('class', 'y-axis-item tick left-axis-item').attr('transform', (theTick, tickIndex) => `translate(0, ${theFirstScaleFunc(theTick.value)})`).attr('opacity', 0).transition().duration(200).delay((_, tickIndex) => tickIndex * 20).attr('opacity', 1), update => update.attr('opacity', 1).transition().duration(300).attr('transform', (theTick, tickIndex) => `translate(0, ${theFirstScaleFunc(theTick.value)})`), exit => exit.remove());\n\n          // 每条轴里面的线条\n          const tickLines = yAxisGroup.selectAll('line.y-tick-line.left-line').data(d => [d]).join(enter => enter.append('line').attr('class', 'y-tick-line left-line').attr(\"x1\", theMeasureTickWidth + theSeparate).attr(\"y1\", 0).attr(\"x2\", theMeasureTickWidth + theSeparate + theLineWidth).attr(\"y2\", 0).attr(\"stroke-dasharray\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              let lineStyle = zeroAxisLineStyle && zeroAxisLineStyle.lineStyle || axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            } else {\n              // 非零线样式\n              let lineStyle = axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            }\n            return '';\n          }).attr(\"stroke-width\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              return zeroAxisLineStyle && zeroAxisLineStyle.lineWidth || 1;\n            } else {\n              // 非零线样式\n              return axisLineStyle && axisLineStyle.lineWidth || 1;\n            }\n            return 1;\n          }).attr(\"stroke\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              return zeroAxisLineStyle && zeroAxisLineStyle.lineColor || axisLineStyle && axisLineStyle.lineColor || 'rgba(28, 28, 28 , 0.1)';\n            } else {\n              // 非零线样式\n              return axisLineStyle && axisLineStyle.lineColor || 'rgba(28, 28, 28 , 0.1)';\n            }\n            return 'rgba(28, 28, 28 , 0.1)';\n          }).attr(\"stroke-opacity\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 显示零线\n              return showAxisLineFlag ? 1 : 0;\n            } else {\n              // 显示非零线\n              if (showOnlyZeroLineFlag) return 0;\n              return showAxisLineFlag ? 1 : 0;\n            }\n          }), update => update.attr(\"x1\", theMeasureTickWidth + theSeparate).attr(\"y1\", 0).attr(\"x2\", theMeasureTickWidth + theSeparate + theLineWidth).attr(\"y2\", 0).attr(\"stroke-dasharray\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              let lineStyle = zeroAxisLineStyle && zeroAxisLineStyle.lineStyle || axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            } else {\n              // 非零线样式\n              let lineStyle = axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            }\n            return '';\n          }).attr(\"stroke-width\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              return zeroAxisLineStyle && zeroAxisLineStyle.lineWidth || 1;\n            } else {\n              // 非零线样式\n              return axisLineStyle && axisLineStyle.lineWidth || 1;\n            }\n            return 1;\n          }).attr(\"stroke\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              return zeroAxisLineStyle && zeroAxisLineStyle.lineColor || axisLineStyle && axisLineStyle.lineColor || 'rgba(28, 28, 28 , 0.1)';\n            } else {\n              // 非零线样式\n              return axisLineStyle && axisLineStyle.lineColor || 'rgba(28, 28, 28 , 0.1)';\n            }\n            return 'rgba(28, 28, 28 , 0.1)';\n          }).attr(\"stroke-opacity\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 显示零线\n              return showAxisLineFlag ? 1 : 0;\n            } else {\n              // 显示非零线\n              if (showOnlyZeroLineFlag) return 0;\n              return showAxisLineFlag ? 1 : 0;\n            }\n          }), exit => exit.remove());\n\n          // 每条轴里的刻度值\n          const tickTexts = yAxisGroup.selectAll('text.y-tick-text.left-text').data(d => [d]).join(enter => enter.append(\"text\").attr(\"class\", \"y-tick-text left-text\").attr(\"text-anchor\", \"end\").attr(\"transform\", function (theTick, tickIndex) {\n            // 刻度垂直摆放时，最上面的刻度超出画图区域后需要下移处理，显示在可视区域\n            let theLastTick = theMeasureTickScale.ticks[theMeasureTickScale.ticksLength - 1];\n            if (theTick && theLastTick && theTick.value === theLastTick.value) {\n              return \"translate(\" + (theFirstMeasureWidth - theSeparate) + \" , \" + (axisFontSize * 0.4 > scalePaddingTop ? axisFontSize - scalePaddingTop : axisFontSize * 0.4) + \")\";\n            } else {\n              return \"translate(\" + (theFirstMeasureWidth - theSeparate) + \" , \" + axisFontSize * 0.4 + \")\";\n            }\n          }).text(function (theTick, tickIndex) {\n            // 当设置过最大值最小值时 , 两条线太近时,会忽略一条 (保证最大值与最小值一定显示)\n            if (prevTick && theFirstScaleFunc(prevTick.value) - theFirstScaleFunc(theTick.value) < axisFontSize) {\n              if (tickIndex > 1) {\n                prevTextDom && prevTextDom.style(\"display\", \"none\");\n              }\n            }\n            prevTick = theTick;\n            if (theMeasureTickWidth < 3) return '';else if (theMeasureTickWidth < 5) return '.';\n\n            // 如果第一个y轴列配置不是默认配置，则刻度使用该配置\n            // 如果当前刻度长度超过了最大宽度，则截取显示\n            let dText = theTick.name || '',\n              theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                fontSize: axisFontSize\n              });\n            if (theTextSize.width > theMeasureTickWidth) {\n              let theSubText = '';\n              for (let i = 0; i < dText.length; i++) {\n                let chart = dText.charAt(i);\n                theSubText += chart;\n                let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                  fontSize: axisFontSize\n                });\n                if (theSubTextSize.width + axisFontSize > theMeasureTickWidth) {\n                  break;\n                }\n              }\n              if (theSubText.length === dText.length) {\n                return dText;\n              } else {\n                return theSubText + '..';\n              }\n            }\n            return theTick.name;\n          }).append(\"title\").text(theTick => theTick.name), update => update.attr(\"transform\", function (theTick, tickIndex) {\n            if (tickIndex === theMeasureTickScale.ticksLength - 1) {\n              return \"translate(\" + (theFirstMeasureWidth - theSeparate) + \" , \" + (axisFontSize * 0.4 > scalePaddingTop ? axisFontSize - scalePaddingTop : axisFontSize * 0.4) + \")\";\n            } else {\n              return \"translate(\" + (theFirstMeasureWidth - theSeparate) + \" , \" + axisFontSize * 0.4 + \")\";\n            }\n          }).text(function (theTick, tickIndex) {\n            // 当设置过最大值最小值时 , 两条线太近时,会忽略一条 (保证最大值与最小值一定显示)\n            if (prevTick && theFirstScaleFunc(prevTick.value) - theFirstScaleFunc(theTick.value) < axisFontSize) {\n              if (tickIndex > 1) {\n                prevTextDom && prevTextDom.style(\"display\", \"none\");\n              }\n            }\n            prevTick = theTick;\n            if (theMeasureTickWidth < 3) return '';else if (theMeasureTickWidth < 5) return '.';\n\n            // 如果第一个y轴列配置不是默认配置，则刻度使用该配置\n            // 如果当前刻度长度超过了最大宽度，则截取显示\n            let dText = theTick.name || '',\n              theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                fontSize: axisFontSize\n              });\n            if (theTextSize.width > theMeasureTickWidth) {\n              let theSubText = '';\n              for (let i = 0; i < dText.length; i++) {\n                let chart = dText.charAt(i);\n                theSubText += chart;\n                let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                  fontSize: axisFontSize\n                });\n                if (theSubTextSize.width + axisFontSize > theMeasureTickWidth) {\n                  break;\n                }\n              }\n              if (theSubText.length === dText.length) {\n                return dText;\n              } else {\n                return theSubText + '..';\n              }\n            }\n            return theTick.name;\n          }).select(\"title\").text(theTick => theTick.name), exit => exit.remove());\n        } else {\n          theVerticalMeasContainer.selectAll('g.y-axis-item.tick.left-axis-item').remove();\n        }\n\n        // 画第二个刻度标尺的线 及 刻度值\n        prevTextDom = undefined;\n        prevTick = undefined;\n        let theSecondScaleFunc;\n        if (options.secondMeasure && options.secondMeasure.measureTickScale) {\n          let theMeasureTickScale = options.secondMeasure.measureTickScale,\n            theMeasureTickWidth = options.secondMeasure.measureTickWidth;\n          // 第二个数值刻度的比例尺\n          theSecondScaleFunc = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].scale.linear().domain([theMeasureTickScale.min, theMeasureTickScale.max]).range([scaleHeight, 0]);\n\n          // 右侧Y轴刻度\n          const rightYAxisGroup = theVerticalMeasContainer.selectAll('g.y-axis-item.tick.right-axis-item').data(theMeasureTickScale.ticks, d => d.value).join(enter => enter.append('g').attr('class', 'y-axis-item tick right-axis-item').attr('transform', theTick => \"translate(\" + theFirstMeasureWidth + \" , \" + theSecondScaleFunc(theTick.value) + \")\").attr('opacity', 0).transition().duration(200).delay((_, tickIndex) => tickIndex * 20).attr('opacity', 1), update => update.attr('opacity', 1).transition().duration(300).attr('transform', theTick => \"translate(\" + theFirstMeasureWidth + \" , \" + theSecondScaleFunc(theTick.value) + \")\"), exit => exit.remove());\n\n          // 右侧Y轴刻度线条\n          const rightYTickLines = rightYAxisGroup.selectAll('line.y-tick-line.right-line').data(d => [d]).join(enter => enter.append('line').attr('class', 'y-tick-line right-line').attr(\"x1\", 0).attr(\"y1\", theTick => {\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            return theSecondScaleFunc(theTick.value) <= theStrokeWidth / 2 ? theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : scaleHeight - theSecondScaleFunc(theTick.value) < theStrokeWidth / 2 ? scaleHeight - theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : theStrokeWidth;\n          }).attr(\"x2\", theLineWidth).attr(\"y2\", theTick => {\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            return theSecondScaleFunc(theTick.value) <= theStrokeWidth / 2 ? theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : scaleHeight - theSecondScaleFunc(theTick.value) < theStrokeWidth / 2 ? scaleHeight - theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : theStrokeWidth;\n          }).attr(\"stroke-dasharray\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              let lineStyle = zeroAxisLineStyle && zeroAxisLineStyle.lineStyle || axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            } else {\n              // 非零线样式\n              let lineStyle = axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            }\n            return '';\n          }).attr(\"stroke-width\", function (theTick, tickIndex) {\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            return theStrokeWidth;\n          }).attr(\"stroke\", function (theTick, tickIndex) {\n            if (theTick.value === 0) return zeroStrokeLineColor || '#ddd';\n            return '#ddd';\n          }).attr(\"stroke-opacity\", showAxisLineFlag && !options.firstMeasure ? 1 : 0), update => update.attr(\"x1\", 0).attr(\"y1\", theTick => {\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            return theSecondScaleFunc(theTick.value) <= theStrokeWidth / 2 ? theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : scaleHeight - theSecondScaleFunc(theTick.value) < theStrokeWidth / 2 ? scaleHeight - theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : theStrokeWidth;\n          }).attr(\"x2\", theLineWidth).attr(\"y2\", theTick => {\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            return theSecondScaleFunc(theTick.value) <= theStrokeWidth / 2 ? theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : scaleHeight - theSecondScaleFunc(theTick.value) < theStrokeWidth / 2 ? scaleHeight - theSecondScaleFunc(theTick.value) - theStrokeWidth / 2 : theStrokeWidth;\n          }).attr(\"stroke-dasharray\", function (theTick, tickIndex) {\n            if (theTick.value === 0) {\n              // 零线样式\n              let lineStyle = zeroAxisLineStyle && zeroAxisLineStyle.lineStyle || axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            } else {\n              // 非零线样式\n              let lineStyle = axisLineStyle && axisLineStyle.lineStyle || 'solid';\n              return lineStyle === 'solid' ? '' : '5,5';\n            }\n            return '';\n          }).attr(\"stroke-width\", function (theTick, tickIndex) {\n            let theStrokeWidth = 1;\n            if (theTick.value === 0) {\n              // 零线样式\n              if (zeroAxisLineStyle && _DataFocusMethod.isPureNumber(zeroAxisLineStyle.lineWidth)) {\n                theStrokeWidth = zeroAxisLineStyle.lineWidth;\n              } else if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            } else {\n              // 非零线样式\n              if (axisLineStyle && _DataFocusMethod.isPureNumber(axisLineStyle.lineWidth)) {\n                theStrokeWidth = axisLineStyle.lineWidth;\n              } else {\n                theStrokeWidth = 1;\n              }\n            }\n            return theStrokeWidth;\n          }).attr(\"stroke\", function (theTick, tickIndex) {\n            if (theTick.value === 0) return zeroStrokeLineColor || '#ddd';\n            return '#ddd';\n          }).attr(\"stroke-opacity\", showAxisLineFlag && !options.firstMeasure ? 1 : 0), exit => exit.remove());\n\n          // 右侧Y轴刻度Label\n          const rightYTickTexts = rightYAxisGroup.selectAll('text.y-tick-text.right-text').data(d => [d]).join(enter => enter.append(\"text\").attr(\"class\", \"y-tick-text right-text\").attr(\"text-anchor\", \"start\").attr(\"transform\", function (theTick, tickIndex) {\n            if (tickIndex === theMeasureTickScale.ticksLength - 1) {\n              return \"translate(\" + (theLineWidth + theSeparate) + \" , \" + (axisFontSize * 0.4 > scalePaddingTop ? axisFontSize - scalePaddingTop : axisFontSize * 0.4) + \")\";\n            } else {\n              return \"translate(\" + (theLineWidth + theSeparate) + \" , \" + axisFontSize * 0.4 + \")\";\n            }\n          }).text(function (theTick, tickIndex) {\n            // 当设置过最大值最小值时 , 两条线太近时,会忽略一条 (保证最大值与最小值一定显示)\n            if (prevTick && theSecondScaleFunc(prevTick.value) - theSecondScaleFunc(theTick.value) < 10) {\n              if (tickIndex > 1) {\n                prevTextDom && prevTextDom.style(\"display\", \"none\");\n              }\n            }\n            prevTick = theTick;\n            if (theMeasureTickWidth < 3) return '';else if (theMeasureTickWidth < 5) return '.';\n\n            // 如果第一个y轴列配置不是默认配置，则刻度使用该配置\n            // 如果当前刻度长度超过了最大宽度，则截取显示\n            let dText = theTick.name || '',\n              theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                fontSize: axisFontSize\n              });\n            if (theTextSize.width > theMeasureTickWidth) {\n              let theSubText = '';\n              for (let i = 0; i < dText.length; i++) {\n                let chart = dText.charAt(i);\n                theSubText += chart;\n                let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                  fontSize: axisFontSize\n                });\n                if (theSubTextSize.width + axisFontSize > theMeasureTickWidth) {\n                  break;\n                }\n              }\n              if (theSubText.length === dText.length) {\n                return dText;\n              } else {\n                return theSubText + '..';\n              }\n            }\n            return theTick.name;\n          }).append(\"title\").text(theTick => theTick.name), update => update.attr(\"transform\", function (theTick, tickIndex) {\n            if (tickIndex === theMeasureTickScale.ticksLength - 1) {\n              return \"translate(\" + (theLineWidth + theSeparate) + \" , \" + (axisFontSize * 0.4 > scalePaddingTop ? axisFontSize - scalePaddingTop : axisFontSize * 0.4) + \")\";\n            } else {\n              return \"translate(\" + (theLineWidth + theSeparate) + \" , \" + axisFontSize * 0.4 + \")\";\n            }\n          }).text(function (theTick, tickIndex) {\n            // 当设置过最大值最小值时 , 两条线太近时,会忽略一条 (保证最大值与最小值一定显示)\n            if (prevTick && theFirstScaleFunc(prevTick.value) - theFirstScaleFunc(theTick.value) < axisFontSize) {\n              if (tickIndex > 1) {\n                prevTextDom && prevTextDom.style(\"display\", \"none\");\n              }\n            }\n            prevTick = theTick;\n            if (theMeasureTickWidth < 3) return '';else if (theMeasureTickWidth < 5) return '.';\n\n            // 如果第一个y轴列配置不是默认配置，则刻度使用该配置\n            // 如果当前刻度长度超过了最大宽度，则截取显示\n            let dText = theTick.name || '',\n              theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', dText, {\n                fontSize: axisFontSize\n              });\n            if (theTextSize.width > theMeasureTickWidth) {\n              let theSubText = '';\n              for (let i = 0; i < dText.length; i++) {\n                let chart = dText.charAt(i);\n                theSubText += chart;\n                let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getStrSizeByCanvas('string', theSubText, {\n                  fontSize: axisFontSize\n                });\n                if (theSubTextSize.width + axisFontSize > theMeasureTickWidth) {\n                  break;\n                }\n              }\n              if (theSubText.length === dText.length) {\n                return dText;\n              } else {\n                return theSubText + '..';\n              }\n            }\n            return theTick.name;\n          }).select(\"title\").text(theTick => theTick.name), exit => exit.remove());\n        } else {\n          theVerticalMeasContainer.selectAll('g.y-axis-item.tick.right-axis-item').remove();\n        }\n        theVerticalMeasContainer.attr(\"transform\", \"translate( 0 , \" + scalePaddingTop + \")\");\n        return {\n          measureContainer: theVerticalMeasContainer,\n          firstMeasureScaleFunc: theFirstScaleFunc,\n          firstMeasure: options.firstMeasure,\n          firstMeasureTickWidth: options.firstMeasure && options.firstMeasure.measureTickWidth,\n          secondMeasureScaleFunc: theSecondScaleFunc,\n          secondMeasure: options.secondMeasure,\n          secondMeasureTickWidth: options.secondMeasure && options.secondMeasure.measureTickWidth\n        };\n        break;\n    }\n  },\n  // 获取数值的小数部分的位数\n  getDigitalNumber: function (value) {\n    if (value - 0 !== value) return false;\n    value = value || '';\n    let scaleStr = value + \"\",\n      scaleOriNumbers = scaleStr.split(\".\"),\n      decimalDigits = scaleOriNumbers[1] && scaleOriNumbers[1].length || 0;\n    return decimalDigits;\n  },\n  // 保持小数位与step一致\n  keepDecimal: function (number, scale) {\n    if (!number || !scale) return number;\n    let scaleDecimalStr = scale.toString().split('.')[1],\n      scaleDecimal = scaleDecimalStr && scaleDecimalStr.length || 0;\n    if (scaleDecimal) {\n      return parseFloat(number.toFixed(scaleDecimal));\n    }\n    if (scale && !scaleDecimalStr) {\n      return parseFloat(number.toFixed(0));\n    }\n    return number;\n  },\n  /**\r\n   * 标准显示数值，超过1000的用K/M/G/万/百万之类的转换显示\r\n   * @param number  -   需要格式化的数据\r\n   * @param options\r\n   *          {\r\n   *              formatType  -   数据格式，default说明使用默认的格式\r\n   *              currency    -   货币格式\r\n   *              percent     -   百分比\r\n   *              number      -   数字\r\n   *              ...\r\n   *          }\r\n   * */\n  calcUnitNumber: function (number, options) {\n    let theNumber = parseFloat(number),\n      theAbsNumber = Math.abs(theNumber);\n    if (isNaN(theNumber)) return number;\n    options = options || {};\n    let language = options.language || 'chinese';\n    let separate = parseFloat(options.separate);\n    let unitSuffix = '',\n      unitStep = 1;\n    // 英文单位是K/M/G/T....\n    if (language === 'english') {\n      const unitT = Math.pow(10, 12),\n        unitG = Math.pow(10, 9),\n        unitM = Math.pow(10, 6),\n        unitK = Math.pow(10, 3);\n\n      // 如果没有传入separate, 则自己计算单位\n      if (!separate) {\n        if (theAbsNumber / unitT >= 1) separate = unitT;else if (theAbsNumber / unitG >= 1) separate = unitG;else if (theAbsNumber / unitM >= 1) separate = unitM;else if (theAbsNumber / unitK >= 1) separate = unitK;\n      }\n      if (separate / unitT >= 1) {\n        unitSuffix = 'T';\n        unitStep = unitT;\n      } else if (separate / unitG >= 1) {\n        unitSuffix = 'G';\n        unitStep = unitG;\n      } else if (separate / unitM >= 1) {\n        unitSuffix = 'M';\n        unitStep = unitM;\n      } else if (separate / unitK >= 1) {\n        unitSuffix = 'K';\n        unitStep = unitK;\n      } else {\n        unitSuffix = '';\n        unitStep = 1;\n      }\n    }\n    // 中文后缀是万/百万/千万/亿。。。\n    else if (language === 'chinese') {\n      const unitYi = Math.pow(10, 8),\n        unitQw = Math.pow(10, 7),\n        unitBw = Math.pow(10, 6),\n        unitW = Math.pow(10, 4),\n        unitQ = Math.pow(10, 3);\n\n      // 如果没有传入separate, 则自己计算单位\n      if (isNaN(separate)) {\n        if (theAbsNumber / unitYi >= 1) separate = unitYi;else if (theAbsNumber / unitQw >= 1) separate = unitQw;else if (theAbsNumber / unitBw >= 1) separate = unitBw;else if (theAbsNumber / unitW >= 1) separate = unitW;else if (theAbsNumber / unitQ >= 1) separate = unitQ;else separate = 1;\n      }\n      if (separate / unitYi >= 1) {\n        unitSuffix = '亿';\n        unitStep = unitYi;\n      } else if (separate / unitQw >= 1) {\n        unitSuffix = '千万';\n        unitStep = unitQw;\n      } else if (separate / unitBw >= 1) {\n        unitSuffix = '百万';\n        unitStep = unitBw;\n      } else if (separate / unitW >= 1) {\n        unitSuffix = '万';\n        unitStep = unitW;\n      } else if (separate / unitQ >= 1) {\n        unitSuffix = '千';\n        unitStep = unitQ;\n      } else {\n        unitSuffix = '';\n        unitStep = 1;\n      }\n    }\n    let theUnitNumberStr;\n    if (theNumber === 0) {\n      theUnitNumberStr = '0';\n    } else if (theAbsNumber > 1 && unitSuffix) {\n      theUnitNumberStr = theNumber / unitStep + unitSuffix;\n    } else {\n      theUnitNumberStr = theNumber + '';\n    }\n\n    // 如果配置了数据格式，则使用配置的\n    if (options.dataFormat && options.dataFormat.formatType && options.dataFormat.formatType !== 'default') {\n      theUnitNumberStr = _DataFocusMethod.formatData(theNumber, $.extend(options.dataFormat, {\n        numberDecimalAutoFlag: true\n      }));\n    }\n    return theUnitNumberStr;\n  },\n  /**\r\n   * 计算数值区间的间隔单位\r\n   * @param exponent  -   计算倍数\r\n   * @param absMax    -   起点数值与终点数值间的间隔\r\n   * @param options\r\n   *          {\r\n   *              maxSeparate     -   最大的间隔限制，计算的scale必须比该值小\r\n   *          }\r\n   *\r\n   * @return separate -   合适的间隔值\r\n   * */\n  calcSeparate: function (exponent, absMax) {\n    let self = this;\n    if (!_DataFocusMethod.isPureNumber(exponent + absMax)) return false;\n    // 如果计算的间隔单元是无穷大，则是一个无效间隔\n    if (Math.abs(exponent + absMax) === Infinity) return false;\n    let scale = Math.pow(10, exponent);\n    // scale的5倍数间隔\n    if (absMax / (5 * scale) < 5 && absMax / (5 * scale) >= 2) {\n      return 5 * scale;\n    }\n    // scale的2倍数间隔\n    else if (absMax / (2 * scale) < 5 && absMax / (2 * scale) >= 2) {\n      return 2 * scale;\n    }\n    // scale的1倍数间隔\n    else if (absMax / scale < 5 && absMax / scale >= 2) {\n      return scale;\n    }\n    // scale的1倍数间隔\n    else if (absMax < scale) {\n      return scale;\n    } else return self.calcSeparate(++exponent, absMax);\n  },\n  // 计算比当前间隔scale更小一级的间隔值\n  getLessScale: function (scale) {\n    let temp = scale;\n    if (temp < 1) {\n      let avoidEndless = 15;\n      while (avoidEndless > 0) {\n        avoidEndless--;\n        temp *= 10;\n        if (temp === 1 || temp === 2) return scale / 2;\n        if (temp === 5) return scale * 2 / 5;\n      }\n    } else {\n      let avoidEndless = 15;\n      while (avoidEndless > 0) {\n        avoidEndless--;\n        if (temp === 1 || temp === 2) return scale / 2;\n        if (temp === 5) return scale * 2 / 5;\n        temp = temp / 10;\n      }\n    }\n    return scale;\n  },\n  /**\r\n   * 通过最大值最小值及间隔计算一组数值刻度 ， 每个刻度的小数位与刻度差保持一致\r\n   * 该数值数组将最大值最小值的范围包含在内，但min/max不是起始点\r\n   * @param separate  -   步数间隔\r\n   * @param min       -   最小值\r\n   * @param max       -   最大值\r\n     * @return values    -   一组相同间隔的数值数组\r\n   * */\n  calcTickValues: function (separate, min, max, options) {\n    if (!_DataFocusMethod.isPureNumber(separate + min + max)) return false;\n    options = options || {};\n    let self = this,\n      mustHaveZeroFlag = !!(options.mustHaveZeroFlag || options.mustHaveZeroFlag === undefined),\n      values = [0];\n    let calUnit = separate,\n      calUnit1 = separate;\n    let absmax = Math.abs(max),\n      absmin = Math.abs(min),\n      absMax = Math.max(absmax, absmin),\n      scaleStr = separate + \"\",\n      scaleOriNumbers = scaleStr.split(\".\"),\n      decimalDigits = scaleOriNumbers[1] && scaleOriNumbers[1].length || 0;\n    // 如果必须要0刻度的情况下\n    if (mustHaveZeroFlag) {\n      // 如果正数部分占据比例大\n      if (absMax === absmax && max >= 0) {\n        while (absMax / calUnit > 1) {\n          values.push(calUnit);\n          calUnit += separate;\n          calUnit = self.keepDecimal(calUnit, separate);\n        }\n        values.push(calUnit);\n        if (min < 0) {\n          while (Math.abs(min) / calUnit1 > 1) {\n            values.unshift(0 - calUnit1);\n            calUnit1 += separate;\n            calUnit1 = self.keepDecimal(calUnit1, separate);\n          }\n          values.unshift(0 - calUnit1);\n        }\n      }\n      // 如果负数部分占据比例大\n      else if (absMax === absmin && min < 0) {\n        while (absMax / calUnit > 1) {\n          values.unshift(0 - calUnit);\n          calUnit += separate;\n        }\n        values.unshift(0 - calUnit);\n        if (max > 0) {\n          while (max / calUnit1 > 1) {\n            values.push(calUnit1);\n            calUnit1 += separate;\n            calUnit1 = self.keepDecimal(calUnit1, separate);\n          }\n          values.push(calUnit1);\n        }\n      }\n    }\n    // 如果不必需要要0，则依据刻度计算第一个规整的起点\n    else {\n      // 依据最大值最小值计算values\n      values = [];\n      let theBeginTick = Math.floor(min / separate) * separate;\n      values.push(theBeginTick);\n      for (let i = 0; theBeginTick <= max && i < 100; i++) {\n        theBeginTick += separate;\n        values.push(theBeginTick);\n      }\n    }\n\n    // 控制每个坐标刻度的小数位\n    values.forEach(function (value, i) {\n      values[i] = parseFloat(value.toFixed(decimalDigits));\n    });\n    return values;\n  },\n  /**\r\n   * 往数值数组中插入数值\r\n   * @param arr   -   待插入的数值数组\r\n   * @param value -   待插入的数值\r\n   *\r\n   * @return newArray -   拥有value的数值数值\r\n   * */\n  insertValue: function (arr, value) {\n    if (!arr || !_DataFocusMethod.isPureNumber(value)) return false;\n    let neoArr = [];\n    let count = 0;\n    let finished = false;\n    for (let i = 0; i < arr.length; i++) {\n      if (value < arr[i] && !finished) {\n        neoArr[count++] = value;\n        finished = true;\n      } else if (value === arr[i] && !finished) {\n        finished = true;\n      }\n      neoArr[count++] = arr[i];\n    }\n    if (!finished) {\n      neoArr[count] = value;\n    }\n    return neoArr;\n  },\n  // 获取数值的小数位数\n  getTheDecimal: function (number) {\n    if (!number) return 0;\n    number = number || '';\n    number = number + '';\n    let scaleDecimalStr = number.split('.')[1],\n      scaleDecimal = scaleDecimalStr && scaleDecimalStr.length || 0;\n    return scaleDecimal || 0;\n  },\n  /**\r\n   * 依据数值配置，计算刻度对象\r\n   * @param options\r\n   *          {\r\n   *              type         -   刻度类型  auto: 自动通过Y轴最大值最小值生成的刻度  ； defined: 用户自定义的固定间隔的刻度\r\n   *              min          -   [auto] 真实值的最小值\r\n   *              max          -   [auto] 真实值的最大值\r\n   *              definedMin   -   [auto] 用户定义的最小值\r\n   *              definedMax   -   [auto] 用户定义的最大值\r\n   *\r\n   *              min          -   [defined] 自定义区间的起始值\r\n   *              separate     -   [defined] 自定义区间的间隔\r\n   *              step         -   [defined] 自定义区间个数\r\n   *\r\n   *              yScaleFormat -   数据格式\r\n   *          }\r\n   *\r\n   * @return returnObj {\r\n   *          measureLength       -   数值轴的个数\r\n   *          ticks               -   刻度数组\r\n   *          ...\r\n   * }\r\n   * */\n  calcMeasureTicks: function (options) {\n    options = options || {};\n    let self = this;\n    let theValues = [],\n      separate = 0,\n      mustHaveZeroFlag = !!(options.mustHaveZeroFlag || options.mustHaveZeroFlag === undefined);\n    // 自定义固定间隔的刻度标尺\n    if (options.type === 'defined') {\n      if (!_DataFocusMethod.isPureNumber(options.min) || !_DataFocusMethod.isPureNumber(options.separate)) {\n        console.log(\"自定义的区间间隔配置不合法\");\n        return false;\n      }\n\n      // 计算固定间隔下的各个刻度\n      let scaleMin = parseFloat(options.min),\n        scaleStep = parseFloat(options.separate),\n        scaleStepNumber = parseInt(options.step) || 2;\n      scaleStepNumber = Math.max(2, scaleStepNumber);\n      separate = scaleStep;\n      let scaleDecimalDigits = self.getDigitalNumber(scaleStep) || 0,\n        minDecimalDigits = self.getDigitalNumber(scaleMin) || 0,\n        theDigital = Math.max(scaleDecimalDigits, minDecimalDigits);\n      for (let i = 0; i < scaleStepNumber; i++) {\n        let theTick = scaleMin + scaleStep * i;\n        theTick = parseFloat(theTick.toFixed(theDigital));\n        theValues.push(theTick);\n      }\n    }\n    // 自动计算最大值最小值之间的刻度间隔\n    else {\n      if (!_DataFocusMethod.isPureNumber(options.min) || !_DataFocusMethod.isPureNumber(options.max)) {\n        console.log(\"自动获取的区间值不合法\");\n        return false;\n      }\n      let min = parseFloat(options.min),\n        max = parseFloat(options.max);\n      if (min > max) {\n        let temp = min;\n        min = max;\n        max = temp;\n      }\n      // 实际值中最小值与最大值一样时，如果都是0时，选择0-1区间；如果都是1时选择0-1区间；如果时其他的，则-1\n      if (min === max) {\n        if (min === 0) min = max + 1;else if (min === 1) {\n          min = max - 1;\n        } else if (min > 0 && min < 1) {\n          min = 0;\n        } else if (min > -1 && min < 0) {\n          max = 0;\n        } else if (max === -1) {\n          min = max + 1;\n        } else min = max - 1;\n      }\n      let absMax = Math.max(Math.abs(min), Math.abs(max));\n      let exponent = -6;\n      if (mustHaveZeroFlag) {\n        // 计算刻度差[ 依据从0开始的刻度间距计算刻度间隔 ]\n        separate = self.calcSeparate(exponent, absMax);\n        // 如果间隔超出了指定的最大间隔，则重新计算一个更小的间隔\n        if (options.maxSeparate && separate >= options.maxSeparate) {\n          separate = self.getLessScale(separate);\n        }\n        // 由初始最大值最小值算出来的刻度数组\n        theValues = self.calcTickValues(separate, min, max, {\n          mustHaveZeroFlag: mustHaveZeroFlag,\n          maxSeparate: options.maxSeparate\n        });\n      } else {\n        // 计算刻度差[ 依据最大值与最小值的间距计算刻度间隔 ]\n        separate = self.calcSeparate(exponent, Math.max(max, min) - Math.min(max, min));\n        // 如果间隔超出了指定的最大间隔，则重新计算一个更小的间隔\n        if (options.maxSeparate && separate >= options.maxSeparate) {\n          separate = self.getLessScale(separate);\n        }\n        // 由初始最大值最小值算出来的刻度数组\n        theValues = self.calcTickValues(separate, min, max, {\n          mustHaveZeroFlag: mustHaveZeroFlag\n        });\n      }\n\n      // 如果传入定义的最大值或最小值，则需要重新计算刻度将定义的最大值最小值放在起始刻度的位置\n      if (options.definedMin || options.definedMax) {\n        // 如果用户传入了自定义的definedMin/definedMax , 获取用户配置的最大值最小值\n        let userDefinedMin, userDefinedMax;\n        if (options.definedMin) {\n          let theDefinedMin = options.definedMin;\n          theDefinedMin = theDefinedMin.replace(/\\s/g, '').trim();\n\n          // 配置的最小值是固定值\n          if (_DataFocusMethod.isPureNumber(theDefinedMin)) {\n            userDefinedMin = parseFloat(theDefinedMin);\n          }\n          // 配置最小值是公式 $ - 0.2 / $ - (20)\n          else if (theDefinedMin.startsWith(\"$-\")) {\n            let minPercent = theDefinedMin.substring(2);\n            if (_DataFocusMethod.isPureNumber(minPercent)) {\n              // 用户配置 $ - 0.2\n              let thePercent = parseFloat(minPercent);\n              thePercent = Math.max(0, thePercent);\n              thePercent = Math.min(1, thePercent);\n              userDefinedMin = theValues[0] - thePercent * separate;\n              let theScaleDecimal = self.getTheDecimal(separate),\n                thePercentDecimal = self.getTheDecimal(thePercent);\n              userDefinedMin = self.keepDecimal(userDefinedMin, theScaleDecimal > thePercentDecimal ? separate : thePercent);\n            } else {\n              // 用户配置 $ - (20)\n              let minNumber = theDefinedMin.substring(3, theDefinedMin.length - 1);\n              if (_DataFocusMethod.isPureNumber(minNumber)) {\n                minNumber = parseFloat(minNumber);\n                if (minNumber > 0) {\n                  userDefinedMin = theValues[0] - minNumber;\n                  let theScaleDecimal = self.getTheDecimal(separate),\n                    theNumberDecimal = self.getTheDecimal(minNumber);\n                  userDefinedMin = self.keepDecimal(userDefinedMin, theScaleDecimal > theNumberDecimal ? separate : minNumber);\n                }\n              }\n            }\n          }\n        }\n        if (options.definedMax) {\n          let theDefinedMax = options.definedMax;\n          theDefinedMax = theDefinedMax.replace(/\\s/g, '').trim();\n\n          // 配置的最大值是固定值\n          if (_DataFocusMethod.isPureNumber(theDefinedMax)) {\n            userDefinedMax = parseFloat(theDefinedMax);\n          }\n          // 配置最大值是公式 $ + 0.2 / $ + (20)\n          else if (theDefinedMax.startsWith(\"$+\")) {\n            let maxPercent = theDefinedMax.substring(2);\n            if (_DataFocusMethod.isPureNumber(maxPercent)) {\n              // 用户配置 $ + 0.2\n              let thePercent = parseFloat(maxPercent);\n              thePercent = Math.max(0, thePercent);\n              thePercent = Math.min(1, thePercent);\n              userDefinedMax = theValues[theValues.length - 1] + thePercent * separate;\n              let theScaleDecimal = self.getTheDecimal(separate),\n                thePercentDecimal = self.getTheDecimal(thePercent);\n              userDefinedMax = self.keepDecimal(userDefinedMax, theScaleDecimal > thePercentDecimal ? separate : thePercent);\n            } else {\n              // 用户配置 $ + (20)\n              let maxNumber = theDefinedMax.substring(3, theDefinedMax.length - 1);\n              if (_DataFocusMethod.isPureNumber(maxNumber)) {\n                maxNumber = parseFloat(maxNumber);\n                if (maxNumber > 0) {\n                  userDefinedMax = theValues[theValues.length - 1] + maxNumber;\n                  let theScaleDecimal = self.getTheDecimal(separate),\n                    theNumberDecimal = self.getTheDecimal(maxNumber);\n                  userDefinedMax = self.keepDecimal(userDefinedMax, theScaleDecimal > theNumberDecimal ? separate : maxNumber);\n                }\n              }\n            }\n          }\n        }\n        // 校验用户配置的起始值\n        if (_DataFocusMethod.isPureNumber(userDefinedMin) && _DataFocusMethod.isPureNumber(userDefinedMax)) {\n          if (userDefinedMin > userDefinedMax) {\n            let temp = userDefinedMin;\n            userDefinedMin = userDefinedMax;\n            userDefinedMax = temp;\n          }\n        }\n        if (_DataFocusMethod.isPureNumber(userDefinedMin) && userDefinedMin === userDefinedMax) {\n          userDefinedMax = userDefinedMin + 1;\n        }\n        if (_DataFocusMethod.isPureNumber(userDefinedMin)) {\n          min = userDefinedMin;\n        }\n        if (_DataFocusMethod.isPureNumber(userDefinedMax)) {\n          max = userDefinedMax;\n        }\n        // 校验最大最小值\n        if (min > max) {\n          let temp = min;\n          min = max;\n          max = temp;\n        }\n        // 依据用户定义的最大最小值重新计算刻度数组[ 一定会用户配置的最大值最小值包含在内 ]\n        absMax = Math.max(Math.abs(min), Math.abs(max));\n        separate = self.calcSeparate(exponent, absMax);\n        // 如果间隔超出了指定的最大间隔，则重新计算一个更小的间隔\n        if (options.maxSeparate && separate >= options.maxSeparate) {\n          separate = self.getLessScale(separate);\n        }\n        theValues = self.calcTickValues(separate, min, max);\n        // 将用户定义的最大值最小值插入到刻度数组中\n        if (_DataFocusMethod.isPureNumber(userDefinedMin)) {\n          theValues = self.insertValue(theValues, userDefinedMin);\n        }\n        if (_DataFocusMethod.isPureNumber(userDefinedMax)) {\n          theValues = self.insertValue(theValues, userDefinedMax);\n        }\n\n        // 清除计算的不在用户定义的最大值最小值之间的刻度值\n        if (_DataFocusMethod.isPureNumber(userDefinedMin)) {\n          theValues = theValues.filter(function (v) {\n            return v >= userDefinedMin;\n          });\n        }\n        if (_DataFocusMethod.isPureNumber(userDefinedMax)) {\n          theValues = theValues.filter(function (v) {\n            return v <= userDefinedMax;\n          });\n        }\n      }\n    }\n    if (!theValues || !theValues.length) {\n      console.log('计算刻度异常');\n      return false;\n    }\n    let yTicks = [],\n      yTickStringLength = 0;\n    theValues && theValues.forEach(function (theOriginalValue) {\n      let theDisplayValue = self.calcUnitNumber(theOriginalValue, {\n        language: options.language,\n        separate: separate,\n        dataFormat: options.yScaleFormat\n      });\n      yTicks.push({\n        value: theOriginalValue,\n        name: theDisplayValue\n      });\n      yTickStringLength = Math.max(theDisplayValue.length, yTickStringLength);\n    });\n    return {\n      measureLength: options.measureLength,\n      ticks: yTicks,\n      min: theValues[0],\n      max: theValues[theValues.length - 1],\n      separate: separate,\n      scaleFormat: options.yScaleFormat,\n      values: theValues,\n      originalValues: theValues,\n      ticksLength: yTicks.length,\n      tickStringLength: yTickStringLength\n    };\n  },\n  /**\r\n   * 获取Y轴的百分比刻度列表\r\n   * 用到的图表有：帕累托图/堆积柱状图\r\n   * @ticksLength  Y轴刻度数量，即为百分比的刻度数量\r\n   * */\n  getPercentYTicks: function (ticksLength) {\n    var yTickes = [],\n      unit = \"%\",\n      scale = 1,\n      tick,\n      maxLength = 0,\n      max = 100,\n      min = 0;\n    tick = Math.ceil((100 / scale / (ticksLength - 1)).toFixed(2) * 10) / 10;\n    for (var i = 0; i < ticksLength; i++) {\n      var curTick = min / scale + tick * i;\n      if (curTick % 1 != 0) {\n        curTick = curTick.toFixed(1);\n      }\n      if (curTick >= 100) {\n        curTick = 100;\n      }\n      curTick += unit;\n      max = (min / scale + tick * i) * scale;\n      if (max >= 100) max = 100;\n      maxLength = curTick.length > maxLength ? curTick.length : maxLength;\n      yTickes.push({\n        value: max,\n        name: curTick\n      });\n    }\n    return {\n      min: min,\n      max: max,\n      unit: unit,\n      scale: scale,\n      ticks: yTickes,\n      maxStrLength: maxLength\n    };\n  },\n  // 对齐两个刻度数组的零刻度\n  alignMeasureZeroTicks: function (options) {\n    options = options || {};\n    let firstMeasureTicks = options.firstMeasureScale,\n      secondMeasureTicks = options.secondMeasureScale,\n      language = options.language || 'chinese';\n    if (!firstMeasureTicks || !secondMeasureTicks) return false;\n    if (!firstMeasureTicks.originalValues || !secondMeasureTicks.originalValues) return;\n    let self = this;\n    let tempLeftValues = firstMeasureTicks.values.slice(0);\n    let tempRightValues = secondMeasureTicks.values.slice(0);\n\n    //统计左右Y轴的相互超出的刻度数\n    let negativeMax = 0,\n      positiveMax = 0;\n    let lTempCt = 0;\n    let lTempCtP = 0;\n    for (let i = 0; i < firstMeasureTicks.originalValues.length; i++) {\n      if (firstMeasureTicks.originalValues[i] < 0) lTempCt++;\n      if (firstMeasureTicks.originalValues[i] > 0) lTempCtP++;\n    }\n    if (lTempCt > negativeMax) negativeMax = lTempCt;\n    if (lTempCtP > positiveMax) positiveMax = lTempCtP;\n    let rTempCt = 0;\n    let rTempCtP = 0;\n    for (let i = 0; i < secondMeasureTicks.originalValues.length; i++) {\n      if (secondMeasureTicks.originalValues[i] < 0) rTempCt++;\n      if (secondMeasureTicks.originalValues[i] > 0) rTempCtP++;\n    }\n    if (rTempCt > negativeMax) negativeMax = rTempCt;\n    if (rTempCtP > positiveMax) positiveMax = rTempCtP;\n\n    //将左右Y轴各自不足的刻度数补全\n    let insertValue = firstMeasureTicks.originalValues[firstMeasureTicks.originalValues.length - 1];\n    for (let i = 0; i < positiveMax - lTempCtP; i++) {\n      if (i === positiveMax - lTempCtP - 1) {\n        insertValue += Math.abs(firstMeasureTicks.separate * (tempRightValues[tempRightValues.length - 1] - tempRightValues[tempRightValues.length - 2]) / secondMeasureTicks.separate);\n      } else insertValue += firstMeasureTicks.separate;\n      firstMeasureTicks.values = self.insertValue(firstMeasureTicks.values, self.keepDecimal(insertValue, firstMeasureTicks.separate));\n    }\n    insertValue = firstMeasureTicks.originalValues[0];\n    for (let i = 0; i < negativeMax - lTempCt; i++) {\n      if (i === negativeMax - lTempCt - 1) {\n        insertValue -= Math.abs(firstMeasureTicks.separate * (tempRightValues[0] - tempRightValues[1]) / secondMeasureTicks.separate);\n      } else insertValue -= firstMeasureTicks.separate;\n      firstMeasureTicks.values = self.insertValue(firstMeasureTicks.values, self.keepDecimal(insertValue, firstMeasureTicks.separate));\n    }\n    insertValue = secondMeasureTicks.originalValues[secondMeasureTicks.originalValues.length - 1];\n    for (let i = 0; i < positiveMax - rTempCtP; i++) {\n      if (i === positiveMax - rTempCtP - 1) {\n        insertValue += Math.abs(secondMeasureTicks.separate * (tempLeftValues[tempLeftValues.length - 1] - tempLeftValues[tempLeftValues.length - 2]) / firstMeasureTicks.separate);\n      } else insertValue += secondMeasureTicks.separate;\n      secondMeasureTicks.values = self.insertValue(secondMeasureTicks.values, self.keepDecimal(insertValue, secondMeasureTicks.separate));\n    }\n    insertValue = secondMeasureTicks.originalValues[0];\n    for (let i = 0; i < negativeMax - rTempCt; i++) {\n      if (i === negativeMax - rTempCt - 1) {\n        insertValue -= Math.abs(secondMeasureTicks.separate * (tempLeftValues[0] - tempLeftValues[1]) / firstMeasureTicks.separate);\n      } else insertValue -= secondMeasureTicks.separate;\n      secondMeasureTicks.values = self.insertValue(secondMeasureTicks.values, self.keepDecimal(insertValue, secondMeasureTicks.separate));\n    }\n    //若无需补全，则无法对齐最值，故而补全边界\n    if (rTempCtP === lTempCtP) {\n      firstMeasureTicks.values = self.insertValue(firstMeasureTicks.values, firstMeasureTicks.originalValues[firstMeasureTicks.originalValues.length - 1]);\n      secondMeasureTicks.values = self.insertValue(secondMeasureTicks.values, secondMeasureTicks.originalValues[secondMeasureTicks.originalValues.length - 1]);\n    }\n    if (rTempCt === lTempCt) {\n      firstMeasureTicks.values = self.insertValue(firstMeasureTicks.values, firstMeasureTicks.originalValues[0]);\n      secondMeasureTicks.values = self.insertValue(secondMeasureTicks.values, secondMeasureTicks.originalValues[0]);\n    }\n    firstMeasureTicks.values = self.insertValue(firstMeasureTicks.values, 0);\n    secondMeasureTicks.values = self.insertValue(secondMeasureTicks.values, 0);\n    let units = firstMeasureTicks.values.slice(0);\n    let yTicks = [],\n      yTickStringLength = 0;\n    for (let i = 0; i < units.length; i++) {\n      let theDisplayValue = self.calcUnitNumber(units[i], {\n        separate: firstMeasureTicks.separate,\n        language: language,\n        dataFormat: firstMeasureTicks.scaleFormat\n      });\n      yTicks.push({\n        value: units[i],\n        name: theDisplayValue\n      });\n      yTickStringLength = Math.max(theDisplayValue.length, yTickStringLength);\n    }\n    firstMeasureTicks.ticks = yTicks;\n    firstMeasureTicks.min = firstMeasureTicks.values[0];\n    firstMeasureTicks.max = firstMeasureTicks.values[firstMeasureTicks.values.length - 1];\n    firstMeasureTicks.ticksLength = yTicks.length;\n    firstMeasureTicks.tickStringLength = yTickStringLength;\n    units = secondMeasureTicks.values.slice(0);\n    yTicks = [];\n    yTickStringLength = 0;\n    for (let i = 0; i < units.length; i++) {\n      let theDisplayValue = self.calcUnitNumber(units[i], {\n        separate: secondMeasureTicks.separate,\n        language: language,\n        dataFormat: secondMeasureTicks.scaleFormat\n      });\n      yTicks.push({\n        value: units[i],\n        name: theDisplayValue\n      });\n      yTickStringLength = Math.max(theDisplayValue.length, yTickStringLength);\n    }\n    secondMeasureTicks.ticks = yTicks;\n    secondMeasureTicks.min = secondMeasureTicks.values[0];\n    secondMeasureTicks.max = secondMeasureTicks.values[secondMeasureTicks.values.length - 1];\n    secondMeasureTicks.ticksLength = yTicks.length;\n    secondMeasureTicks.tickStringLength = yTickStringLength;\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (MeasureAxisComponent);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/MeasureAxisComponent.js?");

/***/ })

}]);