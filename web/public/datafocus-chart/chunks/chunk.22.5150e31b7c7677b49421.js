(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[22],{

/***/ "../src-v5/assets/js/charts.system.basic/scatter/ScatterChartComponent.js":
/*!********************************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/scatter/ScatterChartComponent.js ***!
  \********************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n// 辅助柱形图画图的组件\n\n\nlet ScatterChartComponent = {\n  /**\r\n   * X轴是数值列的情况下，\r\n   * 解析所有的散点数据，生成所有需要画的散点数据供 drawCanvasScatterChartSet 画图\r\n   * @param chartSetData  -   各个图例下的数据\r\n   * @param options\r\n   *          {\r\n   *              curXAxis        -   X轴的数值列\r\n   *              measureXAxis    -   依据X轴数值列计算的X轴刻度对象\r\n   *              curYAxis        -   Y轴的数值列\r\n   *              measureYAxis    -   依据Y轴数值列计算的Y轴刻度对象\r\n   *              paddingTop      -   顶部的间隔\r\n   *              legendConfig    -   图例的配置对象\r\n   *              yIndex          -   当前Y轴数值列的索引\r\n   *              legendType      -   图例类型  legendAxis： 有图例属性列 ； yAxis： 多个Y轴生成的图例\r\n   *              legendValue     -   图例值   legendAxis下是图例列中值 ； yAxis下Y轴的col_id\r\n   *              legendIndex     -   图例值的索引\r\n   *              scatterSize -   散点大小，默认是5\r\n   *          }\r\n   * **/\n  getMeasureScatterChartSet: function (chartSetData, options) {\n    options = options || {};\n    if (!chartSetData || !chartSetData.length) return false;\n    if (!options.measureXAxis || !options.measureXAxis.firstMeasureScaleFunc || !options.measureYAxis || !options.measureYAxis.firstMeasureScaleFunc || !options.curYAxis || !options.curXAxis) return false;\n    let measureXScaleFunc = options.measureXAxis.firstMeasureScaleFunc,\n      measureYScaleFunc = options.measureYAxis.firstMeasureScaleFunc,\n      paddingTop = parseFloat(options.paddingTop) || 0,\n      legendConfig = options.legendConfig || {},\n      scatterRadius = parseFloat(options.scatterSize) || 5;\n    let drawScatterList = [],\n      theMax = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].max(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      }),\n      theMin = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].min(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      });\n    chartSetData.forEach(function (curData) {\n      if (!curData) return false;\n      let theXValue = curData.x0,\n        theYValue = curData['y' + options.yIndex];\n      if (_DataFocusMethod.isPureNumber(theXValue) && _DataFocusMethod.isPureNumber(theYValue)) {\n        let theOX = measureXScaleFunc(curData.x0),\n          theOY = measureYScaleFunc(curData['y' + options.yIndex]) + paddingTop;\n        let theColor = legendConfig.color;\n        // X轴的颜色规则\n        if (options.curXAxis.header && options.curXAxis.header.colorFormattings) {\n          let theXColorFormats = options.curXAxis.header.colorFormattings;\n          let curColor = _DataFocusMethod.calcTheColor(theXValue, theXColorFormats, {\n            rowData: curData.rowData\n          });\n          if (curColor) theColor = curColor;\n        }\n        // Y轴的颜色规则\n        if (options.curYAxis.header && options.curYAxis.header.colorFormattings) {\n          let theYColorFormats = options.curYAxis.header.colorFormattings;\n          let curColor = _DataFocusMethod.calcTheColor(theYValue, theYColorFormats, {\n            rowData: curData.rowData\n          });\n          if (curColor) theColor = curColor;\n        }\n\n        // 当前点是警告点的情况下 , 则需要使用svg画该点，加上闪烁效果\n        if (curData[\"alarm\" + options.yIndex] || curData[\"alarm_x_0\"]) {\n          theColor = '#ff0000';\n        }\n        drawScatterList.push({\n          ox: theOX,\n          oy: theOY,\n          color: theColor,\n          yIndex: options.yIndex,\n          x0: curData.x0,\n          y0: curData.y0,\n          legendType: options.legendType,\n          legendId: options.legendId,\n          legendValue: options.legendValue,\n          legendIndex: options.legendIndex,\n          legendConfig: options.legendConfig,\n          legendTotal: chartSetData.total,\n          rowData: curData.rowData,\n          rowIndex: curData.rowIndex,\n          isAlarmFlag: curData[\"alarm\" + options.yIndex] || curData[\"alarm_x_0\"],\n          isMaxFlag: curData.y0 == theMax,\n          isMinFlag: curData.y0 == theMin,\n          scatterType: options.scatterType,\n          scatterSize: scatterRadius,\n          scatterTransparent: options.scatterTransparent,\n          scatterStrokeWidth: options.scatterStrokeWidth\n        });\n      }\n    });\n    return drawScatterList;\n  },\n  /**\r\n   * 在X轴是属性的情况下，\r\n   * 解析所有的散点数据，生成所有需要画的散点数据供 drawCanvasScatterChartSet 画图\r\n   * @param chartSetData  -   散点数据\r\n   * @param options\r\n   *          {\r\n   *              attributeXAxis  -   属性X轴的比例尺对象\r\n   *              measureYAxis    -   数值Y轴的比例尺对象\r\n   *              scatterSize -   散点大小，默认是5\r\n   *          }\r\n   * **/\n  getAttributeScatterChartSet: function (chartSetData, options) {\n    options = options || {};\n    if (!chartSetData || !chartSetData.length) return false;\n    if (!options.attributeXAxis || !options.attributeXAxis.scale || !options.measureYAxis || !options.measureYAxis.firstMeasureScaleFunc || !options.curYAxis) return false;\n    let attributeXScaleFunc = options.attributeXAxis.scale,\n      rangeBand = options.attributeXAxis.rangeBand || 0,\n      measureYScaleFunc = options.curYAxis.direction !== 'right' ? options.measureYAxis.firstMeasureScaleFunc : options.measureYAxis.secondMeasureScaleFunc,\n      legendConfig = options.legendConfig || {},\n      scatterRadius = parseFloat(options.scatterSize) || 5;\n    let drawScatterList = [],\n      theMax = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].max(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      }),\n      theMin = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].min(chartSetData, function (d) {\n        return d['y' + options.yIndex];\n      });\n    chartSetData.forEach(function (curData) {\n      if (!curData) return false;\n      let theYValue = curData['y' + options.yIndex];\n      if (_DataFocusMethod.isPureNumber(theYValue)) {\n        let theOX = attributeXScaleFunc(curData.x0) + rangeBand / 2,\n          theOY = measureYScaleFunc(curData['y' + options.yIndex]);\n        let theColor = legendConfig.color;\n        // Y轴的颜色规则\n        if (options.curYAxis.header && options.curYAxis.header.colorFormattings) {\n          let theYColorFormats = options.curYAxis.header.colorFormattings;\n          let curColor = _DataFocusMethod.calcTheColor(theYValue, theYColorFormats, {\n            rowData: curData.rowData\n          });\n          if (curColor) theColor = curColor;\n        }\n\n        // 当前点是警告点的情况下 , 则需要使用svg画该点，加上闪烁效果\n        if (curData[\"alarm\" + options.yIndex]) {\n          theColor = '#ff0000';\n        }\n        drawScatterList.push({\n          ox: theOX,\n          oy: theOY,\n          color: theColor,\n          yIndex: options.yIndex,\n          x0: curData.x0,\n          y0: curData['y' + options.yIndex],\n          legendType: options.legendType,\n          legendId: options.legendId,\n          legendValue: options.legendValue,\n          legendIndex: options.legendIndex,\n          legendConfig: options.legendConfig,\n          legendTotal: chartSetData.total,\n          rowData: curData.rowData,\n          rowIndex: curData.rowIndex,\n          isAlarmFlag: curData[\"alarm\" + options.yIndex],\n          isMaxFlag: curData['y' + options.yIndex] == theMax,\n          isMinFlag: curData['y' + options.yIndex] == theMin,\n          scatterType: options.scatterType,\n          scatterSize: scatterRadius,\n          scatterTransparent: options.scatterTransparent,\n          scatterStrokeWidth: options.scatterStrokeWidth\n        });\n      }\n    });\n    return drawScatterList;\n  },\n  /**\r\n   * 在Canvas中画散点，无需分页，直接画所有数据【主要应对散点数据过多的情况，在svg中数据过多会导致标签过多从而导致浏览器崩溃】\r\n   * @param chartSetData  -   所有三点数据\r\n   * @param options\r\n   *          {\r\n   *              canvasContext   -   当前的canvas画图上下文\r\n   *              canvasZoom      -   当前canvas的缩放大小\r\n   *              canvasHeight    -   画布的高度\r\n   *              canvasWidth     -   画布的宽度\r\n   *              svgWarningContext   -   画SVG图形的区域\r\n   *\r\n   *              animateFlag             -   是否需要动画\r\n   *\r\n   *              mouseoverCallback           -    鼠标移入事件的响应方法\r\n   *              mouseoutCallback            -    鼠标移出事件的响应方法\r\n   *              mousedownCallback           -    鼠标点击事件的响应方法\r\n   *          }\r\n   * */\n  drawCanvasScatterChartSet: function (scatterDataSet, options) {\n    if (!scatterDataSet || !scatterDataSet.length) return false;\n    options = options || {};\n    if (!options.canvasContext || !options.canvasHeight || !options.canvasWidth) return false;\n    let self = this,\n      canvasContext = options.canvasContext,\n      canvasZoom = parseFloat(options.canvasZoom) || 1,\n      animateFlag = !!options.animateFlag,\n      canvasHeight = parseFloat(options.canvasHeight),\n      currentLegendId = options.currentLegendId,\n      selectedScatterIndex = parseInt(options.selectedScatterIndex);\n    let animateCanvasTimer,\n      canvasPercentage = animateFlag ? 0 : 1,\n      canvasPercentStep = animateFlag ? 0.1 : 1;\n    let animateCanvasScatter = function () {\n      if (animateCanvasTimer) return false;\n      animateCanvasTimer = setTimeout(function () {\n        canvasContext.clearRect(0, 0, options.canvasWidth * canvasZoom, options.canvasHeight * canvasZoom);\n        // 画圆圈\n        scatterDataSet.forEach(function (theScatter, index) {\n          if (!_DataFocusMethod.isPureNumber(theScatter.ox) || !_DataFocusMethod.isPureNumber(theScatter.oy) || !theScatter.color) return false;\n          let theColor = theScatter.color,\n            theOpacity;\n          // 如果有高亮图例时，非高亮图例的透明度是0.2 颜色是灰色 ；\n          // 高亮图例透明度是0.3，高亮点边框加粗\n          if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== theScatter.legendId) {\n            theColor = 'rgba(28,28,28,0.2)';\n            theOpacity = 0.2;\n          }\n          self.drawScatterShapeByCanvas({\n            canvasContext: canvasContext,\n            canvasZoom: canvasZoom,\n            svgWarningContext: options.svgWarningContext,\n            isEndFlag: canvasPercentage >= 0.95,\n            ox: theScatter.ox,\n            oy: theScatter.oy + (canvasHeight - theScatter.oy) * (1 - canvasPercentage),\n            isAlarmFlag: theScatter.isAlarmFlag,\n            color: theColor,\n            strokeOpacity: theOpacity,\n            selectedFlag: selectedScatterIndex === index,\n            scatterType: theScatter.scatterType,\n            scatterSize: theScatter.scatterSize,\n            scatterTransparent: theScatter.scatterTransparent,\n            scatterStrokeWidth: theScatter.scatterStrokeWidth\n          });\n        });\n        // 画数据标签 [ 因为canvasPercentage小数叠加0.1会出现误差 ]\n        if (options.showLabelFlag && canvasPercentage >= 0.95) {\n          let labelFontSize = options.labelFontSize || 10,\n            labelFontColor = options.labelFontColor === undefined ? '#333' : options.labelFontColor,\n            labelFontBold = options.labelFontBold === undefined ? '500' : options.labelFontBold ? 'bold' : '500',\n            labelFontItalic = options.labelFontItalic === undefined ? 'normal' : options.labelFontItalic ? 'italic' : 'normal',\n            labelPosition = options.labelPosition || \"default\",\n            labelChartSpace = 3,\n            //  标签局内局外时，与散点的距离\n            labelRotation = options.labelRotation || 0,\n            labelVisibleMap = options.labelVisibleMap || 'all',\n            labelAllowOverlap = !!options.labelAllowOverlap;\n          let drewScatterArray = [];\n          canvasContext.globalAlpha = 1;\n          scatterDataSet.forEach(function (theScatter, index) {\n            if (!theScatter || !theScatter.labelText) return false;\n            // 非当前图例的标签不画\n            if (currentLegendId !== undefined && currentLegendId !== null && currentLegendId !== theScatter.legendId) {\n              return false;\n            }\n            // 只显示最大最小值的情况下\n            if (labelVisibleMap !== 'all' && !theScatter.isMaxFlag && !theScatter.isMinFlag) return false;\n            let theTextArray = theScatter.labelText.split('\\n'),\n              maxLabelWidth = 0,\n              perHeight = 0,\n              maxLabelHeight = 0;\n            theTextArray && theTextArray.forEach(function (theText) {\n              if (theText) {\n                let theTextStrSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', theText, {\n                  fontSize: labelFontSize\n                });\n                maxLabelWidth = Math.max(maxLabelWidth, theTextStrSize.width);\n                maxLabelHeight += theTextStrSize.height;\n                perHeight = theTextStrSize.height;\n              }\n            });\n            let theOy = theScatter.oy * canvasPercentage;\n            let theTextPosition = {\n              ox: theScatter.ox,\n              oy: theOy,\n              x: theScatter.ox - maxLabelWidth / 2,\n              y: theOy - maxLabelHeight / 2,\n              width: maxLabelWidth,\n              perHeight: perHeight,\n              height: maxLabelHeight\n            };\n            if (labelPosition === 'in') {\n              // 如果设置居点内\n              theTextPosition.y = theOy - maxLabelHeight / 2;\n            } else if (labelPosition === 'out') {\n              // 设置居点外\n              theTextPosition.y = theOy - theScatter.scatterSize - maxLabelHeight;\n            } else {\n              // 默认情况下居点外\n              theTextPosition.y = theOy - theScatter.scatterSize - maxLabelHeight;\n            }\n\n            // 居外标签旋转，是网上旋转； 居内标签旋转是居中旋转\n            if (labelRotation > 0) {\n              if (labelPosition === 'in') {\n                // 中心点不变，中心点旋转\n                theTextPosition.x = theScatter.ox - maxLabelHeight / 2;\n                theTextPosition.y = theOy - maxLabelWidth / 2;\n                theTextPosition.width = maxLabelHeight;\n                theTextPosition.height = maxLabelWidth;\n              } else {\n                // 往上旋转\n                theTextPosition.ox = theScatter.ox;\n                theTextPosition.oy = theOy - theScatter.scatterSize - maxLabelWidth / 2;\n                theTextPosition.x = theScatter.ox - maxLabelHeight / 2;\n                theTextPosition.y = theOy - theScatter.scatterSize - maxLabelWidth;\n                theTextPosition.width = maxLabelHeight;\n                theTextPosition.height = maxLabelWidth;\n              }\n            }\n\n            // 如果与图形之间有间隔 , 只有居外时需要有间隔\n            if (labelChartSpace && labelPosition !== 'in') {\n              theTextPosition.y = theTextPosition.y - labelChartSpace;\n            }\n\n            // 如果左侧超出图形，则往右移动 ； 超出右侧往左移\n            if (theTextPosition.x < 0) theTextPosition.x = 0;else if (theTextPosition.x + theTextPosition.width > options.canvasWidth) theTextPosition.x = options.canvasWidth - theTextPosition.width;\n            // 如果上侧超出图形，则往下移动；超出下侧，往上移动\n            if (theTextPosition.y < 0) theTextPosition.y = 0;else if (theTextPosition.y + theTextPosition.height > options.canvasHeight) theTextPosition.y = options.canvasHeight - theTextPosition.height;\n            let overlapFlag = false;\n            for (let i = drewScatterArray.length - 1; !labelAllowOverlap && i >= 0; i--) {\n              let compScatterTextDom = drewScatterArray[i];\n              if (_pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].isOverlap(theTextPosition, compScatterTextDom)) {\n                overlapFlag = true;\n                break;\n              }\n            }\n            if (labelAllowOverlap || !overlapFlag) {\n              canvasContext.save();\n              /*// 主要用于矫正位置的rect [ 本地测试使用 ]\r\n              canvasContext.beginPath() ;\r\n              canvasContext.rect(theTextPosition.x * canvasZoom , theTextPosition.y * canvasZoom ,\r\n                  theTextPosition.width * canvasZoom , theTextPosition.height * canvasZoom) ;\r\n              canvasContext.fillStyle = 'rgba(28,28,28,0)';\r\n              canvasContext.fill();\r\n              canvasContext.closePath() ;*/\n              canvasContext.translate(theTextPosition.x * canvasZoom, theTextPosition.y * canvasZoom);\n              canvasContext.rotate(labelRotation * Math.PI / 180);\n              canvasContext.fillStyle = labelFontColor;\n              canvasContext.font = labelFontBold + ' ' + labelFontItalic + ' ' + labelFontSize * canvasZoom + 'px 微软雅黑,Helvetica,Arial,sans-serif';\n              canvasContext.textBaseline = 'hanging';\n              let drawIndex = 0;\n              theTextArray && theTextArray.forEach(function (theText) {\n                if (labelRotation === 90) {\n                  canvasContext.fillText(theText, 0, -(theTextPosition.width - theTextPosition.perHeight * drawIndex) * canvasZoom);\n                } else if (labelRotation === 270) {\n                  canvasContext.fillText(theText, -theTextPosition.height * canvasZoom, theTextPosition.perHeight * drawIndex * canvasZoom);\n                } else {\n                  canvasContext.fillText(theText, 0, theTextPosition.perHeight * drawIndex * canvasZoom);\n                }\n                drawIndex++;\n              });\n              canvasContext.restore();\n              drewScatterArray.push(theTextPosition);\n            }\n          });\n        }\n\n        // 画数据分析的结果 趋势线\n        // 针对有数据分析结果的,在分析数据中增加相关性的线[ 有相关性的X轴都是数值列 ]\n        if (options.analysisData && options.analysisData.hasAnalysisFlag && options.analysisData.analysisLineData && options.analysisData.analysisLineData.length) {\n          let analysisData = options.analysisData;\n          // 在canvas中画相关线\n          canvasContext.beginPath();\n          canvasContext.lineWidth = _DataFocusMethod.isPureNumber(analysisData.analysisLineWidth) ? analysisData.analysisLineWidth : 1;\n          canvasContext.strokeStyle = analysisData.analysisLineColor || 'red';\n          canvasContext.moveTo(analysisData.analysisLineData[0][0], analysisData.analysisLineData[0][1]);\n          let prevPoint = analysisData.analysisLineData[0];\n          for (let i = 1; i < analysisData.analysisLineData.length; i++) {\n            let thePoint = analysisData.analysisLineData[i];\n            canvasContext.lineTo(thePoint[0], thePoint[1]);\n            // canvasContext.quadraticCurveTo(prevPoint[0] , prevPoint[1] , thePoint[0]  , thePoint[1]);\n            prevPoint = thePoint;\n          }\n          canvasContext.stroke();\n        }\n        canvasPercentage += canvasPercentStep;\n        animateCanvasTimer = null;\n        // 放置小数叠加的误差\n        if (canvasPercentage <= 1 + 0.05) animateCanvasScatter(canvasPercentage);\n      }, 30);\n    };\n    animateCanvasScatter(canvasPercentage);\n  },\n  /**\r\n   *  在canvas种画不同形状的点\r\n   *  @params options\r\n   *              {\r\n   *                  canvasContext   -   当前的canvas画图上下文\r\n   *                  canvasZoom      -   当前canvas的缩放大小\r\n   *                  ox              -   散点的X位置\r\n   *                  oy              -   散点的Y位置\r\n   *                  color           -   散点的颜色\r\n   *\r\n   *                  scatterType     -   散点形状\r\n   *                  scatterSize     -   散点大小\r\n   *                  scatterTransparent  -   散点的不透明度\r\n   *                  scatterStrokeWidth  -   散点的描边宽度\r\n   *              }\r\n   *\r\n   * */\n  drawScatterShapeByCanvas: function (options) {\n    options = options || {};\n    if (!options.canvasContext) return false;\n    let canvasContext = options.canvasContext,\n      canvasZoom = parseInt(options.canvasZoom) || 1,\n      ox = parseFloat(options.ox),\n      oy = parseFloat(options.oy),\n      scatterSize = _DataFocusMethod.isPureNumber(options.scatterSize) ? parseFloat(options.scatterSize) : 5,\n      strokeWidth = _DataFocusMethod.isPureNumber(options.scatterStrokeWidth) ? parseFloat(options.scatterStrokeWidth) : 1;\n    if (isNaN(ox) && isNaN(oy)) return false;\n\n    // 如果是告警的元素\n    if (options.isAlarmFlag && options.isEndFlag) {\n      options.svgWarningContext && options.svgWarningContext.append(\"g\").attr(\"class\", \"scatter-circles\").attr(\"style\", \"cursor:pointer;\").attr(\"transform\", function (d) {\n        return 'translate(' + ox + ',' + oy + ')';\n      }).append(\"circle\").attr(\"class\", \"circles\").attr(\"alarm-status\", true).attr(\"r\", scatterSize * 1.25).attr(\"cx\", 0).attr(\"cy\", 0);\n    }\n    switch (options.scatterType) {\n      case \"option_legend_shape_type_three\":\n      case \"three\":\n        canvasContext.restore();\n        canvasContext.fillStyle = options.color;\n        // 画透明的圈\n        canvasContext.beginPath();\n        canvasContext.moveTo(ox * canvasZoom, oy * canvasZoom - scatterSize * 1.3 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + Math.cos(Math.PI / 6) * scatterSize * 1.3 * canvasZoom, oy * canvasZoom + Math.cos(Math.PI / 3) * scatterSize * 1.3 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - Math.cos(Math.PI / 6) * scatterSize * 1.3 * canvasZoom, oy * canvasZoom + Math.cos(Math.PI / 3) * scatterSize * 1.3 * canvasZoom);\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fill();\n        canvasContext.closePath();\n        // 画外面不透明的环\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.beginPath();\n        canvasContext.moveTo(ox * canvasZoom, oy * canvasZoom - scatterSize * 1.3 * canvasZoom + 1);\n        canvasContext.lineTo(ox * canvasZoom + Math.cos(Math.PI / 6) * scatterSize * 1.3 * canvasZoom - 1, oy * canvasZoom + 1 + Math.cos(Math.PI / 3) * scatterSize * 1.3 * canvasZoom - 1);\n        canvasContext.lineTo(ox * canvasZoom - Math.cos(Math.PI / 6) * scatterSize * 1.3 * canvasZoom + 1, oy * canvasZoom + Math.cos(Math.PI / 3) * scatterSize * 1.3 * canvasZoom - 1);\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.closePath();\n        canvasContext.stroke();\n        break;\n      case \"option_legend_shape_type_four\":\n      case \"four\":\n        canvasContext.restore();\n        // 画透明的\n        canvasContext.fillStyle = options.color;\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fillRect(ox * canvasZoom - scatterSize * 0.85 * canvasZoom, oy * canvasZoom - scatterSize * 0.85 * canvasZoom, scatterSize * 1.7 * canvasZoom, scatterSize * 1.7 * canvasZoom);\n        // 画外面不透明的环\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.strokeRect(ox * canvasZoom - scatterSize * 0.85 * canvasZoom - 1, oy * canvasZoom - scatterSize * 0.85 * canvasZoom - 1, scatterSize * 1.7 * canvasZoom + 1, scatterSize * 1.7 * canvasZoom + 1);\n        break;\n      case \"option_legend_shape_type_rect\":\n      case \"rect\":\n        canvasContext.restore();\n        // 画透明的\n        canvasContext.fillStyle = options.color;\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fillRect(ox * canvasZoom - scatterSize * canvasZoom, oy * canvasZoom - scatterSize * 0.5 * canvasZoom, scatterSize * 2 * canvasZoom, scatterSize * canvasZoom);\n        // 画外面不透明的环\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.strokeRect(ox * canvasZoom - scatterSize * canvasZoom - 1, oy * canvasZoom - scatterSize * 0.5 * canvasZoom - 1, scatterSize * 2 * canvasZoom + 1, scatterSize * canvasZoom + 1);\n        break;\n      case \"option_legend_shape_type_five\":\n      case \"five\":\n        canvasContext.restore();\n        canvasContext.fillStyle = options.color;\n        let theArc = Math.PI / 5,\n          theRadius = scatterSize * 0.8,\n          theInnerRadius = Math.cos(theArc) * theRadius;\n        // 画透明的\n        canvasContext.beginPath();\n        // 1\n        canvasContext.moveTo(ox * canvasZoom, oy * canvasZoom - theInnerRadius * 2 * canvasZoom);\n        // 2\n        canvasContext.lineTo(ox * canvasZoom + Math.sin(theArc) * theRadius * canvasZoom, oy * canvasZoom - Math.cos(theArc) * theRadius * canvasZoom);\n        // 3\n        canvasContext.lineTo(ox * canvasZoom + Math.sin(theArc * 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom - Math.cos(theArc * 2) * theInnerRadius * 2 * canvasZoom);\n        // 4\n        canvasContext.lineTo(ox * canvasZoom + Math.cos(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom, oy * canvasZoom + Math.sin(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom);\n        // 5\n        canvasContext.lineTo(ox * canvasZoom + Math.cos(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom + Math.sin(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom);\n        // 6\n        canvasContext.lineTo(ox * canvasZoom, oy * canvasZoom + theRadius * canvasZoom);\n        // 7\n        canvasContext.lineTo(ox * canvasZoom - Math.cos(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom + Math.sin(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom);\n        // 8\n        canvasContext.lineTo(ox * canvasZoom - Math.cos(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom, oy * canvasZoom + Math.sin(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom);\n        // 9\n        canvasContext.lineTo(ox * canvasZoom - Math.sin(theArc * 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom - Math.cos(theArc * 2) * theInnerRadius * 2 * canvasZoom);\n        // 10\n        canvasContext.lineTo(ox * canvasZoom - Math.sin(theArc) * theRadius * canvasZoom, oy * canvasZoom - Math.cos(theArc) * theRadius * canvasZoom);\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fill();\n        canvasContext.closePath();\n\n        // 画外面不透明的环\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.beginPath();\n        // 1\n        canvasContext.moveTo(ox * canvasZoom, oy * canvasZoom - theInnerRadius * 2 * canvasZoom);\n        // 2\n        canvasContext.lineTo(ox * canvasZoom + Math.sin(theArc) * theRadius * canvasZoom, oy * canvasZoom - Math.cos(theArc) * theRadius * canvasZoom);\n        // 3\n        canvasContext.lineTo(ox * canvasZoom + Math.sin(theArc * 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom - Math.cos(theArc * 2) * theInnerRadius * 2 * canvasZoom);\n        // 4\n        canvasContext.lineTo(ox * canvasZoom + Math.cos(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom, oy * canvasZoom + Math.sin(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom);\n        // 5\n        canvasContext.lineTo(ox * canvasZoom + Math.cos(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom + Math.sin(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom);\n        // 6\n        canvasContext.lineTo(ox * canvasZoom, oy * canvasZoom + theRadius * canvasZoom);\n        // 7\n        canvasContext.lineTo(ox * canvasZoom - Math.cos(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom + Math.sin(theArc * 4 - Math.PI / 2) * theInnerRadius * 2 * canvasZoom);\n        // 8\n        canvasContext.lineTo(ox * canvasZoom - Math.cos(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom, oy * canvasZoom + Math.sin(theArc * 3 - Math.PI / 2) * theInnerRadius * canvasZoom);\n        // 9\n        canvasContext.lineTo(ox * canvasZoom - Math.sin(theArc * 2) * theInnerRadius * 2 * canvasZoom, oy * canvasZoom - Math.cos(theArc * 2) * theInnerRadius * 2 * canvasZoom);\n        // 10\n        canvasContext.lineTo(ox * canvasZoom - Math.sin(theArc) * theRadius * canvasZoom, oy * canvasZoom - Math.cos(theArc) * theRadius * canvasZoom);\n        canvasContext.closePath();\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.stroke();\n        break;\n      case \"option_legend_shape_type_diamond\":\n      case \"diamond\":\n        canvasContext.restore();\n        canvasContext.fillStyle = options.color;\n        // 画透明的\n        canvasContext.beginPath();\n        canvasContext.moveTo(ox * canvasZoom, oy * canvasZoom + scatterSize * 1.2 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * canvasZoom, oy * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom, oy * canvasZoom - scatterSize * 1.2 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * canvasZoom, oy * canvasZoom);\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fill();\n        canvasContext.closePath();\n        // 画外面不透明的环\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.beginPath();\n        canvasContext.moveTo(ox * canvasZoom, oy * canvasZoom + scatterSize * 1.2 * canvasZoom + 1);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * canvasZoom + 1, oy * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom, oy * canvasZoom - scatterSize * 1.2 * canvasZoom - 1);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * canvasZoom - 1, oy * canvasZoom);\n        canvasContext.closePath();\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.stroke();\n        break;\n      case \"option_legend_shape_type_add\":\n      case \"add\":\n        // 加号\n        canvasContext.restore();\n        canvasContext.fillStyle = options.color;\n        // 画透明的\n        canvasContext.beginPath();\n        canvasContext.moveTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fill();\n        canvasContext.closePath();\n        // 画外面不透明的环\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.beginPath();\n        canvasContext.moveTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom + scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * canvasZoom, oy * canvasZoom + scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(ox * canvasZoom - scatterSize * 0.25 * canvasZoom, oy * canvasZoom - scatterSize * 0.25 * canvasZoom);\n        canvasContext.closePath();\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.stroke();\n        break;\n      case \"option_legend_shape_type_cross\":\n      case \"cross\":\n        // 叉号\n        canvasContext.save();\n        canvasContext.translate(ox * canvasZoom, oy * canvasZoom);\n        canvasContext.rotate(Math.PI * 45 / 180);\n        canvasContext.fillStyle = options.color;\n        // 画透明的\n        canvasContext.beginPath();\n        canvasContext.moveTo(-scatterSize * 0.25 * canvasZoom, -scatterSize * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, -scatterSize * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, +scatterSize * canvasZoom);\n        canvasContext.lineTo(-scatterSize * 0.25 * canvasZoom, +scatterSize * canvasZoom);\n        canvasContext.lineTo(-scatterSize * 0.25 * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(-scatterSize * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(-scatterSize * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(-scatterSize * 0.25 * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fill();\n        canvasContext.closePath();\n\n        // 画外面不透明的环\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.beginPath();\n        canvasContext.moveTo(-scatterSize * 0.25 * canvasZoom, -scatterSize * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, -scatterSize * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(+scatterSize * 0.25 * canvasZoom, +scatterSize * canvasZoom);\n        canvasContext.lineTo(-scatterSize * 0.25 * canvasZoom, +scatterSize * canvasZoom);\n        canvasContext.lineTo(-scatterSize * 0.25 * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(-scatterSize * canvasZoom, +scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(-scatterSize * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.lineTo(-scatterSize * 0.25 * canvasZoom, -scatterSize * 0.25 * canvasZoom);\n        canvasContext.closePath();\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.stroke();\n        canvasContext.restore();\n        break;\n      case \"option_legend_shape_type_circle\":\n      case \"circle\":\n      default:\n        canvasContext.restore();\n        canvasContext.fillStyle = options.color;\n        // 画透明的圈\n        canvasContext.beginPath();\n        canvasContext.arc(ox * canvasZoom, oy * canvasZoom, scatterSize * canvasZoom, 0, Math.PI * 2, true);\n        canvasContext.globalAlpha = options.opacity || parseFloat(options.scatterTransparent) / 100 || 0.5;\n        canvasContext.fill();\n        // 画外面不透明的环\n        canvasContext.beginPath();\n        canvasContext.globalAlpha = _DataFocusMethod.isPureNumber(options.strokeOpacity) ? options.strokeOpacity : 1;\n        canvasContext.arc(ox * canvasZoom, oy * canvasZoom, scatterSize * canvasZoom + 1, 0, Math.PI * 2, true);\n        canvasContext.strokeStyle = options.color;\n        canvasContext.lineWidth = options.selectedFlag ? strokeWidth + 3 : strokeWidth;\n        canvasContext.stroke();\n    }\n  },\n  /**\r\n   * 为散点图的canvas元素绑定事件\r\n   * @param options\r\n   *      {\r\n   *          canvasDom\r\n   *          scatterSize\r\n   *          mouseoverCallback\r\n   *          mouseoutCallback\r\n   *          mousedownCallback\r\n   *      }\r\n   * **/\n  appendScatterCanvasEvent: function (options) {\n    options = options || {};\n    if (!options.canvasDom) return false;\n    if (!options.scatterDataSet || !options.scatterDataSet.length) return false;\n    let theCanvasDom = options.canvasDom,\n      theScatterDataSet = options.scatterDataSet,\n      theScatterRadius = parseFloat(options.scatterSize) || 5;\n    if (typeof options.mousedownCallback === 'function') {\n      let mouseMoveTimer = null,\n        prevInCircleIndex = -1,\n        prevInCircleFlag = false;\n      // 鼠标在canvas上移动时，处理canvas内圆圈的移入移出\n      theCanvasDom.onmousemove = function (event) {\n        let mouseX = event.offsetX,\n          mouseY = event.offsetY;\n        if (mouseMoveTimer) clearTimeout(mouseMoveTimer);\n        mouseMoveTimer = setTimeout(function () {\n          let inCircleFlag = false;\n          if (typeof options.mouseoverCircleCallback === 'function') {\n            for (let k = theScatterDataSet.length - 1; k >= 0; k--) {\n              let curScatter = theScatterDataSet[k];\n              if (mouseX > curScatter.ox + theScatterRadius || mouseX < curScatter.ox - theScatterRadius || mouseY > curScatter.oy + theScatterRadius || mouseY < curScatter.oy - theScatterRadius) continue;\n              let distance = Math.sqrt((curScatter.ox - mouseX) * (curScatter.ox - mouseX) + (curScatter.oy - mouseY) * (curScatter.oy - mouseY));\n              if (distance < theScatterRadius) {\n                inCircleFlag = true;\n                // 如果当前没有在圈中，且与上一次的不一样时触发mouseover事件\n                if (k !== prevInCircleIndex) {\n                  // 移入圆圈后的回调\n                  options.mouseoverCircleCallback(event, {\n                    index: k,\n                    scatterData: curScatter\n                  });\n                }\n                prevInCircleIndex = k;\n                prevInCircleFlag = true;\n                break;\n              }\n            }\n          }\n\n          // 如果当前没有在圆圈内，上一次在圆圈内，则触发mouseout事件\n          if (!inCircleFlag && prevInCircleFlag) {\n            prevInCircleIndex = -1;\n            typeof options.mouseoutCircleCallback === 'function' && options.mouseoutCircleCallback();\n          }\n          // 如果没有在圆圈里 且 需要显示X轴刻度的区域 , 则显示当前X轴刻度的区域元素\n          if (!options.measureXFlag && !inCircleFlag) {\n            prevInCircleIndex = -1;\n            if (typeof options.mousemoverXLabelCallback === 'function') {\n              options.mousemoverXLabelCallback({\n                event: event,\n                xLabelIndex: options.hoverWidth ? Math.floor(mouseX / options.hoverWidth) : -1\n              });\n            }\n          }\n        }, options.measureXFlag ? 100 : 10);\n      };\n\n      // 鼠标移出canvas\n      theCanvasDom.onmouseout = function () {\n        //  移出canvas时，直接执行mouseoutCallback\n        if (mouseMoveTimer) clearTimeout(mouseMoveTimer);\n        typeof options.mouseoutCircleCallback === 'function' && options.mouseoutCircleCallback();\n        typeof options.mouseoutXLabelCallback === 'function' && options.mouseoutXLabelCallback();\n      };\n\n      // 鼠标点击事件, 处理鼠标在点上的左击右击事件\n      theCanvasDom.onmousedown = function (event) {\n        let mouseX = event.offsetX,\n          mouseY = event.offsetY;\n        for (let k = theScatterDataSet.length - 1; k >= 0; k--) {\n          let curScatter = theScatterDataSet[k];\n          if (mouseX > curScatter.ox + theScatterRadius || mouseX < curScatter.ox - theScatterRadius || mouseY > curScatter.oy + theScatterRadius || mouseY < curScatter.oy - theScatterRadius) continue;\n          let distance = Math.sqrt((curScatter.ox - mouseX) * (curScatter.ox - mouseX) + (curScatter.oy - mouseY) * (curScatter.oy - mouseY));\n          if (distance < theScatterRadius) {\n            typeof options.mousedownCallback === 'function' && options.mousedownCallback(event, curScatter);\n            break;\n          }\n        }\n      };\n    }\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (ScatterChartComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/scatter/ScatterChartComponent.js?");

/***/ }),

/***/ "../src-v5/assets/js/charts.system.basic/scatter/systemScatterChart.js":
/*!*****************************************************************************!*\
  !*** ../src-v5/assets/js/charts.system.basic/scatter/systemScatterChart.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function($) {/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ContainerComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @pc/assets/js/charts.components/ContainerComponent */ \"../src-v5/assets/js/charts.components/ContainerComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_TranslateDataComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @pc/assets/js/charts.components/TranslateDataComponent */ \"../src-v5/assets/js/charts.components/TranslateDataComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @pc/assets/js/charts.components/LegendComponent */ \"../src-v5/assets/js/charts.components/LegendComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @pc/assets/js/charts.components/TitleComponent */ \"../src-v5/assets/js/charts.components/TitleComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @pc/assets/js/charts.components/MeasureAxisComponent */ \"../src-v5/assets/js/charts.components/MeasureAxisComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_AttributeAxisComponent__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @pc/assets/js/charts.components/AttributeAxisComponent */ \"../src-v5/assets/js/charts.components/AttributeAxisComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @pc/assets/js/charts.components/MarkerComponent */ \"../src-v5/assets/js/charts.components/MarkerComponent.js\");\n/* harmony import */ var _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ScatterChartComponent.js */ \"../src-v5/assets/js/charts.system.basic/scatter/ScatterChartComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @pc/assets/js/charts.components/ReferenceLineComponent */ \"../src-v5/assets/js/charts.components/ReferenceLineComponent.js\");\n/* harmony import */ var _pc_assets_js_charts_components_PaginationChartComponent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @pc/assets/js/charts.components/PaginationChartComponent */ \"../src-v5/assets/js/charts.components/PaginationChartComponent.js\");\n/**\r\n * 系统散点图画图组件\r\n *\r\n * 从系统中剥离的目的\r\n * 1. 为了减轻图形打包文件的大小【20230301时最大的打包文件是10M左右】\r\n * 2. 各个图形控制各自的图表配置\r\n * 3. 支持图形的延迟分批加载\r\n * **/\n\n// 通用组件[ 获取字符串长度之类 ...  ]\n\n// 画图容器组件[ 主要区分svg部分与图例部分 ]\n\n// 数据处理组件[ 解析XY轴配置组的数据 ]\n\n// 画图例列表的组件\n\n// 画标题组件\n\n// 解析数值刻度 及  画数值刻度的组件\n\n// 画属性刻度轴\n\n// 画标准线[ 最大/最小/平均值 ]\n\n// 画图形中的散点元素\n\n\n// 画标度线\n\n// 画分页组件\n\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  // [*必填项] 图姓唯一标识\n  chartType: \"scatter\",\n  // [*必填项] 图形名称中英文Key\n  chartDisplayNameKey: \"chart_scatter\",\n  // [*必填项] 图形描述中英文Key\n  chartDescriptionKey: \"chart_scatter_tooltip\",\n  // [*必填项] 图轴配置元素 ( X轴 ，Y轴（允许右Y轴），图例 )\n  needAxis: {\n    xAxis: {\n      allowMeasureXAxis: true\n    },\n    yAxis: {\n      defaultYAxisNumber: -1,\n      allowMultiYAxis: true\n    },\n    legend: {}\n  },\n  // [*必填项] 搜索数据是否支持该图形 ( 聚合数据：1.至少一个属性列，一个数值列， 2. 或者两个数值列，多行数据 ; 非聚合数据：也允许画散点图，数值列超过两列，多行数据 )\n  isSatisfiedTheChart: function (searchResultStatistic) {\n    let satisfiedFlag = false;\n    if (!searchResultStatistic) return false;\n    let measureCount = searchResultStatistic.measureColumns && searchResultStatistic.measureColumns.length,\n      attributeCount = searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.length,\n      queryResultCount = searchResultStatistic.queryResultCount;\n\n    // 1.至少一个属性列，一个数值列， 2. 或者两个数值列，多行数据\n    if (attributeCount > 0 && measureCount > 0 || measureCount >= 2 && queryResultCount > 1) {\n      satisfiedFlag = true;\n    }\n    return satisfiedFlag;\n  },\n  /**\r\n   * [选填] 获取当前图形各个needAxis中可选择的配置列\r\n   * @return\r\n   *      {\r\n   *          // 依据needAxis结构返回各个可选列的index\r\n   *          xAxis: [1,2,3] ,\r\n   *          yAxis: [4,5] ,\r\n   *          legend: [1,2,3] ,\r\n   *          size: [4,5] ,\r\n   *          time: [1,2]\r\n   *      }\r\n   * */\n  getSatisfiedChartAxis: function (searchResultStatistic) {\n    let self = this; //  是当前_DataFocusChartTypes中的对象\n\n    const needAxis = self.needAxis || {};\n    if (!needAxis || !searchResultStatistic) return false;\n    let theAxisObj = {};\n    // Time / legend / xAxis / yAxis / size\n    // X轴的可选项\n    if (needAxis.xAxis) {\n      theAxisObj.xAxis = searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    // Y轴的可选项\n    if (needAxis.yAxis) {\n      theAxisObj.yAxis = searchResultStatistic.measureColumns && searchResultStatistic.measureColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    // 大小列的可选项\n    if (needAxis.size) {\n      theAxisObj.size = searchResultStatistic.measureColumns && searchResultStatistic.measureColumns.map(function (h) {\n        return h.idx;\n      });\n    }\n    // 图例列的可选项\n    // 如果x轴不允许数值列，有XAxis时，图例则必须在有X轴的情况下才可以有，所以在只有一个属性列时，不允许存在图例列 ；\n    // 如果x轴允许数值列，则只有一个属性列时，可以有图例列\n    if (needAxis.legend) {\n      if (needAxis.xAxis && !needAxis.xAxis.allowMeasureXAxis && searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.length <= 1) {\n        theAxisObj.legend = [];\n      } else {\n        theAxisObj.legend = searchResultStatistic.legendColumns && searchResultStatistic.legendColumns.map(function (h) {\n          return h.idx;\n        });\n      }\n    }\n    // 时间列的可选项\n    if (needAxis.time) {\n      if (needAxis.xAxis && searchResultStatistic.attributeColumns && searchResultStatistic.attributeColumns.length <= 1) {\n        theAxisObj.time = [];\n      } else {\n        theAxisObj.time = searchResultStatistic.dateColumns && searchResultStatistic.dateColumns.map(function (h) {\n          return h.idx;\n        });\n      }\n    }\n    if (_DataFocusMethod.isObjEmpty(theAxisObj)) {\n      return false;\n    } else {\n      theAxisObj.name = self.name;\n      theAxisObj.type = self.name;\n      return theAxisObj;\n    }\n  },\n  /**\r\n   * [选填] 在图形没有图轴配置的情况下，从getSatisfiedChartAxis中图轴可选项中初始化画图配置\r\n   *\r\n   * 初始化规则：\r\n   * 1. 如果当前数据中有两个以上数值列，则默认X轴是数值列，Y轴是一个数值列\r\n   * 2. 如果当前数据只有一个数值列，则默认X轴是属性列，Y轴是数值列\r\n   *\r\n   * @param options\r\n   *      {\r\n   *          tableData   -   查询数据，是在focus.chart中将无穷数据转换为null以后的数据\r\n   *      }\r\n   * // 依据needAxis生成初始的图轴配置值，及各个轴的配置可选项\r\n   *    返回对象名字规则: 可选项是needAxis中各项名字 + Area ； 当前配置项是 cur + needAxis中各项名字\r\n   * @return chartAxis\r\n   *          {\r\n   *              xAxisArea: [  {col_id , index ...} , {} ] ,\r\n   *              curXAxis: [ {col_id , index ...} ]\r\n   *              yAxisArea: [ {col_id , index , min , max ...} , {} ] ,\r\n   *              curYAxis: [ {col_id , index , min , max ...} ] ,\r\n   *              legendArea: [ {col_id , index ...} ],\r\n   *              curLegend: {col_id , index ...} ,\r\n   *              sizeArea: [{col_id , index ...}] ,\r\n   *              curSize: {col_id , index ...} ,\r\n   *              timeArea: [ {col_id , index ...} ] ,\r\n   *              curTime: {col_id , index ...}\r\n   *          }\r\n   *\r\n   * */\n  initChartAxisConfig: function (options) {\n    options = options || {};\n    if (!options.tableData || !options.tableData.headers) return false;\n    let self = this,\n      //  是当前_DataFocusChartTypes中的对象\n      tableData = options.tableData,\n      headers = tableData.headers,\n      columns = tableData.columns;\n\n    // charts是依据各个图形中的getSatisfiedChartAxis生成的\n    let theMatchedChart = tableData.charts && tableData.charts.find(function (chart) {\n        return (chart.name || chart.type) === self.name;\n      }),\n      chartAxis = {};\n    if (!theMatchedChart) {\n      console.log(\"当前数据不适合散点图\");\n      return chartAxis;\n    }\n    let getIdIndexInHeader = function (colIdx, headers) {\n      // 目前charts返回的都是索引\n      if (colIdx < headers.length) return colIdx;\n      for (let i = 0; i < headers.length; i++) {\n        if (headers[i].col_id === colIdx) return i;\n      }\n      return -1;\n    };\n    // 获取图例列及可选数组 [ 默认legend不允许与时间列相同 ]\n    if (self.needAxis && self.needAxis.legend) {\n      chartAxis.legendArea = [];\n      let theLegendArea = [];\n      theMatchedChart.legend && theMatchedChart.legend.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        chartAxis.legendArea.push(obj);\n        theLegendArea.push(obj);\n      });\n\n      // 默认使用值distinct count最小的作为图例\n      theLegendArea.sort(function (a, b) {\n        return a.statistics && b.statistics && a.statistics['unique count'] - b.statistics['unique count'];\n      });\n      chartAxis.curLegend = theLegendArea[0];\n    }\n\n    // 获取XAxis列及可选数组\n    if (self.needAxis && self.needAxis.xAxis) {\n      chartAxis.xAxisArea = [];\n      theMatchedChart.xAxis && theMatchedChart.xAxis.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        chartAxis.xAxisArea.push(obj);\n      });\n\n      // 赋值默认的X轴，默认X轴与图例列不能重叠\n      let xAxisArea = chartAxis.xAxisArea.filter(function (xAxis) {\n        return !(chartAxis.curLegend && xAxis.index === chartAxis.curLegend.index);\n      });\n      // 如果指令了属性列的数量\n      let defaultXAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.xAxis.defaultXAxisNumber) ? self.needAxis.xAxis.defaultXAxisNumber : -1;\n      let withoutSortX = xAxisArea && xAxisArea.filter(function (head) {\n        return !head.isSortNoFlag;\n      });\n      // 如果没有排序列的属性列足够分配需要的X轴，则优先使用非排序列的属性列\n      if (defaultXAxisNumber < 0) {\n        chartAxis.curXAxis = withoutSortX.length ? withoutSortX : xAxisArea;\n      } else {\n        if (withoutSortX.length >= defaultXAxisNumber) {\n          chartAxis.curXAxis = withoutSortX.slice(0, defaultXAxisNumber);\n        } else {\n          chartAxis.curXAxis = xAxisArea.slice(0, defaultXAxisNumber);\n        }\n      }\n    }\n\n    // 获取YAxis列及可选数组 [ 必须计算yAxis的最大值与最小值，计算刻度使用 ]\n    if (self.needAxis && self.needAxis.yAxis) {\n      chartAxis.yAxisArea = [];\n      theMatchedChart.yAxis && theMatchedChart.yAxis.forEach(function (c) {\n        let curColumnIndex = getIdIndexInHeader(c, headers);\n        let obj = $.extend({}, headers[curColumnIndex]);\n        obj.header = headers[curColumnIndex];\n        obj.index = curColumnIndex;\n        obj.direction = \"left\";\n        let min = obj.statistics && obj.statistics.min,\n          max = obj.statistics && obj.statistics.max;\n        // 如果min/max中存在Infinity这类的无穷数据 或者 存在非法数字时，需要从原始数据中重新获取合法数值\n        if (!isFinite(min + max) || !_DataFocusMethod.isPureNumber(min) || !_DataFocusMethod.isPureNumber(max)) {\n          let theMin = Infinity,\n            theMax = -Infinity;\n          columns && columns.forEach(function (d) {\n            if (_DataFocusMethod.isPureNumber(d[curColumnIndex]) && isFinite(d[curColumnIndex])) {\n              theMin = Math.min(theMin, d[curColumnIndex]);\n              theMax = Math.max(theMax, d[curColumnIndex]);\n            }\n          });\n          min = theMin;\n          max = theMax;\n          // 如果theMin是Infinity, 说明数据表中没有合法的数值，则将其设置成0\n          if (Math.abs(theMin) === Infinity) {\n            min = 0;\n            max = 0;\n          }\n        }\n        // 如果min是undefined 说明，数据表头中没有统计 且 返回数据中没有合法的数值，则默认设置为0\n        if (min === undefined) {\n          min = 0;\n          max = 0;\n        }\n        obj.min = min;\n        obj.max = min === max && max === 0 && min === 0 ? 1 : max;\n        chartAxis.yAxisArea.push(obj);\n      });\n\n      // 如果有图例列，则Y轴只允许1个；将Y轴中的curSize的列清除\n      if (chartAxis.curLegend) {\n        let theYAxis = chartAxis.yAxisArea.find(function (yAxis) {\n          return true;\n        });\n        if (theYAxis) chartAxis.curYAxis = [theYAxis];\n      } else {\n        // 没有图例的情况，使用配置中默认的Y轴数量\n        let yAxisArea = chartAxis.yAxisArea;\n        let defaultYAxisNumber = _DataFocusMethod.isPureNumber(self.needAxis.yAxis.defaultYAxisNumber) ? self.needAxis.yAxis.defaultYAxisNumber : 1;\n        // 如果默认Y轴< 0 ， 说明剩下所有可用Y轴全部是默认Y轴\n        if (defaultYAxisNumber < 0) {\n          chartAxis.curYAxis = yAxisArea;\n        } else {\n          chartAxis.curYAxis = yAxisArea.slice(0, defaultYAxisNumber);\n        }\n      }\n    }\n\n    // 如果X轴允许配置数值列-------------------------------------------------------------\n    // 如果允许X轴是数值列 ， 则将数值列加入X轴的可选区域中[ yAxis多时，X轴默认为measure列 ]\n    if (self.needAxis && self.needAxis.xAxis && self.needAxis.xAxis.allowMeasureXAxis) {\n      chartAxis.xAxisArea = [].concat(chartAxis.xAxisArea, chartAxis.yAxisArea);\n\n      // 有Size时，将size使用的数值列分配出去后，如果还有2个以上的数值列，且允许X轴时数值列，则默认x为数值列\n      let tempYArea = chartAxis.yAxisArea && chartAxis.yAxisArea.filter(function (yAxis) {\n        return chartAxis.curSize && yAxis.idx !== chartAxis.curSize.idx || !chartAxis.curSize;\n      });\n      if (tempYArea && tempYArea.length >= 2) {\n        chartAxis.curXAxis = tempYArea.slice(0, 1);\n        chartAxis.curYAxis = tempYArea.slice(1, 2);\n      }\n    }\n\n    // 因为Legend与Time将属性列全部使用完了，这种时候默认不需要legend , 将Legend分配给XAxis\n    if (self.needAxis && self.needAxis.xAxis) {\n      if (chartAxis.curLegend && !chartAxis.curXAxis.length) {\n        chartAxis.curXAxis = chartAxis.xAxisArea.filter(function (xAxis) {\n          return xAxis.index === chartAxis.curLegend.index;\n        });\n        chartAxis.curLegend = undefined;\n      }\n    }\n    return chartAxis;\n  },\n  /***\r\n   * [*必填项] 图轴配置是否合法\r\n   *\r\n   * 1. X轴是Measure列时的限制条件\r\n   *\r\n   *     - X轴不允许为空\r\n   *     - Y轴不允许为空\r\n   *     - Y轴不允许超过两个\r\n   *     - X轴不允许超过两个\r\n   *     - X轴不允许与Y轴一致\r\n   *     - X轴中不允许属性列与数值列一起\r\n   *\r\n   * 2. X轴是Attribute列时的限制条件\r\n   *\r\n   *      - X轴不允许为空\r\n   *      - Y轴不允许为空\r\n   *      - 左Y轴不允许为空\r\n   *      - Y轴不允许重复\r\n   *      - 有legend时，Y轴不允许超过1个\r\n   *      - 有legend时，不允许与X轴中的项重复\r\n   * */\n  validateAxisConfig: function (theAxisConfig) {\n    let chartErrorMsg = '';\n    if (!theAxisConfig) return chartErrorMsg;\n\n    // X轴为必填选项\n    if (!theAxisConfig.xAxis || !theAxisConfig.xAxis.length) {\n      chartErrorMsg = 'chart_modify_x_not_null';\n      return chartErrorMsg;\n    }\n\n    // X轴不允许属性列与数值列混合在一起\n    let theAttributeX = [],\n      theMeasureX = [];\n    theAxisConfig.xAxis && theAxisConfig.xAxis.forEach(function (axis) {\n      if (axis.columnClassify === 'number') {\n        theMeasureX.push(axis);\n      } else {\n        theAttributeX.push(axis);\n      }\n    });\n    if (theAttributeX.length && theMeasureX.length) {\n      chartErrorMsg = 'chart_modify_x_error_attr';\n      return chartErrorMsg;\n    }\n\n    // X轴是有数值列时只能有一个\n    if (theMeasureX.length && theMeasureX.length > 1) {\n      chartErrorMsg = 'chart_modify_x_too_much_mea';\n      return chartErrorMsg;\n    }\n\n    // Y轴不允许为空\n    if (!theAxisConfig.yAxis || !theAxisConfig.yAxis.length) {\n      chartErrorMsg = 'chart_modify_y_not_null';\n      return chartErrorMsg;\n    }\n\n    // X轴是数值列时，Y轴允许一个\n    if (theMeasureX.length && theAxisConfig.yAxis.length > 1) {\n      chartErrorMsg = 'chart_modify_y_only_one';\n      return chartErrorMsg;\n    }\n\n    // 左Y轴不允许为空\n    let leftYIds = theAxisConfig.yAxis && theAxisConfig.yAxis.filter(function (axis) {\n      return axis.direction === 'left';\n    });\n    if (!leftYIds || !leftYIds.length) {\n      chartErrorMsg = 'chart_modify_y_left_not_null';\n      return chartErrorMsg;\n    }\n\n    // Y轴不允许重复\n    for (let i = 0, yyIds = []; theAxisConfig.yAxis && i < theAxisConfig.yAxis.length; i++) {\n      let theAxis = theAxisConfig.yAxis[i];\n      if (yyIds.indexOf(theAxis.index) > -1) {\n        chartErrorMsg = 'chart_modify_y_not_repeat';\n        yyIds.push(theAxis.index);\n        return chartErrorMsg;\n      }\n    }\n\n    // 有legend时，Y轴不允许超过1个\n    if (theAxisConfig.legend && theAxisConfig.yAxis && theAxisConfig.yAxis.length > 1) {\n      chartErrorMsg = 'chart_modify_y_only_one';\n      return chartErrorMsg;\n    }\n\n    // 有legend时，不允许与X轴中的项重复\n    if (theAxisConfig.legend && theAxisConfig.xAxis && theAxisConfig.xAxis.find(function (axis) {\n      return axis.index === theAxisConfig.legend.index;\n    })) {\n      chartErrorMsg = 'chart_modify_x_legend_not_equal';\n      return chartErrorMsg;\n    }\n    return chartErrorMsg;\n  },\n  // [* 必填项]画图方法\n  drawChart: function (options) {\n    options = options || {};\n    if (!options.container) {\n      console.error('DataFocus没有提供画图元素Dom');\n      return false;\n    }\n    if (!options.currentChart) {\n      console.error('DataFocus没有提供图形实例');\n      return false;\n    }\n    if (!options.chartAxis) {\n      console.error('DataFocus没有图形的配置信息');\n      return false;\n    }\n    if (!options.datas) {\n      console.error('DataFocus没有提供画图数据');\n      return false;\n    }\n    const drawChartOptions = options;\n    let self = this,\n      container = options.container,\n      chartAxis = options.chartAxis,\n      currentChart = options.currentChart,\n      conf = currentChart.defaultConf || {},\n      chartDatas = conf.datas,\n      chartUUID = conf.chartUUID,\n      systemLanguage = conf.systemLanguage || 'chinese',\n      chartConfigures = options.chartConfigures || {},\n      hasLegendFlag = !!(chartAxis.curLegend || chartAxis.curYAxis && chartAxis.curYAxis.length > 1),\n      aChartFrameReturn,\n      hideCategories = conf.hideCategories;\n\n    // 获取图例的位置，默认在右侧\n    let legendPosition = hasLegendFlag ? 'right' : '';\n    if (legendPosition) {\n      legendPosition = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendConfigure(chartConfigures.legend_position);\n    }\n    container.innerHTML = '';\n    // 给柱状图初始化画图容器  SVG图形部分(X轴Y轴图形) / X轴标题(位置) / Y轴标题(位置) / 图例(位置)\n    let containerResult = _pc_assets_js_charts_components_ContainerComponent__WEBPACK_IMPORTED_MODULE_2__[\"default\"].drawCommonContainer({\n      container: container,\n      legendPosition: !!(chartConfigures.show_legend === undefined || chartConfigures.show_legend) ? legendPosition : '',\n      needCanvasFlag: true\n    });\n    if (!containerResult.svgJqDom) return false;\n    // 为了防止图形先画了图例，导致没有数据时有图例的区域在\n    if (!options.datas.columns || !options.datas.columns.length) {\n      console.log('当前图形没有合法的画图数据');\n      return false;\n    }\n\n    // 获取图形的整体宽度和高度\n    let chartWidth = container.offsetWidth,\n      chartHeight = container.offsetHeight;\n    // 当前画图区域的缩放比例【会影响到获取字体高度的计算】\n    if (_DataFocusMethod.isPureNumber(chartConfigures._DF_SYS_TRANSFORM_SCALE)) {\n      _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].transformScale = chartConfigures._DF_SYS_TRANSFORM_SCALE;\n    }\n    // 获取当前图形的配置颜色主题方法\n    let colorFunc = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translateColorThemeConfigure(chartConfigures.chart_color_theme, {\n      chart_custom_theme: chartConfigures.chart_custom_theme\n    });\n    // 获取隐藏聚合方式的标志配置, 即所有属性列的聚合方式不显示在标签内\n    let hideOperatorFlag = false;\n    if (chartConfigures.hide_operator_label) hideOperatorFlag = true;\n    // 获取图形的字体大小配置\n    let chartFontSize = chartConfigures.font_size_label && parseInt(chartConfigures.font_size_label.fontSize) || 10,\n      chartFontColor = chartConfigures.font_size_label && chartConfigures.font_size_label.fontColor,\n      chartFontBold = chartConfigures.font_size_label && chartConfigures.font_size_label.fontBold,\n      chartFontItalic = chartConfigures.font_size_label && chartConfigures.font_size_label.fontItalic;\n    chartFontSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].translateFontSizeConfigure(chartFontSize) || 10;\n    if (chartFontColor) {\n      container.style.color = chartFontColor || 'inherit';\n      container.style.fill = chartFontColor || 'inherit';\n      containerResult.svgJqDom.style.color = chartFontColor;\n      containerResult.svgJqDom.style.fill = chartFontColor;\n    }\n    if (chartFontBold) {\n      container.style.fontWeight = 'bold';\n    } else {\n      container.style.fontWeight = 'normal';\n    }\n    if (chartFontItalic) {\n      container.style.fontStyle = 'italic';\n    } else {\n      container.style.fontStyle = 'normal';\n    }\n    let theXTitleFontSize = chartConfigures.x_axis_title_style && parseInt(chartConfigures.x_axis_title_style.fontSize) || chartFontSize || 10,\n      //  X轴标题字体大小\n      theXAxisFontSize = chartConfigures.x_axis_label_style && parseInt(chartConfigures.x_axis_label_style.fontSize) || chartFontSize || 10,\n      //  X轴刻度字体大小， 默认使用图形统一的字体大小\n      theYTitleFontSize = chartConfigures.y_axis_title_style && parseInt(chartConfigures.y_axis_title_style.fontSize) || chartFontSize || 10,\n      //  Y轴标题字体大小\n      theYAxisFontSize = chartConfigures.y_axis_label_style && parseInt(chartConfigures.y_axis_label_style.fontSize) || chartFontSize || 10,\n      //  Y轴刻度字体大小， 默认使用图形统一的字体大小\n      theLegendFontSize = chartConfigures.legend_font_style && parseInt(chartConfigures.legend_font_style.fontSize) || chartFontSize || 10;\n\n    // 先填充图例区域 [ 绘制图例列表，翻页 ，宽度高度限制 ]\n    // 计算图例列表\n    let showLegendLength = 0,\n      legendValueList = [],\n      defaultLegendList = [];\n    let savedLegendColorConfig = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendColor({\n        // legendColors: conf.legendColors ,\n        // yAxisColors: conf.yAxisColors ,\n        curYAxis: chartAxis.curYAxis,\n        configureLegendList: chartConfigures.chart_legend_list\n      }),\n      legendShapeTypeArray = [\"option_legend_shape_type_circle\", \"option_legend_shape_type_three\", \"option_legend_shape_type_four\", \"option_legend_shape_type_rect\", \"option_legend_shape_type_five\", \"option_legend_shape_type_diamond\", \"option_legend_shape_type_add\", \"option_legend_shape_type_cross\"];\n    if (chartAxis.curLegend) {\n      chartAxis.curLegend.distincts && chartAxis.curLegend.distincts.forEach(function (legendName, index) {\n        let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('legendAxis', legendName); // \"column-value-\" + legendName ,\n        let theConfigLegend = savedLegendColorConfig && savedLegendColorConfig.find(function (theConfig) {\n          return theConfig.id === theLegendId;\n        });\n        let defaultLegendShape = chartConfigures.legend_shape_type === 'option_legend_shape_type_loop' ? legendShapeTypeArray[index % legendShapeTypeArray.length] : chartConfigures.legend_shape_type;\n        legendValueList.push({\n          type: 'columnValue',\n          legend: legendName,\n          legendTranslateName: _DataFocusMethod.formatTextData(legendName, chartAxis.curLegend),\n          id: theLegendId,\n          index: index,\n          shape: theConfigLegend && theConfigLegend.shape || defaultLegendShape,\n          color: theConfigLegend && theConfigLegend.color || colorFunc(index),\n          show: !theConfigLegend || theConfigLegend.show === undefined ? true : !!theConfigLegend.show\n        });\n        defaultLegendList.push({\n          type: 'columnValue',\n          legend: legendName,\n          legendTranslateName: _DataFocusMethod.formatTextData(legendName, chartAxis.curLegend),\n          id: theLegendId,\n          index: index,\n          shape: defaultLegendShape,\n          color: colorFunc(index),\n          show: true\n        });\n      });\n    } else if (chartAxis.curYAxis) {\n      chartAxis.curYAxis.forEach(function (yAxis, index) {\n        let theYLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('yAxis', yAxis.idx); //  \"measure-column-id-\" + yAxis.col_id ,\n        let theConfigLegend = savedLegendColorConfig && savedLegendColorConfig.find(function (theConfig) {\n          return theConfig.id === theYLegendId;\n        });\n        let defaultLegendShape = chartConfigures.legend_shape_type === 'option_legend_shape_type_loop' ? legendShapeTypeArray[index % legendShapeTypeArray.length] : chartConfigures.legend_shape_type;\n        legendValueList.push({\n          type: 'measureColumn',\n          legend: _DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n            hideOperator: hideOperatorFlag\n          }),\n          id: theYLegendId,\n          index: index,\n          shape: theConfigLegend && theConfigLegend.shape || defaultLegendShape,\n          color: theConfigLegend && theConfigLegend.color || colorFunc(index),\n          show: !theConfigLegend || theConfigLegend.show === undefined ? true : !!theConfigLegend.show\n        });\n        defaultLegendList.push({\n          type: 'measureColumn',\n          legend: _DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n            hideOperator: hideOperatorFlag\n          }),\n          id: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('yAxis', yAxis.idx),\n          //  \"measure-column-id-\" + yAxis.col_id ,\n          index: index,\n          color: colorFunc(index),\n          shape: defaultLegendShape,\n          show: true\n        });\n      });\n    }\n    legendValueList && legendValueList.forEach(function (theLegend) {\n      if (theLegend.show) showLegendLength++;\n    });\n    // 如果没有显示的图例，则至少保证显示一个\n    if (!showLegendLength) {\n      showLegendLength = 1;\n      legendValueList[0] && (legendValueList[0].show = true);\n    }\n    // 画图例元素,先将图例元素画完成后，才可以计算SVG的宽度与高度\n    if (hasLegendFlag && containerResult.legendContainer) {\n      // 画图例元素\n      let drawLegendFlag = !!(chartConfigures.show_legend === undefined || chartConfigures.show_legend);\n      if (drawLegendFlag) {\n        _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].drawAttributeLegend({\n          container: containerResult.legendContainer,\n          chartWidth: chartWidth,\n          chartHeight: chartHeight,\n          legendPosition: legendPosition,\n          legendMaxWidthInVertical: chartConfigures.legend_position_width,\n          legendValueList: legendValueList,\n          legendFontSize: theLegendFontSize,\n          legendFontColor: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontColor,\n          legendBoldStyle: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontBold,\n          legendItalicStyle: chartConfigures.legend_font_style && chartConfigures.legend_font_style.fontItalic,\n          legendOffsetSpace: chartConfigures.legend_position_offset,\n          legendIntervalSpace: chartConfigures.legend_position_interval,\n          changeLegendColorFlag: !!(conf.action && !conf.wxFlag) && !conf.inPinboard,\n          chooseButtonText: self.getPluginKeyText(),\n          changeLegendColorCallback: function (options) {\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              // 修改图形中的图例配置，并将其传给配置组件，然后由配置组件触发画图， 而不是在此处直接画图\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend) {\n                let theMatchedConfigure = chartConfigures.chart_legend_list && chartConfigures.chart_legend_list.find(function (configure) {\n                  return configure.id === theMatchedLegend.id || configure.legend === theMatchedLegend.legend;\n                });\n                if (theMatchedConfigure) {\n                  theMatchedConfigure.color = options.color || undefined;\n                } else {\n                  chartConfigures.chart_legend_list = chartConfigures.chart_legend_list || [];\n                  chartConfigures.chart_legend_list.push({\n                    id: theMatchedLegend.id,\n                    legend: theMatchedLegend.legend,\n                    color: options.color || undefined\n                  });\n                }\n                // 修改图形配置\n                currentChart.requireSetConfig({\n                  key: \"chart_legend_list\",\n                  value: chartConfigures.chart_legend_list\n                });\n              }\n            }\n          },\n          // 点击 显示/隐藏 图例\n          mousedownEventCallback: function (options) {\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              // 修改图形中的图例配置，并将其传给配置组件，然后由配置组件触发画图， 而不是在此处直接画图\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend) {\n                let theMatchedConfigure = chartConfigures.chart_legend_list && chartConfigures.chart_legend_list.find(function (configure) {\n                  return configure.id === theMatchedLegend.id || configure.legend === theMatchedLegend.legend;\n                });\n                let theShownLegendLength = legendValueList.filter(function (legend) {\n                  return legend.show;\n                }).length;\n                // 如果只有一个图例显示，则不再隐藏最后一个了\n                if (theShownLegendLength === 1 && !!theMatchedLegend.show) return false;\n                if (theMatchedConfigure) {\n                  theMatchedConfigure.show = !theMatchedLegend.show;\n                } else {\n                  chartConfigures.chart_legend_list = chartConfigures.chart_legend_list || [];\n                  chartConfigures.chart_legend_list.push({\n                    id: theMatchedLegend.id,\n                    legend: theMatchedLegend.legend,\n                    show: !theMatchedLegend.show\n                  });\n                }\n                // 修改图形配置\n                currentChart.requireSetConfig({\n                  key: \"chart_legend_list\",\n                  value: chartConfigures.chart_legend_list\n                });\n              }\n            }\n          },\n          // 鼠标移入图例，高亮对应图例\n          mouseoverEventCallback: function (options) {\n            // 高亮当前图例所在的图形元素，置灰其他元素\n            options = options || {};\n            if (_DataFocusMethod.isPureNumber(options.legendIndex)) {\n              let theMatchedLegend = legendValueList[options.legendIndex];\n              if (theMatchedLegend && theMatchedLegend.id && theMatchedLegend.show) {\n                drawAChartFrame({\n                  start: aChartFrameReturn && aChartFrameReturn.start,\n                  end: aChartFrameReturn && aChartFrameReturn.end,\n                  currentLegend: theMatchedLegend,\n                  animateFlag: false\n                });\n                if (options.legendDom) {\n                  $(options.legendDom).find(\"svg\").removeClass(\"fill-grey\");\n                  $(options.legendDom).siblings().find(\"svg\").addClass(\"fill-grey\");\n                }\n              }\n            }\n          },\n          mouseoutEventCallback: function (options) {\n            options = options || {};\n            // // 恢复高亮所有图例的图形元素\n            drawAChartFrame({\n              start: aChartFrameReturn && aChartFrameReturn.start,\n              end: aChartFrameReturn && aChartFrameReturn.end,\n              animateFlag: false\n            });\n            if (options.legendDom) $(options.legendDom).parent().find(\"svg\").removeClass(\"fill-grey\");\n          }\n        });\n      }\n    }\n\n    // 数值X轴不使用默认的散点轴\n    if (chartAxis.curXAxis && chartAxis.curXAxis[0].columnType === 'measure') {\n      if (chartConfigures.x_axis_draw_type === 'option_select_x_axis_dot_line') {\n        chartConfigures.x_axis_draw_type = undefined;\n      }\n    }\n    // 0. 解析数据为当前画图数据\n    let translateData = _pc_assets_js_charts_components_TranslateDataComponent__WEBPACK_IMPORTED_MODULE_3__[\"default\"].translateXYLegendBasicData({\n      tableData: conf.datas,\n      chartAxis: chartAxis,\n      xLabelType: chartConfigures.x_axis_draw_type === 'option_select_x_axis_dot_line' ? 'dotLine' : 'auto',\n      language: systemLanguage,\n      hideCategories\n    });\n    if (!translateData || !translateData.datas) {\n      console.log('当前图形没有合法的画图数据');\n      return false;\n    }\n\n    // 再填充画图区域\n    // 1. 先计算Y轴刻度比例尺[ 左Y轴比例尺 及 右Y轴比例尺 及 左右Y轴宽度 ]\n    if (!chartAxis.curYAxis || !chartAxis.curYAxis.length) {\n      console.log('当前图形Y轴配置异常');\n      return false;\n    }\n    let svgDrawWidth = $(containerResult.svgJqDom).width(),\n      svgDrawHeight = $(containerResult.svgJqDom).height();\n    let showYTitleFlag = !conf.inPinboard;\n    if (!chartConfigures.y_axis_title_visible || chartConfigures.y_axis_title_visible === 'system_auto_default') {\n      showYTitleFlag = !conf.inPinboard;\n    } else {\n      showYTitleFlag = !!(chartConfigures.y_axis_title_visible === \"option_title_visible_show\");\n    }\n    let yAxisBasicMessage = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].calcMeasureAxisBasicMessage({\n      direction: 'vertical',\n      language: systemLanguage,\n      axisFontSize: theYAxisFontSize,\n      drawWidth: svgDrawWidth,\n      drawHeight: svgDrawHeight,\n      firstMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n        return axis.direction !== 'right';\n      }), {\n        axisType: 'normal',\n        tableData: conf.datas,\n        scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type),\n        min: chartConfigures.measure_scale_min,\n        max: chartConfigures.measure_scale_max,\n        definedMin: chartConfigures.measure_scale_defined_min || 0,\n        definedSeparate: chartConfigures.measure_scale_step,\n        definedStep: chartConfigures.measure_scale_step_number,\n        definedScaleFormat: chartConfigures.measure_left_y_configure\n      }),\n      secondMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curYAxis.filter(function (axis) {\n        return axis.direction === 'right';\n      }), {\n        axisType: 'normal',\n        tableData: conf.datas,\n        scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type_right),\n        min: chartConfigures.measure_scale_min_right,\n        max: chartConfigures.measure_scale_max_right,\n        definedMin: chartConfigures.measure_scale_defined_min_right || 0,\n        definedSeparate: chartConfigures.measure_scale_step_right,\n        definedStep: chartConfigures.measure_scale_step_number_right,\n        definedScaleFormat: chartConfigures.measure_right_y_configure\n      }),\n      showAxisTitleFlag: showYTitleFlag,\n      // Y轴标签没有配置的情况下, 默认是显示的\n      measureAxisVisible: chartConfigures.y_axis_label_visible === undefined ? true : chartConfigures.y_axis_label_visible,\n      titleFontSize: theYTitleFontSize,\n      maxLabelWidthPercent: chartConfigures.y_axis_label_max_width_percent,\n      alignZeroFlag: chartConfigures.measure_scale_parallel,\n      mustHaveZeroFlag: translateData.xLabelType === 'scaleLine' ? false : true\n    });\n    if (!yAxisBasicMessage || !yAxisBasicMessage.firstMeasure) return false;\n\n    // 2. 计算是否有标准线及 标准线的宽度\n    let hasMarkerFlag = !hasLegendFlag && chartAxis.curYAxis.length === 1; //  没有图例的情况下[只有一个yAxis时]就有可以有标准线\n    hasMarkerFlag = hasMarkerFlag && !chartConfigures.grid_remove_standard_line; //  是否配置了移除标准线\n    hasMarkerFlag = hasMarkerFlag && translateData.xLabelType !== 'scaleLine'; //  X轴得是属性轴的情况下才有标准线\n    let theMarkerBasicMessage;\n    if (hasMarkerFlag) {\n      theMarkerBasicMessage = _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_8__[\"default\"].calcMeasureMarkerMessage({\n        direction: 'vertical',\n        measureAxis: chartAxis.curYAxis,\n        markerFontSize: chartFontSize,\n        drawWidth: svgDrawWidth,\n        drawHeight: svgDrawHeight,\n        scaleFormat: yAxisBasicMessage.firstMeasure.measureAxis && yAxisBasicMessage.firstMeasure.measureAxis.yScaleFormat,\n        getI18nKey: conf.curLanguage\n      });\n      if (!theMarkerBasicMessage || !theMarkerBasicMessage.hasMarkerFlag) hasMarkerFlag = false;\n    }\n\n    // 翻页时需要重新画以下图形部分 / 缩放时也需要重新画以下图形部分 ---------------------------------------------------------- //\n\n    // 3. 计算X轴刻度值 [ 先通过Y轴刻度宽度值 及 标准线宽度值，计算X轴刻度的宽度 ， 画完X轴刻度后才可以确认X轴刻度的高度]\n    let measureSeparate = 5,\n      //  刻度值与轴之间的间隔[ Y轴刻度与Y轴线之间的间隔 ]\n      attributeSeparate = 2,\n      //  X轴刻度与轴之间的间隔 [ X轴刻度与Y轴最小的一条线的间隔 ]\n      titleSeparate = 5,\n      //  轴标题与轴刻度之间的间隔 [ X轴标题与X轴刻度的间隔 ； Y轴标题与Y轴刻度的间隔 ]\n      firstTitleWidth = yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag ? (yAxisBasicMessage.firstMeasure.measureTitleSize || 0) + titleSeparate : 0,\n      firstMeasureWidth = (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.measureTickWidth || 0) + measureSeparate,\n      secondTitleWidth = yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag ? (yAxisBasicMessage.secondMeasure.measureTitleSize || 0) + titleSeparate : 0,\n      secondMeasureWidth = yAxisBasicMessage.secondMeasure ? yAxisBasicMessage.secondMeasure.measureTickWidth + measureSeparate : 0,\n      markerMessageWidth = theMarkerBasicMessage && theMarkerBasicMessage.markerMaxWidth || 0,\n      scaleAttributeWidth = svgDrawWidth - firstMeasureWidth - firstTitleWidth - secondMeasureWidth - secondTitleWidth - markerMessageWidth;\n\n    // 获取数据标签的配置\n    let labelFontSize = chartConfigures.label_text_font_style && parseInt(chartConfigures.label_text_font_style.fontSize) || Math.max(chartFontSize - 2, 10) || 10,\n      showLabelFlag = false,\n      labelPosition = 'default',\n      labelRotation = 0,\n      labelVisibleMap = 'all',\n      allowOverlap = false;\n    if (chartConfigures.label_text_visible) {\n      showLabelFlag = true;\n    }\n    if (chartConfigures.label_text_circle_position) {\n      switch (conf.chartConfigures.label_text_circle_position) {\n        case 'option_label_position_in':\n          labelPosition = 'in';\n          break;\n        case 'option_label_position_out':\n          labelPosition = 'out';\n          break;\n        default:\n          labelPosition = 'default';\n          break;\n      }\n    }\n    if (chartConfigures.label_text_rotation_angle) {\n      switch (chartConfigures.label_text_rotation_angle) {\n        case 'option_label_rotation_90':\n          labelRotation = 90;\n          break;\n        case 'option_label_rotation_270':\n          labelRotation = 270;\n          break;\n        default:\n          labelRotation = 0;\n          break;\n      }\n    }\n    if (chartConfigures.label_text_visible_items) {\n      switch (chartConfigures.label_text_visible_items) {\n        case 'option_label_visible_all':\n          labelVisibleMap = 'all';\n          break;\n        case 'option_label_visible_standard':\n          labelVisibleMap = 'standard';\n          break;\n        default:\n          labelVisibleMap = 'all';\n          break;\n      }\n    }\n    if (chartConfigures.label_text_allow_overlap) {\n      allowOverlap = true;\n    }\n\n    // 是否显示X轴标题的配置\n    let showXTitleFlag = !conf.inPinboard; //  用户没有配置X轴或配置为自动的情况下，系统按是否是看板自动分配\n    if (!chartConfigures.x_axis_title_visible || chartConfigures.x_axis_title_visible === 'system_auto_default') {\n      showXTitleFlag = !conf.inPinboard;\n    } else {\n      showXTitleFlag = !!(chartConfigures.x_axis_title_visible === \"option_title_visible_show\");\n    }\n    let animateFlag = !chartConfigures.animation_forbidden; //  是否禁止动画的标志;\n\n    /** * frameOptions 主要用于翻页 及 缩放时的参数传递\r\n     * @param frameOptions\r\n     *      {\r\n     *          type    -   操作类型    page: 翻页； zoom: 缩放 ； select: 区域选择 ； 无：是初始化\r\n     *          start   -   X刻度开始的索引\r\n     *          steps   -   X轴可以放的X刻度数量\r\n     *      }\r\n     * */\n    let drawAChartFrame = function (frameOptions) {\n      frameOptions = frameOptions || {};\n      let scalePaddingTop = 0; //  垂直方向的刻度轴顶部需要预留10px空白\n      let scatterDataSet = [];\n      // 清空canvas画布\n      if (!containerResult.canvasJqDom) return false;\n      let theCanvasContext = containerResult.canvasJqDom.getContext('2d');\n      let theCanvasWidth = 0,\n        theCanvasHeight = 0,\n        theCanvasZoom = 2,\n        xLabelStart = 0,\n        //  X轴是属性轴的情况下, X轴刻度的起始位置索引[ 主要给图例高亮使用 ]\n        xLabelEnd = 0,\n        //  X轴是属性轴的情况下, X轴刻度的结束位置索引[ 主要给图例高亮使用 ]\n        xLabelDatas = {},\n        //  X轴是属性轴的情况下, 各个X轴刻度的数据\n        xLabelWidth = 0,\n        //  X轴是属性轴的情况下, 各个X轴刻度的宽度\n        hoverRangeHeight = 0; //  X轴是属性轴的情况下，鼠标移入各个X轴度区域需要显示该区域数据\n      let measureYAxis, analysisDataObj;\n      switch (translateData.xLabelType) {\n        // 如果当前图形是数值轴，则X轴是水平摆放的measureAxis ， 也支持X轴标度及X轴最大值最小值\n        // X轴是数值刻度比例尺时，散点图的鼠标事件是移入到散点范围，高亮放大该点，高亮同图例点，置灰其他图例点，显示该点的悬浮文本\n        case \"scaleLine\":\n          // X轴是数值时，直接显示所有的散点数据，无需分页\n          // 清空SVG的区域\n          containerResult.svgJqDom.innerHTML = '';\n\n          // 1. 计算X轴标尺信息\n          let xAxisBasicMessage = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].calcMeasureAxisBasicMessage({\n            direction: 'horizontal',\n            language: systemLanguage,\n            axisFontSize: theXAxisFontSize,\n            drawWidth: svgDrawWidth,\n            drawHeight: svgDrawHeight,\n            firstMeasureAxis: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateMeasureAxis(chartAxis.curXAxis, {\n              axisType: 'normal',\n              scaleType: _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].translateScaleType(chartConfigures.measure_scale_type_x),\n              min: chartConfigures.measure_scale_min_x,\n              max: chartConfigures.measure_scale_max_x,\n              definedMin: chartConfigures.measure_scale_defined_min_x || 0,\n              definedSeparate: chartConfigures.measure_scale_step_x,\n              definedStep: chartConfigures.measure_scale_step_number_x,\n              definedScaleFormat: chartConfigures.measure_x_configure\n            }),\n            showAxisTitleFlag: showYTitleFlag,\n            // Y轴标签没有配置的情况下, 默认是显示的\n            measureAxisVisible: chartConfigures.x_axis_label_visible === undefined ? true : chartConfigures.x_axis_label_visible,\n            titleFontSize: theXTitleFontSize,\n            maxLabelHeightPercent: chartConfigures.x_axis_label_max_height_percent,\n            mustHaveZeroFlag: false\n          });\n\n          // 2. 画X轴标题[ 如果看板中显示 或者 强制显示的情况 ]\n          let measureXTitleHeight = 0; //  X轴标题横向摆放的高度\n          if (showXTitleFlag) {\n            let theSettingXTitleText = chartConfigures.x_axis_title_content,\n              theDefaultXTitleText = [];\n            chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n              theDefaultXTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, xAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theXTitleSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', \"KKK\", {\n              fontSize: theXTitleFontSize\n            });\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n              svgContainer: containerResult.svgJqDom,\n              direction: 'horizontal',\n              titleText: theSettingXTitleText || theDefaultXTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.x_axis_title_alignment || 'center',\n              titleFontSize: theXTitleFontSize,\n              titleFontColor: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontItalic,\n              translateTop: svgDrawHeight - theXTitleSize.height,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              titleHeight: theXTitleSize.height,\n              titleWidth: scaleAttributeWidth,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? chartAxis.curXAxis : null\n            });\n            measureXTitleHeight = theXTitleSize.height + titleSeparate;\n          }\n          // 3. 画X轴刻度\n          let measureXAxis = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawMeasureAxis({\n            svgContainer: containerResult.svgJqDom,\n            drawWidth: svgDrawWidth - firstTitleWidth - secondTitleWidth,\n            drawHeight: svgDrawHeight - measureXTitleHeight - scalePaddingTop,\n            axisFontSize: theXAxisFontSize,\n            axisFontColor: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontColor,\n            axisFontBold: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontBold,\n            axisFontItalic: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontItalic,\n            direction: \"horizontal\",\n            position: \"bottom\",\n            separate: measureSeparate,\n            firstMeasure: xAxisBasicMessage.firstMeasure,\n            scaleWidth: scaleAttributeWidth,\n            // 默认显示网格线\n            showAxisLineFlag: (chartConfigures.grid_show_all_line === undefined ? true : chartConfigures.grid_show_all_line) && (chartConfigures.grid_show_vertical_grid_line === undefined ? true : chartConfigures.grid_show_vertical_grid_line),\n            // 网格线样式\n            strokeLineStyle: chartConfigures.grid_vertical_line_style,\n            // 只显示零线\n            showOnlyZeroLineFlag: !!chartConfigures.grid_show_vertical_only_zero_line,\n            // 零线样式\n            zeroStrokeLineStyle: chartConfigures.grid_vertical_zero_line_style\n          });\n          if (!measureXAxis || !measureXAxis.measureContainer) {\n            console.log('画点X数值刻度轴异常');\n            return false;\n          }\n          if (measureXAxis.measureContainer) {\n            measureXAxis.measureContainer.attr(\"transform\", \"translate(\" + (firstTitleWidth + firstMeasureWidth) + \" , \" + (svgDrawHeight - measureXTitleHeight) + \")\");\n          }\n\n          // 画Y轴标题\n          // 4. 填充Y轴标题 及 刻度 [ 通过X轴刻度高度确定Y轴比例尺的高度，画Y轴刻度，返回Y轴刻度比例尺 ]\n          let scaleYMeasureHeight = svgDrawHeight - (measureXAxis.firstMeasureHeight || 0) - measureXTitleHeight - scalePaddingTop;\n          // 画第一个Y轴标题\n          if (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag) {\n            let theDefaultTitleText = [];\n            let theMeasureAxis = yAxisBasicMessage.firstMeasure.measureAxis;\n            theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n              theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theSettingTitleText = chartConfigures.y_axis_title_content;\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n              svgContainer: containerResult.svgJqDom,\n              direction: 'vertical',\n              titleText: theSettingTitleText || theDefaultTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n              titleFontSize: theYTitleFontSize,\n              titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n              translateLeft: 0,\n              translateTop: scalePaddingTop,\n              titleHeight: scaleYMeasureHeight,\n              titleWidth: yAxisBasicMessage.firstMeasure.measureTitleSize,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n            });\n          }\n\n          // 画Y轴刻度\n          measureYAxis = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawMeasureAxis({\n            svgContainer: containerResult.svgJqDom,\n            drawWidth: svgDrawWidth,\n            drawHeight: svgDrawHeight,\n            axisFontSize: theYAxisFontSize,\n            axisFontColor: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontColor,\n            axisFontBold: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontBold,\n            axisFontItalic: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontItalic,\n            direction: 'vertical',\n            separate: measureSeparate,\n            scaleHeight: scaleYMeasureHeight,\n            scaleLineWidth: scaleAttributeWidth,\n            firstMeasure: yAxisBasicMessage.firstMeasure,\n            secondMeasure: yAxisBasicMessage.secondMeasure,\n            // 默认显示网格线\n            showAxisLineFlag: (chartConfigures.grid_show_all_line === undefined ? true : chartConfigures.grid_show_all_line) && (chartConfigures.grid_show_horizontal_grid_line === undefined ? true : chartConfigures.grid_show_horizontal_grid_line),\n            // 网格线样式\n            strokeLineStyle: chartConfigures.grid_horizontal_line_style,\n            // 只显示零线\n            showOnlyZeroLineFlag: !!chartConfigures.grid_show_horizontal_only_zero_line,\n            // 零线样式\n            zeroStrokeLineStyle: chartConfigures.grid_horizontal_zero_line_style\n          });\n          measureYAxis.measureContainer.attr(\"transform\", \"translate( \" + firstTitleWidth + \" , \" + scalePaddingTop + \")\");\n\n          // 画X轴目标线\n          chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n            if (_DataFocusMethod.isPureNumber(xAxis.goal)) {\n              // 设置目标值后，需要画目标线\n              let theScaleFunc = measureXAxis.firstMeasureScaleFunc,\n                yScaleFormat = measureXAxis.firstMeasure && measureXAxis.firstMeasure.yScaleFormat;\n              _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawVerticalGoalLine({\n                svgContainer: containerResult.svgJqDom,\n                position: \"bottom\",\n                translateLeft: firstTitleWidth + firstMeasureWidth + theScaleFunc(xAxis.goal),\n                translateTop: scalePaddingTop,\n                lineHeight: scaleYMeasureHeight,\n                hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(xAxis.goal, yScaleFormat)\n              });\n            }\n          });\n          // 画Y轴目标线\n          chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis) {\n            if (_DataFocusMethod.isPureNumber(yAxis.goal)) {\n              // 设置目标值后，需要画目标线\n              if (yAxis.direction !== 'right') {\n                let theScaleFunc = measureYAxis.firstMeasureScaleFunc,\n                  yScaleFormat = measureYAxis.firstMeasure && measureYAxis.firstMeasure.yScaleFormat;\n                _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalGoalLine({\n                  svgContainer: containerResult.svgJqDom,\n                  position: \"left\",\n                  translateLeft: firstTitleWidth + firstMeasureWidth,\n                  translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n                  lineWidth: scaleAttributeWidth,\n                  hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n                });\n              } else {\n                let theScaleFunc = measureYAxis.secondMeasureScaleFunc,\n                  yScaleFormat = measureYAxis.secondMeasure && measureYAxis.secondMeasure.yScaleFormat;\n                _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalGoalLine({\n                  svgContainer: containerResult.svgJqDom,\n                  position: \"right\",\n                  translateLeft: firstTitleWidth + firstMeasureWidth,\n                  translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n                  lineWidth: scaleAttributeWidth,\n                  hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n                });\n              }\n            }\n          });\n          // 画标度[参考]线 及 区域\n          if (chartConfigures.scale_y_range) {\n            _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalDivisionRange({\n              language: systemLanguage,\n              referenceConfigure: chartConfigures.scale_y_range,\n              svgContainer: containerResult.svgJqDom,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              measureAxis: measureYAxis,\n              rangeWidth: scaleAttributeWidth,\n              defaultTitleText: conf.curLanguage(\"option_scale_config_text_default\")\n            });\n          }\n          if (chartConfigures.scale_x_range) {\n            _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawVerticalDivisionRange({\n              language: systemLanguage,\n              referenceConfigure: chartConfigures.scale_x_range,\n              position: 'bottom',\n              svgContainer: containerResult.svgJqDom,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              measureAxis: measureXAxis,\n              rangeHeight: scaleYMeasureHeight,\n              defaultTitleText: conf.curLanguage(\"option_scale_config_text_default\")\n            });\n          }\n          theCanvasWidth = scaleAttributeWidth;\n          theCanvasHeight = scaleYMeasureHeight + scalePaddingTop;\n          scatterDataSet = [];\n          // 有图例的情况， 获取所有散点数据\n          if (translateData.datasType === 'legend') {\n            let thePrevColumnIndex = -1;\n            translateData.legendDistinct && translateData.legendDistinct.forEach(function (theLegendStr, legendIndex) {\n              let theLegendData = translateData.datas[theLegendStr];\n              let theLegendConfig = legendValueList[legendIndex];\n              if (!theLegendConfig.show) return false;\n              thePrevColumnIndex++;\n              if (!theLegendData) return false;\n              // 有图例的情况Y轴只允许一个\n              let theScatterSet = _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getMeasureScatterChartSet(theLegendData, {\n                measureXAxis: measureXAxis,\n                measureYAxis: measureYAxis,\n                curXAxis: chartAxis.curXAxis && chartAxis.curXAxis[0],\n                curYAxis: chartAxis.curYAxis && chartAxis.curYAxis[0],\n                paddingTop: scalePaddingTop,\n                yIndex: 0,\n                yLength: translateData.yLength,\n                legendType: \"legendAxis\",\n                legendValue: theLegendStr,\n                legendIndex: legendIndex,\n                legendConfig: theLegendConfig,\n                legendId: theLegendConfig && theLegendConfig.id,\n                // 散点形状/大小/透明度/描边\n                scatterType: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendShapeConfigure(theLegendConfig.shape),\n                scatterTransparent: _DataFocusMethod.isPureNumber(chartConfigures.scatter_shape_transparent) ? parseFloat(chartConfigures.scatter_shape_transparent) : 50,\n                scatterSize: parseFloat(chartConfigures.scatter_shape_size) || 5,\n                scatterStrokeWidth: chartConfigures.scatter_shape_stroke_flag === undefined || chartConfigures.scatter_shape_stroke_flag ? chartConfigures.scatter_shape_stroke_width || 2 : 0\n              });\n              scatterDataSet = scatterDataSet.concat(theScatterSet);\n            });\n          }\n          // 无图例的情况， 获取所有散点数据\n          else {\n            let theLegendData = translateData.datas;\n            let thePrevColumnIndex = -1;\n            chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis, yIndex) {\n              let theLegendConfig = legendValueList[yIndex] || {};\n              // 因为只有一个Y轴时，legendValueList是为空的\n              if (legendValueList && legendValueList.length && !theLegendConfig.show) return false;\n              thePrevColumnIndex++;\n              let theScatterSet = _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getMeasureScatterChartSet(theLegendData, {\n                measureXAxis: measureXAxis,\n                measureYAxis: measureYAxis,\n                curXAxis: chartAxis.curXAxis && chartAxis.curXAxis[0],\n                paddingTop: scalePaddingTop,\n                curYAxis: yAxis,\n                yIndex: yIndex,\n                yLength: translateData.yLength,\n                legendType: \"YAxis\",\n                legendValue: yAxis.col_id,\n                legendIndex: yIndex,\n                legendConfig: theLegendConfig,\n                legendId: theLegendConfig && theLegendConfig.id,\n                // 散点形状/大小/透明度/描边\n                scatterType: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendShapeConfigure(theLegendConfig.shape),\n                //  chartConfigures.legend_shape_type ,\n                scatterTransparent: _DataFocusMethod.isPureNumber(chartConfigures.scatter_shape_transparent) ? parseFloat(chartConfigures.scatter_shape_transparent) : 50,\n                scatterSize: parseFloat(chartConfigures.scatter_shape_size) || 5,\n                scatterStrokeWidth: chartConfigures.scatter_shape_stroke_flag === undefined || chartConfigures.scatter_shape_stroke_flag ? chartConfigures.scatter_shape_stroke_width || 2 : 0\n              });\n              scatterDataSet = scatterDataSet.concat(theScatterSet);\n            });\n          }\n\n          // 计算所有数据的标签\n          if (showLabelFlag) {\n            scatterDataSet && scatterDataSet.forEach(function (theScatterData) {\n              let theScatterLabelText = _DataFocusMethod.formatTextData(theScatterData.x0, chartAxis.curXAxis[0]) + ':' + theScatterData.y0;\n              if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n                let theSuspendTextConfig = chartConfigures.label_text_regex || '';\n                if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_X_VALUE : %_Y_VALUE \";\n                theScatterLabelText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n                  type: \"label\",\n                  xValue: theScatterData.x0,\n                  yValue: theScatterData.y0,\n                  xAxis: chartAxis.curXAxis[0],\n                  yAxis: chartAxis.curYAxis[0],\n                  legend: theScatterData.legendValue,\n                  legendIndex: theScatterData.legendIndex + 1,\n                  legendTotal: theScatterData.total,\n                  rowData: theScatterData.rowData,\n                  headers: drawChartOptions.datas && drawChartOptions.datas.headers\n                });\n              }\n              theScatterData.labelText = theScatterLabelText;\n            });\n          }\n\n          // 如果有分析数据趋势，则依据返回数据画拟合曲线\n          analysisDataObj = {\n            hasAnalysisFlag: translateData.xLabelType === 'scaleLine',\n            analysisLineData: function () {\n              if (translateData.xLabelType === 'scaleLine' && chartDatas.analysis && chartDatas.analysis.factor && chartDatas.analysis.factor.length >= 2) {\n                let theIntercept = chartDatas.analysis.factor[0],\n                  theSlope = chartDatas.analysis.factor.slice(1) || [];\n                // 用于归一化的参数\n                let theDomain = chartDatas.analysis.domain || 1,\n                  theXMin = chartDatas.analysis.x_min || 0;\n                if (_DataFocusMethod.isPureNumber(theIntercept) && theSlope.length && _DataFocusMethod.isPureNumber(theSlope[0])) {\n                  if (measureXAxis && measureXAxis.firstMeasureScaleFunc && measureYAxis && measureYAxis.firstMeasureScaleFunc) {\n                    let theXAxis = chartAxis.curXAxis && chartAxis.curXAxis[0];\n                    let theXMeasure = measureXAxis.firstMeasure && measureXAxis.firstMeasure.measureTickScale || {};\n                    let theMin = _DataFocusMethod.isPureNumber(theXMeasure.min) ? theXMeasure.min : theXAxis.min;\n                    let theMax = _DataFocusMethod.isPureNumber(theXMeasure.max) ? theXMeasure.max : theXAxis.max;\n                    // 如果theSlope是数组，则是多元线性回归 y = theIntercept + theSlope[0] * x^1 + theSlope[1] * x^2 + ...\n                    // 由于是曲线，所以需要画多个点，暂定画200个点\n                    let theAnalysisPointArray = [];\n                    for (let i = 0; i < 301; i++) {\n                      // 计算点的X轴\n                      let theX = theMin + (theMax - theMin) / 300 * i;\n                      // 计算点的Y轴\n                      let theYSlope = theIntercept;\n                      for (let i = 0; i < theSlope.length; i++) {\n                        theYSlope += theSlope[i] * Math.pow((theX - theXMin) / theDomain, i + 1);\n                      }\n                      theAnalysisPointArray.push([measureXAxis.firstMeasureScaleFunc(theX) * theCanvasZoom, (measureYAxis.firstMeasureScaleFunc(theYSlope) + scalePaddingTop) * theCanvasZoom]);\n                    }\n                    return theAnalysisPointArray;\n                  }\n                }\n              }\n            }(),\n            analysisLineColor: chartConfigures.outlier_correlation_line_color,\n            analysisLineWidth: chartConfigures.outlier_correlation_line_width\n          };\n          break;\n\n        // 如果当前图形是属性轴，则按照X轴是属性轴的方式画散点图\n        // X轴是属性轴时，移入该X刻度区域，显示该区域下的所有数据信息 ， 移入单个点高亮放大该点，高亮同图例的数据，置灰其他图例数据\n        case \"timeLine\":\n        case \"levelLine\":\n        case \"dotLine\":\n        default:\n          // X轴是属性时，直接显示所有的X轴刻度及所有的点，无需翻页\n          frameOptions = frameOptions || {};\n          let start = parseInt(frameOptions.start),\n            end = 0,\n            steps = parseInt(frameOptions.steps) || 0;\n          // 如果没有传入steps，则使用配置值手动计算每页的数量\n          if (!steps) {\n            // 翻页/或初始化\n            // 计算是否有翻页，翻页的pageSize 及 每页的柱宽\n            let minimumColumnWidth = parseFloat(chartConfigures.chart_column_minimum_width) || 10;\n            minimumColumnWidth = Math.max(5, minimumColumnWidth);\n            // 使用最小柱宽计算每页的pageSize\n            steps = Math.floor(scaleAttributeWidth / minimumColumnWidth);\n          }\n          // 检正start , step , end的值\n          steps = Math.min(steps, translateData.xLabelDistinct.length);\n          steps = Math.max(steps, 1); //  至少有一个刻度可以画图\n\n          // 默认情况下，需要依据x_axis_right_first_flag来判断start的值： 优先画右侧数据,还是优先画左侧数据\n          if (isNaN(start) || start === undefined || start === null) {\n            if (chartConfigures.x_axis_right_first_flag) {\n              // 优先画右侧数据\n              start = translateData.xLabelDistinct.length - steps;\n              start = Math.max(0, start);\n            } else {\n              start = 0;\n            }\n          }\n          end = start + steps;\n          if (end > translateData.xLabelDistinct.xLength) {\n            end = translateData.xLabelDistinct.xLength;\n            start = end - steps;\n          }\n          // 清空SVG的区域\n          containerResult.svgJqDom.innerHTML = '';\n          xLabelStart = start;\n          xLabelEnd = end;\n\n          // 画X轴标题[ 如果看板中显示 或者 强制显示的情况 ]\n          let attributeTitleHeight = 0; //  X轴横向摆放的高度\n          if (showXTitleFlag) {\n            let theSettingXTitleText = chartConfigures.x_axis_title_content,\n              theDefaultXTitleText = [];\n            chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n              theDefaultXTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, xAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theXTitleSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', \"KKK\", {\n              fontSize: theXTitleFontSize\n            });\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n              svgContainer: containerResult.svgJqDom,\n              direction: 'horizontal',\n              titleText: theSettingXTitleText || theDefaultXTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.x_axis_title_alignment || 'center',\n              titleFontSize: theXTitleFontSize,\n              titleFontColor: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.x_axis_title_style && chartConfigures.x_axis_title_style.fontItalic,\n              translateTop: svgDrawHeight - theXTitleSize.height,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              titleHeight: theXTitleSize.height,\n              titleWidth: scaleAttributeWidth,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? chartAxis.curXAxis : null\n            });\n            attributeTitleHeight = theXTitleSize.height;\n          }\n          // 画X轴刻度\n          let attributeAxis = _pc_assets_js_charts_components_AttributeAxisComponent__WEBPACK_IMPORTED_MODULE_7__[\"default\"].drawHorizontalAttributeAxis({\n            axisType: translateData.xLabelType,\n            axisTimeType: translateData.xAxisTimeType,\n            svgContainer: containerResult.svgJqDom,\n            drawWidth: svgDrawWidth - firstTitleWidth - secondTitleWidth,\n            drawHeight: svgDrawHeight - attributeTitleHeight,\n            axisFontSize: theXAxisFontSize,\n            axisFontColor: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontColor,\n            axisFontBold: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontBold,\n            axisFontItalic: chartConfigures.x_axis_label_style && chartConfigures.x_axis_label_style.fontItalic,\n            position: 'bottom',\n            attributeValueList: translateData.xLabelDistinct,\n            attributeValueMap: translateData.xLabelDistinctMapping,\n            start: start,\n            end: end,\n            // X轴标签没有配置的情况下, 默认是显示的\n            attributeAxisVisible: chartConfigures.x_axis_label_visible === undefined ? true : chartConfigures.x_axis_label_visible,\n            hoverTranslateLeft: firstTitleWidth + firstMeasureWidth,\n            hoverTranslateTop: scalePaddingTop,\n            hoverTopSeparate: attributeSeparate,\n            scaleWidth: scaleAttributeWidth,\n            maxLabelHeightPercent: chartConfigures.x_axis_label_max_height_percent,\n            rotate: chartConfigures.x_axis_label_dot_line_rotation_value,\n            labelStepWidth: chartConfigures.x_axis_label_dot_line_space_width\n          });\n          if (!attributeAxis || !attributeAxis.attributeContainer) {\n            console.log('画点X属性轴异常');\n            return false;\n          }\n          if (attributeAxis.attributeContainer) {\n            attributeAxis.attributeContainer.attr(\"transform\", \"translate(\" + (firstTitleWidth + firstMeasureWidth) + \" , \" + (svgDrawHeight - (attributeAxis.maxLabelHeight || 0) - attributeTitleHeight) + \")\");\n          }\n\n          // 4. 填充Y轴标题 及 刻度 [ 通过X轴刻度高度确定Y轴比例尺的高度，画Y轴刻度，返回Y轴刻度比例尺 ]\n          let scaleMeasureHeight = svgDrawHeight - (attributeAxis.maxLabelHeight || 0) - attributeTitleHeight - attributeSeparate - scalePaddingTop;\n          // 画第一个Y轴标题\n          if (yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag) {\n            let theDefaultTitleText = [];\n            let theMeasureAxis = yAxisBasicMessage.firstMeasure.measureAxis;\n            theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n              theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theSettingTitleText = chartConfigures.y_axis_title_content;\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n              verticalTitleClass: 'first-y-title',\n              svgContainer: containerResult.svgJqDom,\n              direction: 'vertical',\n              titleText: theSettingTitleText || theDefaultTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n              titleFontSize: theYTitleFontSize,\n              titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n              translateLeft: 0,\n              translateTop: scalePaddingTop,\n              titleHeight: scaleMeasureHeight,\n              titleWidth: yAxisBasicMessage.firstMeasure.measureTitleSize,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n            });\n          }\n          // 画第二个Y轴标题\n          if (yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag) {\n            let theDefaultTitleText = [];\n            let theMeasureAxis = yAxisBasicMessage.secondMeasure.measureAxis;\n            theMeasureAxis && theMeasureAxis.axisList && theMeasureAxis.axisList.forEach(function (yAxis) {\n              theDefaultTitleText.push(_DataFocusMethod.getDisplayOperateColumn(systemLanguage, yAxis, {\n                hideOperator: hideOperatorFlag\n              }));\n            });\n            let theSettingTitleText = chartConfigures.right_y_axis_title_content;\n            _pc_assets_js_charts_components_TitleComponent__WEBPACK_IMPORTED_MODULE_5__[\"default\"].drawAxisTitle({\n              verticalTitleClass: 'second-y-title',\n              svgContainer: containerResult.svgJqDom,\n              direction: 'vertical',\n              titleText: theSettingTitleText || theDefaultTitleText.join(','),\n              //  标题内容\n              titleAlignment: chartConfigures.y_axis_title_alignment || 'center',\n              //  标题内容\n              titleFontSize: theYTitleFontSize,\n              titleFontColor: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontColor,\n              titleFontBold: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontBold,\n              titleFontItalic: chartConfigures.y_axis_title_style && chartConfigures.y_axis_title_style.fontItalic,\n              translateLeft: firstMeasureWidth + firstTitleWidth + scaleAttributeWidth + secondMeasureWidth + titleSeparate,\n              translateTop: scalePaddingTop,\n              titleHeight: scaleMeasureHeight,\n              titleWidth: yAxisBasicMessage.secondMeasure.measureTitleSize,\n              titleAxisList: chartConfigures._DF_SYS_ALLOW_HEADER_CONFIG ? theMeasureAxis && theMeasureAxis.axisList : null\n            });\n          }\n\n          // 画Y轴刻度\n          measureYAxis = _pc_assets_js_charts_components_MeasureAxisComponent__WEBPACK_IMPORTED_MODULE_6__[\"default\"].drawMeasureAxis({\n            svgContainer: containerResult.svgJqDom,\n            drawWidth: svgDrawWidth,\n            drawHeight: svgDrawHeight,\n            axisFontSize: theYAxisFontSize,\n            axisFontColor: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontColor,\n            axisFontBold: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontBold,\n            axisFontItalic: chartConfigures.y_axis_label_style && chartConfigures.y_axis_label_style.fontItalic,\n            direction: 'vertical',\n            separate: measureSeparate,\n            scaleHeight: scaleMeasureHeight,\n            scaleLineWidth: scaleAttributeWidth,\n            firstMeasure: yAxisBasicMessage.firstMeasure,\n            secondMeasure: yAxisBasicMessage.secondMeasure,\n            // 默认显示网格线\n            showAxisLineFlag: chartConfigures.grid_show_all_line === undefined ? true : chartConfigures.grid_show_all_line,\n            // 网格线样式\n            strokeLineStyle: chartConfigures.grid_line_style,\n            // 只显示零线\n            showOnlyZeroLineFlag: !!chartConfigures.grid_show_only_zero_line,\n            // 零线样式\n            zeroStrokeLineStyle: chartConfigures.grid_zero_line_style\n          });\n          measureYAxis.measureContainer.attr(\"transform\", \"translate( \" + firstTitleWidth + \" , \" + scalePaddingTop + \")\");\n\n          // 画标准线\n          if (hasMarkerFlag && theMarkerBasicMessage) {\n            _pc_assets_js_charts_components_MarkerComponent__WEBPACK_IMPORTED_MODULE_8__[\"default\"].drawHorizontalMarkerLine({\n              svgContainer: containerResult.svgJqDom,\n              markerTextList: theMarkerBasicMessage.markerTextList,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              markerFontSize: chartFontSize,\n              maxWidth: theMarkerBasicMessage.markerMaxWidth,\n              lineWidth: scaleAttributeWidth,\n              scaleHeight: scaleMeasureHeight,\n              scaleFunc: measureYAxis.firstMeasureScaleFunc,\n              markerLineColor: conf.colors(0)\n            });\n          }\n          // 画目标线\n          chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis) {\n            if (_DataFocusMethod.isPureNumber(yAxis.goal)) {\n              // 设置目标值后，需要画目标线\n              if (yAxis.direction !== 'right') {\n                let theScaleFunc = measureYAxis.firstMeasureScaleFunc,\n                  yScaleFormat = measureYAxis.firstMeasure && measureYAxis.firstMeasure.yScaleFormat;\n                _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalGoalLine({\n                  svgContainer: containerResult.svgJqDom,\n                  position: \"left\",\n                  translateLeft: firstTitleWidth + firstMeasureWidth,\n                  translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n                  lineWidth: scaleAttributeWidth,\n                  hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n                });\n              } else {\n                let theScaleFunc = measureYAxis.secondMeasureScaleFunc,\n                  yScaleFormat = measureYAxis.secondMeasure && measureYAxis.secondMeasure.yScaleFormat;\n                _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalGoalLine({\n                  svgContainer: containerResult.svgJqDom,\n                  position: \"right\",\n                  translateLeft: firstTitleWidth + firstMeasureWidth,\n                  translateTop: scalePaddingTop + theScaleFunc(yAxis.goal),\n                  lineWidth: scaleAttributeWidth,\n                  hoverText: conf.curLanguage(\"chart_conf_goal\") + ': ' + _DataFocusMethod.formatData(yAxis.goal, yScaleFormat)\n                });\n              }\n            }\n          });\n          // 画标度[参考]线 及 区域\n          if (chartConfigures.scale_y_range) {\n            _pc_assets_js_charts_components_ReferenceLineComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"].drawHorizontalDivisionRange({\n              language: systemLanguage,\n              referenceConfigure: chartConfigures.scale_y_range,\n              svgContainer: containerResult.svgJqDom,\n              translateLeft: firstTitleWidth + firstMeasureWidth,\n              translateTop: scalePaddingTop,\n              measureAxis: measureYAxis,\n              rangeWidth: scaleAttributeWidth,\n              defaultTitleText: conf.curLanguage(\"option_scale_config_text_default\")\n            });\n          }\n          theCanvasWidth = scaleAttributeWidth;\n          theCanvasHeight = scaleMeasureHeight + scalePaddingTop;\n          hoverRangeHeight = scaleMeasureHeight;\n          xLabelWidth = attributeAxis.rangeBand;\n          scatterDataSet = [];\n          // 有图例的情况， 获取所有散点数据\n          if (translateData.datasType === 'legend') {\n            let thePrevColumnIndex = -1;\n            translateData.legendDistinct && translateData.legendDistinct.forEach(function (theLegendStr, legendIndex) {\n              let theLegendData = translateData.datas[theLegendStr];\n              let theLegendConfig = legendValueList[legendIndex];\n              if (!theLegendConfig.show) return false;\n              thePrevColumnIndex++;\n              if (!theLegendData) return false;\n              let currentPageLegendData = theLegendData && theLegendData.filter(function (data) {\n                let theMappingObj = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[data.x0];\n                let theIndex = theMappingObj && theMappingObj.index || 0;\n                if (theIndex >= start && theIndex < end) {\n                  return true;\n                }\n              });\n              // 有图例的情况Y轴只允许一个\n              let theScatterSet = _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getAttributeScatterChartSet(currentPageLegendData, {\n                attributeXAxis: attributeAxis,\n                measureYAxis: measureYAxis,\n                curYAxis: chartAxis.curYAxis && chartAxis.curYAxis[0],\n                yIndex: 0,\n                yLength: translateData.yLength,\n                legendType: \"legendAxis\",\n                legendId: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('legendAxis', theLegendStr),\n                legendValue: theLegendStr,\n                legendIndex: legendIndex,\n                legendConfig: theLegendConfig,\n                // 散点形状/大小/透明度/描边\n                scatterType: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendShapeConfigure(theLegendConfig.shape),\n                // chartConfigures.legend_shape_type ,\n                scatterTransparent: _DataFocusMethod.isPureNumber(chartConfigures.scatter_shape_transparent) ? parseFloat(chartConfigures.scatter_shape_transparent) : 50,\n                scatterSize: parseFloat(chartConfigures.scatter_shape_size) || 5,\n                scatterStrokeWidth: chartConfigures.scatter_shape_stroke_flag === undefined || chartConfigures.scatter_shape_stroke_flag ? chartConfigures.scatter_shape_stroke_width || 2 : 0\n              });\n              if (theScatterSet) {\n                theScatterSet && theScatterSet.forEach(function (data) {\n                  if (!xLabelDatas[data.x0]) xLabelDatas[data.x0] = [];\n                  xLabelDatas[data.x0].push(data);\n                });\n                scatterDataSet = scatterDataSet.concat(theScatterSet);\n              }\n            });\n          }\n          // 无图例的情况， 获取所有散点数据\n          else {\n            let theLegendData = translateData.datas;\n            let thePrevColumnIndex = -1;\n            let currentPageLegendData = theLegendData && theLegendData.filter(function (data) {\n              let theMappingObj = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[data.x0];\n              let theIndex = theMappingObj && theMappingObj.index || 0;\n              if (theIndex >= start && theIndex < end) {\n                return true;\n              }\n            });\n            chartAxis.curYAxis && chartAxis.curYAxis.forEach(function (yAxis, yIndex) {\n              let theLegendConfig = legendValueList[yIndex];\n              if (!theLegendConfig.show) return false;\n              thePrevColumnIndex++;\n              let theScatterSet = _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].getAttributeScatterChartSet(currentPageLegendData, {\n                attributeXAxis: attributeAxis,\n                measureYAxis: measureYAxis,\n                curYAxis: yAxis,\n                yIndex: yIndex,\n                yLength: translateData.yLength,\n                legendType: \"YAxis\",\n                legendId: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('yAxis', yAxis.idx),\n                legendValue: yAxis.col_id,\n                legendIndex: yIndex,\n                legendConfig: theLegendConfig,\n                // 散点形状/大小/透明度/描边\n                scatterType: _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].translateLegendShapeConfigure(theLegendConfig.shape),\n                // chartConfigures.legend_shape_type ,\n                scatterTransparent: _DataFocusMethod.isPureNumber(chartConfigures.scatter_shape_transparent) ? parseFloat(chartConfigures.scatter_shape_transparent) : 50,\n                scatterSize: parseFloat(chartConfigures.scatter_shape_size) || 5,\n                scatterStrokeWidth: chartConfigures.scatter_shape_stroke_flag === undefined || chartConfigures.scatter_shape_stroke_flag ? chartConfigures.scatter_shape_stroke_width || 2 : 0\n              });\n              if (theScatterSet) {\n                theScatterSet && theScatterSet.forEach(function (data) {\n                  if (!xLabelDatas[data.x0]) xLabelDatas[data.x0] = [];\n                  xLabelDatas[data.x0].push(data);\n                });\n                scatterDataSet = scatterDataSet.concat(theScatterSet);\n              }\n            });\n          }\n\n          // 计算所有数据的标签\n          if (showLabelFlag) {\n            scatterDataSet && scatterDataSet.forEach(function (theScatterData) {\n              let theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[theScatterData.x0];\n              let theScatterLabelText = (theXLabelMapping && theXLabelMapping.text || theScatterData.x0) + ':' + theScatterData.y0;\n              if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n                let theSuspendTextConfig = chartConfigures.label_text_regex || '';\n                if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_NAME : %_Y_VALUE \";\n                theScatterLabelText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n                  type: \"label\",\n                  xLabel: theXLabelMapping && theXLabelMapping.text || theScatterData.x0,\n                  yValue: theScatterData.y0,\n                  yAxis: chartAxis.curYAxis[0],\n                  legend: theScatterData.legendValue,\n                  legendIndex: theScatterData.legendIndex + 1,\n                  legendTotal: theScatterData.total,\n                  rowData: theScatterData.rowData,\n                  headers: drawChartOptions.datas && drawChartOptions.datas.headers\n                });\n              }\n              theScatterData.labelText = theScatterLabelText;\n            });\n          }\n\n          // 画翻页的元素 [ 翻页也是临时的，不保存在配置中的 ]\n          _pc_assets_js_charts_components_PaginationChartComponent__WEBPACK_IMPORTED_MODULE_11__[\"default\"].drawHorizontalPagination({\n            chartContainer: containerResult.svgContainer,\n            translateLeft: firstTitleWidth,\n            translateTop: scalePaddingTop,\n            height: scaleMeasureHeight,\n            width: scaleAttributeWidth + firstMeasureWidth + secondMeasureWidth + markerMessageWidth,\n            start: start,\n            pageSize: steps,\n            totalNumber: translateData.xLabelDistinct.length,\n            pagingFunc: drawAChartFrame\n          });\n          break;\n      }\n\n      // 初始化散点区域的数据\n      $(containerResult.canvasJqDom).css({\n        width: theCanvasWidth,\n        height: theCanvasHeight,\n        left: firstTitleWidth + firstMeasureWidth,\n        top: 0\n      });\n      containerResult.canvasJqDom.width = theCanvasWidth * theCanvasZoom;\n      containerResult.canvasJqDom.height = theCanvasHeight * theCanvasZoom;\n      // 初始化告警散点部分，放于SVG部分【由于canvas中的动画是不断的清空重画，所以预警的散点动画使用svg的css实现】\n      let svgWarningContext = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom).append(\"g\").attr(\"class\", 'warning-scatter-container').attr(\"transform\", \"translate(\" + (firstTitleWidth + firstMeasureWidth) + \" , 0)\").attr(\"width\", theCanvasWidth).attr(\"height\", theCanvasHeight);\n      // 画所有散点数据对应的图形\n      _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawCanvasScatterChartSet(scatterDataSet, {\n        canvasContext: theCanvasContext,\n        canvasZoom: theCanvasZoom,\n        canvasHeight: theCanvasHeight,\n        canvasWidth: theCanvasWidth,\n        svgWarningContext: svgWarningContext,\n        currentLegendId: frameOptions.currentLegend && frameOptions.currentLegend.id,\n        analysisData: analysisDataObj,\n        // 显示数据标签\n        showLabelFlag: showLabelFlag,\n        // 标签字体大小\n        labelFontSize: labelFontSize,\n        labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor || chartFontColor || \"#333\",\n        labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold || chartFontBold,\n        labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic || chartFontItalic,\n        // 标签位置\n        labelPosition: labelPosition,\n        // 旋转方向\n        labelRotation: labelRotation,\n        // 显示的集合\n        labelVisibleMap: labelVisibleMap,\n        // 标签是否允许重复\n        labelAllowOverlap: allowOverlap,\n        // 是否有动画\n        animateFlag: frameOptions.animateFlag\n      });\n\n      // Canvas绑定鼠标事件\n      let prevXLabelIndex = -1,\n        theMouseoverHtml;\n      _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].appendScatterCanvasEvent({\n        canvasDom: containerResult.canvasJqDom,\n        scatterDataSet: scatterDataSet,\n        canvasHeight: theCanvasHeight,\n        canvasWidth: theCanvasWidth,\n        scatterSize: parseFloat(chartConfigures.scatter_shape_size) || 5,\n        canvasZoom: theCanvasZoom,\n        measureXFlag: translateData.xLabelType === 'scaleLine',\n        hoverWidth: xLabelWidth,\n        // 鼠标在当前画布上移动时，显示X轴刻度区域及提示\n        mousemoverXLabelCallback: function (options) {\n          options = options || {};\n          let theXLabelIndex = parseInt(options.xLabelIndex);\n          if (!isNaN(theXLabelIndex) || !options.event) {\n            // 显示当前X刻度的数据信息\n            let theLeftXWidth = theXLabelIndex * xLabelWidth;\n            theXLabelIndex += xLabelStart;\n            if (prevXLabelIndex !== theXLabelIndex && theXLabelIndex >= 0) {\n              prevXLabelIndex = theXLabelIndex;\n\n              // 显示X刻度 及 各个图例的颜色，图例名称 及 数值\n              let theXLabel = translateData.xLabelDistinct && translateData.xLabelDistinct[theXLabelIndex],\n                theXLabelMapping = translateData.xLabelDistinctMapping && translateData.xLabelDistinctMapping[theXLabel],\n                theXLabelData = xLabelDatas && xLabelDatas[theXLabel];\n              theMouseoverHtml = (theXLabelMapping && theXLabelMapping.text || theXLabel) + '<br/>';\n              theXLabelData && theXLabelData.forEach(function (data) {\n                if (data.legendConfig) {\n                  theMouseoverHtml += '<span style=\"display:inline-block;width:10px;height:10px;border-radius: 2px;background: ' + data.legendConfig.color + ';margin-right:2px;\"></span>';\n                }\n                let theYAxis = chartAxis.curYAxis[data.yIndex];\n                if (chartAxis.curLegend) {\n                  theMouseoverHtml += data.legendValue + ':';\n                } else {\n                  theMouseoverHtml += (theYAxis.displayName || theYAxis.col_name) + ':';\n                }\n                theMouseoverHtml += _DataFocusMethod.formatData(data.y0, theYAxis);\n                theMouseoverHtml += '<br />';\n              });\n            }\n            _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].positionChartPrompt(options.event, theMouseoverHtml);\n            let theSvgDom = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom),\n              theHoverDom = theSvgDom.select(\".hover-area-dom\");\n            if (!theHoverDom[0][0]) {\n              theHoverDom = theSvgDom.append(\"g\").attr(\"class\", \"hover-area-dom\").attr(\"pointer-events\", 'none');\n              theHoverDom.append(\"rect\")\n              // .style(\"fill\" , \"rgba(93 , 25 , 128 , 0.1)\")\n              .style(\"fill\", \"rgba(137,137,137,0.3)\").style(\"stroke\", \"none\").attr(\"x\", \"0\").attr(\"y\", \"0\").attr(\"width\", xLabelWidth).attr(\"height\", theCanvasHeight);\n              theHoverDom.append(\"line\").style(\"stroke\", \"rgba(93 , 25 , 128)\").style(\"stroke-width\", \"1\").attr(\"x1\", \"0\").attr(\"y1\", theCanvasHeight).attr(\"x2\", xLabelWidth).attr(\"y2\", theCanvasHeight);\n            }\n            theHoverDom.attr(\"transform\", \"translate(\" + (firstTitleWidth + firstMeasureWidth + theLeftXWidth) + \", 0)\");\n          }\n        },\n        // 移出整个画布时，清除高亮X轴的区域\n        mouseoutXLabelCallback: function () {\n          let theContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(containerResult.svgJqDom);\n          theContainer.select(\".hover-area-dom\").remove();\n        },\n        // 鼠标移入当前散点，高亮同图例的散点\n        mouseoverCircleCallback: function (event, options) {\n          let theTranslateSuspendText;\n          options = options || {};\n          let theScatterData = options.scatterData,\n            theScatterIndex = options.index;\n          if (!theScatterData) return false;\n          // 高亮当前图例的点\n          if (theScatterData.legendValue) {\n            _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawCanvasScatterChartSet(scatterDataSet, {\n              canvasContext: theCanvasContext,\n              canvasZoom: theCanvasZoom,\n              canvasHeight: theCanvasHeight,\n              canvasWidth: theCanvasWidth,\n              currentLegendId: theScatterData.legendId,\n              selectedScatterIndex: theScatterIndex,\n              analysisData: analysisDataObj,\n              showLabelFlag: showLabelFlag,\n              // 标签字体大小\n              labelFontSize: labelFontSize,\n              labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n              labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n              labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n              // 标签位置\n              labelPosition: labelPosition,\n              // 旋转方向\n              labelRotation: labelRotation,\n              // 显示的集合\n              labelVisibleMap: labelVisibleMap,\n              // 标签是否允许重复\n              labelAllowOverlap: allowOverlap\n            });\n            let theMatchedLegend = legendValueList.find(function (item) {\n              return item.legend === theScatterData.legendValue;\n            });\n            if (theMatchedLegend && theMatchedLegend.id && theMatchedLegend.show) {\n              let theLegendItem = $(containerResult.legendContainer).find(\".legend-item[data-legend-id='\" + theMatchedLegend.id + \"']\");\n              theLegendItem.find(\"svg\").removeClass(\"fill-grey\");\n              theLegendItem.siblings().find(\"svg\").addClass(\"fill-grey\");\n            }\n          }\n          if (self.chartConfigureAdvanced && self.chartConfigureAdvanced.translateMacro) {\n            let theSuspendTextConfig = chartConfigures.suspend_text_regex || '';\n            if (!theSuspendTextConfig.trim()) theSuspendTextConfig = \"%_SERIES_NAME %_BR %_X_VALUE_NAME: %_X_VALUE %_BR %_Y_VALUE_NAME:%_Y_VALUE \";\n            theTranslateSuspendText = self.chartConfigureAdvanced.translateMacro(theSuspendTextConfig, {\n              xValue: theScatterData.x0,\n              yValue: theScatterData.y0,\n              xAxis: chartAxis.curXAxis[0],\n              yAxis: chartAxis.curYAxis[0],\n              legend: theScatterData.legendValue,\n              legendIndex: theScatterData.legendIndex + 1,\n              legendTotal: theScatterData.total,\n              rowData: theScatterData.rowData,\n              headers: drawChartOptions.datas && drawChartOptions.datas.headers\n            });\n          }\n          _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].positionChartPrompt(event, theTranslateSuspendText || theScatterData.x0 + ':' + theScatterData.y0);\n        },\n        // 鼠标移出当前散点，高亮所有图例的散点\n        mouseoutCircleCallback: function () {\n          _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].clearChartPrompt();\n          _ScatterChartComponent_js__WEBPACK_IMPORTED_MODULE_9__[\"default\"].drawCanvasScatterChartSet(scatterDataSet, {\n            canvasContext: theCanvasContext,\n            canvasZoom: theCanvasZoom,\n            canvasHeight: theCanvasHeight,\n            canvasWidth: theCanvasWidth,\n            analysisData: analysisDataObj,\n            showLabelFlag: showLabelFlag,\n            // 标签字体大小\n            labelFontSize: labelFontSize,\n            labelFontColor: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontColor,\n            labelFontBold: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontBold,\n            labelFontItalic: chartConfigures.label_text_font_style && chartConfigures.label_text_font_style.fontItalic,\n            // 标签位置\n            labelPosition: labelPosition,\n            // 旋转方向\n            labelRotation: labelRotation,\n            // 显示的集合\n            labelVisibleMap: labelVisibleMap,\n            // 标签是否允许重复\n            labelAllowOverlap: allowOverlap\n          });\n          $(containerResult.legendContainer).find(\".legend-item .fill-grey\").removeClass(\"fill-grey\");\n        },\n        // 鼠标点击当前散点，触发左右击事件\n        mousedownCallback: function (event, d) {\n          // 移动端的mousedown事件不执行\n          if (!!(conf.action && !conf.wxFlag)) {\n            let theDataColumnIdx = [];\n            chartAxis.curXAxis && chartAxis.curXAxis.forEach(function (xAxis) {\n              if (xAxis.columnClassify !== 'number') theDataColumnIdx.push(xAxis.idx);\n            });\n            if (chartAxis && chartAxis.curLegend) {\n              theDataColumnIdx.push(chartAxis.curLegend.idx);\n            }\n            typeof conf.mousedownCallback === 'function' && conf.mousedownCallback.call(this, event, {\n              dataColumnIndex: theDataColumnIdx,\n              dataRowIndex: d.rowIndex\n            });\n          }\n        }\n      });\n      return {\n        start: xLabelStart,\n        end: xLabelEnd\n      };\n    };\n\n    // 默认画第一页数据\n    aChartFrameReturn = drawAChartFrame({\n      animateFlag: animateFlag\n    });\n\n    /* *\r\n    * 画完图需要告诉外部的配置组件，当前图形的配置：\r\n    *   X轴类型是单层刻度/多层刻度/时间轴 及 单层刻度列表 ； 或者用户配置的类型 ；\r\n    *   标题是自动显示，还是自动隐藏 ； 或者是用户配置的显示及隐藏\r\n    *   是否有右Y轴\r\n    *   是否有图例，属性列图例；多Y轴图例 ；\r\n    * */\n    let returnConfigureAutoValue = {};\n    // 如果用户配置的X轴类型是自动，则返回给图形配置组件提供当前X轴的自动类型\n    if (chartConfigures.x_axis_draw_type !== 'option_select_x_axis_dot_line') {\n      switch (translateData.autoXLabelType) {\n        case \"dotLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_dot_line';\n          break;\n        case \"timeLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_time_line';\n          break;\n        case \"levelLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_level_line';\n          break;\n        case \"scaleLine\":\n          returnConfigureAutoValue.x_axis_draw_type = 'option_select_x_axis_scale_line';\n          break;\n      }\n    }\n    if (translateData.xLabelType === 'scaleLine') {\n      returnConfigureAutoValue.measure_x_flag = true;\n    }\n    // 如果用户配置X轴标题显示自动，则返回给图形配置组件提供当前X轴标题的自动显示类型\n    if (!chartConfigures.x_axis_title_visible || chartConfigures.x_axis_title_visible === 'system_auto_default') {\n      returnConfigureAutoValue.x_axis_title_visible = showXTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n    }\n    // 如果用户配置Y轴标题显示自动，则返回给图形配置组件提供当前Y轴标题的自动显示类型\n    if (!chartConfigures.y_axis_title_visible || chartConfigures.y_axis_title_visible === 'system_auto_default') {\n      returnConfigureAutoValue.y_axis_title_visible = yAxisBasicMessage.firstMeasure && yAxisBasicMessage.firstMeasure.showTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n    }\n    // 如果用户配置了右Y轴，则将右Y轴存在的标志传给图形\n    if (yAxisBasicMessage.secondMeasure) {\n      returnConfigureAutoValue.has_right_y_axis = true;\n      // 如果用户配置右Y轴标题显示自动，则返回给图形配置组件提供当前右Y轴标题的自动显示类型\n      if (!chartConfigures.right_y_axis_title_visible || chartConfigures.right_y_axis_title_visible === 'system_auto_default') {\n        returnConfigureAutoValue.right_y_axis_title_visible = yAxisBasicMessage.secondMeasure && yAxisBasicMessage.secondMeasure.showTitleFlag ? 'option_title_visible_show' : 'option_title_visible_hide';\n      }\n    }\n    // 如果当前图形配置有图例，则将图例配置传给图形\n    if (hasLegendFlag) {\n      returnConfigureAutoValue.has_legend_flag = hasLegendFlag;\n      returnConfigureAutoValue.legendValueList = legendValueList;\n      returnConfigureAutoValue.defaultLegendList = defaultLegendList;\n    }\n    // 如果当前图形可以配置最大最小值标准线，则将该配置传给图形\n    if (!hasLegendFlag && translateData.xLabelType !== 'scaleLine' && chartAxis.curYAxis.length === 1) {\n      returnConfigureAutoValue.allow_marker_flag = true;\n    }\n\n    /**\r\n     * @return\r\n     *      {\r\n     *          // 当前图形自动识别的配置，主要可以用于chartConfigureList中条件判断\r\n     *          chartAutoConfigures: {}\r\n     *      }\r\n     * */\n    return {\n      chartAutoConfigures: returnConfigureAutoValue\n    };\n  },\n  // [*必填项]图表配置列表，其中的require条件不仅可以使用以下配置项的key，也可以使用drawChart中返回的chartAutoConfigures中的值\n  // drawChart返回的chartAutoConfigures是图形返回给图形配置组件的信息，用于开发者可以控制配置的显示与隐藏\n  /**\r\n   * [\r\n   *      key: 'category_name' ,\r\n   *      title: \"category_display_name_key\" ,\r\n   *      require: \"\" ,\r\n   *      options: [\r\n   *          {\r\n   *              key: 'configure_name'\r\n   *              title: 'configure_display_name_key'\r\n   *              description: 'configure_description_key'\r\n   *              require: '' ,\r\n   *              type: 'theme / select / input ... '\r\n   *          }\r\n   *      ]\r\n   *\r\n   * ]\r\n   *\r\n   * */\n  chartConfigureList: [\n  // 通用 ： 字体大小，动画，最小柱宽，\n  {\n    key: \"category_general\",\n    title: \"category_general\",\n    options: [\n    // 图形的颜色主题\n    {\n      key: \"chart_color_theme\",\n      title: \"option_chart_color_theme\",\n      description: \"option_chart_color_theme_desc\",\n      type: \"theme\",\n      selection: [\"option_chart_theme_eight\", \"option_chart_theme_one\", \"option_chart_theme_two\", \"option_chart_theme_three\", \"option_chart_theme_four\", \"option_chart_theme_five\", \"option_chart_theme_six\", \"option_chart_theme_seven\", \"option_chart_theme_custom\"],\n      defaultValue: \"option_chart_theme_one\"\n    },\n    //自定义主题颜色\n    {\n      key: \"chart_custom_theme\",\n      title: \"option_chart_custom_theme\",\n      description: \"option_chart_custom_theme_desc\",\n      type: \"colorList\",\n      require: \"chart_color_theme=option_chart_theme_custom\"\n    },\n    // 图形字体大小\n    {\n      key: \"font_size_label\",\n      title: \"option_font_size_label\",\n      description: \"option_font_size_label_desc\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      }\n    },\n    // 最小刻度宽度\n    {\n      key: \"chart_column_minimum_width\",\n      title: \"option_chart_column_minimum_width\",\n      description: \"option_chart_column_minimum_width_desc\",\n      type: \"input\",\n      min: 5,\n      defaultNumber: 10,\n      allowNullFlag: true,\n      withoutSlider: true,\n      require: \"!measure_x_flag\"\n    },\n    // 隐藏聚合方式 [ 图例的聚合方式 ]\n    {\n      key: \"hide_operator_label\",\n      title: \"option_hide_operator_label\",\n      description: \"option_hide_operator_label_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 禁止图形动画\n    {\n      key: \"animation_forbidden\",\n      title: \"option_animation_forbidden\",\n      description: \"option_animation_forbidden_desc\",\n      type: \"checkbox-prev\"\n    },\n    // 图例限制条目数，默认为50\n    {\n      key: \"legend_count_limit\",\n      title: \"option_legend_count_limit\",\n      description: \"option_legend_count_limit_desc\",\n      defaultNumber: 50,\n      max: 1000,\n      withoutSlider: true,\n      type: \"input\",\n      reTranslateResult: true\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 散点配置：散点符号，描边，符号大小，符号透明度\n  {\n    key: \"category_scatter_general\",\n    title: \"category_scatter_general\",\n    options: [\n    // 散点形状\n    {\n      key: \"legend_shape_type\",\n      title: \"option_scatter_shape_type\",\n      type: \"shape-select\",\n      selection: [\"option_legend_shape_type_circle\", \"option_legend_shape_type_three\", \"option_legend_shape_type_four\", \"option_legend_shape_type_rect\", \"option_legend_shape_type_five\", \"option_legend_shape_type_diamond\", \"option_legend_shape_type_add\", \"option_legend_shape_type_cross\", \"option_legend_shape_type_loop\"],\n      defaultValue: \"option_legend_shape_type_circle\"\n    },\n    // 散点大小\n    {\n      key: \"scatter_shape_size\",\n      title: \"option_scatter_shape_size\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      defaultNumber: 5\n    },\n    // 不透明度\n    {\n      key: \"scatter_shape_transparent\",\n      title: \"option_scatter_shape_transparent\",\n      type: \"input\",\n      min: 0,\n      step: 5,\n      max: 100,\n      defaultNumber: 50,\n      unit: '%'\n    },\n    // 是否散点描边\n    {\n      key: \"scatter_shape_stroke_flag\",\n      title: \"option_scatter_shape_stroke_flag\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // 散点描边宽度\n    {\n      key: \"scatter_shape_stroke_width\",\n      cssStyle: {\n        \"margin-top\": \"-40px\",\n        \"margin-left\": \"25%\"\n      },\n      type: \"input\",\n      min: 0,\n      defaultNumber: 2,\n      withoutSlider: true,\n      unit: 'px',\n      require: \"scatter_shape_stroke_flag\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 颜色：颜色主题，图例形状颜色，单Y轴情况下，将颜色分配给各个X轴刻度，各个刻度的颜色\n  {\n    key: \"category_color\",\n    title: \"category_color\",\n    require: \"has_legend_flag\",\n    options: [\n    // 自定义图例颜色[ @20221201 tong - 新的图例颜色样式配置结构  从attrColorArray组件调整为container组件 ]\n    // 仪表图只能通过点击选择图例颜色，无法通过配置设置\n    // 图例类型是单个属性列的情况下，配置各个图例的颜色，虚实....\n    {\n      key: \"chart_legend_list\",\n      // \"chart_custom_legend_new\",\n      type: \"legendList\",\n      legendConfigSet: ['color', 'show', 'shape'],\n      //  当前图例可以配置的值 color: 颜色 ； shape:形状 ；dash： 虚实 ； shadow: 阴影\n      legendShapeSelection: [\"option_legend_shape_type_circle\", \"option_legend_shape_type_three\", \"option_legend_shape_type_four\", \"option_legend_shape_type_rect\", \"option_legend_shape_type_five\", \"option_legend_shape_type_diamond\", \"option_legend_shape_type_add\", \"option_legend_shape_type_cross\"],\n      legendValueList: \"legendValueList\",\n      //  当前所有图例使用的配置值\n      defaultLegendList: \"defaultLegendList\",\n      //  当前所有图例的默认值\n      require: \"has_legend_flag\",\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // X轴： X刻度类型[单层/多层/时间]，最高高度，倾斜角度，X轴标题显示，标题自定义，隐藏X轴\n  {\n    key: \"category_x_axis\",\n    title: \"category_x_axis\",\n    options: [\n    // 优先画X轴最右侧的数据: X轴不是数值标尺时可以试用该规则\n    {\n      key: \"x_axis_right_first_flag\",\n      title: \"option_x_axis_right_first_flag\",\n      description: \"option_x_axis_right_first_flag_desc\",\n      type: \"checkbox-prev\",\n      require: \"!measure_x_flag\"\n    },\n    // 显示隐藏X轴标签\n    {\n      key: \"x_axis_label_visible\",\n      title: \"option_axis_label_visible\",\n      type: 'checkbox-prev',\n      defaultValue: true\n    },\n    // X轴标签字体样式 [ 显示轴标签才可以配置， 大小 ，颜色，字体，加粗，斜体，下划线 ]\n    {\n      key: \"x_axis_label_style\",\n      title: \"option_font_style\",\n      type: 'fontStyle',\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"x_axis_label_visible\"\n    },\n    // X轴数据格式\n    {\n      key: \"measure_x_configure\",\n      title: \"option_measure_configure\",\n      type: \"axisFormat\",\n      require: \"measure_x_flag\"\n    },\n    // X轴刻度类型[ 单层属性 / 多层属性 / 时间轴 ]\n    // X轴是属性的情况下，刻度类型只能在单层与多层之间切换 或者 单层与时间轴之间切换， 所以提供两种选项：自动 ; 单层 ；\n    {\n      key: \"x_axis_draw_type\",\n      title: \"option_x_axis_draw_type\",\n      description: \"option_x_axis_draw_type_desc\",\n      type: 'selectTile',\n      selection: [\"system_auto_default\", \"option_select_x_axis_dot_line\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\",\n      require: \"x_axis_label_visible;!measure_x_flag\"\n    },\n    // X轴单层属性下，旋转角度\n    {\n      // attribute_label_rotate\n      key: \"x_axis_label_dot_line_rotation_value\",\n      title: \"option_x_axis_label_dot_line_rotation_value\",\n      type: 'input',\n      withoutSlider: true,\n      defaultNumber: 30,\n      min: 0,\n      max: 180,\n      // X轴是属性的情况下， X轴是单层散点模式 且 显示轴标签时，才可以配置旋转角度\n      require: \"x_axis_label_visible;!measure_x_flag;x_axis_draw_type=option_select_x_axis_dot_line\"\n    },\n    // X轴单层属性下，刻度间距\n    {\n      // attribute_label_space_width\n      key: \"x_axis_label_dot_line_space_width\",\n      title: \"option_x_axis_label_dot_line_space_width\",\n      description: \"option_x_axis_label_dot_line_space_width_desc\",\n      type: 'input',\n      withoutSlider: true,\n      min: 1,\n      max: 999,\n      defaultNumber: 50,\n      // X轴是属性的情况下， X轴是单层散点模式 且 显示轴标签时，才可以配置旋转角度\n      require: \"x_axis_label_visible;!measure_x_flag;x_axis_draw_type=option_select_x_axis_dot_line\"\n    },\n    // X轴最大高度限制\n    {\n      // attribute_label_max_height\n      key: \"x_axis_label_max_height_percent\",\n      title: \"option_x_axis_label_max_height_percent\",\n      description: \"option_x_axis_label_max_height_percent_desc\",\n      type: 'input',\n      min: 0,\n      max: 100,\n      defaultNumber: 30,\n      step: 5,\n      require: \"x_axis_label_visible\"\n    },\n    // X轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type_x\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      defaultValue: \"option_default_value\",\n      require: \"measure_x_flag\"\n    },\n    // 默认类型下最大值\n    {\n      key: \"measure_scale_min_x\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_x_flag;measure_scale_type_x!=option_measure_scale_type_define'\n    },\n    // 默认类型下最小值\n    {\n      key: \"measure_scale_max_x\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_x_flag;measure_scale_type_x!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min_x\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_x_flag;measure_scale_type_x=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step_x\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_x_flag;measure_scale_type_x=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number_x\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_x_flag;measure_scale_type_x=option_measure_scale_type_define'\n    },\n    // X轴标题自动 / 强制显示 / 强制隐藏 [ 平铺选项 ]\n    {\n      key: \"x_axis_title_visible\",\n      title: \"option_axis_title_visible\",\n      description: \"option_axis_title_visible_desc\",\n      type: 'selectTile',\n      prevIcon: \"eye-icon\",\n      openEyeValue: \"option_title_visible_show\",\n      selection: [\"system_auto_default\", \"option_title_visible_show\", \"option_title_visible_hide\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\"\n    },\n    // 自定义的X轴标题内容\n    {\n      key: \"x_axis_title_content\",\n      title: \"option_axis_title_content\",\n      description: \"option_axis_title_content_desc\",\n      type: \"text\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题字体样式\n    {\n      key: \"x_axis_title_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题对齐方式\n    {\n      key: \"x_axis_title_alignment\",\n      title: \"option_font_alignment\",\n      type: \"fontAlign\",\n      defaultValue: \"center\",\n      require: \"x_axis_title_visible=option_title_visible_show\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // Y轴：Y轴刻度最宽宽度，Y轴标尺，Y轴标题\n  {\n    key: \"category_y_axis\",\n    title: \"category_y_axis\",\n    options: [\n    // 显示隐藏Y轴标签\n    {\n      key: \"y_axis_label_visible\",\n      title: \"option_axis_label_visible\",\n      type: 'checkbox-prev',\n      defaultValue: true\n    },\n    // Y轴标签字体样式 [ 显示轴标签才可以配置， 大小 ，颜色，字体，加粗，斜体，下划线 ]\n    {\n      key: \"y_axis_label_style\",\n      title: \"option_font_style\",\n      type: 'fontStyle',\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"y_axis_label_visible\"\n    },\n    // Y轴数据格式\n    {\n      key: \"measure_left_y_configure\",\n      title: \"option_measure_configure\",\n      description: \"option_measure_left_y_configure_desc\",\n      type: \"axisFormat\"\n    },\n    // Y轴最大宽度限制\n    {\n      key: \"y_axis_label_max_width_percent\",\n      title: \"option_y_axis_label_max_width_percent\",\n      type: 'input',\n      min: 0,\n      max: 100,\n      defaultNumber: 30,\n      step: 5,\n      require: \"y_axis_label_visible\"\n    },\n    // Y轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      defaultValue: \"option_default_value\"\n    },\n    // 默认类型下最大值\n    {\n      key: \"measure_scale_min\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_scale_type!=option_measure_scale_type_define'\n    },\n    // 默认类型下最小值\n    {\n      key: \"measure_scale_max\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_scale_type!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_scale_type=option_measure_scale_type_define'\n    },\n    // Y轴标题自动 / 强制显示 / 强制隐藏 [ 平铺选项 ]\n    {\n      key: \"y_axis_title_visible\",\n      title: \"option_axis_title_visible\",\n      description: \"option_axis_title_visible_desc\",\n      type: 'selectTile',\n      prevIcon: \"eye-icon\",\n      openEyeValue: \"option_title_visible_show\",\n      selection: [\"system_auto_default\", \"option_title_visible_show\", \"option_title_visible_hide\"],\n      explainDefaultFlag: true,\n      defaultValue: \"system_auto_default\"\n    },\n    // 自定义的Y轴标题内容\n    {\n      key: \"y_axis_title_content\",\n      title: \"option_axis_title_content\",\n      type: \"text\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题字体样式\n    {\n      key: \"y_axis_title_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 标题对齐方式\n    {\n      key: \"y_axis_title_alignment\",\n      title: \"option_font_alignment\",\n      type: \"fontAlign\",\n      defaultValue: \"center\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 右Y轴[ 有右Y轴的情况下，该信息由画图组件提供出去 ]\n  {\n    key: \"category_right_y_axis\",\n    title: \"category_right_y_axis\",\n    require: \"has_right_y_axis\",\n    options: [\n    // Y轴数据格式\n    {\n      key: \"measure_right_y_configure\",\n      title: \"option_measure_configure\",\n      description: \"option_measure_right_y_configure_desc\",\n      type: \"axisFormat\"\n    },\n    // Y轴刻度类型[ 自动，自定义刻度间隔 ]\n    {\n      key: \"measure_scale_type_right\",\n      title: \"option_measure_scale_type\",\n      description: \"option_measure_scale_type_desc\",\n      type: \"selectTile\",\n      selection: [\"option_default_value\", \"option_measure_scale_type_define\"],\n      defaultValue: \"option_default_value\"\n    },\n    // 默认类型下最大值\n    {\n      key: \"measure_scale_min_right\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_min_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right!=option_measure_scale_type_define'\n    },\n    // 默认类型下最小值\n    {\n      key: \"measure_scale_max_right\",\n      title: \"option_measure_scale_max\",\n      description: \"option_measure_scale_max_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right!=option_measure_scale_type_define'\n    },\n    // 自定义类型下最小值\n    {\n      key: \"measure_scale_defined_min_right\",\n      title: \"option_measure_scale_min\",\n      description: \"option_measure_scale_defined_min_desc\",\n      type: \"text\",\n      default: \"0\",\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义类型下间隔值\n    {\n      key: \"measure_scale_step_right\",\n      title: \"option_measure_scale_step\",\n      description: \"option_measure_scale_step_desc\",\n      type: \"text\",\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义类型下的步数\n    {\n      key: \"measure_scale_step_number_right\",\n      title: \"option_measure_scale_step_number\",\n      description: \"option_measure_scale_step_number_desc\",\n      type: \"input\",\n      min: 2,\n      defaultNumber: 5,\n      require: 'measure_scale_type_right=option_measure_scale_type_define'\n    },\n    // 自定义的Y轴标题内容\n    {\n      key: \"right_y_axis_title_content\",\n      title: \"option_axis_title_content\",\n      type: \"text\",\n      require: \"y_axis_title_visible=option_title_visible_show\"\n    },\n    // 左右Y轴0刻度对齐\n    {\n      key: \"measure_scale_parallel\",\n      title: \"option_measure_scale_parallel\",\n      description: \"option_measure_scale_parallel_desc\",\n      type: \"checkbox-prev\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  //图例： 是否隐藏，图例色块形状，图例位置，图例宽度，图例间隔 ， 图例限制条目数\n  {\n    key: \"category_legend_config\",\n    title: \"category_legend_config\",\n    require: \"has_legend_flag\",\n    options: [\n    // 隐藏图例\n    {\n      key: \"show_legend\",\n      title: \"option_map_info_show\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // 字体样式\n    {\n      key: \"legend_font_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label\",\n      require: \"show_legend\"\n    },\n    // 图例位置\n    {\n      key: \"legend_position\",\n      title: \"option_legend_position\",\n      description: \"option_legend_position_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_position_right\", \"option_position_top\", \"option_position_bottom\", \"option_position_right_top\"],\n      require: \"show_legend\"\n    },\n    // 图例宽度\n    {\n      key: \"legend_position_width\",\n      title: \"option_legend_position_width\",\n      description: \"option_legend_position_width_desc\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      max: 200,\n      defaultNumber: 80,\n      require: \"show_legend;legend_position=option_position_top,option_position_bottom\"\n    },\n    // 图例离画图区域的间隔\n    {\n      key: \"legend_position_offset\",\n      title: \"option_legend_position_offset\",\n      description: \"option_legend_position_offset_desc\",\n      type: \"input\",\n      withoutSlider: true,\n      min: 0,\n      max: 100,\n      defaultNumber: 5,\n      require: \"show_legend\"\n    },\n    // 图例之间的间隔\n    {\n      key: \"legend_position_interval\",\n      title: \"option_legend_position_interval\",\n      description: \"option_legend_position_interval_desc\",\n      type: \"input\",\n      allowNullFlag: true,\n      withoutSlider: true,\n      min: 0,\n      max: 100,\n      require: \"show_legend\"\n    },\n    // 图例限制条目数，默认为50\n    {\n      key: \"legend_count_limit\",\n      title: \"option_legend_count_limit\",\n      description: \"option_legend_count_limit_desc\",\n      defaultNumber: 50,\n      max: 1000,\n      withoutSlider: true,\n      type: \"input\",\n      reTranslateResult: true\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 网格线配置\n  {\n    key: \"category_grid_line\",\n    title: \"category_grid_line\",\n    options: [\n    // 网格线分别可以配置零线显示/样式（虚实粗细颜色） ； 非零线显示/样式（虚实粗细颜色）；\n    // 显示所有的网格线\n    {\n      key: \"grid_show_all_line\",\n      title: \"option_grid_show_all_line\",\n      type: \"checkbox-prev\",\n      defaultValue: true\n    },\n    // --- X轴是属性列情况下的网格线配置--------------\n    // 只显示零线\n    {\n      key: \"grid_show_only_zero_line\",\n      title: \"option_grid_show_only_zero_line\",\n      description: \"option_grid_show_only_zero_line_desc\",\n      type: \"checkbox-prev\",\n      require: \"!measure_x_flag;grid_show_all_line\"\n    },\n    // 网格线样式\n    {\n      key: \"grid_line_style\",\n      title: \"option_grid_line_style\",\n      description: \"option_grid_line_style_desc\",\n      type: \"lineStyle\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"!measure_x_flag;grid_show_all_line\"\n    },\n    // 零线样式\n    {\n      key: \"grid_zero_line_style\",\n      title: \"option_grid_zero_line_style\",\n      description: \"option_grid_zero_line_style_desc\",\n      type: \"lineStyle\",\n      defaultValueConfig: \"grid_line_style\",\n      require: \"!measure_x_flag;grid_show_all_line\"\n    },\n    // --- X轴是数值列的情况下，单独配置垂直方向的网格线 ---------------------\n    // 显示垂直网格线\n    {\n      key: \"grid_show_vertical_grid_line\",\n      title: \"option_grid_show_vertical_grid_line\",\n      type: \"checkbox-prev\",\n      require: \"measure_x_flag;grid_show_all_line\",\n      defaultValue: true\n    },\n    // 只显示零线\n    {\n      key: \"grid_show_vertical_only_zero_line\",\n      title: \"option_grid_show_vertical_only_zero_line\",\n      type: \"checkbox-prev\",\n      require: \"measure_x_flag;grid_show_all_line\"\n    },\n    // 网格线样式\n    {\n      key: \"grid_vertical_line_style\",\n      title: \"option_grid_line_style\",\n      type: \"lineStyle\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\"\n      },\n      require: \"measure_x_flag;grid_show_all_line\"\n    },\n    // 零线样式\n    {\n      key: \"grid_vertical_zero_line_style\",\n      title: \"option_grid_zero_line_style\",\n      type: \"lineStyle\",\n      defaultValueConfig: \"grid_line_style\",\n      require: \"measure_x_flag;grid_show_all_line\"\n    },\n    // --- X轴是数值列的情况下，单独配置水平方向的网格线  ----------------\n    // 显示水平网格线\n    {\n      key: \"grid_show_horizontal_grid_line\",\n      title: \"option_grid_show_horizontal_grid_line\",\n      type: \"checkbox-prev\",\n      require: \"measure_x_flag;grid_show_all_line\",\n      defaultValue: true\n    },\n    // 只显示零线\n    {\n      key: \"grid_show_horizontal_only_zero_line\",\n      title: \"option_grid_show_horizontal_only_zero_line\",\n      type: \"checkbox-prev\",\n      require: \"measure_x_flag;grid_show_all_line\"\n    },\n    // 网格线样式\n    {\n      key: \"grid_horizontal_line_style\",\n      title: \"option_grid_line_style\",\n      type: \"lineStyle\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"measure_x_flag;grid_show_all_line\"\n    },\n    // 零线样式\n    {\n      key: \"grid_horizontal_zero_line_style\",\n      title: \"option_grid_zero_line_style\",\n      type: \"lineStyle\",\n      defaultValueConfig: \"grid_line_style\",\n      defaultValue: {\n        lineColor: \"rgba(28, 28, 28 , 0.1)\",\n        lineWidth: 1\n      },\n      require: \"measure_x_flag;grid_show_all_line\"\n    },\n    // 隐藏最大值/最小值标准线，在有的情况下显示该配置\n    {\n      key: \"grid_remove_standard_line\",\n      title: \"option_grid_remove_standard_line\",\n      description: \"option_grid_remove_standard_line_desc\",\n      type: \"checkbox-prev\",\n      require: \"allow_marker_flag\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 数据标签格式\n  {\n    key: \"category_label\",\n    title: \"category_label\",\n    options: [\n    // 是否显示数据标签\n    {\n      key: \"label_text_visible\",\n      title: \"option_label_text_visible\",\n      description: \"option_label_text_visible_desc\",\n      type: 'checkbox-prev'\n    },\n    // 字体样式\n    {\n      key: \"label_text_font_style\",\n      title: \"option_font_style\",\n      type: \"fontStyle\",\n      defaultValue: {\n        fontColor: \"#333\",\n        fontSize: 10\n      },\n      // 没有配置该值的情况下，继承的配置值\n      defaultValueConfig: \"font_size_label-2\",\n      require: \"label_text_visible\"\n    },\n    // 数据标签的内容\n    {\n      key: \"label_text_regex\",\n      title: \"option_label_text_regex\",\n      description: \"option_suspend_text_regex_desc\",\n      type: \"chartRichText\",\n      require: 'label_text_visible',\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    // 柱状（居内/居外）\n    {\n      key: \"label_text_circle_position\",\n      title: \"option_label_text_position\",\n      description: \"option_label_text_position_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_position_in\", \"option_label_position_out\"],\n      require: 'label_text_visible'\n    },\n    // 旋转角度0/90/270\n    {\n      key: \"label_text_rotation_angle\",\n      title: \"option_label_text_rotation_angle\",\n      description: \"option_label_text_rotation_angle_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_rotation_0\", \"option_label_rotation_90\", \"option_label_rotation_270\"],\n      require: 'label_text_visible'\n    },\n    // 标签显示项 [ 全部/标准最大值最小值平均值 ]\n    {\n      key: \"label_text_visible_items\",\n      title: \"option_label_text_visible_items\",\n      description: \"option_label_text_visible_items_desc\",\n      type: \"select\",\n      selection: [\"option_default_value\", \"option_label_visible_all\", \"option_label_visible_standard\"],\n      require: 'label_text_visible'\n    },\n    // 标签是否允许重叠\n    {\n      key: \"label_text_allow_overlap\",\n      title: \"option_label_text_allow_overlap\",\n      description: \"option_label_text_allow_overlap_desc\",\n      type: \"checkbox\",\n      require: 'label_text_visible'\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 悬浮文本设置\n  {\n    key: \"category_suspend_text\",\n    title: \"category_suspend_text\",\n    options: [{\n      key: \"suspend_text_regex\",\n      title: \"option_suspend_text_regex\",\n      description: \"option_suspend_text_regex_desc\",\n      type: \"chartRichText\",\n      inheritFlag: false // 主要用于看板中替换模板问答时，标明该配置是不接受模板中配置的标志\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  },\n  // 标度配置\n  {\n    key: \"category_scale_config\",\n    title: \"category_scale_config\",\n    require: \"!has_right_y_axis\",\n    options: [\n    // 显示/隐藏Y标度\n    {\n      key: \"scale_y_visible\",\n      title: \"option_scale_y_visible\",\n      type: 'checkbox-prev'\n    },\n    // 其他图形的标度配置全部调整为数组(container)模式  @20221206 by tong\n    {\n      key: \"scale_y_range\",\n      description: \"option_scale_y_range_desc\",\n      type: \"container\",\n      withoutRange: true,\n      options: [\n      // 标度类型 - 直线或区间 [ 默认为直线 ]\n      {\n        type: \"selectTile\",\n        key: \"option_scale_config_type\",\n        title: \"option_scale_config_type\",\n        selection: [\"options_scale_config_type_line\", \"options_scale_config_type_range\"]\n      },\n      // 文本\n      {\n        type: \"text\",\n        title: \"option_scale_config_text\"\n      },\n      // 标度使用列信息\n      {\n        type: \"select\",\n        title: \"option_scale_config_column\",\n        selectType: \"yAxis\",\n        defaultValueKey: 'option_default_value' //  默认显示值的i18n key\n      },\n      // ==== 标度为直线的情况下 start==================================\n      // 标度值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_value_type\",\n        title: \"option_scale_config_value_type\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"],\n        require: \"option_scale_config_type=options_scale_config_type_line\"\n      },\n      // 标度值\n      {\n        type: \"text\",\n        key: \"option_scale_config_value_input\",\n        title: \"option_scale_config_value_input\",\n        require: \"option_scale_config_type=options_scale_config_type_line;option_scale_config_value_type=options_config_value_input\"\n      }, {\n        type: \"color\",\n        title: \"option_scale_config_value_color\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        defaultColor: \"#D62728\"\n      },\n      // 粗细\n      {\n        type: \"input\",\n        title: \"option_scale_config_value_thickness\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        withoutSlider: true,\n        min: 0,\n        defaultNumber: 1\n      },\n      // 虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_value_style\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        selection: [\"option_default_value\", \"option_line_style_solid_line\", \"option_line_style_dashed\"]\n      },\n      // ==== 标度为直线的情况下 end==================================\n\n      // ==== 标度为区间的情况下 start==================================\n      // 上区间值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_top_range_type\",\n        title: \"option_scale_config_top_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"]\n      },\n      // 上区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_top_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_top_range_type=option_default_value,options_config_value_input\"\n      }, {\n        type: \"select\",\n        key: \"option_scale_config_bottom_range_type\",\n        title: \"option_scale_config_bottom_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"]\n      },\n      // 下区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_bottom_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_bottom_range_type=option_default_value,options_config_value_input\"\n      },\n      // 区间颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        defaultColor: \"#D62728\"\n      },\n      // 区间透明度\n      {\n        type: \"input\",\n        title: \"option_scale_config_range_color_transparent\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        min: 0,\n        max: 100,\n        defaultNumber: 30\n      },\n      // 区间边框颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_edge_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\"\n      },\n      // 区间边框虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_range_edge_style\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"option_line_style_solid_line\", \"option_line_style_dashed\"]\n      }\n      // ==== 标度为区间的情况下 end==================================\n      ],\n      rangeInits: [{\n        min: 0,\n        max: 10\n      }],\n      require: \"scale_y_visible\"\n    },\n    // 显示/隐藏X标度\n    {\n      key: \"scale_x_visible\",\n      title: \"option_scale_x_visible\",\n      type: 'checkbox-prev',\n      require: \"measure_x_flag\"\n    },\n    // 有X轴图形的标度配置全部调整为数组(container)模式  @20221206 by tong\n    {\n      key: \"scale_x_range\",\n      description: \"option_scale_x_range_desc\",\n      type: \"container\",\n      withoutRange: true,\n      options: [\n      // 标度类型 - 直线或区间 [ 默认为直线 ]\n      {\n        type: \"selectTile\",\n        key: \"option_scale_config_type\",\n        title: \"option_scale_config_type\",\n        selection: [\"options_scale_config_type_line\", \"options_scale_config_type_range\"]\n      },\n      // 文本\n      {\n        type: \"text\",\n        title: \"option_scale_config_text\"\n      },\n      // 标度使用列信息\n      {\n        type: \"select\",\n        title: \"option_scale_config_column\",\n        selectType: \"xAxis\",\n        defaultValueKey: 'option_default_value' //  默认显示值的i18n key\n      },\n      // ==== 标度为直线的情况下 start==================================\n      // 标度值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_value_type\",\n        title: \"option_scale_config_value_type\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"],\n        require: \"option_scale_config_type=options_scale_config_type_line\"\n      },\n      // 标度值\n      {\n        type: \"text\",\n        key: \"option_scale_config_value_input\",\n        title: \"option_scale_config_value_input\",\n        require: \"option_scale_config_type=options_scale_config_type_line;option_scale_config_value_type=options_config_value_input\"\n      },\n      // 标度颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_value_color\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        defaultColor: \"#D62728\"\n      },\n      // 粗细\n      {\n        type: \"input\",\n        title: \"option_scale_config_value_thickness\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        withoutSlider: true,\n        min: 0,\n        defaultNumber: 1\n      },\n      // 虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_value_style\",\n        require: \"option_scale_config_type=options_scale_config_type_line\",\n        selection: [\"option_line_style_solid_line\", \"option_line_style_dashed\"],\n        defaultValue: \"option_line_style_solid_line\"\n      },\n      // ==== 标度为直线的情况下 end==================================\n\n      // ==== 标度为区间的情况下 start==================================\n      // 上区间值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_top_range_type\",\n        title: \"option_scale_config_top_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"]\n      },\n      // 上区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_top_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_top_range_type=option_default_value,options_config_value_input\"\n      },\n      // 下区间值类型\n      {\n        type: \"select\",\n        key: \"option_scale_config_bottom_range_type\",\n        title: \"option_scale_config_bottom_range_type\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_default_value\", \"options_config_value_input\", \"options_config_value_max\", \"options_config_value_min\", \"options_config_value_avg\", \"options_config_value_std\"]\n      },\n      // 下区间值\n      {\n        type: \"text\",\n        title: \"option_scale_config_bottom_range_input\",\n        require: \"option_scale_config_type=options_scale_config_type_range;option_scale_config_bottom_range_type=option_default_value,,options_config_value_input\"\n      },\n      // 区间颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        defaultColor: \"#D62728\"\n      },\n      // 区间透明度\n      {\n        type: \"input\",\n        title: \"option_scale_config_range_color_transparent\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        min: 0,\n        max: 100\n      },\n      // 区间边框颜色\n      {\n        type: \"color\",\n        title: \"option_scale_config_range_edge_color\",\n        require: \"option_scale_config_type=options_scale_config_type_range\"\n      },\n      // 区间边框虚实\n      {\n        type: \"select\",\n        title: \"option_scale_config_range_edge_style\",\n        require: \"option_scale_config_type=options_scale_config_type_range\",\n        selection: [\"option_line_style_solid_line\", \"option_line_style_dashed\"],\n        defaultValue: \"option_line_style_solid_line\"\n      }\n      // ==== 标度为区间的情况下 end==================================\n      ],\n      rangeInits: [{\n        min: 0,\n        max: 10\n      }],\n      require: \"measure_x_flag;scale_x_visible\"\n    },\n    //恢复默认配置\n    {\n      key: \"chart_config_restart\",\n      type: \"restart\"\n    }]\n  }],\n  /**\r\n   * 图形配置的辅助对象：当前图形定义的宏列表 及 宏 解析方法 ； 适配之前图形配置值的方法 ；\r\n   *\r\n   * 当前图形提供的宏列表[ 宏名的命名规则： 开头是%_ 用_连接的大写字符字符串 ]\r\n   * 供自定义数据标签 及 悬浮文本使用，可以让用户配置显示内容\r\n   * 键值对  MacroName : MacroDisplayNameKey\r\n   * {\r\n   *     [Array]chartMacroList: [{key , nameKey , descriptionKey}] ,  供用户配置的自定义宏列表\r\n   *     [Func]translateMacro                                         解析用使用宏配置的字符串\r\n   *     [Func]compatibleHistoryConfigure                             适配之前的配置为最新的配置\r\n   *\r\n   * }\r\n   * */\n  chartConfigureAdvanced: {\n    // 根据宏配置列表，已足够外部组件将 %_NAME:%_VALUE 翻译成 [属性]：[值] 显示给用户\n    // 如果当前图形支持换行的宏，则输入时允许输入换行符 ； 否则编辑时也不支持换行符 ；\n    chartMacroList: [{\n      key: \"%_X_VALUE_NAME\",\n      nameKey: '%_X_VALUE_NAME',\n      descriptionKey: '%_X_VALUE_NAME_desc'\n    }, {\n      key: \"%_X_VALUE\",\n      nameKey: '%_X_VALUE',\n      descriptionKey: '%_X_VALUE_desc'\n    }, {\n      key: \"%_Y_VALUE_NAME\",\n      nameKey: '%_Y_VALUE_NAME',\n      descriptionKey: '%_Y_VALUE_NAME_desc'\n    }, {\n      key: \"%_Y_VALUE\",\n      nameKey: '%_Y_VALUE',\n      descriptionKey: '%_Y_VALUE_desc'\n    }, {\n      key: \"%_VALUE\",\n      nameKey: '%_Y_VALUE',\n      disabled: true\n    }, {\n      key: \"%_SERIES_NAME\",\n      nameKey: '%_SERIES_NAME',\n      descriptionKey: '%_VALUE_NAME_desc'\n    }, {\n      key: \"%_CATEGORY_NAME\",\n      nameKey: '%_CATEGORY_NAME',\n      disabled: true\n    }, {\n      key: \"%_SERIES_NUMBER\",\n      nameKey: '%_SERIES_NUMBER',\n      descriptionKey: '%_SERIES_NUMBER_desc'\n    }, {\n      key: '%_CATEGORY_TOTAL',\n      nameKey: '%_CATEGORY_TOTAL',\n      descriptionKey: '%_CATEGORY_TOTAL_desc'\n    }, {\n      key: '%_CATEGORY_AVERAGE',\n      nameKey: '%_CATEGORY_AVERAGE',\n      descriptionKey: '%_CATEGORY_AVERAGE_desc'\n    }, {\n      key: '%_PERCENT_OF_CATEGORY',\n      nameKey: '%_PERCENT_OF_CATEGORY',\n      descriptionKey: '%_PERCENT_OF_CATEGORY_desc'\n    }, {\n      key: '%_PERCENT_OF_TOTAL',\n      nameKey: '%_PERCENT_OF_TOTAL',\n      descriptionKey: '%_PERCENT_OF_TOTAL_desc'\n    }, {\n      key: '%_BR',\n      nameKey: '%_BR',\n      descriptionKey: '%_BR_desc'\n    }],\n    // 依据当前配置，将 %_NAME:%_VALUE 转译成真实值显示\n    /**\r\n     * @param configMacroStr    -   用户配置的带宏的内容\r\n     * @param options\r\n     *          {\r\n     *              type        -\r\n     *\r\n     *              xLabel       -   图形单元对应的属性值 用于实现%_NAME %_CATEGORY_NAME\r\n     *              xLabelIndex  -   图形单元对应的属性索引，用于实现 %_CATEGORY_NUMBER\r\n     *              xLabelTotal  -   图形单元对应的属性上所有值的总和用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              xLabelNumber -   图形单元对应的属性上所有值的个数用于实现 %_CATEGORY_TOTAL  %_CATEGORY_AVERAGE  %_PERCENT_OF_CATEGORY\r\n     *              yValue       -   图形单元对应的值 用于实现 %_VALUE\r\n     *              yAxis        -   图形单元对应的值列 用于实现 %_VALUE_NAME  %_SERIES_NAME\r\n     *              legend       -   图形单元对应的图例名(为空时说明是多Y轴) 用于实现 %_SERIES_NAME\r\n     *              legendIndex  -   图形单元对应的图例索引 用于实现 %_SERIES_NUMBER\r\n     *              legendTotal  -   图形单元对应的图例上所有值的总和,用于实现 %_PERCENT_OF_TOTAL\r\n     *              rowData -  图形单元对应的一整行数据 用于实现%_COLUMN_N的宏\r\n     *          }\r\n     * */\n    translateMacro: function (configMacroStr, options) {\n      options = options || {};\n      if (!configMacroStr) return false;\n      let macroRegex = /%(_[A-Z0-9]*){1,}/g;\n      let theMatchedTextValue = '',\n        matchedIndex = 0;\n      macroRegex.lastIndex = -1;\n      for (let i = 0, execResult; (execResult = macroRegex.exec(configMacroStr)) && i < 100; i++) {\n        if (!execResult || !execResult[0][0]) break;\n        let theMatchStr = execResult[0],\n          theMatchIndex = execResult.index;\n        theMatchedTextValue += configMacroStr.substring(matchedIndex, Math.max(theMatchIndex, matchedIndex));\n        switch (theMatchStr) {\n          case \"%_X_VALUE_NAME\":\n            if (options.xAxis) {\n              theMatchedTextValue += options.xAxis.displayName || options.xAxis.col_name || '';\n            }\n            break;\n          case \"%_X_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.xValue, options.xAxis) || '';\n            break;\n          case \"%_Y_VALUE_NAME\":\n            if (options.yAxis) {\n              theMatchedTextValue += options.yAxis.displayName || options.yAxis.col_name || '';\n            }\n            break;\n          case \"%_Y_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.yValue, options.yAxis) || '';\n            break;\n          case \"%_NAME\":\n            theMatchedTextValue += options.xLabel || _DataFocusMethod.formatData(options.xValue, options.xAxis) || '';\n            break;\n          case \"%_CATEGORY_NAME\":\n            theMatchedTextValue += options.xLabel || _DataFocusMethod.formatData(options.xValue, options.xAxis) || '';\n            break;\n          case \"%_SERIES_NAME\":\n            theMatchedTextValue += options.legend || '';\n            break;\n          case \"%_SERIES_NUMBER\":\n            theMatchedTextValue += options.legendIndex || '';\n            break;\n          case \"%_VALUE_NAME\":\n            if (options.yAxis) {\n              theMatchedTextValue += options.yAxis.displayName || options.yAxis.col_name || '';\n            }\n            break;\n          case \"%_VALUE\":\n            theMatchedTextValue += _DataFocusMethod.formatData(options.yValue, options.yAxis) || '';\n            break;\n          case \"%_CATEGORY_TOTAL\":\n            theMatchedTextValue += options.xLabelTotal || '';\n            break;\n          case \"%_CATEGORY_AVERAGE\":\n            let theAverage = options.xLabelTotal / (options.xLabelNumber || 1);\n            if (!isNaN(theAverage) && options.xLabelNumber) {\n              theMatchedTextValue += _DataFocusMethod.formatData(_DataFocusMethod.getValidNum(theAverage, 2), options.yAxis);\n            }\n            break;\n          case \"%_PERCENT_OF_CATEGORY\":\n            let theCPercent = options.yValue / (options.xLabelTotal || 1);\n            if (!isNaN(theCPercent) && options.xLabelTotal) {\n              theMatchedTextValue += _DataFocusMethod.getValidNum(theCPercent * 100, 2) + '%';\n            }\n            break;\n          case \"%_PERCENT_OF_TOTAL\":\n            let theTPercent = options.yValue / (options.legendTotal || 1);\n            if (!isNaN(theTPercent)) {\n              theMatchedTextValue += _DataFocusMethod.getValidNum(theTPercent * 100, 2) + '%';\n            }\n            break;\n          case \"%_BR\":\n            theMatchedTextValue += options.type === 'label' ? '\\n' : '<br/>';\n            break;\n          default:\n            if (theMatchStr.startsWith(\"%_COLUMN_\")) {\n              let theColumnN = parseInt(theMatchStr.substring(9));\n              const matchedHeader = options.headers[theColumnN - 1];\n              if (!isNaN(theColumnN) && options.rowData && theColumnN > 0 && theColumnN <= options.rowData.length) {\n                theMatchedTextValue += _DataFocusMethod.formatData(options.rowData[theColumnN - 1], matchedHeader) || '';\n              }\n            }\n            break;\n        }\n        matchedIndex = theMatchIndex + theMatchStr.length;\n      }\n      if (matchedIndex < configMacroStr.length) {\n        theMatchedTextValue += configMacroStr.substring(matchedIndex);\n      }\n      return theMatchedTextValue;\n    },\n    // 如果当前图形配置在上线后需要更新配置，需要兼容行为，则在此处处理[ 不同图形兼容方法不一样 ]\n    compatibleHistoryConfigure: function (chartConfigure, options) {\n      if (!chartConfigure) return false;\n      options = options || {};\n\n      // 图形字体大小修改了值结构\n      if (_DataFocusMethod.isPureNumber(chartConfigure.font_size_label)) {\n        let theFontSize = parseInt(chartConfigure.font_size_label);\n        chartConfigure.font_size_label = {\n          fontSize: theFontSize\n        };\n      }\n      // 旋转角度 变了名字\n      if (chartConfigure.attribute_label_rotate !== undefined) {\n        chartConfigure.x_axis_label_dot_line_rotation_value = chartConfigure.attribute_label_rotate;\n        chartConfigure.attribute_label_rotate = undefined;\n      }\n      // 刻度间隔 变了名字\n      if (chartConfigure.attribute_label_space_width !== undefined) {\n        chartConfigure.x_axis_label_dot_line_space_width = chartConfigure.attribute_label_space_width;\n        chartConfigure.attribute_label_space_width = undefined;\n      }\n      // 最大高度限制 变了名字\n      if (chartConfigure.attribute_label_max_height !== undefined) {\n        chartConfigure.x_axis_label_max_height_percent = chartConfigure.attribute_label_max_height * 100;\n        chartConfigure.attribute_label_max_height = undefined;\n      }\n\n      // 图形标题隐藏配置调整为两个配置值 [ 新的柱状图 ]\n      if (chartConfigure.hidden_chart_title) {\n        chartConfigure.x_axis_title_visible = \"option_title_visible_hide\";\n        chartConfigure.y_axis_title_visible = \"option_title_visible_hide\";\n        chartConfigure.hidden_chart_title = undefined;\n      }\n      // 隐藏X轴标签修改了名字\n      if (chartConfigure.hide_x_axis) {\n        chartConfigure.x_axis_label_visible = false;\n        chartConfigure.hide_x_axis = undefined;\n      }\n      // 隐藏Y轴就是隐藏Y轴标签及Y轴网格线 , 修改了名字\n      if (chartConfigure.hide_y_axis) {\n        chartConfigure.y_axis_label_visible = false;\n        chartConfigure.grid_show_all_line = false;\n        chartConfigure.hide_y_axis = undefined;\n      }\n      // 显示图例改了名字\n      if (chartConfigure.hide_legend && chartConfigure.show_legend === undefined) {\n        chartConfigure.show_legend = false;\n        chartConfigure.hide_legend = undefined;\n      }\n\n      // 属性图例颜色 与 Y轴颜色只会存在其中一个\n      // 图例配置列表配置了属性图例的颜色\n      if (!chartConfigure.chart_legend_list) {\n        // 图例配置列表配置了属性图例的颜色\n        if (chartConfigure.chart_custom_legend_new && chartConfigure.chart_custom_legend_new.length || options.legendColors && options.legendColors.length) {\n          let theLegendList = [],\n            theLegendIdObj = {};\n          chartConfigure.chart_custom_legend_new && chartConfigure.chart_custom_legend_new.forEach(function (legend) {\n            if (legend.legend !== undefined && legend.color) {\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"legendAxis\", legend.legend);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: legend.legend,\n                  color: legend.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_custom_legend_new = undefined;\n\n          // 继承之前保存的legendColors配置\n          options.legendColors && options.legendColors.forEach(function (legend) {\n            if (legend.legend !== undefined && legend.color) {\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"legendAxis\", legend.legend);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: legend.legend,\n                  color: legend.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_legend_list = theLegendList;\n        }\n        // 图例配置列表配置了Y轴的颜色\n        if (chartConfigure.chart_custom_legend_new_measure && chartConfigure.chart_custom_legend_new_measure.length || options.yAxisColors && options.yAxisColors.length) {\n          let theLegendList = [],\n            theLegendIdObj = {};\n          chartConfigure.chart_custom_legend_new_measure && chartConfigure.chart_custom_legend_new_measure.forEach(function (configLeg) {\n            let theLegendNameObj = configLeg.options && configLeg.options.find(function (obj) {\n                return obj.title === 'option_chart_legend_measure_name';\n              }),\n              theLegendName = theLegendNameObj && theLegendNameObj.value || '',\n              theLegendColorObj = configLeg.options && configLeg.options.find(function (obj) {\n                return obj.title === 'option_chart_legend_color';\n              }),\n              theLegendColor = theLegendColorObj && theLegendColorObj.value || '';\n            theLegendName = theLegendName.replace(\"-y-axis-\", \"\");\n            let theYAxisArray = theLegendName.split('-'),\n              theColIdx = theYAxisArray[0],\n              theColName = theYAxisArray[1],\n              theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId('YAxis', theColIdx);\n            if (theLegendName && theLegendColor) {\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: theColName,\n                  color: theLegendColor\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_custom_legend_new_measure = undefined;\n\n          // 继承之前保存的yAxisColors配置\n          console.log('---------------yAxisColors------------');\n          options.yAxisColors && options.yAxisColors.forEach(function (yAxis) {\n            if (yAxis.col_id !== undefined && yAxis.color) {\n              if (options.tableData && options.tableData.headers) {\n                let theMatchedHeader = options.tableData.headers.find(function (head) {\n                  return yAxis.col_id === head.col_id || head.idx + '' === yAxis.col_id + '';\n                });\n                if (theMatchedHeader) yAxis.col_id = theMatchedHeader.idx;\n              }\n              let theLegendId = _pc_assets_js_charts_components_LegendComponent__WEBPACK_IMPORTED_MODULE_4__[\"default\"].generateLegendId(\"YAxis\", yAxis.col_id);\n              if (!theLegendIdObj[theLegendId]) {\n                theLegendList.push({\n                  id: theLegendId,\n                  legend: yAxis.name,\n                  color: yAxis.color\n                });\n                theLegendIdObj[theLegendId] = true;\n              }\n            }\n          });\n          chartConfigure.chart_legend_list = theLegendList;\n        }\n      }\n\n      // 隐藏网格线调整了显示网格线的名字\n      if (chartConfigure.grid_hide_all_line) {\n        chartConfigure.grid_show_all_line = false;\n        chartConfigure.grid_hide_all_line = undefined;\n      }\n      // 零线颜色及零线粗细调整了配置名\n      if (chartConfigure.grid_zero_color || chartConfigure.grid_zero_width) {\n        chartConfigure.grid_zero_line_style = {\n          lineColor: chartConfigure.grid_zero_color,\n          lineWidth: chartConfigure.grid_zero_width\n        };\n        chartConfigure.grid_vertical_zero_line_style = {\n          lineColor: chartConfigure.grid_zero_color,\n          lineWidth: chartConfigure.grid_zero_width\n        };\n        chartConfigure.grid_horizontal_zero_line_style = {\n          lineColor: chartConfigure.grid_zero_color,\n          lineWidth: chartConfigure.grid_zero_width\n        };\n        chartConfigure.grid_zero_color = undefined;\n        chartConfigure.grid_zero_width = undefined;\n      }\n\n      // Y标度增加了显示与隐藏的配置\n      if (chartConfigure.scale_y_visible === undefined && chartConfigure.scale_y_range && chartConfigure.scale_y_range.length) {\n        chartConfigure.scale_y_visible = true;\n        chartConfigure.scale_y_range && chartConfigure.scale_y_range.forEach(function (theScaleYItem) {\n          // 以前标度类型默认值是default, 现在默认的类型是直线，所以得将之前的配置转换为具体值\n          let theTypeOption = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_type\";\n          });\n          if (!theTypeOption) {\n            theScaleYItem.options = theScaleYItem.options || [];\n            theScaleYItem.options.push({\n              title: \"option_scale_config_type\",\n              value: \"option_default_value\"\n            });\n          } else if (theTypeOption && !theTypeOption.value) theTypeOption.value = 'option_default_value';\n\n          // 以前直线的粗细是类型，目前调整为数值\n          let theThickness = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_value_thickness\";\n          });\n          if (theThickness && theThickness.value) {\n            switch (theThickness.value) {\n              case \"option_thickness_line_medium\":\n                theThickness.value = 2;\n                break;\n              case \"option_thickness_line_heavy\":\n                theThickness.value = 3;\n                break;\n            }\n          }\n        });\n      }\n      // X标度增加了显示与隐藏的配置\n      if (chartConfigure.scale_x_visible === undefined && chartConfigure.scale_x_range && chartConfigure.scale_x_range.length) {\n        chartConfigure.scale_x_visible = true;\n        chartConfigure.scale_x_range && chartConfigure.scale_x_range.forEach(function (theScaleYItem) {\n          // 以前标度类型默认值是default, 现在默认的类型是直线，所以得将之前的配置转换为具体值\n          let theTypeOption = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_type\";\n          });\n          if (!theTypeOption) {\n            theScaleYItem.options = theScaleYItem.options || [];\n            theScaleYItem.options.push({\n              title: \"option_scale_config_type\",\n              value: \"option_default_value\"\n            });\n          } else if (theTypeOption && !theTypeOption.value) theTypeOption.value = 'option_default_value';\n\n          // 以前直线的粗细是类型，目前调整为数值\n          let theThickness = theScaleYItem.options && theScaleYItem.options.find(function (option) {\n            return option.title === \"option_scale_config_value_thickness\";\n          });\n          if (theThickness && theThickness.value) {\n            switch (theThickness.value) {\n              case \"option_thickness_line_medium\":\n                theThickness.value = 2;\n                break;\n              case \"option_thickness_line_heavy\":\n                theThickness.value = 3;\n                break;\n            }\n          }\n        });\n      }\n    }\n  },\n  // [*必填项]图轴及图表自定义的中英文\n  /**\r\n   * {\r\n   *     chinese: {\"category_x_axis\": \"X轴\" ... } ,\r\n   *     english: {\"category_x_axis\": \"X Axis\" ...}\r\n   * }\r\n   * */\n  i18nObj: {\n    chinese: {\n      \"system_auto_default\": \"自动\",\n      \"user_define_text\": \"自定义\",\n      \"category_x_axis\": \"X轴\",\n      \"option_x_axis_right_first_flag\": \"优先画X轴最右侧数据\",\n      \"option_x_axis_right_first_flag_desc\": \"默认情况下，从X轴最左侧数据开始画，超出一屏时往右分页显示。<br />开启优先画X轴最右侧数据后，从X轴最右侧数据开始画，超出一屏时往左分页显示\",\n      \"option_x_axis_draw_type\": \"X轴类型\",\n      \"option_select_x_axis_dot_line\": \"单层散点\",\n      \"option_select_x_axis_time_line\": \"时间轴\",\n      \"option_select_x_axis_level_line\": \"多层属性\",\n      \"option_x_axis_draw_type_desc\": \"X轴是属性轴的情况下，总共有三种类型：\" + \"<br /> 多层属性<span class='color-main-green'>[自动识别]</span>：X轴有2个或3个属性列时，自动会识别使用多层属性展示X轴刻度\" + \"<br /> 时间轴<span class='color-main-green'>[自动识别]</span>：X轴只有1个时间列 且 经过每天/每小时/每分钟聚合时，自动会识别使用时间轴展示X轴刻度\" + \"<br /> 单层散点<span class='color-main-green'>[自动识别]</span>：所有数据均可以强制使用单层三点的模式展示X轴刻度\" + \"<br /> 系统会自动适配合适的X轴，但是您可以强制切换称单层单点模式\",\n      \"option_axis_label_visible\": \"轴标签\",\n      \"option_axis_title_visible\": \"轴标题\",\n      \"option_axis_title_visible_desc\": \"自动情况下，会在详情页面显示标题，看板中隐藏标题\",\n      \"option_title_visible_show\": \"显示\",\n      \"option_title_visible_hide\": \"隐藏\",\n      \"option_axis_title_content\": \"标题内容\",\n      \"option_axis_title_content_desc\": \"默认会使用X轴的列名\",\n      \"option_x_axis_label_dot_line_rotation_value\": \"旋转角度\",\n      \"option_x_axis_label_dot_line_space_width\": \"刻度间距\",\n      \"option_x_axis_label_dot_line_space_width_desc\": \"X轴刻度是单层散点模式下，刻度之间的最小间距，默认是50（即每50px显示一个刻度）\",\n      \"option_x_axis_label_max_height_percent\": \"最大高度(%)\",\n      \"option_x_axis_label_max_height_percent_desc\": \"X轴是单层散点模式下，超出最大高度百分比时，截取字符串显示；其他模式下，超出最大高度时，将不显示X轴刻度\",\n      \"option_font_style\": \"字体\",\n      \"option_font_alignment\": \"对齐方式\",\n      \"category_y_axis\": \"Y轴\",\n      \"option_y_axis_label_max_width_percent\": \"最大宽度(%)\",\n      \"option_measure_configure\": \"格式配置\",\n      \"category_right_y_axis\": \"右Y轴\",\n      \"category_color\": \"颜色/形状\",\n      \"option_chart_column_minimum_width\": \"自适应最小刻度宽\",\n      \"option_chart_column_minimum_width_desc\": \"默认情况下，依据画图区域及画图数据自适应的刻度宽值，默认最小值是5px\",\n      \"option_suspend_text_regex_desc\": \"要显示的文本。有以下替换宏可用：<br /> \" + \"<span class='mr3'>[Y刻度]</span> - 对应的Y轴的数值 <br />\" + \"<span class='mr3'>[Y轴名称]</span> - 显示的数值标签为对应的Y轴的属性名<br /> \" + \"<span class='mr3'>[X刻度]</span> - 显示的数值标签为对应的X轴的值<br /> \" + \"<span class='mr3'>[X轴名称]</span> - 显示的数值标签为对应的X轴的属性名<br /> \" + \"<span class='mr3'>[刻度索引]</span> - 数值标签为对应的X轴值的顺序 <br /> \" + \"<span class='mr3'>[图例]</span> - 对应的图例的类别值<br /> \" + \"<span class='mr3'>[图例索引]</span> - 对应的图例的类别顺序索引<br /> \" + \"<span class='mr3'>[类别百分比]</span> - X轴的刻度上Y值占所有Y值总和的百分比 <br />\" + \"<span class='mr3'>[X刻度总和]</span> - X轴是属性轴时，可显示X轴为某个值时所有Y轴的数值之和 <br /> \" + \"<span class='mr3'>[X刻度平均值]</span> - X轴是属性轴时，可显示X轴为某个值时所有Y轴的平均值<br /> \" + \"<span class='mr3'>[X刻度百分比]</span> - X轴是属性轴时，X轴的刻度上Y值占该X刻度上所有Y值总和的百分比 <br /> \" + \"<span class='mr3'>[(列N)]</span> - 第N列的数值 <br /> \" + \"<span class='mr3'>[换行]</span> - 换行符\",\n      \"%_X_VALUE_NAME\": \"X轴名称\",\n      \"%_X_VALUE\": \"X刻度\",\n      \"%_Y_VALUE_NAME\": \"Y轴名称\",\n      \"%_Y_VALUE\": \"Y刻度\",\n      \"%_LEGEND_VALUE\": \"图例\",\n      \"%_NAME\": \"属性\",\n      \"%_NAME_desc\": \"对应的X轴的刻度值\",\n      \"%_VALUE\": \"值\",\n      \"%_VALUE_desc\": \"对应的Y轴的数值\",\n      \"%_VALUE_NAME\": \"值名称\",\n      \"%_VALUE_NAME_desc\": \"对应的Y轴的名称\",\n      \"%_SERIES_NAME\": \"类别\",\n      \"%_SERIES_NAME_desc\": \"对应的图例的类别值\",\n      \"%_SERIES_NUMBER\": \"类别索引\",\n      \"%_SERIES_NUMBER_desc\": \"对应的图例的类别顺序索引\",\n      \"%_CATEGORY_NAME\": \"X刻度\",\n      \"%_CATEGORY_NAME_desc\": \"对应的X轴的刻度值\",\n      \"%_CATEGORY_NUMBER\": \"刻度索引\",\n      \"%_CATEGORY_NUMBER_desc\": \"对应的X轴的刻度顺序索引\",\n      \"%_CATEGORY_TOTAL\": \"刻度总和\",\n      \"%_CATEGORY_TOTAL_desc\": \"各个X轴刻度上所有Y轴值的总和\",\n      \"%_CATEGORY_AVERAGE\": \"刻度平均值\",\n      \"%_CATEGORY_AVERAGE_desc\": \"各个X轴刻度上所有Y轴值的平均值\",\n      \"%_PERCENT_OF_TOTAL\": \"类别百分比\",\n      \"%_PERCENT_OF_TOTAL_desc\": \"X轴的刻度上Y值占所有Y值总和的百分比\",\n      \"%_PERCENT_OF_CATEGORY\": \"刻度百分比\",\n      \"%_PERCENT_OF_CATEGORY_desc\": \"X轴的刻度上Y值占该X刻度上所有Y值总和的百分比\",\n      \"%_BR\": \"换行\",\n      \"option_grid_show_all_line\": \"显示全部网格线\",\n      \"option_grid_line_style\": \"网格线样式\",\n      \"option_grid_line_style_desc\": \"配置所有网格线的样式，包括虚实，颜色及粗细\",\n      \"option_grid_show_only_zero_line\": \"只显示零线\",\n      \"option_grid_show_only_zero_line_desc\": \"配置后，网格线中非零线将全部隐藏，只显示零线 <br /> 如果Y轴最小值大于0，则没有零线，所有网格线均都不显示 \",\n      \"option_grid_zero_line_style\": \"零线样式\",\n      \"option_grid_zero_line_style_desc\": \"配置零线的样式，包括虚实，颜色及粗细\",\n      \"option_grid_show_vertical_grid_line\": \"垂直线\",\n      \"option_grid_show_horizontal_grid_line\": \"水平线\",\n      \"option_grid_show_vertical_only_zero_line\": \"只显示垂直零线\",\n      \"option_grid_show_horizontal_only_zero_line\": \"只显示水平零线\",\n      \"category_scatter_general\": \"散点配置\",\n      \"option_legend_shape_type\": \"散点形状\",\n      \"option_scatter_shape_type\": \"散点形状\",\n      \"option_scatter_shape_size\": \"散点大小\",\n      \"option_scatter_shape_transparent\": \"不透明度\",\n      \"option_scatter_shape_stroke_flag\": \"描边\",\n      \"option_legend_shape_type_add\": \"加号\",\n      \"option_legend_shape_type_cross\": \"叉号\",\n      \"option_scale_y_visible\": \"显示/隐藏 自定义Y轴标度\",\n      \"option_scale_x_visible\": \"显示/隐藏 自定义X轴标度\"\n    },\n    english: {\n      \"system_auto_default\": \"Auto\",\n      \"user_define_text\": \"Define\",\n      \"category_x_axis\": \"X Axis\",\n      \"option_x_axis_right_first_flag\": \"Prioritize drawing the rightmost data on the X-axis\",\n      \"option_x_axis_right_first_flag_desc\": \"By default, the data is drawn from the leftmost side of the X-axis, and when it exceeds one screen, it is paginated to the right.<br/> After enabling priority drawing of the rightmost data on the X-axis, start drawing from the rightmost data on the X-axis and display it in a left page when it exceeds one screen\",\n      \"option_x_axis_draw_type\": \"X axis type\",\n      \"option_select_x_axis_dot_line\": \"Single dot\",\n      \"option_select_x_axis_time_line\": \"Time\",\n      \"option_select_x_axis_level_line\": \"Multi Level\",\n      \"option_x_axis_draw_type_desc\": \"When the X-axis is an attribute axis, there are three types in total:\" + \"<br /> Multi level<span class='color-main-green'>[Auto]</span>: 2 or 3 attribute columns on the X-axis, it will automatically recognize the multi level \" + \"<br /> Time line<span class='color-main-green'>[Auto]</span>: only one time column on the X-axis and it is aggregated daily / hourly / minutely , it will automatically recognize the time line\" + \"<br /> Single dot<span class='color-main-green'>[Auto]</span>: All data can be forced to display the single level\" + \"<br /> The system will automatically adapt to the appropriate X-axis, but you can forcibly switch to the single level\",\n      \"option_axis_label_visible\": \"Axis Label\",\n      \"option_axis_title_visible\": \"Axis Title\",\n      \"option_axis_title_visible_desc\": \"In automatic mode, the title will be displayed on the answer detail page and hidden in the pinboard\",\n      \"option_title_visible_show\": \"Show\",\n      \"option_title_visible_hide\": \"Hidden\",\n      \"option_axis_title_content\": \"Title Content\",\n      \"option_axis_title_content_desc\": \"By default, column names on the axis will be used\",\n      \"option_x_axis_label_dot_line_rotation_value\": \"Rotate\",\n      \"option_x_axis_label_dot_line_space_width\": \"Label Spacing\",\n      \"option_x_axis_label_dot_line_space_width_desc\": \"The scale is the minimum spacing between labels in single level axis, with a default of 50 (i.e. one scale displayed every 50px)\",\n      \"option_x_axis_label_max_height_percent\": \"Max height(%)\",\n      \"option_x_axis_label_max_height_percent_desc\": \"The axis is in single level, and when the maximum height percentage is exceeded, the string is truncated and displayed; In other modes, when the maximum height is exceeded, the scale will not be displayed\",\n      \"option_font_style\": \"Font\",\n      \"option_font_alignment\": \"Alignment\",\n      \"category_y_axis\": \"Y Axis\",\n      \"option_y_axis_label_max_width_percent\": \"Max Width(%)\",\n      \"option_measure_configure\": \"Data Format\",\n      \"category_right_y_axis\": \"Right Y Axis\",\n      \"category_color\": \"Color\",\n      \"option_chart_column_minimum_width\": \"Adaptive minimum column width\",\n      \"option_chart_column_minimum_width_desc\": \"By default, the column width value is adaptively adjusted based on the drawing area and data. The default minimum value is 5px. After setting the fixed width of the scale, this value is invalid\",\n      \"option_chart_column_width\": \"Fixed column width\",\n      \"option_chart_column_width_desc\": \"By default, the width is adaptive based on the width of the drawing area. After setting a fixed scale width, the scale width is fixed, with a minimum value of 5px\",\n      \"option_suspend_text_regex_desc\": \"The text to be displayed. The following replacement macros are available:<br /> \" + \"<span class='mr3'>[Value]</span> - The corresponding value of the Y-axis <br />\" + \"<span class='mr3'>[Attribute]</span> - The displayed numerical labels are the corresponding X-axis values<br /> \" + \"<span class='mr3'>[Label]</span> - The displayed numerical labels are the corresponding X-axis values<br /> \" + \"<span class='mr3'>[Label Index]</span> - The order in which the numerical labels correspond to the X-axis values <br /> \" + \"<span class='mr3'>[Series]</span> - The series value of the corresponding legend<br /> \" + \"<span class='mr3'>[Series Index]</span> - The series order of the corresponding legend<br /> \" + \"<span class='mr3'>[Label Total]</span> - Can display the sum of all Y-axis values when the X-axis is a certain value <br /> \" + \"<span class='mr3'>[Label AVG]</span> - Can display the average value of all Y-axes when the X-axis is a certain value<br /> \" + \"<span class='mr3'>[Series Percentage]</span> - The percentage of Y values on the scale of the X-axis to the total of all Y values on the legend<br />\" + \"<span class='mr3'>[Label Percentage]</span> - The percentage of Y values on the scale of the X-axis to the total of all Y values on that scale <br /> \" + \"<span class='mr3'>[(ColumnN)]</span> - Value in column N <br /> \" + \"<span class='mr3'>[Wrap]</span> - Line break\",\n      \"%_NAME\": \"Attribute\",\n      \"%_NAME_desc\": \"The displayed numerical labels are the corresponding X-axis values\",\n      \"%_VALUE\": \"Value\",\n      \"%_VALUE_desc\": \"The corresponding value of the Y-axis\",\n      \"%_VALUE_NAME\": \"Value Name\",\n      \"%_VALUE_NAME_desc\": \"The corresponding y-axis column name\",\n      \"%_SERIES_NAME\": \"Series\",\n      \"%_SERIES_NAME_desc\": \"The category value of the corresponding legend\",\n      \"%_SERIES_NUMBER\": \"Series Index\",\n      \"%_SERIES_NUMBER_desc\": \"Category order index of corresponding legend\",\n      \"%_CATEGORY_NAME\": \"Label\",\n      \"%_CATEGORY_NAME_desc\": \"The corresponding X-axis scale value\",\n      \"%_CATEGORY_NUMBER\": \"Label Index\",\n      \"%_CATEGORY_NUMBER_desc\": \"Corresponding X-axis scale sequence index\",\n      \"%_CATEGORY_TOTAL\": \"Label Total\",\n      \"%_CATEGORY_TOTAL_desc\": \"The sum of all Y-axis values on each X-axis scale\",\n      \"%_CATEGORY_AVERAGE\": \"Label AVG\",\n      \"%_CATEGORY_AVERAGE_desc\": \"The average value of all Y-axis values on each X-axis scale\",\n      \"%_PERCENT_OF_TOTAL\": \"Series Percentage\",\n      \"%_PERCENT_OF_TOTAL_desc\": \"The percentage of Y value on the X-axis scale to the total sum of all Y values\",\n      \"%_PERCENT_OF_CATEGORY\": \"Label Percentage\",\n      \"%_PERCENT_OF_CATEGORY_desc\": \"The percentage of Y value on the X-axis scale to the total sum of all Y values on that X-axis scale\",\n      \"%_BR\": \"Wrap\",\n      \"option_grid_show_all_line\": \"Show all grid lines\",\n      \"option_grid_line_style\": \"Line style\",\n      \"option_grid_line_style_desc\": \"Configure the styles of all grid lines, including virtual and solid, color, and thickness\",\n      \"option_grid_show_only_zero_line\": \"Only show the zero line\",\n      \"option_grid_show_only_zero_line_desc\": \"After configuration, all non zero lines in the grid lines will be hidden, and only zero lines will be displayed.<br/>If the minimum value of the Y-axis is greater than 0, there will be no zero lines, and all grid lines will not be displayed\",\n      \"option_grid_zero_line_style\": \"Zero line style\",\n      \"option_grid_zero_line_style_desc\": \"Configure the style of the zero line, including virtual and solid, color, and thickness\",\n      \"option_grid_show_vertical_grid_line\": \"Vertical line\",\n      \"option_grid_show_horizontal_grid_line\": \"Horizontal line\",\n      \"option_grid_show_vertical_only_zero_line\": \"Show only vertical zero lines\",\n      \"option_grid_show_horizontal_only_zero_line\": \"Show only horizontal zero lines\",\n      \"category_scatter_general\": \"Scatter Configuration\",\n      \"option_legend_shape_type\": \"Scatter Type\",\n      \"option_scatter_shape_type\": \"Scatter Shape\",\n      \"option_scatter_shape_size\": \"Scatter Size\",\n      \"option_scatter_shape_transparent\": \"Opacity\",\n      \"option_scatter_shape_stroke_flag\": \"Stroke\",\n      \"option_legend_shape_type_add\": \"plus\",\n      \"option_legend_shape_type_cross\": \"cross\",\n      \"option_scale_y_visible\": \"Show/hide custom y-axis scale\",\n      \"option_scale_x_visible\": \"Show/hide custom x-axis scale\"\n    }\n  },\n  // [*必填项]生成当前图表类型的模板数据\n  getTemplateData: function () {}\n});\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! jquery */ \"../node_modules/jquery/dist/jquery.js\")))\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.system.basic/scatter/systemScatterChart.js?");

/***/ })

}]);