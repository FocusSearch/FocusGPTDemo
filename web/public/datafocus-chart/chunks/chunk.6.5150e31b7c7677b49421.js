(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[6],{

/***/ "../src-v5/assets/js/charts.components/MarkerComponent.js":
/*!****************************************************************!*\
  !*** ../src-v5/assets/js/charts.components/MarkerComponent.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @pc/assets/js/d3.js */ \"../src-v5/assets/js/d3.js\");\n/* harmony import */ var _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @pc/assets/js/charts.components/CommonComponent */ \"../src-v5/assets/js/charts.components/CommonComponent.js\");\n// 计算图形标准线[ 即：最大值/最小值/平均值的线 ]的组件： 计算标准线所占宽度 ， 画标准线 ...\n\n\nlet MarkerComponent = {\n  /**\r\n   * 计算数值轴对应的标准线的信息: 是否可以画标准线，宽度\r\n   *\r\n   * **/\n  calcMeasureMarkerMessage: function (options) {\n    options = options || {};\n    if (!options.measureAxis || !options.drawWidth || !options.drawHeight) return false;\n    if (options.measureAxis.length > 1) return false;\n    let curMeasureAxis = options.measureAxis[0],\n      markerFontSize = parseInt(options.markerFontSize) || 10;\n    let theMinNum = _DataFocusMethod.isPureNumber(curMeasureAxis.preMin) ? curMeasureAxis.preMin : _DataFocusMethod.isPureNumber(curMeasureAxis.statistics && curMeasureAxis.statistics.min) ? curMeasureAxis.statistics.min : curMeasureAxis.min;\n    let theMaxNum = _DataFocusMethod.isPureNumber(curMeasureAxis.preMax) ? curMeasureAxis.preMax : _DataFocusMethod.isPureNumber(curMeasureAxis.statistics && curMeasureAxis.statistics.max) ? curMeasureAxis.statistics.max : curMeasureAxis.min;\n    let theAvgNum = _DataFocusMethod.isPureNumber(curMeasureAxis.avg) ? curMeasureAxis.avg : _DataFocusMethod.isPureNumber(curMeasureAxis.statistics && curMeasureAxis.statistics.average) ? curMeasureAxis.statistics.average : curMeasureAxis.avg;\n    let theMinStr, theAvgStr, theMaxStr;\n    if (typeof options.getI18nKey === 'function') {\n      theMinStr = options.getI18nKey(\"chart_marker_min\") + _DataFocusMethod.formatData(theMinNum, options.scaleFormat);\n      theAvgStr = options.getI18nKey(\"chart_marker_avg\") + _DataFocusMethod.formatData(theAvgNum, options.scaleFormat);\n      theMaxStr = options.getI18nKey(\"chart_marker_max\") + _DataFocusMethod.formatData(theMaxNum, options.scaleFormat);\n    } else {\n      theMinStr = _DataFocusMethod.formatData(theMinNum, options.scaleFormat) || '';\n      theAvgStr = _DataFocusMethod.formatData(theAvgNum, options.scaleFormat) || '';\n      theMaxStr = _DataFocusMethod.formatData(theMaxNum, options.scaleFormat) || '';\n    }\n    let theMarkerText = [];\n    if (theMinStr) theMarkerText.push({\n      text: theMinStr,\n      value: theMinNum\n    });\n    if (theAvgStr) theMarkerText.push({\n      text: theAvgStr,\n      value: theAvgNum\n    });\n    if (theMaxStr) theMarkerText.push({\n      text: theMaxStr,\n      value: theMaxNum\n    });\n    if (!theMarkerText.length) return false;\n    let theMaxMarkerWidth = 0,\n      theMaxMarkerHeight = 0;\n    theMarkerText.forEach(function (markerText) {\n      let theStringSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', markerText.text, {\n        fontSize: markerFontSize\n      });\n      markerText.width = theStringSize.width;\n      markerText.height = theStringSize.height;\n      theMaxMarkerWidth = Math.max(theMaxMarkerWidth, theStringSize.width);\n      theMaxMarkerHeight = Math.max(theMaxMarkerHeight, theStringSize.height);\n    });\n    let direction = options.direction || \"vertical\";\n    if (direction === 'vertical') {\n      // 标准线垂直摆放，线条方向为水平方向，文字内容限制最大宽度[ 不得超过画图区域的20% ]\n      theMaxMarkerWidth = Math.min(options.drawWidth * 0.2, theMaxMarkerWidth);\n      if (theMaxMarkerWidth < 30) theMaxMarkerWidth = 0;\n\n      // 计算当前画图高度最多能放的marker个数\n      let theAllowTextNumber = Math.floor(options.drawHeight / theMaxMarkerHeight);\n      if (theAllowTextNumber < 1) {\n        // 不显示\n        theMaxMarkerHeight = 0;\n      } else if (theAllowTextNumber < 2) {\n        // 只显示最大值\n        theMarkerText = [theMarkerText[2]];\n      } else if (theAllowTextNumber < 3) {\n        // 只显示最大值 和 最小值\n        theMarkerText = [theMarkerText[0], theMarkerText[2]];\n      }\n      return {\n        hasMarkerFlag: theMaxMarkerWidth > 0,\n        direction: direction,\n        markerMaxWidth: theMaxMarkerWidth,\n        markerMaxHeight: theMaxMarkerHeight,\n        markerTextList: theMarkerText\n      };\n    } else {\n      // 标准线的线条方向为竖直方向，文字内容限制最大宽度[ 不得超过画图区域高度的20% ]\n      theMaxMarkerHeight = Math.min(options.drawHeight * 0.2, theMaxMarkerHeight);\n      if (theMaxMarkerHeight < 10) theMaxMarkerHeight = 0;\n      return {\n        hasMarkerFlag: theMaxMarkerHeight > 0,\n        direction: direction,\n        markerMaxWidth: theMaxMarkerWidth,\n        markerMaxHeight: theMaxMarkerHeight,\n        markerTextList: theMarkerText\n      };\n    }\n  },\n  /**\r\n   * 画水平方向的标准线\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   画图容器\r\n   *              markerTextList  -   标准线的内容\r\n   *              translateLeft   -   标准线的左侧偏移\r\n   *              translateTop    -   标准线的顶部偏移\r\n   *\r\n   *              markerFontSize  -   标准线的字体大小\r\n   *              maxWidth        -   文本内容的最大宽度\r\n   *              lineWidth       -   线的宽度\r\n   *              scaleHeight     -   高度比例尺的最大值\r\n   *              scaleFunc       -   计算高度位置的比例尺\r\n   *          }\r\n   *\r\n   * **/\n  drawHorizontalMarkerLine: function (options) {\n    options = options || {};\n    if (!options.svgContainer || !options.markerTextList || !options.markerTextList.length) return false;\n    if (!options.scaleFunc || !options.scaleHeight || !options.maxWidth) return false;\n    let theSvgContainer = options.svgContainer,\n      theMarkerTextList = options.markerTextList;\n    let markerFontSize = parseInt(options.markerFontSize) || 10,\n      theMarkerScaleFunc = options.scaleFunc,\n      theMarkerContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(theSvgContainer).append(\"g\").attr(\"class\", 'marker-line horizontal-marker-line').attr(\"transform\", \"translate(\" + options.translateLeft + \" , \" + options.translateTop + \")\");\n    let preValueScale, prevTextScaleY, prevOffsetTop;\n    theMarkerTextList && theMarkerTextList.forEach(function (theMarker, index) {\n      let theTextScaleY = theMarkerScaleFunc(theMarker.value);\n      if (theTextScaleY > options.scaleHeight || theTextScaleY < 0) return false;\n      let theMarkerDom = theMarkerContainer.append(\"g\").attr(\"class\", \"marker-item\").attr(\"transform\", \"translate(0 , \" + theTextScaleY + \")\");\n      let theOffsetTop = 0;\n      if (theTextScaleY + options.translateTop < theMarker.height * (theMarkerTextList.length - 1 - index) + theMarker.height / 2) {\n        // 上面放不下剩下的marker , 需要将该marker下移\n        theOffsetTop = theMarker.height * (theMarkerTextList.length - 1 - index) + theMarker.height / 2 - theTextScaleY - options.translateTop;\n      } else if (prevTextScaleY !== undefined && prevTextScaleY + prevOffsetTop - theTextScaleY < theMarker.height) {\n        // 如果两个标签之间重叠，将该标签上移\n        theOffsetTop -= theMarker.height - prevTextScaleY - prevOffsetTop + theTextScaleY;\n      }\n      let showMarkLineFlag = true;\n      if (preValueScale === theMarker.text) {\n        showMarkLineFlag = false;\n      }\n      // 当标准线值都一样时，只画一条线\n      if (showMarkLineFlag) {\n        theMarkerDom.append('line').attr('class', 'marker-line').attr({\n          'x1': '0',\n          'y1': '0',\n          'x2': options.lineWidth,\n          'y2': '0'\n        }).attr('stroke', options.markerLineColor).attr('stroke-width', '1').attr('stroke-dasharray', '8,8').style('opacity', '0.8').attr('transform', 'translate(0.5,0.5)');\n      }\n      // 画标准线的文字\n      let curMarkerText = theMarkerDom.append('text').attr('class', 'marker-num text').style(\"font-size\", markerFontSize + 'px').text(function () {\n        let dText = theMarker.text;\n        let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', dText, {\n          fontSize: markerFontSize\n        });\n        if (theTextSize.width > options.maxWidth) {\n          let theSubText = '';\n          for (let i = 0; i < dText.length; i++) {\n            let chart = dText.charAt(i);\n            theSubText += chart;\n            let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', theSubText + '..', {\n              fontSize: markerFontSize\n            });\n            if (theSubTextSize.width > options.maxWidth - markerFontSize) {\n              break;\n            }\n          }\n          if (theSubText.length === dText.length) {\n            return dText;\n          } else {\n            return theSubText + '..';\n          }\n        }\n        return dText;\n      }).attr('text-anchor', 'start').attr('dominant-baseline', 'middle').attr('transform', 'translate(' + options.lineWidth + ', ' + theOffsetTop + ')');\n      prevTextScaleY = theTextScaleY;\n      prevOffsetTop = theOffsetTop;\n    });\n  },\n  /**\r\n   * 画竖直方向的标准线\r\n   * @param options\r\n   *          {\r\n   *              svgContainer    -   画图容器\r\n   *              markerTextList  -   标准线的内容\r\n   *              translateLeft   -   标准线的左侧偏移\r\n   *              translateTop    -   标准线的顶部偏移\r\n   *\r\n   *              markerFontSize  -   标准线的字体大小\r\n   *              maxWidth        -   文本内容的最大宽度\r\n   *              lineWidth       -   线的宽度\r\n   *              lineHeight      -   线的高度\r\n   *              scaleHeight     -   高度比例尺的最大值\r\n   *              scaleWidth      -   比例尺宽度最大值\r\n   *              scaleFunc       -   计算高度位置的比例尺\r\n   *          }\r\n   *\r\n   * **/\n  drawVerticalMarkerLine: function (options) {\n    options = options || {};\n    if (!options.svgContainer || !options.markerTextList || !options.markerTextList.length) return false;\n    if (!options.scaleFunc || !options.scaleWidth || !options.maxWidth) return false;\n    let theSvgContainer = options.svgContainer,\n      theMarkerTextList = options.markerTextList;\n    let markerFontSize = parseInt(options.markerFontSize) || 10,\n      theMarkerScaleFunc = options.scaleFunc,\n      theMarkerContainer = _pc_assets_js_d3_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].select(theSvgContainer).append(\"g\").attr(\"class\", 'marker-line horizontal-marker-line').attr(\"transform\", \"translate(\" + options.translateLeft + \" , \" + options.translateTop + \")\");\n    let preValueScale, prevTextScaleX,\n      // 前一个文字的比例尺坐标\n      prevOffsetLeft,\n      // 前一个文字的偏移量\n      prevWidth; // 前一个文字的宽度\n\n    theMarkerTextList && theMarkerTextList.forEach(function (theMarker, index) {\n      let theTextScaleX = theMarkerScaleFunc(theMarker.value);\n      // 文字内容位置超过范围的不画\n      if (theTextScaleX > options.scaleWidth || theTextScaleX < 0) return false;\n      const theMarkerDom = theMarkerContainer.append(\"g\").attr(\"class\", \"marker-item\").attr(\"transform\", `translate(${theTextScaleX}, 0)`);\n      const leftExcessLength = -(theTextScaleX - theMarker.width / 2);\n      const rightExcessLength = theTextScaleX + theMarker.width / 2 - options.scaleWidth;\n      let theOffsetLeft = 0;\n      if (leftExcessLength > 0) {\n        // 左侧超出\n        theOffsetLeft = leftExcessLength;\n      } else if (rightExcessLength > 0) {\n        // 右侧超出\n        theOffsetLeft = -rightExcessLength;\n      }\n\n      // 检测是否跟前一个文字重叠\n      const prevTextRightBound = prevTextScaleX + prevOffsetLeft + prevWidth / 2; // 上一个文字的右边界\n      const currentTextLeftBound = theTextScaleX + theOffsetLeft - theMarker.width / 2; // 当前文字的左边界\n      if (prevTextScaleX !== undefined && prevTextRightBound > currentTextLeftBound) {\n        // 如果两个标签之间重叠，将当前标签右移\n        const overlapWidth = prevTextRightBound - currentTextLeftBound;\n        theOffsetLeft += overlapWidth;\n      }\n      let showMarkLineFlag = true;\n      // 当标准线值都一样时，只画一条线\n      if (preValueScale === theMarker.text) {\n        showMarkLineFlag = false;\n      }\n      if (showMarkLineFlag) {\n        theMarkerDom.append('line').attr('class', 'marker-line').attr({\n          'x1': '0',\n          'y1': '0',\n          'x2': '0',\n          'y2': options.lineHeight\n        }).attr('stroke', options.markerLineColor).attr('stroke-width', '1').attr('stroke-dasharray', '8,8').style('opacity', '0.8').attr('transform', 'translate(0.5,0.5)');\n      }\n\n      // 如果调整完位置后，当前文字标签右侧仍然超出，则不显示文字\n      const currentTextRightRightBound = theTextScaleX + theOffsetLeft + theMarker.width / 2;\n      if (currentTextRightRightBound > options.scaleWidth) {\n        return;\n      }\n\n      // 画标准线的文字\n      let curMarkerText = theMarkerDom.append('text').attr('class', 'marker-num text').style(\"font-size\", markerFontSize + 'px').text(function () {\n        let dText = theMarker.text;\n        let theTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', dText, {\n          fontSize: markerFontSize\n        });\n\n        // 找到未超出的最大文字内容，并拼接..\n        if (theTextSize.width > options.maxWidth) {\n          let theSubText = '';\n          for (let i = 0; i < dText.length; i++) {\n            let chart = dText.charAt(i);\n            theSubText += chart;\n            let theSubTextSize = _pc_assets_js_charts_components_CommonComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getStrSizeByCanvas('string', theSubText + '..', {\n              fontSize: markerFontSize\n            });\n            if (theSubTextSize.width > options.maxWidth - markerFontSize) {\n              break;\n            }\n          }\n          if (theSubText.length === dText.length) {\n            return dText;\n          } else {\n            return theSubText + '..';\n          }\n        }\n        return dText;\n      }).attr('text-anchor', 'middle').attr('dominant-baseline', 'text-before-edge').attr('transform', `translate(${theOffsetLeft}, ${options.lineHeight})`);\n      prevTextScaleX = theTextScaleX;\n      prevOffsetLeft = theOffsetLeft;\n      prevWidth = theMarker.width; // 前一个\n    });\n  }\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (MarkerComponent);\n\n//# sourceURL=webpack:///../src-v5/assets/js/charts.components/MarkerComponent.js?");

/***/ })

}]);